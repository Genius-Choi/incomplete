static int cmd_print(void *data, const char *input) {
	RCore *core = (RCore *) data;
	st64 l;
	int i, len, ret;
	ut8* block = NULL;
	bool myblock = false;
	ut32 tbs = core->blocksize;
	ut64 n, off, from, to, at, ate, piece;
	ut64 tmpseek = UT64_MAX;
	const size_t addrbytes = core->io->addrbytes;
	i = l = len = ret = 0;
	n = off = from = to = at = ate = piece = 0;
	PJ *pj = NULL;

	/* !strncmp (input, "du", 2) */
	if (input[0] == 'd' && input[1] == 'u') { // "pdu"
		/* hijack here for now, idk how to more cleanly integrate it */
		return cmd_pdu (core, input + 2);
	}
	if (r_str_startswith (input, "ushd")) { // "pushd"
		bool halp = true;
		const char *arg = strchr (input, ' ');
		if (arg) {
			arg = r_str_trim_head_ro (arg + 1);
			if (*arg) {
				halp = false;
				if (r_syscmd_pushd (arg)) {
					r_core_return_value (core, 0);
				} else {
					r_core_return_value (core, 1);
				}
			}
		}
		if (halp) {
			eprintf ("Usage: pushd [dir]\n");
			r_core_return_value (core, 1);
		}
		return 0;
	}
	if (r_str_startswith (input, "opd")) { // "popd"
		bool all = strstr (input, "-a");
		bool halp = strstr (input, "-h");
		if (halp) {
			R_LOG_ERROR ("Usage: popd [-a]");
			r_core_return_value (core, 1);
		} else {
			bool suc = all
				? r_syscmd_popalld ()
				: r_syscmd_popd ();
			if (suc) {
				r_core_return_value (core, 0);
			} else {
				R_LOG_ERROR ("Nothing was pushd. Cannot popd");
				r_core_return_value (core, 1);
			}
		}
		return 0;
	}

	r_print_init_rowoffsets (core->print);
	off = UT64_MAX;
	l = len = core->blocksize;
	if (input[0] && input[1]) {
		int idx = (input[0] == 'h')? 2: 1;
		const char *p = off? strchr (input + idx, ' '): NULL;
		if (!p) {
			p = strchr (input, '-');
			if (p) {
				p--;
			}
		}
		if (p) {
			l = (int) r_num_math (core->num, p + 1);
			/* except disasm and memoryfmt (pd, pm) and overlay (po) */
			if (input[0] != 'd' && input[0] != 't' && input[0] != 'D' && input[0] != 'm' &&
				input[0] != 'a' && input[0] != 'f' && input[0] != 'i' &&
				input[0] != 'I' && input[0] != 'o') {
				if (l < 0) {
					off = core->offset + l;
					len = l = -l;
					tmpseek = core->offset;
				} else {
					len = l;
					if (l > core->blocksize) {
						if (!r_core_block_size (core, l)) {
							goto beach;
						}
					}
				}
			} else {
				len = l;
			}
		}
	}
	if (len < 0) {
		len = -len;
	}
	if (len > core->blocksize) {
		block = calloc (1, len);
		if (block) {
			r_io_read_at (core->io, core->offset - len, block, len);
			myblock = true;
		} else {
			len = core->blocksize;
			block = core->block;
		}
	} else {
		block = core->block;
	}

	if (input[0] != 'd' && input[0] != 'm' && input[0] != 'a' && input[0] != 'f' && input[0] != 'i') {
		n = core->blocksize_max;
		i = (int) n;
		if (i != n) {
			i = 0;
		}
		if (i && l > i) {
			R_LOG_ERROR ("Block size is too large (0x%"PFMT64x " < 0x%" PFMT64x "). Did you mean 'p%c @ %s' instead?",
				n, l, *input, *input? r_str_trim_head_ro (input + 1): "");
			goto beach;
		}
	}
	if (input[0] == 'x' || input[0] == 'D') {
		if (l > 0 && tmpseek == UT64_MAX) {
			if (!r_core_block_size (core, l)) {
				R_LOG_ERROR ("This block size is too big. Did you mean 'p%c @ %s' instead?", *input, input + 2);
				goto beach;
			}
		}
	}

	if (input[0] && input[0] != 'z' && input[1] == 'f' && input[2]!='?') {
		RAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset, 0);
		// R_ANAL_FCN_TYPE_FCN|R_ANAL_FCN_TYPE_SYM);
		if (f) {
			len = r_anal_function_linear_size (f);
			if (len > core->blocksize) {
				len = core->blocksize;
			}
		} else {
			R_LOG_ERROR ("Cannot find function at 0x%08"PFMT64x, core->offset);
			r_core_return_value (core, 0);
			goto beach;
		}
	}
	// TODO figure out why `f eax=33; f test=eax; pa call test` misassembles if len is 0
	r_core_return_value (core, len ? len : core->blocksize);
	if (off != UT64_MAX) {
		r_core_seek (core, off, SEEK_SET);
		r_core_block_read (core);
	}
	switch (*input) {
	case 'w': // "pw"
		if (input[1] == 'n') {
			cmd_print_pwn (core);
		} else if (input[1] == 'd') {
			if (!r_sandbox_enable (0)) {
				char *cwd = r_sys_getdir ();
				if (cwd) {
					r_cons_println (cwd);
					free (cwd);
				}
			}
		} else {
			r_cons_printf ("| pwd               display current working directory\n");
		}
		break;
	case 'j': // "pj"
		if (input[1] == '?') {
			r_core_cmd_help (core, help_msg_pj);
		} else if (input[1] == '.') {
			if (input[2] == '.') {
				ut8 *data = calloc (core->offset + 1, 1);
				if (data) {
					data[core->offset] = 0;
					(void)r_io_read_at (core->io, 0, data, core->offset);
					char *res = r_print_json_path ((const char *)data, core->offset);
					if (res) {
						r_cons_println (res);
					}
/*
					char *res = r_print_json_indent ((char*)data, false, "  ", NULL);
					print_json_path (core, res);
					free (res);
*/
				} else {
					R_LOG_ERROR ("Cannot allocate %d", (int)(core->offset));
				}
			} else {
				r_core_cmdf (core, "pj %"PFMT64u" @ 0", core->offset);
			}
		} else {
			if (core->blocksize < 4 || !memcmp (core->block, "\xff\xff\xff\xff", 4)) {
				R_LOG_ERROR ("Cannot read");
			} else {
				char *res = r_print_json_indent ((const char *)core->block, true, "  ", NULL);
				r_cons_printf ("%s\n", res);
				free (res);
			}
		}
		break;
	case 'h': // "ph"
		cmd_print_ph (core, input + 1);
		break;
	case 'v': // "pv"
		cmd_print_pv (core, input + 1, false);
		break;
	case 'V': // "pv"
		cmd_print_pv (core, input + 1, true);
		break;
	case '-': // "p-"
		return cmd_print_blocks (core, input + 1);
	case '=': // "p="
		cmd_print_bars (core, input);
		break;
	case 'A': // "pA"
	{
		const ut64 saved_from = r_config_get_i (core->config, "search.from"),
				saved_to = r_config_get_i (core->config, "search.to"),
				saved_maxhits = r_config_get_i (core->config, "search.maxhits");

		int want = r_num_math (core->num, input + 1);
		if (input[1] == '?') {
			r_core_cmd0 (core, "/A?");
		} else {
			r_config_set_i (core->config, "search.maxhits", want);
			r_config_set_i (core->config, "search.from", core->offset);
			r_config_set_i (core->config, "search.to", core->offset + core->blocksize);
			r_core_cmd0 (core, "/A");
			r_config_set_i (core->config, "search.maxhits", saved_maxhits);
			r_config_set_i (core->config, "search.from", saved_from);
			r_config_set_i (core->config, "search.to", saved_to);
		}
	}
	break;
	case 'a': // "pa"
	{
		const char *arg = NULL;
		if (input[1] != '\0') {
			arg = r_str_trim_head_ro (input + 2);
		}
		if (input[1] == 'e') { // "pae"
			if (input[2] == '?') {
				r_cons_printf ("Usage: pae [asm]       print ESIL expression of the given assembly expression\n");
			} else {
				int printed = 0;
				int bufsz;
				RAnalOp aop = {0};
				r_asm_set_pc (core->rasm, core->offset);
				RAsmCode *acode = r_asm_massemble (core->rasm, input + 2);
				if (acode) {
					bufsz = acode->len;
					while (printed < bufsz) {
						aop.size = 0;
						if (r_anal_op (core->anal, &aop, core->offset,
							    (const ut8 *)acode->bytes + printed, bufsz - printed, R_ARCH_OP_MASK_ESIL) > 0) {
							const char *str = R_STRBUF_SAFEGET (&aop.esil);
							r_cons_println (str);
						} else {
							R_LOG_ERROR ("Cannot decode instruction");
							break;
						}
						if (aop.size < 1) {
							R_LOG_ERROR ("Cannot decode instruction");
							break;
						}
						printed += aop.size;
						r_anal_op_fini (&aop);
					}
				}
			}
		} else if (input[1] == 'D') { // "paD"
			if (input[2] == '?') {
				r_cons_printf ("Usage: paD [hex]       print assembly expression from hexpairs and show hexpairs\n");
			} else {
				r_core_cmdf (core, "pdi@x:%s", input + 2);
			}
		} else if (input[1] == 'd') { // "pad*"
			switch (input[2]) {
			case 'e': // "pade"
				if (input[3] == '?') {
					r_cons_printf ("Usage: pade [hex]       print ESIL expression from hexpairs\n");
				} else {
					int printed = 0;
					int bufsz;
					RAnalOp aop = {0};
					char *hex_arg = calloc (1, strlen (arg) + 1);
					if (hex_arg) {
						bufsz = r_hex_str2bin (arg + 1, (ut8 *)hex_arg);
						while (printed < bufsz) {
							aop.size = 0;
							if (r_anal_op (core->anal, &aop, core->offset,
								    (const ut8 *)hex_arg + printed, bufsz - printed, R_ARCH_OP_MASK_ESIL) > 0) {
								const char *str = R_STRBUF_SAFEGET (&aop.esil);
								r_cons_println (str);
							} else {
								R_LOG_ERROR ("Cannot decode instruction");
								break;
							}
							if (aop.size < 1) {
								R_LOG_ERROR ("Cannot decode instruction");
								break;
							}
							printed += aop.size;
							r_anal_op_fini (&aop);
						}
						free (hex_arg);
					}
				}
				break;
			case ' ': // "pad"
				__cmd_pad (core, arg);
				break;
			case '?': // "pad?"
				r_core_cmd_help_match (core, help_msg_pa, "pad", false);
				break;
			default:
				r_cons_printf ("Usage: pa[edD] [asm|hex]  print (dis)assembled\n");
				break;
			}
		} else if (input[1] == '?') {
			if (input[2] == 'j') {
				r_cons_cmd_help_json (help_msg_pa);
			} else {
				r_core_cmd_help (core, help_msg_pa);
			}
		} else {
			r_asm_set_pc (core->rasm, core->offset);
			RAsmCode *acode = r_asm_massemble (core->rasm, input + 1);
			if (acode) {
				if (!acode->len) {
					r_core_cmd_help_match (core, help_msg_pa, "pa", false);
				} else {
					size_t i;
					for (i = 0; i < acode->len; i++) {
						ut8 b = acode->bytes[i];
						r_cons_printf ("%02x", b);
					}
					r_cons_newline ();
					r_asm_code_free (acode);
				}
			}
		}
	}
	break;
	case 'b': { // "pb"
		if (input[1] == '?') {
			r_cons_printf ("Usage: p[bB] [len] ([skip])  ; see also pB and pxb\n");
		} else if (l != 0) {
			int from, to;
			const int size = len * 8;
			char *spc, *buf = malloc (size + 1);
			spc = strchr (input, ' ');
			if (spc) {
				len = r_num_math (core->num, spc + 1);
				if (len < 1) {
					len = 1;
				}
				spc = strchr (spc + 1, ' ');
				if (spc) {
					from = r_num_math (core->num, spc + 1);
				} else {
					from = 0;
				}
				to = from + len;
			} else {
				from = 0;
				to = size;
			}
			if (buf) {
				int buf_len;
				r_str_bits (buf, block, size, NULL);
				buf_len = strlen (buf);
				if (from >= 0 && to >= 0) {
					if (from >= buf_len) {
						from = buf_len;
					}
					if (to < buf_len) {
						buf[to] = 0;
						//buf[buf_len - 1] = 0;
					}
					r_cons_println (buf + from);
				}
				free (buf);
			} else {
				R_LOG_ERROR ("Cannot allocate %d byte(s)", size);
			}
		}
	}
		break;
	case 'B': { // "pB"
		if (input[1] == '?') {
			r_cons_printf ("Usage: p[bB] [len]       bitstream of N bytes\n");
		} else if (l != 0) {
			int size;
			char *buf;
			if (!r_core_block_size (core, len)) {
				len = core->blocksize;
			}
			size = len * 8;
			buf = malloc (size + 1);
			if (buf) {
				r_str_bits (buf, core->block, size, NULL);
				r_cons_println (buf);
				free (buf);
			} else {
				R_LOG_ERROR ("Cannot allocate %d byte(s)", size);
			}
		}
	}
		break;
	case 'I': // "pI"
		switch (input[1]) {
		case 'j': // "pIj" is the same as pDj
			if (l != 0) {
				if (input[2]) {
					cmd_pDj (core, input + 2);
				} else {
					r_strf_var (numstr, 32, "%d", core->blocksize);
					cmd_pDj (core, numstr);
				}
			}
			break;
		case 'f': // "pIf"
		{
			const RAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset,
				R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);
			if (f) {
				r_core_print_disasm_instructions (core,
					r_anal_function_linear_size ((RAnalFunction *) f), 0);
				break;
			}
		}
		case 'd': // "pId" is the same as pDi
			if (l) {
				r_core_disasm_pdi (core, 0, l, 0);
			}
			break;
		case '?': // "pi?"
			r_cons_printf ("Usage: p[iI][df] [len]   print N instructions/bytes"
				"(f=func) (see pi? and pdi)\n");
			break;
		default:
			if (l) {
				r_core_print_disasm_instructions (core, l, 0);
			}
			break;
		}
		break;
	case 'i': // "pi"
		if (cmd_pi (core, input, len, l, block)) {
			break;
		}
		goto beach;
	case 'D': // "pD"
	case 'd': // "pd"
	{
		ut64 use_blocksize = core->blocksize;
		ut8 bw_disassemble = false;
		ut32 pd_result = false, processed_cmd = false;
		bool formatted_json = false;
		if (input[1] && input[2]) {
			// "pd--" // context disasm
			if (!strncmp (input + 1, "--", 2)) {
				char *offs = r_str_newf ("%s", input + 2);
				if (offs) {
					ut64 sz = r_num_math (core->num, offs);
					char *fmt;
					if (((st64)sz * -1) > core->offset) {
						// the offset is smaller than the negative value
						// so only print -offset
						fmt = r_str_newf ("d %"PFMT64d, -1 * core->offset);
					} else {
						fmt = r_str_newf ("d %s", input + 2);
					}
					if (fmt) {
						cmd_print (core, fmt);
						strcpy (fmt + 2, input + 3);
						cmd_print (core, fmt);
						free (fmt);
					}
					free (offs);
				}
				ret = 0;
				goto beach;
			}
		}

		if (input[1] == 'x') { // pdx
			__cmd_pad (core, r_str_trim_head_ro (input + 2));
			return 0;
		}

		const char *sp = NULL;
		if (input[1] == '.' || input[1] == '+') {
			sp = input + 2;
		} else {
			sp = strchr (input + 1, ' ');
		}
		if (IS_DIGIT (input[1])) {
			sp = input + 1;
		} else if (!sp && input[1] == '-') {
			sp = input + 1;
		}
		if (sp) {
			int n = (int) r_num_math (core->num, r_str_trim_head_ro (sp));
			if (!n) {
				goto beach;
			}
			use_blocksize = n;
		}

		int mbs = core->blocksize_max;
		if (core->blocksize_max < use_blocksize && (int) use_blocksize < -mbs) {
			R_LOG_ERROR ("Block size is too large (%"PFMT64u "<%"PFMT64u "). Did you mean 'p%c @ 0x%08"PFMT64x "' instead?",
				(ut64) core->blocksize_max, (ut64) use_blocksize, input[0], (ut64) use_blocksize);
			goto beach;
		} else if (core->blocksize_max < use_blocksize && (int) use_blocksize > -mbs) {
			bw_disassemble = true;
			l = use_blocksize; // negative
			use_blocksize = (ut64)-(st64)use_blocksize;
		} else {
			l = use_blocksize;
		}
		// may be unnecessary, fixes 'pd 1;pdj 100;pd 1' bug
		r_core_block_read (core);

		switch (input[1]) {
		case 'C': // "pdC"
			r_core_disasm_pdi (core, l, 0, 'C');
			pd_result = 0;
			processed_cmd = true;
			break;
		case 'v': // "pdv" // east decompiler
			R_LOG_ERROR ("Missing plugin. Run: r2pm -ci east");
			processed_cmd = true;
			break;
		case 'd': // "pdd" // r2dec
			R_LOG_ERROR ("Missing plugin. Run: r2pm -ci r2dec");
			processed_cmd = true;
			break;
		case 'z': // "pdz" // retdec
			R_LOG_ERROR ("Missing plugin. Run: r2pm -ci r2retdec");
			processed_cmd = true;
			break;
		case 'g': // "pdg" // r2ghidra
			R_LOG_ERROR ("Missing plugin. Run: r2pm -ci r2ghidra");
			processed_cmd = true;
			break;
		case 'c': // "pdc" // "pDc"
			r_core_pseudo_code (core, input + 2);
			pd_result = 0;
			processed_cmd = true;
			break;
		case ',': // "pd,"
		case 't': // "pdt" // R_DEPRECATE pdt imho
			if (input[2] == '?') {
				r_core_cmd_help_match (core, help_msg_pd, "pd,", true);
				return 0;
			} else {
				r_core_disasm_table (core, l, r_str_trim_head_ro (input + 2));
				pd_result = 0;
				processed_cmd = true;
			}
			break;
		case 'k': // "pdk" -print class
			if (input[2] == '?') {
				r_core_cmd_help_match (core, help_msg_pd, "pdk", true);
				return 0;
			} else {
				int len = 0;
				ut64 at = findClassBounds (core, r_str_trim_head_ro (input + 2), &len);
				return r_core_cmdf (core, "pD %d @ %"PFMT64u, len, at);
			}
			break;
		case 'i': // "pdi" // "pDi"
			if (input[2] == '?') {
				r_core_cmd_help_match (core, help_msg_pd, "pdi", true);
				return 0;
			} else {
				processed_cmd = true;
				if (*input == 'D') {
					r_core_disasm_pdi (core, 0, l, 0);
				} else {
					r_core_disasm_pdi (core, l, 0, 0);
				}
				pd_result = 0;
			}
			break;
		case 'a': // "pda"
			processed_cmd = true;
			if (input[2] == '?') {
				r_core_cmd_help (core, help_msg_pda);
				break;
			}
			r_core_print_disasm_all (core, core->offset, l, len, input[2]);
			pd_result = true;
			break;
		case 'o': // "pdo"
			if (input[2] == '?') {
				r_core_cmd_help (core, help_msg_pdo);
				return 0;
			}
			core_print_decompile (core, input + 2);
			pd_result = true;
			processed_cmd = true;
			break;
		case 'e': // "pde"
			processed_cmd = true;
			if (!core->fixedblock && !sp) {
				l /= 4;
			}
			if (input[2] == '?') { // "pde?"
				r_core_cmd_help (core, help_msg_pde);
				return 0;
			};
			int mode = R_MODE_PRINT;
			if (input[2] == 'j') {
				mode = R_MODE_JSON;
			} else if (input[2] == 'q') {
				if (input[3] == 'q') { // "pdeqq"
					mode = R_MODE_SIMPLEST; // Like pi
				} else { // "pdeq"
					mode = R_MODE_SIMPLE; // Like pdi
				}
			}
			r_core_disasm_pde (core, l, mode);
			pd_result = true;
			break;
		case 'R': // "pdR"
			processed_cmd = true;
			if (input[2] == 'j') {
				disasm_recursive (core, core->offset, use_blocksize, 'j');
			} else {
				disasm_recursive (core, core->offset, use_blocksize, 'D');
			}
			pd_result = true;
			break;
		case 'r': // "pdr"
			processed_cmd = true;
			if (input[2] == '?') { // "pdr?"
				r_core_cmd_help (core, help_msg_pdr);
				pd_result = true;
				break;
			};
			{
				RAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset, 0);
				// R_ANAL_FCN_TYPE_FCN|R_ANAL_FCN_TYPE_SYM);
				if (f) {
					func_walk_blocks (core, f, input[2], 'D', input[2] == '.');
				} else {
					R_LOG_ERROR ("Cannot find function at 0x%08"PFMT64x, core->offset);
				}
				pd_result = true;
			}
			break;
		case 'b': // "pdb"
			processed_cmd = true;
			if (input[2] == '?') {
				r_cons_printf ("Usage: pdb[j]  - disassemble basic block\n");
			} else {
				RAnalBlock *b = r_anal_bb_from_offset (core->anal, core->offset);
				if (b) {
					ut8 *block = malloc (b->size + 1);
					if (block) {
						r_io_read_at (core->io, b->addr, block, b->size);

						if (input[2] == 'j') {
							pj = pj_new ();
							if (!pj) {
								break;
							}
							pj_a (pj);
							r_core_print_disasm_json (core, b->addr, block, b->size, 0, pj);
							pj_end (pj);
							r_cons_printf ("%s\n", pj_string (pj));
							pj_free (pj);
						} else {
							int dislen = r_core_print_disasm (
								core, b->addr, block,
								b->size, b->size, 0, NULL, true,
								input[2] == 'J', NULL, NULL);
							r_core_return_value (core, dislen);
						}
						free (block);
						pd_result = 0;
					}
				} else {
					R_LOG_ERROR ("Cannot find function at 0x%08"PFMT64x, core->offset);
					r_core_return_value (core, 0);
				}
			}
			break;
		case 's': // "pds" and "pdsf"
			processed_cmd = true;
			if (input[2] == '?') {
				r_core_cmd_help (core, help_msg_pds);
			} else {
				if (input[2] && input[3] == '?') {
					r_core_cmd_help (core, help_msg_pds);
				} else {
					disasm_strings (core, input, NULL);
				}
			}
			break;
		case 'f': // "pdf"
			processed_cmd = true;
			if (input[2] == '?') {
				r_core_cmd_help (core, help_msg_pdf);
			} else if (input[2] == 's') { // "pdfs"
				ut64 oseek = core->offset;
				int oblock = core->blocksize;
				RAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset,
					R_ANAL_FCN_TYPE_FCN | R_ANAL_FCN_TYPE_SYM);
				if (f) {
					ut32 rs = r_anal_function_realsize (f);
					ut32 fs = r_anal_function_linear_size (f);
					r_core_seek (core, oseek, SEEK_SET);
					r_core_block_size (core, R_MAX (rs, fs));
					disasm_strings (core, input, f);
					r_core_block_size (core, oblock);
					r_core_seek (core, oseek, SEEK_SET);
				}
				processed_cmd = true;
			} else {
				ut32 bsz = core->blocksize;
				RAnalFunction *f = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_ROOT);
				if (!f) {
					f = r_anal_get_fcn_in (core->anal, core->offset, 0);
				}
				RListIter *locs_it = NULL;
				if (f && input[2] == 'j') { // "pdfj"
					RAnalBlock *b;
					ut32 fcn_size = r_anal_function_realsize (f);
					const char *orig_bb_middle = r_config_get (core->config, "asm.bbmiddle");
					r_config_set_i (core->config, "asm.bbmiddle", false);
					pj = pj_new ();
					if (!pj) {
						break;
					}
					pj_o (pj);
					pj_ks (pj, "name", f->name);
					pj_kn (pj, "size", fcn_size);
					pj_kn (pj, "addr", f->addr);
					pj_k (pj, "ops");
					pj_a (pj);
					r_list_sort (f->bbs, bb_cmpaddr);
					r_list_foreach (f->bbs, locs_it, b) {

						ut8 *buf = malloc (b->size);
						if (buf) {
							r_io_read_at (core->io, b->addr, buf, b->size);
							r_core_print_disasm_json (core, b->addr, buf, b->size, 0, pj);
							free (buf);
						} else {
							R_LOG_ERROR ("Cannot allocate %"PFMT64u" byte(s)", b->size);
						}
					}
					pj_end (pj);
					pj_end (pj);
					r_cons_printf ("%s\n", pj_string (pj));
					pj_free (pj);
					pd_result = 0;
					r_config_set (core->config, "asm.bbmiddle", orig_bb_middle);
				} else if (f) {
					ut64 linearsz = r_anal_function_linear_size (f);
					ut64 realsz = r_anal_function_realsize (f);
					if (realsz + 4096 < linearsz) {
						R_LOG_ERROR ("Linear size differs too much from the bbsum, please use pdr instead");
					} else {
						ut64 at = f->addr; // TODO: should be min from r_anal_function_get_range()?
						ut64 sz = R_MAX (linearsz, realsz);
						ut8 *buf = calloc (sz, 1);
						if (buf) {
							(void)r_io_read_at (core->io, at, buf, sz);
							int dislen = r_core_print_disasm (core, at, buf, sz, sz, 0, NULL, true, false, NULL, f);
							r_core_return_value (core, dislen);
							free (buf);
							// r_core_cmdf (core, "pD %d @ 0x%08" PFMT64x, f->_size > 0 ? f->_size: r_anal_function_realsize (f), f->addr);
						}
					}
					pd_result = 0;
				} else {
					R_LOG_ERROR ("pdf: Cannot find function at 0x%08"PFMT64x, core->offset);
					processed_cmd = true;
					r_core_return_value (core, 0);
				}
				if (bsz != core->blocksize) {
					r_core_block_size (core, bsz);
				}
			}
			l = 0;
			break;
		case 'p': // "pdp"
			processed_cmd = true;
			if (input[2] == '?') {
				r_core_cmd_help (core, help_msg_pdp);
				pd_result = true;
				break;
			};
			disasm_ropchain (core, core->offset, 'D');
			pd_result = true;
			break;
		case 'l': // "pdl"
			processed_cmd = true;
			{
				RAnalOp asmop;
				int j, ret;
				if (!l) {
					l = len;
				}
				r_cons_break_push (NULL, NULL);
				for (i = j = 0; i < core->blocksize && j < l; i += ret, j++) {
					ret = r_asm_disassemble (core->rasm, &asmop, block + i, len - i);
					if (r_cons_is_breaked ()) {
						break;
					}
					r_cons_printf ("%d\n", ret);
					if (ret < 1) {
						ret = 1;
					}
				}
				r_cons_break_pop ();
				pd_result = 0;
			}
			break;
		case 'j': // pdj
			processed_cmd = true;
			if (*input == 'D') {
				cmd_pDj (core, input + 2);
			} else {
				cmd_pdj (core, input + 2, block);
			}
			pd_result = 0;
			break;
		case 'J': // pdJ
			formatted_json = true;
			break;
		case 0: // "pd"
			/* "pd" -> will disassemble blocksize/4 instructions */
			if (!core->fixedblock && *input == 'd') {
				l /= 4;
			}
			break;
		case '?': // "pd?"
			processed_cmd = true;
			r_core_cmd_help (core, help_msg_pd);
			pd_result = 0;
		case '.':
		case '-':
		case '+':
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '$':
		case '9':
		case ' ':
			break;
		default:
			R_LOG_ERROR ("Invalid pd subcommand");
			return 0;
		}
		if (formatted_json) {
			if (r_cons_context ()->is_html) {
				r_cons_context ()->is_html = false;
				r_cons_context ()->was_html = true;
			}
		}
		if (!processed_cmd) {
			ut64 addr = core->offset;
			ut8 *block1 = NULL;
			ut64 start;

			if (bw_disassemble) {
				int bs1 = (core->blocksize * 2) + 64;
				block1 = malloc (bs1);
				if (l < 0) {
					l = -l;
				}
				if (block1) {
					if (*input == 'D') { // pD
						free (block1);
						if (!(block1 = malloc (bs1))) {
							break;
						}
						r_io_read_at (core->io, addr - l, block1, bs1);
						int dislen = r_core_print_disasm (core, addr - l, block1, l, l, 0, NULL, true, formatted_json, NULL, NULL);
						r_core_return_value (core, dislen);
					} else { // pd
						if (!r_core_prevop_addr (core, core->offset, l, &start)) {
							// anal ignorance.
							start = r_core_prevop_addr_force (core, core->offset, l);
						}
						int instr_len = core->offset - start;
						ut64 prevaddr = core->offset;
						int bs = core->blocksize;
						int bs2 = addrbytes * instr_len;
						if (bs2 > bs) {
							bs1 += bs2 + 32;
							bs2 = bs1;
							bs = bs2;
							ut8 *tmpblock = realloc (block1, bs1);
							if (!tmpblock) {
								R_LOG_ERROR ("Memory reallocation failed");
								free (block1);
								break;
							}
							block1 = tmpblock;
						}
						r_io_read_at (core->io, prevaddr - instr_len, block1, bs1);
						r_core_seek (core, prevaddr - instr_len, true);
						int dislen = r_core_print_disasm (core,
								core->offset, block1,
								R_MAX (bs, bs1), l, 0, NULL,
								false, formatted_json, NULL,
								NULL);
						r_core_return_value (core, dislen);
						r_core_seek (core, prevaddr, true);
					}
				}
			} else {
				// XXX: issue with small blocks
				if (*input == 'D' && use_blocksize > 0) {
					l = use_blocksize;
					if (l > R_CORE_MAX_DISASM) { // pD
						R_LOG_ERROR ("Block size too big");
						return 1;
					}
					block1 = malloc (addrbytes * l);
					if (block1) {
						r_io_read_at (core->io, addr, block1, addrbytes * l);
						int dislen = r_core_print_disasm (core,
								addr, block1, addrbytes * l, l,
								0, NULL, true, formatted_json,
								NULL, NULL);
						r_core_return_value (core, dislen);
					} else {
						R_LOG_ERROR ("Cannot allocate %" PFMT64d " byte(s)", addrbytes * l);
					}
				} else {
					ut8 *buf = core->block;
					const int buf_size = core->blocksize;
					if (buf) {
						if (!l) {
							l = use_blocksize;
							if (!core->fixedblock) {
								l /= 4;
							}
						}
						core->num->value = r_core_print_disasm (core,
								addr, buf, buf_size, l,	0, NULL,
								false, formatted_json, NULL, NULL);
					}
				}
			}
			free (block1);
			if (formatted_json) {
				r_cons_newline ();
			}
		}
		if (processed_cmd) {
			ret = pd_result;
			goto beach;
		}
	}
	break;
	case 'p': // "pp"
		__printPattern (core, input + 1);
		break;
	case 's': // "ps"
		switch (input[1]) {
		case '?': // "ps?"
			r_core_cmd_help (core, help_msg_ps);
			break;
		case 'i': // "psi"
			if (l > 0) {
				ut8 *buf = malloc (1024 + 1);
				int delta = 512;
				ut8 *p, *e, *b;
				if (!buf) {
					return 0;
				}
				buf[1024] = 0;
				if (core->offset < delta) {
					delta = core->offset;
				}
				p = buf + delta;
				r_io_read_at (core->io, core->offset - delta, buf, 1024);
				for (b = p; b > buf; b--) {
					if (!IS_PRINTABLE (*b)) {
						b++;
						break;
					}
				}
				for (e = p; e < (buf + 1024); e++) {
					if (!IS_PRINTABLE (*b)) {
						*e = 0;
						e--;
						break;
					}
				}
				r_cons_strcat ((const char *) b);
				r_cons_newline ();
				// r_print_string (core->print, core->offset, b,
				// (size_t)(e-b), 0);
				free (buf);
			}
			break;
		case 'x': // "psx"
			if (l > 0) {
				r_print_string (core->print, core->offset, block, len, R_PRINT_STRING_ESC_NL);
			}
			break;
		case 'a': // "psa"
			cmd_psa (core, input + 1);
			break;
		case 'b': // "psb"
			if (l > 0) {
				int quiet = input[2] == 'q'; // "psbq"
				RStrBuf *sb = r_strbuf_new ("");
				int i, hasnl = 0;
				if (sb) {
					if (!quiet) {
						r_print_offset (core->print, core->offset, 0, 0, NULL);
					}
					// TODO: filter more chars?
					for (i = 0; i < core->blocksize; i++) {
						char ch = (char) block[i];
						if (ch == 0xa) {
							char *s = r_strbuf_drain (sb);
							r_cons_print (s); // TODO: missing newline?
							free (s);
							sb = r_strbuf_new ("");
							r_cons_newline ();
							if (!quiet) {
								r_print_offset (core->print, core->offset + i, 0, 0, NULL);
							}
							hasnl = 1;
							continue;
						}
						if (!ch) {
							if (core->print->cur_enabled && core->print->cur == i) {
								r_strbuf_append (sb, Color_INVERT"."Color_RESET);
							}
							if (!hasnl) {
								char *s = r_strbuf_drain (sb);
								r_cons_println (s); // TODO: missing newline?
								free (s);
								sb = r_strbuf_new ("");
								if (!quiet) {
									r_print_offset (core->print, core->offset + i, 0, 0, NULL);
								}
							}
							hasnl = true;
							continue;
						}
						hasnl = 0;
						if (IS_PRINTABLE (ch)) {
							if (core->print->cur_enabled && core->print->cur == i) {
								r_strbuf_appendf (sb, Color_INVERT"%c"Color_RESET, ch);
							} else {
								r_strbuf_appendf (sb, "%c", ch);
							}
						} else {
							if (core->print->cur_enabled && core->print->cur == i) {
								r_strbuf_append (sb, Color_INVERT"."Color_RESET);
							}
						}
					}
					char *s = r_strbuf_drain (sb);
					r_cons_print (s); // TODO: missing newline?
					free (s);
				}
			}
			break;
		case 'z': // "psz"
			if (l > 0) {
				ut8 *s = decode_text (core, core->offset, l, true);
				if (input[2] == 'j') { // pszj
					print_json_string (core, (const char *) s,
						r_str_nlen ((const char*)s, l), NULL);
				} else if (input[2] == '*') {
					char *a = r_str_ndup ((const char*)s, l);
					char *b = r_base64_encode_dyn (a, -1);
					r_cons_printf ("w6e %s\n", b);
					free (b);
					free (a);
				} else if (input[2] == '?') {
					r_core_cmd_help (core, help_msg_psz);
				} else if (input[2] == 'c' || input[2] == 'l') {
					r_cons_printf ("%d\n", (int)r_str_nlen ((const char*)s, l));
				} else {
					r_print_string (core->print, core->offset, s, l, R_PRINT_STRING_ZEROEND);
				}
				free (s);
			}
			break;
		case 'p': // "psp"
			if (l > 0) {
				int mylen = core->block[0];
				// TODO: add support for 2-4 byte length pascal strings
				if (mylen < core->blocksize) {
					if (input[2] == 'j') { // pspj
						print_json_string (core, (const char *) core->block + 1, mylen, NULL);
					} else {
						r_print_string (core->print, core->offset,
							core->block + 1, mylen, R_PRINT_STRING_ZEROEND);
					}
					core->num->value = mylen;
				} else {
					core->num->value = 0; // error
				}
			}
			break;
		case 'w': // "psw"
			if (l > 0) {
				if (input[2] == 'j') { // pswj
					print_json_string (core, (const char *) core->block, len, "wide");
				} else {
					r_print_string (core->print, core->offset, core->block, len,
						R_PRINT_STRING_WIDE | R_PRINT_STRING_ZEROEND);
				}
			}
			break;
		case 'W': // "psW"
			if (l > 0) {
				if (input[2] == 'j') { // psWj
					print_json_string (core, (const char *) core->block, len, "wide32");
				} else {
					r_print_string (core->print, core->offset, core->block, len,
						R_PRINT_STRING_WIDE32 | R_PRINT_STRING_ZEROEND);
				}
			}
			break;
		case 'j': // "psj"
			{
				ut8 *s = decode_text (core, core->offset, l, false);
				print_json_string (core, (const char *) s, l, NULL);
				free (s);
			}
			break;
		case ' ': // "ps"
		{
			ut8 *s = decode_text (core, core->offset, l, false);
			r_print_string (core->print, core->offset, s, l, 0);
			free (s);
			break;
		}
		case 'u': // "psu"
			if (l > 0) {
				bool json = input[2] == 'j'; // "psuj"
				if (input[2] == 'z') { // "psuz"
					int i, z;
					const char* p = (const char *) core->block;
					for (i = 0, z = 0; i < len; i++) {
						// looking for double zeros '\0\0'.
						if (!p[i] && !z) z = 1;
						else if (!p[i] && z) {
							len = i - 1;
							break;
						}
					}
					json = input[3] == 'j'; // "psuzj"
				}
				if (json) { // psuj
					print_json_string (core, (const char *) core->block, len, "utf16");
				} else {
					char *str = r_str_utf16_encode ((const char *) core->block, len);
					r_cons_println (str);
					free (str);
				}
			}
			break;
		case 'q': // "psq"
			r_core_cmd0 (core, "pqs");
			break;
		case 's': // "pss"
			if (l > 0) {
				int h, w = r_cons_get_size (&h);
				int colwidth = r_config_get_i (core->config, "hex.cols") * 2;
				core->print->width = (colwidth == 32)?w: colwidth; // w;
				int bs = core->blocksize;
				if (len == bs) {
					len = (h * w) / 3;
					r_core_block_size (core, len);
				}
				r_print_string (core->print, core->offset, core->block,
						len, R_PRINT_STRING_WRAP);
				r_core_block_size (core, bs);
			}
			break;
		case '+': // "ps+"
			if (l > 0) {
				const bool json = input[2] == 'j'; // ps+j
				ut64 bitness = r_config_get_i (core->config, "asm.bits");
				if (bitness != 32 && bitness != 64) {
					R_LOG_ERROR ("bitness of %" PFMT64u " not supported", bitness);
					break;
				}
				if (*core->block & 0x1) { // "long" string
					if (bitness == 64) {
						r_core_cmdf (core, "ps%c @ 0x%" PFMT64x, json ? 'j' : ' ', *((ut64 *)core->block + 2));
					} else {
						r_core_cmdf (core, "ps%c @ 0x%" PFMT32x, json ? 'j' : ' ', *((ut32 *)core->block + 2));
					}
				} else if (json) {
					print_json_string (core, (const char *) core->block + 1, len, NULL);
				} else {
					r_print_string (core->print, core->offset, core->block + 1,
						len, R_PRINT_STRING_ZEROEND);
				}
			}
			break;
		default: // "ps"
			{
				const char *current_charset = r_config_get (core->config, "cfg.charset");
				if (R_STR_ISEMPTY (current_charset)) {
					r_print_string (core->print, core->offset, core->block, len, R_PRINT_STRING_ZEROEND);
				} else {
					if (len > 0) {
						size_t out_len = len * 10;
						ut8 *out = calloc (len, 10);
						if (out) {
							ut8 *data = malloc (len);
							if (data) {
								r_io_read_at (core->io, core->offset, data, len);
								(void)r_charset_encode_str (core->print->charset, out, out_len, data, len);
								r_print_string (core->print, core->offset,
									out, len, R_PRINT_STRING_ZEROEND);
								free (data);
							}
							free (out);
						}
					}
				}
				break;
			}
		}
		break;
	case 'm': // "pm"
		if (input[1] == '?') {
			r_cons_printf ("Usage: pm [file|directory]\n"
				"| r_magic will use given file/dir as reference\n"
				"| output of those magic can contain expressions like:\n"
				"|   foo@0x40   # use 'foo' magic file on address 0x40\n"
				"|   @0x40      # use current magic file on address 0x40\n"
				"|   \\n         # append newline\n"
				"| e dir.magic  # defaults to " R_JOIN_2_PATHS ("{R2_PREFIX}", R2_SDB_MAGIC) "\n"
				"| /m           # search for magic signatures\n"
				);
		} else if (input[1] == 'j') { // "pmj"
			const char *filename = r_str_trim_head_ro (input + 2);
			PJ *pj = r_core_pj_new (core);
			r_core_magic (core, filename, true, pj);
			r_cons_println (pj_string (pj));
			pj_free (pj);
		} else {
			// XXX: need cmd_magic header for r_core_magic
			const char *filename = r_str_trim_head_ro (input + 1);
			r_core_magic (core, filename, true, NULL);
		}
		break;
	case 'u': // "pu"
		if (input[1] == '?') {
			r_cons_printf ("Usage: pu[w] [len]       print N url"
				"encoded bytes (w=wide)\n");
		} else {
			if (l > 0) {
				r_print_string (core->print, core->offset, core->block, len,
					R_PRINT_STRING_URLENCODE |
					((input[1] == 'w')? R_PRINT_STRING_WIDE: 0));
			}
		}
		break;
	case 'c': // "pc"
		if (input[1] == '?') {
			r_core_cmd_help (core, help_msg_pc);
		} else if (l) {
			const ut8 *buf = core->block;
			int i = 0;
			int j = 0;
			if (input[1] == 'A') { // "pcA"
				r_cons_printf ("sub_0x%08"PFMT64x ":\n", core->offset);
				for (i = 0; i < len; i++) {
					RAnalOp asmop = {
						0
					};
					(void) r_asm_disassemble (core->rasm, &asmop, buf + i, len - i);
					int sz = asmop.size;
					if (sz < 1) {
						sz = 1;
					}
					r_cons_printf (" .byte ");
					for (j = 0; j < sz; j++) {
						r_cons_printf ("%s0x%02x", j? ", ": "", buf[i]);
						i++;
					}
					r_cons_printf ("  // %s\n", asmop.mnemonic);
					i--;
					r_asm_op_fini (&asmop);
				}
				r_cons_printf (".equ shellcode_len, %d\n", len);
			} else {
				r_print_code (core->print, core->offset, core->block, len, input[1]);
			}
		}
		break;
	case 'C': // "pC"
		switch (input[1]) {
		case 0:
			cmd_pCd (core, "");
			break;
		case ' ':
		case 'd': // "pCd"
			cmd_pCd (core, input + 2);
			break;
		case 'D': // "pCD"
			cmd_pCD (core, input + 2);
			break;
		case 'a': // "pCa"
			cmd_pCx (core, input + 2, "pxa");
			break;
		case 'A': // pCA"
			cmd_pCx (core, input + 2, "pxA");
			break;
		case 'x': // "pCx"
			cmd_pCx (core, input + 2, "px");
			break;
		case 'w': // "pCw"
			cmd_pCx (core, input + 2, "pxw");
			break;
		case 'c': // "pCc"
			cmd_pCx (core, input + 2, "pc");
			break;
		default:
			eprintf ("Usage: pC[dDaAxwc] - column output for pxa, pxA, pxw, ..\n");
			break;
		}
		break;
	case 'r': // "pr"
		switch (input[1]) {
		case 'i': // "pri" // color raw image
			if (input[2] == 'n') {
				cmd_printmsg (core, input + 4);
			} else {
				// TODO: do colormap and palette conversions here
				int mode = r_config_get_i (core->config, "scr.color")? 0: 'a';
				int cols = r_config_get_i (core->config, "hex.cols");
				r_cons_image (core->block, core->blocksize, cols, mode);
			}
			break;
		case 'c': // "prc" // color raw dump
			if (input[2] == '?') {
				// TODO: change =e to colorized =mode
				r_cons_printf ("prc=e # colorblocks of entropy\n");
				// TODO: replace pz? help text with "See also"
				r_core_cmd0 (core, "pz?");
			} else if (input[2] == '=') {
				if (input[3] == '?') {
					r_core_cmd_help (core, help_msg_p_equal);
				} else {
					cmd_prc_zoom (core, input + 2);
				}
			} else {
				cmd_prc (core, block, len);
			}
			break;
		case '?':
			r_core_cmd_help (core, help_msg_pr);
			break;
		case 'g': // "prg" // gunzip
			switch (input[2]) {
			default:
			case '?':
				r_core_cmd_help (core, help_msg_prg);
				break;
			case 'l': // "prgl" // lz4
				{
					ut8 *dst = calloc (len, 4);
					if (dst) {
						// TODO. hack into lz4 to make it work without knowing the input
						int consumed = 0;
						int olen = 0;
						ut8 *obuf = r_inflate_lz4 (core->block, len, &consumed, &olen);
						if (obuf) {
							for (i = 0; i < olen; i += 32) {
								int left = R_MIN (olen - i, 32);
								r_cons_printf ("wx+");
								r_print_bytes (core->print, obuf + i, left, "%02x");
							}
						} else {
							R_LOG_ERROR ("Invalid input size %d", olen);
						}
						free (dst);
					}
				}
				break;
			case 'i': // "prgi"
			{
				int outlen = 0;
				int inConsumed = 0;
				ut8 *out;
				out = r_inflate (block, core->blocksize, &inConsumed, &outlen);
				r_cons_printf ("%d\n", inConsumed);
				free (out);
			}
			break;
			case 'o': // "prgo"
			{
				int outlen = 0;
				ut8 *out;
				out = r_inflate (block, core->blocksize, NULL, &outlen);
				r_cons_printf ("%d\n", outlen);
				free (out);
			}
			break;
			case 0:
			case ' ':
			{
				int outlen = 0;
				ut8 *out;
				out = r_inflate (block, core->blocksize, NULL, &outlen);
				if (out) {
					r_cons_write ((const char *) out, outlen);
				}
				free (out);
			}
			}
			break;
		/* TODO: compact */
		case 'l': // "prl"
			if (l != 0) {
				printraw (core, len, 1);
			}
			break;
		case 'x': // "prx"
#if 0
			if (l != 0) {
				printraw (core, len, 2);
			}
#else
			{
				int a = r_config_get_i (core->config, "hex.bytes");
				r_config_set_i (core->config, "hex.bytes", false);
				r_core_cmdf (core, "px%s", input + 1);
				r_config_set_i (core->config, "hex.bytes", a);
			}
#endif
			break;
		case 'z': // "prz"
			if (l != 0) {
				printraw (core, strlen ((const char *) core->block), 0);
			}
			break;
		default:
			if (l != 0) {
				printraw (core, len, 0);
			}
			break;
		}
		break;
	case '3': // "p3" [file]
		if (input[1] == '?') {
			r_core_cmd_help_match (core, help_msg_p, "p3", true);
		} else if (input[1] == ' ') {
			char *data = r_file_slurp (input + 2, NULL);
			if (!data) {
				R_LOG_ERROR ("Could not open '%s'", input + 2);
				break;
			}
			char *res = r_print_stereogram (data, 78, 20);
			r_print_stereogram_print (core->print, res);
			// if (data) eprintf ("%s\n", data);
			free (res);
			free (data);
		} else {
			char *res = r_print_stereogram_bytes (block, core->blocksize);
			r_print_stereogram_print (core->print, res);
			free (res);
		}
		break;
	case 'y': // "py"
		switch (input[1]) {
		case '?':
			r_core_cmd_help_match (core, help_msg_p, "py", false);
			break;
		case '-':
			if (r_config_get_b (core->config, "scr.interactive")) {
				int sz;
				char *data = r_stdin_slurp (&sz);
				if (data) {
					const char *const fn = ".tmp.py";
					r_file_dump (fn, (ut8*)data, sz, false);
					r_core_cmd_callf (core, ". %s", fn);
					r_file_rm (fn);
					free (data);
				}
			} else {
				R_LOG_ERROR ("requires interactive shell");
			}
			break;
		case ':':
			r_core_cmd_callf (core, "#!python %s", input + 2);
			break;
		case ' ':
			{
				char *data = (char *)r_str_trim_head_ro (input + 2);
				int sz = strlen (data);
				if (R_STR_ISNOTEMPTY (data)) {
					const char *const fn = ".tmp.py";
					if (r_file_dump (fn, (ut8*)data, sz, false)) {
						r_core_cmd_callf (core, ". %s", fn);
					}
					r_file_rm (fn);
				}
			}
			break;
		case 0:
			r_core_cmd_call (core, "yp");
			break;
		}
		break;
	case 'o': // "po"
		cmd_print_op (core, input);
		break;
	case 'x': // "px"
		if (input[1] == '-' && input[2] == '-') {
			int rowsize = r_config_get_i (core->config, "hex.cols");
			int ctxlines = r_num_math (core->num, input + 3);
			if (ctxlines < 0) {
				ctxlines = 0;
			}
			int size = rowsize + (rowsize * ctxlines * 2);
			ut64 addr = core->offset - (rowsize * ctxlines);
			r_core_cmdf (core, "px %d@0x%08"PFMT64x, size, addr);
			break;
		} else {
			bool show_offset = r_config_get_i (core->config, "hex.offset");
			if (show_offset) {
				core->print->flags |= R_PRINT_FLAGS_OFFSET;
			} else {
				core->print->flags &= ~R_PRINT_FLAGS_OFFSET;
			}
			int show_header = r_config_get_i (core->config, "hex.header");
			if (show_header) {
				core->print->flags |= R_PRINT_FLAGS_HEADER;
			} else {
				core->print->flags &= ~R_PRINT_FLAGS_HEADER;
			}
			/* Don't show comments in default case */
			core->print->use_comments = false;
		}
		r_cons_break_push (NULL, NULL);
		switch (input[1]) {
		case 'j': // "pxj"
			if (len < core->blocksize) {
				r_print_jsondump (core->print, core->block, R_MIN (core->blocksize, len), 8);
			} else {
				ut8 *data = malloc (len + 1);
				if (data) {
					memset (data, core->io->Oxff, len + 1);
					r_io_read_at (core->io, core->offset, data, len);
					r_print_jsondump (core->print, data, len, 8);
					free (data);
				}
			}
			break;
		case '*': // "px*"
			r_core_cmd0 (core, "pc*");
			break;
		case '/': // "px/"
			r_core_print_examine (core, input + 2);
			break;
		case '?':
			r_core_cmd_help (core, help_msg_px);
			break;
		case '0': // "px0"
			if (l) {
				int len = r_str_nlen ((const char *)core->block, core->blocksize);
				r_print_bytes (core->print, core->block, len, "%02x");
			}
			break;
		case 'a': // "pxa"
			if (l != 0) {
				if (len % 16) {
					len += 16 - (len % 16);
				}
				annotated_hexdump (core, input + 2, len);
			}
			break;
		case 'x': // "pxx"
			if (l != 0) {
				core->print->flags |= R_PRINT_FLAGS_NONHEX;
				r_print_hexdump (core->print, core->offset,
					core->block, len, 8, 1, 1);
				core->print->flags &= ~R_PRINT_FLAGS_NONHEX;
			}
			break;
		case 'X': // "pxX"
			if (l != 0) {
				ut8 *buf = calloc (len, 4);
				if (buf) {
					r_io_read_at (core->io, core->offset, buf, len * 4);
					core->print->flags |= R_PRINT_FLAGS_NONHEX;
					r_print_hexdump (core->print, core->offset, buf, len * 4, 8, 1, 1);
					core->print->flags &= ~R_PRINT_FLAGS_NONHEX;
					free (buf);
				}
			}
			break;
		case 'A': // "pxA"
			if (input[2] == '?') {
				r_core_cmd_help (core, help_msg_pxA);
			} else if (l) {
				cmd_print_pxA (core, len, input + 2);
			}
			break;
		case 'b': // "pxb"
			if (l) {
				ut32 n;
				int i, c;
				char buf[32];
				for (i = c = 0; i < len; i++, c++) {
					if (c == 0) {
						ut64 ea = core->offset + i;
						if (core->print->pava) {
							ut64 va = r_io_p2v (core->io, ea);
							if (va != UT64_MAX) {
								ea = va;
							}
						}
						r_print_section (core->print, ea);
						r_print_offset (core->print, ea, 0, 0, NULL);
					}
					r_str_bits (buf, core->block + i, 8, NULL);

					// split bits
					memmove (buf + 5, buf + 4, 5);
					buf[4] = 0;

					r_print_cursor (core->print, i, 1, 1);
					r_cons_printf ("%s_%s  ", buf, buf + 5);
					r_print_cursor (core->print, i, 1, 0);
					if (c == 3) {
						const ut8 *b = core->block + i - 3;
						int (*k) (const ut8 *, int) = cmd_pxb_k;
						char (*p) (char) = cmd_pxb_p;

						n = k (b, 0) | k (b, 1) | k (b, 2) | k (b, 3);
						r_cons_printf ("0x%08x  %c%c%c%c\n",
							n, p (b[0]), p (b[1]), p (b[2]), p (b[3]));
						c = -1;
					}
				}
			}
			break;
		case 'c': // "pxc"
			{
			int ocomments = core->print->use_comments;
			core->print->use_comments = core->print->flags & R_PRINT_FLAGS_COMMENT;
			if (l) {
				ut64 from = r_config_get_i (core->config, "diff.from");
				ut64 to = r_config_get_i (core->config, "diff.to");
				if (from == to && !from) {
					r_core_block_size (core, len);
					len = core->blocksize;
					r_print_hexdump (core->print, core->offset,
						core->block, core->blocksize, 16, 1, 1);
				} else {
					r_core_print_cmp (core, from, to);
				}
				core->num->value = len;
			}
			core->print->use_comments = ocomments;
			}
			break;
		case 'i': // "pxi"
			if (l != 0) {
				core->print->show_offset = r_config_get_i (core->config, "hex.offset");
				r_print_hexii (core->print, core->offset, core->block,
					core->blocksize, r_config_get_i (core->config, "hex.cols"));
			}
			break;
		case 'o': // "pxo"
			if (l != 0) {
				r_print_hexdump (core->print, core->offset,
					core->block, len, 8, 1, 1);
			}
			break;
		case 't': // "pxt"
			{
			ut64 origin = core->offset;
			const char *arg = strchr (input, ' ');
			if (arg) {
				origin = r_num_math (core->num, arg + 1);
			}
			// _pointer_table does r_core_cmd with @, so it modifies core->block
			// and this results in an UAF access when iterating over the jmptable
			// so we do a new allocation to avoid that issue
			ut8 *block = calloc (len, 1);
			if (block) {
				memcpy (block, core->block, len);
				_pointer_table (core, origin, core->offset, block, len, 4, input[2]);
				free (block);
			}
			}
			break;
		case 'u': // "pxu" // unsigned numbers
		case 'd': // "pxd" // signed numbers
			if (input[2] == '?') {
				if (input[1] == 'u') {
					r_core_cmd_help (core, help_msg_pxu);
				} else {
					r_core_cmd_help (core, help_msg_pxd);
				}
			} else if (l != 0) {
				switch (input[2]) {
				case '1': // "pxd1"
					// 1 byte signed words (byte)
					if (input[3] == 'j') {
						r_print_jsondump (core->print, core->block, len, 8);
					} else {
						const int nfmt = (input[1] == 'u')? -2: -1;
						r_print_hexdump (core->print, core->offset,
								 core->block, len, nfmt, 4, 1);
					}
					break;
				case '2': // "pxd2"
					// 2 byte signed words (short)
					if (input[3] == 'j') {
						r_print_jsondump (core->print, core->block,
							len, 16);
					} else {
						const int nfmt = (input[1] == 'u')? -11: -10;
						r_print_hexdump (core->print, core->offset,
								 core->block, len, nfmt, 2, 1);
					}
					break;
				case '8':
					if (input[3] == 'j') {
						r_print_jsondump (core->print, core->block,
							len, 64);
					} else {
						const int nfmt = (input[1] == 'u')? -9: -8;
						r_print_hexdump (core->print, core->offset,
								 core->block, len, nfmt, 4, 1);
					}
					break;
				case '4':
				case ' ':
				case 'j':
				case 0:
					// 4 byte signed words
					if (input[2] == 'j' || (input[2] && input[3] == 'j')) {
						r_print_jsondump (core->print, core->block,
							len, 32);
					} else {
						const int nfmt = (input[1] == 'u')? 11: 10;
						r_print_hexdump (core->print, core->offset,
								 core->block, len, nfmt, 4, 1);
					}
					break;
				default:
					r_core_cmd_help (core, help_msg_pxd);
					break;
				}
			}
			break;
		case 'w': // "pxw"
			if (l != 0) {
				if (input[2] == 'j') {
					r_print_jsondump (core->print, core->block, len, 32);
				} else {
					r_print_hexdump (core->print, core->offset, core->block, len, 32, 4, 1);
				}
			}
			break;
		case 'W': // "pxW"
			if (l) {
				bool printOffset = (input[2] != 'q' && r_config_get_i (core->config, "hex.offset"));
				bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->print->config);
				len = len - (len % 4);
				for (i = 0; i < len; i += 4) {
					const char *a, *b;
					char *fn;
					RPrint *p = core->print;
					RFlagItem *f;
					ut32 v = r_read_ble32 (core->block + i, be);
					if (p && p->colorfor) {
						a = p->colorfor (p->user, core->offset + i, v, true);
						if (a && *a) {
							b = Color_RESET;
						} else {
							a = b = "";
						}
					} else {
						a = b = "";
					}
					f = r_flag_get_at (core->flags, v, true);
					fn = NULL;
					if (f) {
						st64 delta = (v - f->offset);
						if (delta >= 0 && delta < 8192) {
							if (v == f->offset) {
								fn = strdup (f->name);
							} else {
								fn = r_str_newf ("%s+%" PFMT64d,
									f->name, v - f->offset);
							}
						}
					}
					if (printOffset) {
						r_print_section (core->print, core->offset +i);
						r_cons_printf ("0x%08"PFMT64x " %s0x%08"PFMT64x "%s%s%s\n",
								(ut64) core->offset + i, a, (ut64) v,
								b, fn? " ": "", r_str_get (fn));
					} else {
						r_cons_printf ("%s0x%08"PFMT64x "%s\n", a, (ut64) v, b);
					}
					free (fn);
				}
			}
			break;
		case 'r': // "pxr"
			if (l) {
				int mode = input[2];
				int wordsize = core->anal->config->bits / 8;
				if (mode == '?') {
					r_core_cmd_help_match (core, help_msg_px, "pxr", false);
					break;
				}
				if (mode && isdigit (mode)) {
					char tmp[2] = {input[2], 0};
					wordsize = atoi (tmp);
					mode = input[3];
				}
				switch (wordsize) {
				case 1:
				case 2:
				case 4:
				case 8:
					cmd_pxr (core, len, mode, wordsize, mode? strchr (input, mode): NULL);
					break;
				default:
					R_LOG_ERROR ("Invalid word size. Use 1, 2, 4 or 8");
					break;
				}
			}
			break;
		case 'h': // "pxh"
			if (l) {
				if (input[2] == 'j') {
					r_print_jsondump (core->print, core->block, len, 16);
				} else {
					r_print_hexdump (core->print, core->offset,
						core->block, len, 32, 2, 1);
				}
			}
			break;
		case 'H': // "pxH"
			if (l != 0) {
				const bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->rasm->config);
				len = len - (len % 2);
				for (i = 0; i < len; i += 2) {
					const char *a, *b;
					char *fn;
					RPrint *p = core->print;
					RFlagItem *f;
					ut64 v = (ut64) r_read_ble16 (core->block + i, be);
					if (p && p->colorfor) {
						a = p->colorfor (p->user, core->offset + i, v, true);
						if (a && *a) {
							b = Color_RESET;
						} else {
							a = b = "";
						}
					} else {
						a = b = "";
					}
					f = r_flag_get_at (core->flags, v, true);
					fn = NULL;
					if (f) {
						st64 delta = (v - f->offset);
						if (delta >= 0 && delta < 8192) {
							if (v == f->offset) {
								fn = strdup (f->name);
							} else {
								fn = r_str_newf ("%s+%"PFMT64d, f->name, v - f->offset);
							}
						}
					}
					r_cons_printf ("0x%08"PFMT64x " %s0x%04"PFMT64x "%s %s\n",
						(ut64) core->offset + i, a, v, b, r_str_get (fn));
					free (fn);
				}
			}
			break;
		case 'q': // "pxq"
			if (l) {
				int bs = core->blocksize;
				if (r_core_block_size (core, len)) {
					r_core_block_read (core);
				}
				if (input[2] == 'j') {
					r_print_jsondump (core->print, core->block, len, 64);
				} else {
					r_print_hexdump (core->print, core->offset, core->block, len, 64, 8, 1);
				}
				if (bs != core->blocksize) {
					r_core_block_size (core, bs);
				}
			}
			break;
		case 'Q': // "pxQ"
			// TODO. show if flag name, or inside function
			if (l) {
				bool printOffset = (input[2] != 'q' && r_config_get_i (core->config, "hex.offset"));
				const bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->rasm->config);
				len = len - (len % 8);
				for (i = 0; i < len; i += 8) {
					const char *a, *b;
					char *fn;
					RPrint *p = core->print;
					RFlagItem *f;
					ut64 v = r_read_ble64 (core->block + i, be);
					if (p && p->colorfor) {
						a = p->colorfor (p->user, core->offset + i, v, true);
						if (a && *a) {
							b = Color_RESET;
						} else {
							a = b = "";
						}
					} else {
						a = b = "";
					}
					f = r_flag_get_at (core->flags, v, true);
					fn = NULL;
					if (f) {
						st64 delta = (v - f->offset);
						if (delta >= 0 && delta < 8192) {
							if (v == f->offset) {
								fn = strdup (f->name);
							} else {
								fn = r_str_newf ("%s+%" PFMT64d, f->name, v - f->offset);
							}
						}
					}
					if (printOffset) {
						r_print_section (core->print, core->offset +i);
						r_cons_printf ("0x%08"PFMT64x " %s0x%016"PFMT64x "%s %s\n",
								(ut64) core->offset + i, a, v, b, r_str_get (fn));
					} else {
						r_cons_printf ("%s0x%016"PFMT64x "%s\n", a, v, b);
					}
					free (fn);
				}
			}
			break;
		case 's': // "pxs"
			if (l) {
				core->print->flags |= R_PRINT_FLAGS_SPARSE;
				r_print_hexdump (core->print, core->offset, core->block, len, 16, 1, 1);
				core->print->flags &= (((ut32) - 1) & (~R_PRINT_FLAGS_SPARSE));
			}
			break;
		case 'e': // "pxe" // emoji dump
			if (l != 0) {
				int j;
				char emoji[] = {
					'\x8c', '\x80', '\x8c', '\x82', '\x8c', '\x85', '\x8c', '\x88',
					'\x8c', '\x99', '\x8c', '\x9e', '\x8c', '\x9f', '\x8c', '\xa0',
					'\x8c', '\xb0', '\x8c', '\xb1', '\x8c', '\xb2', '\x8c', '\xb3',
					'\x8c', '\xb4', '\x8c', '\xb5', '\x8c', '\xb7', '\x8c', '\xb8',
					'\x8c', '\xb9', '\x8c', '\xba', '\x8c', '\xbb', '\x8c', '\xbc',
					'\x8c', '\xbd', '\x8c', '\xbe', '\x8c', '\xbf', '\x8d', '\x80',
					'\x8d', '\x81', '\x8d', '\x82', '\x8d', '\x83', '\x8d', '\x84',
					'\x8d', '\x85', '\x8d', '\x86', '\x8d', '\x87', '\x8d', '\x88',
					'\x8d', '\x89', '\x8d', '\x8a', '\x8d', '\x8b', '\x8d', '\x8c',
					'\x8d', '\x8d', '\x8d', '\x8e', '\x8d', '\x8f', '\x8d', '\x90',
					'\x8d', '\x91', '\x8d', '\x92', '\x8d', '\x93', '\x8d', '\x94',
					'\x8d', '\x95', '\x8d', '\x96', '\x8d', '\x97', '\x8d', '\x98',
					'\x8d', '\x9c', '\x8d', '\x9d', '\x8d', '\x9e', '\x8d', '\x9f',
					'\x8d', '\xa0', '\x8d', '\xa1', '\x8d', '\xa2', '\x8d', '\xa3',
					'\x8d', '\xa4', '\x8d', '\xa5', '\x8d', '\xa6', '\x8d', '\xa7',
					'\x8d', '\xa8', '\x8d', '\xa9', '\x8d', '\xaa', '\x8d', '\xab',
					'\x8d', '\xac', '\x8d', '\xad', '\x8d', '\xae', '\x8d', '\xaf',
					'\x8d', '\xb0', '\x8d', '\xb1', '\x8d', '\xb2', '\x8d', '\xb3',
					'\x8d', '\xb4', '\x8d', '\xb5', '\x8d', '\xb6', '\x8d', '\xb7',
					'\x8d', '\xb8', '\x8d', '\xb9', '\x8d', '\xba', '\x8d', '\xbb',
					'\x8d', '\xbc', '\x8e', '\x80', '\x8e', '\x81', '\x8e', '\x82',
					'\x8e', '\x83', '\x8e', '\x84', '\x8e', '\x85', '\x8e', '\x88',
					'\x8e', '\x89', '\x8e', '\x8a', '\x8e', '\x8b', '\x8e', '\x8c',
					'\x8e', '\x8d', '\x8e', '\x8e', '\x8e', '\x8f', '\x8e', '\x92',
					'\x8e', '\x93', '\x8e', '\xa0', '\x8e', '\xa1', '\x8e', '\xa2',
					'\x8e', '\xa3', '\x8e', '\xa4', '\x8e', '\xa5', '\x8e', '\xa6',
					'\x8e', '\xa7', '\x8e', '\xa8', '\x8e', '\xa9', '\x8e', '\xaa',
					'\x8e', '\xab', '\x8e', '\xac', '\x8e', '\xad', '\x8e', '\xae',
					'\x8e', '\xaf', '\x8e', '\xb0', '\x8e', '\xb1', '\x8e', '\xb2',
					'\x8e', '\xb3', '\x8e', '\xb4', '\x8e', '\xb5', '\x8e', '\xb7',
					'\x8e', '\xb8', '\x8e', '\xb9', '\x8e', '\xba', '\x8e', '\xbb',
					'\x8e', '\xbd', '\x8e', '\xbe', '\x8e', '\xbf', '\x8f', '\x80',
					'\x8f', '\x81', '\x8f', '\x82', '\x8f', '\x83', '\x8f', '\x84',
					'\x8f', '\x86', '\x8f', '\x87', '\x8f', '\x88', '\x8f', '\x89',
					'\x8f', '\x8a', '\x90', '\x80', '\x90', '\x81', '\x90', '\x82',
					'\x90', '\x83', '\x90', '\x84', '\x90', '\x85', '\x90', '\x86',
					'\x90', '\x87', '\x90', '\x88', '\x90', '\x89', '\x90', '\x8a',
					'\x90', '\x8b', '\x90', '\x8c', '\x90', '\x8d', '\x90', '\x8e',
					'\x90', '\x8f', '\x90', '\x90', '\x90', '\x91', '\x90', '\x92',
					'\x90', '\x93', '\x90', '\x94', '\x90', '\x95', '\x90', '\x96',
					'\x90', '\x97', '\x90', '\x98', '\x90', '\x99', '\x90', '\x9a',
					'\x90', '\x9b', '\x90', '\x9c', '\x90', '\x9d', '\x90', '\x9e',
					'\x90', '\x9f', '\x90', '\xa0', '\x90', '\xa1', '\x90', '\xa2',
					'\x90', '\xa3', '\x90', '\xa4', '\x90', '\xa5', '\x90', '\xa6',
					'\x90', '\xa7', '\x90', '\xa8', '\x90', '\xa9', '\x90', '\xaa',
					'\x90', '\xab', '\x90', '\xac', '\x90', '\xad', '\x90', '\xae',
					'\x90', '\xaf', '\x90', '\xb0', '\x90', '\xb1', '\x90', '\xb2',
					'\x90', '\xb3', '\x90', '\xb4', '\x90', '\xb5', '\x90', '\xb6',
					'\x90', '\xb7', '\x90', '\xb8', '\x90', '\xb9', '\x90', '\xba',
					'\x90', '\xbb', '\x90', '\xbc', '\x90', '\xbd', '\x90', '\xbe',
					'\x91', '\x80', '\x91', '\x82', '\x91', '\x83', '\x91', '\x84',
					'\x91', '\x85', '\x91', '\x86', '\x91', '\x87', '\x91', '\x88',
					'\x91', '\x89', '\x91', '\x8a', '\x91', '\x8b', '\x91', '\x8c',
					'\x91', '\x8d', '\x91', '\x8e', '\x91', '\x8f', '\x91', '\x90',
					'\x91', '\x91', '\x91', '\x92', '\x91', '\x93', '\x91', '\x94',
					'\x91', '\x95', '\x91', '\x96', '\x91', '\x97', '\x91', '\x98',
					'\x91', '\x99', '\x91', '\x9a', '\x91', '\x9b', '\x91', '\x9c',
					'\x91', '\x9d', '\x91', '\x9e', '\x91', '\x9f', '\x91', '\xa0',
					'\x91', '\xa1', '\x91', '\xa2', '\x91', '\xa3', '\x91', '\xa4',
					'\x91', '\xa5', '\x91', '\xa6', '\x91', '\xa7', '\x91', '\xa8',
					'\x91', '\xa9', '\x91', '\xaa', '\x91', '\xae', '\x91', '\xaf',
					'\x91', '\xba', '\x91', '\xbb', '\x91', '\xbc', '\x91', '\xbd',
					'\x91', '\xbe', '\x91', '\xbf', '\x92', '\x80', '\x92', '\x81',
					'\x92', '\x82', '\x92', '\x83', '\x92', '\x84', '\x92', '\x85'
				};
				int cols = core->print->cols;
				if (cols < 1) {
					cols = 1;
				}
				for (i = 0; i < len; i += cols) {
					r_print_addr (core->print, core->offset + i);
					for (j = i; j < i + cols; j += 1) {
						ut8 *p = (ut8 *) core->block + j;
						if (j < len) {
							r_cons_printf ("\xf0\x9f%c%c ", emoji[*p * 2], emoji[*p * 2 + 1]);
						} else {
							r_cons_print ("  ");
						}
					}
					r_cons_print (" ");
					for (j = i; j < len && j < i + cols; j += 1) {
						ut8 *p = (ut8 *) core->block + j;
						r_print_byte (core->print, core->offset + j, "%c", j, *p);
					}
					r_cons_newline ();
				}
			}
			break;
		case 'l': // "pxl"
			len = core->print->cols * len;
			/* fallthrough */
		default:
			if (l) {
				ut64 from = r_config_get_i (core->config, "diff.from");
				ut64 to = r_config_get_i (core->config, "diff.to");
				if (from == to && !from) {
					const char *sp = NULL;
					if (input[1] == '.') {
						sp = input + 2;
					}
					if (IS_DIGIT (input[1])) {
						sp = input + 1;
					}
					if (sp) {
						int n = (int) r_num_math (core->num, r_str_trim_head_ro (sp));
						if (!n) {
							goto beach;
						}
						len = n;
					}
					if (!r_core_block_size (core, len)) {
						len = core->blocksize;
					}
					r_core_block_read (core);
					r_print_hexdump (core->print, r_core_pava (core, core->offset),
						core->block, len, 16, 1, 1);
				} else {
					r_core_print_cmp (core, from, to);
				}
				core->num->value = len;
			}
			break;
		}
		r_cons_break_pop ();
		break;
	case '2': // "p2"
		if (l) {
			if (input[1] == '?') {
				r_cons_printf ("Usage: p2 [number of bytes representing tiles]\n"
					"NOTE: Only full tiles will be printed\n");
			} else {
				RConsContext *c = core->cons->context;
				const char **colors = (const char *[]) {
					c->pal.mov, //black
					c->pal.nop, //dark
					c->pal.cmp, //light
					c->pal.jmp, //white
				};
				const int cols = r_config_get_i (core->config, "hex.cols");
				r_print_2bpp_tiles (core->print, core->block, len - 1, cols / 4, colors);
			}
		}
		break;
	case '6': // "p6"
		if (1) {
			int malen = (core->blocksize * 4) + 1;
			ut8 *buf = malloc (malen);
			if (!buf) {
				break;
			}
			memset (buf, 0, malen);
			switch (input[1]) {
			case 'd': // "p6d"
				switch (input[2]) {
				case '?':
					r_core_cmd_help_match (core, help_msg_p6, "p6d", true);
					break;
				case 's': // "p6ds"
					if (input[3] == '?') {
						r_core_cmd_help_match (core, help_msg_p6, "p6ds", true);
					} else {
						char *a = r_str_trim_dup (input + 3);
						char *out = malloc ((4 + strlen (a)) * 4);
						if (r_base64_decode ((ut8 *)out,(const char *) a, strlen (a))) {
							r_cons_println ((const char *) out);
						} else {
							R_LOG_ERROR ("r_base64_decode: invalid stream");
						}
						free (a);
						free (out);
					}
					break;
				case 'z': // "p6dz"
					if (input[3] == '?') {
						r_core_cmd_help_match (core, help_msg_p6, "p6dz", true);
					} else {
						len = r_str_nlen ((const char *)block, len);
						if (r_base64_decode (buf, (const char *) block, len)) {
							r_cons_println ((const char *) buf);
						} else {
							R_LOG_ERROR ("r_base64_decode: invalid stream");
						}
						r_cons_println ((const char *) buf);
					}
					break;
				default:
					len = len > core->blocksize? core->blocksize: len;
					if (r_base64_decode (buf, (const char *) block, len)) {
						r_cons_println ((const char *) buf);
					} else {
						R_LOG_ERROR ("r_base64_decode: invalid stream");
					}
					break;
				}
				break;
			case 'e': // "p6e"
				switch (input[2]) {
				case '?':
					r_core_cmd_help_match (core, help_msg_p6, "p6e", true);
					break;
				case 's': // "p6es"
					if (input[3] == '?') {
						r_core_cmd_help_match (core, help_msg_p6, "p6es", true);
					} else {
						char *a = r_str_trim_dup (input + 3);
						char *out = calloc ((4 + strlen (a)), 4);
						r_base64_encode ((char *) out, (const ut8*)a, strlen (a));
						r_cons_println ((const char *) out);
						free (a);
						free (out);
					}
					break;
				case 'z': // "p6ez"
					if (input[3] == '?') {
						r_core_cmd_help_match (core, help_msg_p6, "p6ez", true);
					} else {
						len = r_str_nlen ((const char *)block, len);
						r_base64_encode ((char *) buf, block, len);
						r_cons_println ((const char *) buf);
					}
					break;
				default:
					len = len > core->blocksize? core->blocksize: len;
					r_base64_encode ((char *) buf, block, len);
					r_cons_println ((const char *) buf);
					break;
				}
				break;
			case '?':
			default:
				r_core_cmd_help (core, help_msg_p6);
				break;
			}
			free (buf);
		}
		break;
	case '8': // "p8"
		if (input[1] == '?') {
			r_core_cmd_help (core, help_msg_p8);
		} else if (l) {
			bool rad = strchr (input, '*');
			if (!r_core_block_size (core, len)) {
				len = core->blocksize;
			}
			if (input[1] == 'j') { // "p8j"
				r_core_cmdf (core, "pcj %s", input + 2);
			} else if (input[1] == 'x') { // "p8x"
				r_core_block_read (core);
				block = core->block;
				int cols = r_config_get_i (core->config, "hex.cols");
				if (cols < 1) {
					cols = 1;
				}
				int i;
				for (i = 0; i < len; i += cols) {
					if (rad) {
						r_cons_printf ("wx+ ");
					}
					r_print_bytes (core->print, block + i, R_MIN (cols, len - cols), "%02x");
				}
			} else if (input[1] == 'f') { // "p8f"
				r_core_cmdf (core, "p8 $FS @ $FB");
			} else {
				r_core_block_read (core);
				block = core->block;
				if (rad) {
					r_cons_printf ("wx+ ");
				}
				r_print_bytes (core->print, block, len, "%02x");
			}
		}
		break;
	case 'g': // "pg"
		cmd_print_gadget (core, input + 1);
		break;
	case 'f': // "pf"
		cmd_print_format (core, input, block, len);
		break;
	case 'F': // "pF"
		cmd_print_fromage (core, input + 1, block, len);
		break;
	case 'k': // "pk"
		if (input[1] == '?') {
			r_cons_printf ("Usage: pk [len]       print key in randomart\n");
			r_cons_printf ("Usage: pkill [process-name]\n");
		} else if (!strncmp (input, "kill", 4)) {
			RListIter *iter;
			RDebugPid *pid;
			const char *arg = strchr (input, ' ');
			RList *pids = (core->dbg->h && core->dbg->h->pids)
			? core->dbg->h->pids (core->dbg, 0): NULL;
			if (R_STR_ISNOTEMPTY (arg)) {
				arg++;
				r_list_foreach (pids, iter, pid) {
					if (strstr (pid->path, arg)) {
						r_cons_printf ("dk 9 %d\n", pid->pid);
					}
					// r_debug_kill (core->dbg, pid->pid, pid->pid, 9); // kill -9
				}
			}
			r_list_free (pids);
		} else if (l > 0) {
			len = len > core->blocksize? core->blocksize: len;
			char *s = r_print_randomart (block, len, core->offset);
			r_cons_println (s);
			free (s);
		}
		break;
	case 'K': // "pK"
		if (input[1] == '?') {
			r_cons_printf ("Usage: pK [len]       print key in randomart mosaic\n");
		} else if (l > 0) {
			len = len > core->blocksize? core->blocksize: len;
			int w, h;
			RConsCanvas *c;
			w = r_cons_get_size (&h);
			ut64 offset0 = core->offset;
			int cols = (w / 20);
			int rows = (h / 12);
			int i, j;
			char *s;
			if (rows < 1) {
				rows = 1;
			}
			c = r_cons_canvas_new (w, rows * 11);
			for (i = 0; i < rows; i++) {
				for (j = 0; j < cols; j++) {
					r_cons_canvas_gotoxy (c, j * 20, i * 11);
					core->offset += len;
					r_io_read_at (core->io, core->offset, core->block, len);
					s = r_print_randomart (core->block, len, core->offset);
					r_cons_canvas_write (c, s);
					free (s);
				}
			}
			r_cons_canvas_print (c);
			r_cons_canvas_free (c);
			r_io_read_at (core->io, offset0, core->block, len);
			core->offset = offset0;
			r_cons_printf ("\n");
		}
		break;
	case 'n': // easter
		R_LOG_ERROR ("easter egg license has expired");
		break;
	case 't': // "pt"
		switch (input[1]) {
		case '.': // "pt." same as "date"
			{
				char *nostr = r_time_stamp_to_str (time (0));
				r_cons_println (nostr);
				free (nostr);
			}
			break;
		case ' ':
		case '\0':
			// len must be multiple of 4 since r_mem_copyendian move data in fours - sizeof (ut32)
			if (len < sizeof (ut32)) {
				R_LOG_WARN ("You should change the block size: b %d", (int) sizeof (ut32));
			}
			if (len % sizeof (ut32)) {
				len = len - (len % sizeof (ut32));
			}
			for (l = 0; l < len; l += sizeof (ut32)) {
				r_print_date_unix (core->print, block + l, sizeof (ut32));
			}
			break;
		case 'h': // "pth"
			// len must be multiple of 4 since r_mem_copyendian move data in fours - sizeof (ut32)
			if (len < sizeof (ut32)) {
				R_LOG_WARN ("Change the block size: b %d", (int) sizeof (ut32));
			}
			if (len % sizeof (ut32)) {
				len = len - (len % sizeof (ut32));
			}
			for (l = 0; l < len; l += sizeof (ut32)) {
				r_print_date_hfs (core->print, block + l, sizeof (ut32));
			}
			break;
		case 'b': // "ptb"
			if (len < sizeof (ut32)) {
				R_LOG_WARN ("Change the block size: b %d", (int) sizeof (ut32));
			}
			if (len % sizeof (ut32)) {
				len = len - (len % sizeof (ut32));
			}
			for (l = 0; l < len; l += sizeof (ut64)) {
				ut64 ts = r_read_le64 (block + l);
				int beats = r_time_beats (ts, NULL);
				r_cons_printf ("@%03d\n", beats);
			}
			break;
		case 'd': // "ptd"
			// len must be multiple of 4 since r_print_date_dos read buf+3
			// if block size is 1 or 5 for example it reads beyond the buffer
			if (len < sizeof (ut32)) {
				R_LOG_WARN ("Change the block size: b %d", (int) sizeof (ut32));
			}
			if (len % sizeof (ut32)) {
				len = len - (len % sizeof (ut32));
			}
			for (l = 0; l < len; l += sizeof (ut32)) {
				r_print_date_dos (core->print, block + l, sizeof (ut32));
			}
			break;
		case 'n': // "ptn"
			if (len < sizeof (ut64)) {
				R_LOG_WARN ("Change the block size: b %d", (int) sizeof (ut64));
			}
			if (len % sizeof (ut64)) {
				len = len - (len % sizeof (ut64));
			}
			for (l = 0; l < len; l += sizeof (ut64)) {
				r_print_date_w32 (core->print, block + l, sizeof (ut64));
			}
			break;
		case '?':
			r_core_cmd_help (core, help_msg_pt);
			break;
		}
		break;
	case 'q': // "pq"
		switch (input[1]) {
		case '?':
			r_core_cmd_help (core, help_msg_pq);
			len = 0;
			break;
		case 's': // "pqs" // TODO pqs or pqz or pq0 :D
		case 'z': // for backward compat
			len = r_str_nlen ((const char *)block, core->blocksize);
			break;
		default:
			if (len < 1) {
				len = 0;
			}
			if (len > core->blocksize) {
				len = core->blocksize;
			}
			break;
		}
		if (len > 0) {
			bool inverted = (input[1] == 'i'); // pqi -- inverted colors
			char *res = r_qrcode_gen (block, len, r_config_get_i (core->config, "scr.utf8"), inverted);
			if (res) {
				r_cons_printf ("%s\n", res);
				free (res);
			}
		}
		break;
	case 'z': // "pz"
		if (input[1] == '?') {
			r_core_cmd_help (core, help_msg_pz);
		} else {
			RIOMap* map;
			RListIter *iter;
			RList *list = r_core_get_boundaries_prot (core, -1, NULL, "zoom");
			if (list && r_list_length (list) > 0) {
				RListIter *iter1 = list->head;
				RIOMap* map1 = iter1->data;
				from = map1->itv.addr;
				r_list_foreach (list, iter, map) {
					to = r_io_map_end (map);
				}
			} else {
				from = core->offset;
				to = from + core->blocksize;
			}
			ut64 maxsize = r_config_get_i (core->config, "zoom.maxsz");
			int oldva = core->io->va;
			char *oldmode = NULL;
			bool do_zoom = true;

			core->io->va = 0;
			if (input[1] && input[1] != ' ') {
				oldmode = strdup (r_config_get (core->config, "zoom.byte"));
				if (!r_config_set (core->config, "zoom.byte", input + 1)) {
					do_zoom = false;
				}
			}
			if (do_zoom && l > 0) {
				r_print_zoom (core->print, printzoomcallback, core,
					from, to, l, (int) maxsize);
			}
			if (oldmode) {
				r_config_set (core->config, "zoom.byte", oldmode);
			}
			core->io->va = oldva;
			R_FREE (oldmode);
			r_list_free (list);
		}
		break;
	default:
		if (*input && input[1] == 'j') {
			r_cons_cmd_help_json (help_msg_p);
		} else {
			r_core_cmd_help (core, help_msg_p);
		}
		break;
	}
beach:
	if (myblock) {
		free (block);
	}
	if (tmpseek != UT64_MAX) {
		r_core_seek (core, tmpseek, SEEK_SET);
		r_core_block_read (core);
	}
	if (tbs != core->blocksize) {
		r_core_block_size (core, tbs);
	}
	return ret;
}
