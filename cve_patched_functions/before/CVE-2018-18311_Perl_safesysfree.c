Perl_safesysfree(Malloc_t where)
{
#ifdef ALWAYS_NEED_THX
    dTHX;
#endif
    DEBUG_m( PerlIO_printf(Perl_debug_log, "0x%" UVxf ": (%05ld) free\n",PTR2UV(where),(long)PL_an++));
    if (where) {
#ifdef USE_MDH
	Malloc_t where_intrn = (Malloc_t)((char*)where-PERL_MEMORY_DEBUG_HEADER_SIZE);
	{
	    struct perl_memory_debug_header *const header
		= (struct perl_memory_debug_header *)where_intrn;

# ifdef MDH_HAS_SIZE
	    const MEM_SIZE size = header->size;
# endif
# ifdef PERL_TRACK_MEMPOOL
	    if (header->interpreter != aTHX) {
		Perl_croak_nocontext("panic: free from wrong pool, %p!=%p",
				     header->interpreter, aTHX);
	    }
	    if (!header->prev) {
		Perl_croak_nocontext("panic: duplicate free");
	    }
	    if (!(header->next))
		Perl_croak_nocontext("panic: bad free, header->next==NULL");
	    if (header->next->prev != header || header->prev->next != header) {
		Perl_croak_nocontext("panic: bad free, ->next->prev=%p, "
				     "header=%p, ->prev->next=%p",
				     header->next->prev, header,
				     header->prev->next);
	    }
	    /* Unlink us from the chain.  */
	    maybe_protect_rw(header->next);
	    header->next->prev = header->prev;
	    maybe_protect_ro(header->next);
	    maybe_protect_rw(header->prev);
	    header->prev->next = header->next;
	    maybe_protect_ro(header->prev);
	    maybe_protect_rw(header);
#  ifdef PERL_POISON
	    PoisonNew(where_intrn, size, char);
#  endif
	    /* Trigger the duplicate free warning.  */
	    header->next = NULL;
# endif
# ifdef PERL_DEBUG_READONLY_COW
	    if (munmap(where_intrn, size)) {
		perror("munmap failed");
		abort();
	    }	
# endif
	}
#else
	Malloc_t where_intrn = where;
#endif /* USE_MDH */
#ifndef PERL_DEBUG_READONLY_COW
	PerlMem_free(where_intrn);
#endif
    }
}
