void __mptcp_push_pending(struct sock *sk, unsigned int flags)
{
	struct sock *prev_ssk = NULL, *ssk = NULL;
	struct mptcp_sock *msk = mptcp_sk(sk);
	struct mptcp_sendmsg_info info = {
				.flags = flags,
	};
	struct mptcp_data_frag *dfrag;
	int len, copied = 0;

	while ((dfrag = mptcp_send_head(sk))) {
		info.sent = dfrag->already_sent;
		info.limit = dfrag->data_len;
		len = dfrag->data_len - dfrag->already_sent;
		while (len > 0) {
			int ret = 0;

			prev_ssk = ssk;
			ssk = mptcp_subflow_get_send(msk);

			/* First check. If the ssk has changed since
			 * the last round, release prev_ssk
			 */
			if (ssk != prev_ssk && prev_ssk)
				mptcp_push_release(prev_ssk, &info);
			if (!ssk)
				goto out;

			/* Need to lock the new subflow only if different
			 * from the previous one, otherwise we are still
			 * helding the relevant lock
			 */
			if (ssk != prev_ssk)
				lock_sock(ssk);

			ret = mptcp_sendmsg_frag(sk, ssk, dfrag, &info);
			if (ret <= 0) {
				mptcp_push_release(ssk, &info);
				goto out;
			}

			info.sent += ret;
			copied += ret;
			len -= ret;

			mptcp_update_post_push(msk, dfrag, ret);
		}
		WRITE_ONCE(msk->first_pending, mptcp_send_next(sk));
	}

	/* at this point we held the socket lock for the last subflow we used */
	if (ssk)
		mptcp_push_release(ssk, &info);

out:
	/* ensure the rtx timer is running */
	if (!mptcp_timer_pending(sk))
		mptcp_reset_timer(sk);
	if (copied)
		__mptcp_check_send_data_fin(sk);
}
