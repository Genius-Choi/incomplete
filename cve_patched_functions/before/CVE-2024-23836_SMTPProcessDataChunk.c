int SMTPProcessDataChunk(const uint8_t *chunk, uint32_t len,
        MimeDecParseState *state)
{
    SCEnter();
    int ret = MIME_DEC_OK;
    Flow *flow = (Flow *) state->data;
    SMTPState *smtp_state = (SMTPState *) flow->alstate;
    SMTPTransaction *tx = smtp_state->curr_tx;
    MimeDecEntity *entity = (MimeDecEntity *) state->stack->top->data;
    FileContainer *files = NULL;

    DEBUG_VALIDATE_BUG_ON(tx == NULL);

    uint16_t flags = FileFlowToFlags(flow, STREAM_TOSERVER);

    /* Find file */
    if (entity->ctnt_flags & CTNT_IS_ATTACHMENT) {
        files = &tx->files_ts;

        /* Open file if necessary */
        if (state->body_begin) {

            if (SCLogDebugEnabled()) {
                SCLogDebug("Opening file...%u bytes", len);
                printf("File - ");
                for (uint32_t i = 0; i < entity->filename_len; i++) {
                    printf("%c", entity->filename[i]);
                }
                printf("\n");
            }

            /* Set storage flag if applicable since only the first file in the
             * flow seems to be processed by the 'filestore' detector */
            if (files->head != NULL && (files->head->flags & FILE_STORE)) {
                flags |= FILE_STORE;
            }

            uint32_t depth = smtp_config.content_inspect_min_size +
                (smtp_state->toserver_data_count - smtp_state->toserver_last_data_stamp);
            SCLogDebug("StreamTcpReassemblySetMinInspectDepth STREAM_TOSERVER %"PRIu32, depth);
            StreamTcpReassemblySetMinInspectDepth(flow->protoctx, STREAM_TOSERVER, depth);

            uint16_t flen = (uint16_t)entity->filename_len;
            if (entity->filename_len > SC_FILENAME_MAX) {
                flen = SC_FILENAME_MAX;
                SMTPSetEvent(smtp_state, SMTP_DECODER_EVENT_MIME_LONG_FILENAME);
            }
            if (FileOpenFileWithId(files, &smtp_config.sbcfg, smtp_state->file_track_id++,
                        (uint8_t *)entity->filename, flen, (uint8_t *)chunk, len, flags) != 0) {
                ret = MIME_DEC_ERR_DATA;
                SCLogDebug("FileOpenFile() failed");
            } else {
                SMTPNewFile(tx, files->tail);
            }

            /* If close in the same chunk, then pass in empty bytes */
            if (state->body_end) {

                SCLogDebug("Closing file...%u bytes", len);

                if (files->tail->state == FILE_STATE_OPENED) {
                    ret = FileCloseFile(files, &smtp_config.sbcfg, (uint8_t *)NULL, 0, flags);
                    if (ret != 0) {
                        SCLogDebug("FileCloseFile() failed: %d", ret);
                        ret = MIME_DEC_ERR_DATA;
                    }
                } else {
                    SCLogDebug("File already closed");
                }
                depth = smtp_state->toserver_data_count - smtp_state->toserver_last_data_stamp;

                AppLayerParserTriggerRawStreamReassembly(flow, STREAM_TOSERVER);
                SCLogDebug("StreamTcpReassemblySetMinInspectDepth STREAM_TOSERVER %u",
                        depth);
                StreamTcpReassemblySetMinInspectDepth(flow->protoctx, STREAM_TOSERVER,
                        depth);
            }
        } else if (state->body_end) {
            /* Close file */
            SCLogDebug("Closing file...%u bytes", len);

            if (files->tail && files->tail->state == FILE_STATE_OPENED) {
                ret = FileCloseFile(files, &smtp_config.sbcfg, (uint8_t *)chunk, len, flags);
                if (ret != 0) {
                    SCLogDebug("FileCloseFile() failed: %d", ret);
                    ret = MIME_DEC_ERR_DATA;
                }
            } else {
                SCLogDebug("File already closed");
            }
            uint32_t depth = smtp_state->toserver_data_count - smtp_state->toserver_last_data_stamp;
            AppLayerParserTriggerRawStreamReassembly(flow, STREAM_TOSERVER);
            SCLogDebug("StreamTcpReassemblySetMinInspectDepth STREAM_TOSERVER %u",
                    depth);
            StreamTcpReassemblySetMinInspectDepth(flow->protoctx,
                    STREAM_TOSERVER, depth);
        } else {
            /* Append data chunk to file */
            SCLogDebug("Appending file...%u bytes", len);
            /* 0 is ok, -2 is not stored, -1 is error */
            ret = FileAppendData(files, &smtp_config.sbcfg, (uint8_t *)chunk, len);
            if (ret == -2) {
                ret = 0;
                SCLogDebug("FileAppendData() - file no longer being extracted");
            } else if (ret < 0) {
                SCLogDebug("FileAppendData() failed: %d", ret);
                ret = MIME_DEC_ERR_DATA;
            }

            if (files->tail && files->tail->content_inspected == 0 &&
                    files->tail->size >= smtp_config.content_inspect_min_size) {
                uint32_t depth = smtp_config.content_inspect_min_size +
                    (smtp_state->toserver_data_count - smtp_state->toserver_last_data_stamp);
                AppLayerParserTriggerRawStreamReassembly(flow, STREAM_TOSERVER);
                SCLogDebug("StreamTcpReassemblySetMinInspectDepth STREAM_TOSERVER %u",
                        depth);
                StreamTcpReassemblySetMinInspectDepth(flow->protoctx,
                        STREAM_TOSERVER, depth);

            /* after the start of the body inspection, disable the depth logic */
            } else if (files->tail && files->tail->content_inspected > 0) {
                StreamTcpReassemblySetMinInspectDepth(flow->protoctx,
                        STREAM_TOSERVER, 0);

            /* expand the limit as long as we get file data, as the file data is bigger on the
             * wire due to base64 */
            } else {
                uint32_t depth = smtp_config.content_inspect_min_size +
                    (smtp_state->toserver_data_count - smtp_state->toserver_last_data_stamp);
                SCLogDebug("StreamTcpReassemblySetMinInspectDepth STREAM_TOSERVER %"PRIu32,
                        depth);
                StreamTcpReassemblySetMinInspectDepth(flow->protoctx,
                        STREAM_TOSERVER, depth);
            }
        }

        if (ret == 0) {
            SCLogDebug("Successfully processed file data!");
        }
    } else {
        SCLogDebug("Body not a Ctnt_attachment");
    }
    SCReturnInt(ret);
}
