static long cec_dqevent(struct cec_adapter *adap, struct cec_fh *fh,
			bool block, struct cec_event __user *parg)
{
	struct cec_event_entry *ev = NULL;
	u64 ts = ~0ULL;
	unsigned int i;
	unsigned int ev_idx;
	long err = 0;

	mutex_lock(&fh->lock);
	while (!fh->total_queued_events && block) {
		mutex_unlock(&fh->lock);
		err = wait_event_interruptible(fh->wait,
					       fh->total_queued_events);
		if (err)
			return err;
		mutex_lock(&fh->lock);
	}

	/* Find the oldest event */
	for (i = 0; i < CEC_NUM_EVENTS; i++) {
		struct cec_event_entry *entry =
			list_first_entry_or_null(&fh->events[i],
						 struct cec_event_entry, list);

		if (entry && entry->ev.ts <= ts) {
			ev = entry;
			ev_idx = i;
			ts = ev->ev.ts;
		}
	}

	if (!ev) {
		err = -EAGAIN;
		goto unlock;
	}
	list_del(&ev->list);

	if (copy_to_user(parg, &ev->ev, sizeof(ev->ev)))
		err = -EFAULT;
	if (ev_idx >= CEC_NUM_CORE_EVENTS)
		kfree(ev);
	fh->queued_events[ev_idx]--;
	fh->total_queued_events--;

unlock:
	mutex_unlock(&fh->lock);
	return err;
}
