static int evict_unlinked_inode(struct inode *inode)
{
	struct gfs2_inode *ip = GFS2_I(inode);
	int ret;

	if (S_ISDIR(inode->i_mode) &&
	    (ip->i_diskflags & GFS2_DIF_EXHASH)) {
		ret = gfs2_dir_exhash_dealloc(ip);
		if (ret)
			goto out;
	}

	if (ip->i_eattr) {
		ret = gfs2_ea_dealloc(ip);
		if (ret)
			goto out;
	}

	if (!gfs2_is_stuffed(ip)) {
		ret = gfs2_file_dealloc(ip);
		if (ret)
			goto out;
	}

	if (ip->i_gl)
		gfs2_inode_remember_delete(ip->i_gl, ip->i_no_formal_ino);

	/*
	 * As soon as we clear the bitmap for the dinode, gfs2_create_inode()
	 * can get called to recreate it, or even gfs2_inode_lookup() if the
	 * inode was recreated on another node in the meantime.
	 *
	 * However, inserting the new inode into the inode hash table will not
	 * succeed until the old inode is removed, and that only happens after
	 * ->evict_inode() returns.  The new inode is attached to its inode and
	 *  iopen glocks after inserting it into the inode hash table, so at
	 *  that point we can be sure that both glocks are unused.
	 */

	ret = gfs2_dinode_dealloc(ip);
out:
	return ret;
}
