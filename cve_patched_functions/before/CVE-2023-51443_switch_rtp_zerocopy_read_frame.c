SWITCH_DECLARE(switch_status_t) switch_rtp_zerocopy_read_frame(switch_rtp_t *rtp_session, switch_frame_t *frame, switch_io_flag_t io_flags)
{
	int bytes = 0;

	if (!switch_rtp_ready(rtp_session)) {
		return SWITCH_STATUS_FALSE;
	}

	bytes = rtp_common_read(rtp_session, &frame->payload, &frame->pmap, &frame->flags, io_flags);

	frame->data = RTP_BODY(rtp_session);

	if (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] && (bytes < rtp_header_len || switch_test_flag(frame, SFF_CNG))) {
		frame->packet = NULL;
		frame->timestamp = 0;
		frame->seq = 0;
		frame->ssrc = 0;
		frame->m = 0;
	} else {

		frame->packet = &rtp_session->recv_msg;
		frame->packetlen = bytes;
		frame->source = __FILE__;

		switch_set_flag(frame, SFF_RAW_RTP);
		switch_set_flag(frame, SFF_EXTERNAL);
		if (frame->payload == rtp_session->recv_te) {
			switch_set_flag(frame, SFF_RFC2833);
		}
		frame->timestamp = ntohl(rtp_session->last_rtp_hdr.ts);
		frame->seq = (uint16_t) ntohs((uint16_t) rtp_session->last_rtp_hdr.seq);
		frame->ssrc = ntohl(rtp_session->last_rtp_hdr.ssrc);
		frame->m = rtp_session->last_rtp_hdr.m ? SWITCH_TRUE : SWITCH_FALSE;
	}


	if (bytes < 0) {
		frame->datalen = 0;
		return bytes == -2 ? SWITCH_STATUS_TIMEOUT : SWITCH_STATUS_GENERR;
	} else if (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {
		if (bytes < rtp_header_len) {
			frame->datalen = 0;
			return SWITCH_STATUS_BREAK;
		} else {
			bytes -= rtp_header_len;
		}
	}

	frame->datalen = bytes;
	return SWITCH_STATUS_SUCCESS;
}
