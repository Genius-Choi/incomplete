int mk_request_header_toc_parse(struct headers_toc *toc, const char *data, int len)
{
    int i = 0;
    int header_len;
    int colon;
    char *q;
    char *p = (char *) data;
    char *l = p;

    toc->length = 0;

    for (i = 0; l < (data + len) && p && i < MK_HEADERS_TOC_LEN; i++) {
        if (*p == '\r') goto out;

        /* Locate the colon character and the end of the line by CRLF */
        colon = -1;
        for (q = p; *q != 0x0D; ++q) {
            if (*q == ':' && colon == -1) {
                colon = (q - p);
            }
        }

        /* it must be a LF after CR */
        if (*(q + 1) != 0x0A) {
            return -1;
        }

        /*
         * Check if we reach the last header, take in count the first one can
         * be also the last.
         */
        if (data + len == (q - 1) && colon == -1) {
            break;
        }

        /*
         * By this version we force that after the colon must exists a white
         * space before the value field
         */
        if (*(p + colon + 1) != 0x20) {
            return -1;
        }


        /* Each header key must have a value */
        header_len = q - p - colon - 2;
        if (header_len == 0) {
            return -1;
        }

        /* Register the entry */
        toc->rows[i].init = p;
        toc->rows[i].end = q;
        toc->rows[i].status = 0;
        p = (q + mk_crlf.len);
        l = p;
        toc->length++;
    }

 out:
    return toc->length;
}
