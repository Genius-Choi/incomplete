static void trilogy_pack_scramble_sha2_hash(const char *scramble, const char *password, size_t password_len,
                                            uint8_t *buffer, unsigned int *buffer_len)
{
    EVP_MD_CTX *ctx;
    const EVP_MD *alg;
    unsigned int hash_size_tmp1;
    unsigned int hash_size_tmp2;
    unsigned int x;

#if OPENSSL_VERSION_NUMBER >= 0x1010000fL
    ctx = EVP_MD_CTX_new();
#else
    ctx = EVP_MD_CTX_create();
    EVP_MD_CTX_init(ctx);
#endif
    alg = EVP_sha256();
    hash_size_tmp1 = 0;
    hash_size_tmp2 = 0;
    uint8_t hash_tmp1[EVP_MAX_MD_SIZE];
    uint8_t hash_tmp2[EVP_MAX_MD_SIZE];

    /* First hash the password. */
    EVP_DigestInit_ex(ctx, alg, NULL);
    EVP_DigestUpdate(ctx, (unsigned char *)(password), password_len);
    EVP_DigestFinal_ex(ctx, hash_tmp1, &hash_size_tmp1);

    /* Second, hash the password hash. */
    EVP_DigestInit_ex(ctx, alg, NULL);
    EVP_DigestUpdate(ctx, hash_tmp1, (size_t)hash_size_tmp1);
    EVP_DigestFinal_ex(ctx, hash_tmp2, &hash_size_tmp2);

    /* Third, hash the scramble and the double password hash. */
    EVP_DigestInit_ex(ctx, alg, NULL);
    EVP_DigestUpdate(ctx, hash_tmp2, (size_t)hash_size_tmp2);
    EVP_DigestUpdate(ctx, (unsigned char *)scramble, SCRAMBLE_LEN);
    EVP_DigestFinal_ex(ctx, buffer, buffer_len);

#if OPENSSL_VERSION_NUMBER >= 0x1010000fL
    EVP_MD_CTX_free(ctx);
#else
    EVP_MD_CTX_destroy(ctx);
#endif

    /* Fourth, xor the first and last hash. */
    for (x = 0; x < *buffer_len; x++) {
        buffer[x] = hash_tmp1[x] ^ buffer[x];
    }
}
