choose_passage(passagecnt, oid)
int passagecnt; /* total of available passages */
unsigned oid; /* book.o_id, used to determine whether re-reading same book */
{
    int idx, res;

    if (passagecnt < 1)
        return 0;

    /* if a different book or we've used up all the passages already,
       reset in order to have all 'passagecnt' passages available */
    if (oid != context.novel.id || context.novel.count == 0) {
        int i, range = passagecnt, limit = MAXPASSAGES;

        context.novel.id = oid;
        if (range <= limit) {
            /* collect all of the N indices */
            context.novel.count = passagecnt;
            for (idx = 0; idx < MAXPASSAGES; idx++)
                context.novel.pasg[idx] = (xchar) ((idx < passagecnt)
                                                   ? idx + 1 : 0);
        } else {
            /* collect MAXPASSAGES of the N indices */
            context.novel.count = MAXPASSAGES;
            for (idx = i = 0; i < passagecnt; ++i, --range)
                if (range > 0 && rn2(range) < limit) {
                    context.novel.pasg[idx++] = (xchar) (i + 1);
                    --limit;
                }
        }
    }

    idx = rn2(context.novel.count);
    res = (int) context.novel.pasg[idx];
    /* move the last slot's passage index into the slot just used
       and reduce the number of passages available */
    context.novel.pasg[idx] = context.novel.pasg[--context.novel.count];
    return res;
}
