switch_to_user_with_privs (void)
{
  /* If we're in a new user namespace, we got back the bounding set, clear it again */
  if (opt_unshare_user || opt_userns_fd != -1)
    drop_cap_bounding_set (FALSE);

  /* If we switched to a new user namespace it may allow other uids/gids, so switch to the target one */
  if (opt_userns_fd != -1)
    {
      if (opt_sandbox_uid != real_uid && setuid (opt_sandbox_uid) < 0)
        die_with_error ("unable to switch to uid %d", opt_sandbox_uid);

      if (opt_sandbox_gid != real_gid && setgid (opt_sandbox_gid) < 0)
        die_with_error ("unable to switch to gid %d", opt_sandbox_gid);
    }

  if (!is_privileged)
    return;

  /* Tell kernel not clear capabilities when later dropping root uid */
  if (prctl (PR_SET_KEEPCAPS, 1, 0, 0, 0) < 0)
    die_with_error ("prctl(PR_SET_KEEPCAPS) failed");

  if (setuid (opt_sandbox_uid) < 0)
    die_with_error ("unable to drop root uid");

  /* Regain effective required capabilities from permitted */
  set_required_caps ();
}
