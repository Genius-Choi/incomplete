void HeaderString::append(const char* data, uint32_t size) {
  switch (type_) {
  case Type::Reference: {
    // Rather than be too clever and optimize this uncommon case, we dynamically
    // allocate and copy.
    type_ = Type::Dynamic;
    const uint64_t new_capacity = newCapacity(string_length_, size);
    if (new_capacity > MinDynamicCapacity) {
      validateCapacity(new_capacity);
      dynamic_capacity_ = new_capacity;
    } else {
      dynamic_capacity_ = MinDynamicCapacity;
    }
    char* buf = static_cast<char*>(malloc(dynamic_capacity_));
    RELEASE_ASSERT(buf != nullptr, "");
    memcpy(buf, buffer_.ref_, string_length_);
    buffer_.dynamic_ = buf;
    break;
  }

  case Type::Inline: {
    const uint64_t new_capacity = static_cast<uint64_t>(size) + string_length_;
    if (new_capacity <= sizeof(inline_buffer_)) {
      // Already inline and the new value fits in inline storage.
      break;
    }

    FALLTHRU;
  }

  case Type::Dynamic: {
    // We can get here either because we didn't fit in inline or we are already dynamic.
    if (type_ == Type::Inline) {
      const uint64_t new_capacity = newCapacity(string_length_, size);
      validateCapacity(new_capacity);
      buffer_.dynamic_ = static_cast<char*>(malloc(new_capacity));
      RELEASE_ASSERT(buffer_.dynamic_ != nullptr, "");
      memcpy(buffer_.dynamic_, inline_buffer_, string_length_);
      dynamic_capacity_ = new_capacity;
      type_ = Type::Dynamic;
    } else {
      if (size + string_length_ > dynamic_capacity_) {
        const uint64_t new_capacity = newCapacity(string_length_, size);
        validateCapacity(new_capacity);

        // Need to reallocate.
        dynamic_capacity_ = new_capacity;
        buffer_.dynamic_ = static_cast<char*>(realloc(buffer_.dynamic_, dynamic_capacity_));
        RELEASE_ASSERT(buffer_.dynamic_ != nullptr, "");
      }
    }
  }
  }
  ASSERT(validHeaderString(absl::string_view(data, size)));
  memcpy(buffer_.dynamic_ + string_length_, data, size);
  string_length_ += size;
}
