static Jsi_RC intervalTimer(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr, int once)
{
    bool isNew;
    Jsi_Event *evPtr;
    uintptr_t id;
    Jsi_Number milli;
    long milliseconds, cur_sec, cur_ms;
    Jsi_Value *fv = Jsi_ValueArrayIndex(interp, args, 0);
    Jsi_Value *tv = Jsi_ValueArrayIndex(interp, args, 1);
    
    if (!Jsi_ValueIsFunction(interp, fv)) 
        return Jsi_LogError("arg1: expected function 'callback'");
    if (Jsi_GetNumberFromValue(interp, tv, &milli) != JSI_OK) 
        return Jsi_LogError("arg2: expected number 'ms'");
    milliseconds = (long)milli;
    if (milliseconds < 0)
        milliseconds = 0;
    while (1) {
        id = ++interp->eventIdx;
        Jsi_HashEntry *hPtr = Jsi_HashEntryNew(interp->eventTbl, (void*)id, &isNew);
        if (!isNew)
            continue;
        evPtr = (Jsi_Event*)Jsi_Calloc(1, sizeof(*evPtr));
        SIGINIT(evPtr,EVENT);
        evPtr->id = id;
        evPtr->funcVal = fv;
        Jsi_IncrRefCount(interp, fv);
        evPtr->hPtr = hPtr;
        jsiGetTime(&cur_sec, &cur_ms);
        evPtr->initialms = milliseconds;
        evPtr->when_sec = cur_sec + milliseconds / 1000;
        evPtr->when_ms = cur_ms + milliseconds % 1000;
        if (evPtr->when_ms >= 1000) {
            evPtr->when_sec++;
            evPtr->when_ms -= 1000;
        }
        evPtr->once = once;
        Jsi_HashValueSet(hPtr, evPtr);
        break;
    }
    Jsi_ValueMakeNumber(interp, ret, (Jsi_Number)id);
    return JSI_OK;
}
