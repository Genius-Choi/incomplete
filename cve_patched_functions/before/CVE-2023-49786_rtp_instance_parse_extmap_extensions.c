static void rtp_instance_parse_extmap_extensions(struct ast_rtp_instance *instance, struct ast_rtp *rtp,
	unsigned char *extension, int len)
{
	int transport_wide_cc_id = ast_rtp_instance_extmap_get_id(instance, AST_RTP_EXTENSION_TRANSPORT_WIDE_CC);
	int pos = 0;

	/* We currently only care about the transport-cc extension, so if that's not negotiated then do nothing */
	if (transport_wide_cc_id == -1) {
		return;
	}

	/* Only while we do not exceed available extension data do we continue */
	while (pos < len) {
		int id = extension[pos] >> 4;
		int extension_len = (extension[pos] & 0xF) + 1;

		/* We've handled the first byte as it contains the extension id and length, so always
		 * skip ahead now
		 */
		pos += 1;

		if (id == 0) {
			/* From the RFC:
			 * In both forms, padding bytes have the value of 0 (zero).  They may be
			 * placed between extension elements, if desired for alignment, or after
			 * the last extension element, if needed for padding.  A padding byte
			 * does not supply the ID of an element, nor the length field.  When a
			 * padding byte is found, it is ignored and the parser moves on to
			 * interpreting the next byte.
			 */
			continue;
		} else if (id == 15) {
			/* From the RFC:
			 * The local identifier value 15 is reserved for future extension and
			 * MUST NOT be used as an identifier.  If the ID value 15 is
			 * encountered, its length field should be ignored, processing of the
			 * entire extension should terminate at that point, and only the
			 * extension elements present prior to the element with ID 15
			 * considered.
			 */
			break;
		} else if ((pos + extension_len) > len) {
			/* The extension is corrupted and is stating that it contains more data than is
			 * available in the extensions data.
			 */
			break;
		}

		/* If this is transport-cc then we need to parse it further */
		if (id == transport_wide_cc_id) {
			rtp_instance_parse_transport_wide_cc(instance, rtp, extension + pos, extension_len);
		}

		/* Skip ahead to the next extension */
		pos += extension_len;
	}
}
