R_API void r_print_offset(RPrint *p, ut64 off, int invert, int delta, const char *label) {
	int offdec = (p->flags & R_PRINT_FLAGS_ADDRDEC) != 0;
	const int segbas = p->config->segbas;
	const int seggrn = p->config->seggrn;
	const int offseg = (p->flags & R_PRINT_FLAGS_SEGOFF) != 0;
	char space[32] = {
		0
	};
	const char *reset = p->resetbg? Color_RESET: Color_RESET_NOBG;
	bool show_color = p->flags & R_PRINT_FLAGS_COLOR;
	if (show_color) {
		char rgbstr[32];
		const char *k = r_cons_singleton ()->context->pal.offset; // TODO etooslow. must cache
		const char *inv = invert ? R_CONS_INVERT (true, true) : "";
		if (p->flags & R_PRINT_FLAGS_RAINBOW) {
			k = r_cons_rgb_str_off (rgbstr, sizeof (rgbstr), off);
		}
		if (offseg) {
			ut32 s, a;
			r_num_segaddr (off, segbas, seggrn, &s, &a);
			if (offdec) {
				snprintf (space, sizeof (space), "%d:%d", s, a);
				r_cons_printf ("%s%s%9s%s", k, inv, space, reset);
			} else {
				r_cons_printf ("%s%s%04x:%04x%s", k, inv, s, a, reset);
			}
		} else {
			int sz = lenof (off, 0);
			int sz2 = lenof (delta, 1);
			if (delta > 0 || label) {
				if (label) {
					const int label_padding = 10;
					if (delta > 0) {
						const char *pad = r_str_pad (' ', sz - sz2 + label_padding);
						if (offdec) {
							r_cons_printf ("%s%s%s%s+%d%s", k, inv, label, reset, delta, pad);
						} else {
							r_cons_printf ("%s%s%s%s+0x%x%s", k, inv, label, reset, delta, pad);
						}
					} else {
						const char *pad = r_str_pad (' ', sz + label_padding);
						r_cons_printf ("%s%s%s%s%s", k, inv, label, reset, pad);
					}
				} else {
					const char *pad = r_str_pad (' ', sz - sz2);
					if (offdec) {
						r_cons_printf ("%s+%d%s", pad, delta, reset);
					} else {
						r_cons_printf ("%s+0x%x%s", pad, delta, reset);
					}
				}
			} else {
				if (offdec) {
					snprintf (space, sizeof (space), "%"PFMT64u, off);
					r_cons_printf ("%s%s%10s%s", k, inv, space, reset);
				} else {
					if (p->wide_offsets) {
						r_cons_printf ("%s%s0x%016"PFMT64x "%s", k, inv, off, reset);
					} else {
						r_cons_printf ("%s%s0x%08"PFMT64x "%s", k, inv, off, reset);
					}
				}
			}
		}
		r_cons_print (" ");
	} else {
		if (offseg) {
			ut32 s, a;
			r_num_segaddr (off, segbas, seggrn, &s, &a);
			if (offdec) {
				snprintf (space, sizeof (space), "%d:%d", s & 0xffff, a & 0xffff);
				r_cons_printf ("%9s%s", space, reset);
			} else {
				r_cons_printf ("%04x:%04x", s & 0xFFFF, a & 0xFFFF);
			}
		} else {
			int sz = lenof (off, 0);
			int sz2 = lenof (delta, 1);
			const char *pad = r_str_pad (' ', sz - 5 - sz2 - 3);
			if (delta > 0 || label) {
				if (label) {
					const int label_padding = 10;
					if (delta > 0) {
						const char *pad = r_str_pad (' ', sz - sz2 + label_padding);
						if (offdec) {
							r_cons_printf ("%s+%d%s", label, delta, pad);
						} else {
							r_cons_printf ("%s+0x%x%s", label, delta, pad);
						}
					} else {
						const char *pad = r_str_pad (' ', sz + label_padding);
						r_cons_printf ("%s%s", label, pad);
					}
				} else {
					if (offdec) {
						r_cons_printf ("%s+%d%s", pad, delta, reset);
					} else {
						r_cons_printf ("%s+0x%x%s", pad, delta, reset);
					}
				}
			} else {
				if (offdec) {
					snprintf (space, sizeof (space), "%"PFMT64u, off);
					r_cons_printf ("%10s", space);
				} else {
					r_cons_printf ("0x%08"PFMT64x " ", off);
				}
			}
		}
	}
}
