static intptr_t fio_unix_socket(const char *address, uint8_t server) {
  /* Unix socket */
  struct sockaddr_un addr = {0};
  size_t addr_len = strlen(address);
  if (addr_len >= sizeof(addr.sun_path)) {
    FIO_LOG_ERROR("(fio_unix_socket) address too long (%zu bytes > %zu bytes).",
                  addr_len, sizeof(addr.sun_path) - 1);
    errno = ENAMETOOLONG;
    return -1;
  }
  addr.sun_family = AF_UNIX;
  memcpy(addr.sun_path, address, addr_len + 1); /* copy the NUL byte. */
#if defined(__APPLE__)
  addr.sun_len = addr_len;
#endif
  // get the file descriptor
  int fd = socket(AF_UNIX, SOCK_STREAM, 0);
  if (fd == -1) {
    return -1;
  }
  if (fio_set_non_block(fd) == -1) {
    close(fd);
    return -1;
  }
  if (server) {
    unlink(addr.sun_path);
    if (bind(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
      // perror("couldn't bind unix socket");
      close(fd);
      return -1;
    }
    if (listen(fd, SOMAXCONN) < 0) {
      // perror("couldn't start listening to unix socket");
      close(fd);
      return -1;
    }
    /* chmod for foriegn connections */
    fchmod(fd, 0777);
  } else {
    if (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1 &&
        errno != EINPROGRESS) {
      close(fd);
      return -1;
    }
  }
  fio_lock(&fd_data(fd).protocol_lock);
  fio_clear_fd(fd, 1);
  fio_unlock(&fd_data(fd).protocol_lock);
  if (addr_len < sizeof(fd_data(fd).addr)) {
    memcpy(fd_data(fd).addr, address, addr_len + 1); /* copy the NUL byte. */
    fd_data(fd).addr_len = addr_len;
  }
  return fd2uuid(fd);
}
