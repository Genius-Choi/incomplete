static int _send(gnrc_netif_t *netif, gnrc_pktsnip_t *pkt)
{
    netdev_t *dev = netif->dev;
    netdev_ieee802154_t *state = container_of(dev, netdev_ieee802154_t, netdev);
    gnrc_netif_hdr_t *netif_hdr;
    const uint8_t *src, *dst = NULL;
    int res = 0;
    size_t src_len, dst_len;
    uint8_t mhr_len;
#if IS_USED(MODULE_IEEE802154_SECURITY)
    uint8_t mhr[IEEE802154_MAX_HDR_LEN + IEEE802154_SEC_MAX_AUX_HDR_LEN];
#else
    uint8_t mhr[IEEE802154_MAX_HDR_LEN];
#endif
    uint8_t flags = (uint8_t)(state->flags & NETDEV_IEEE802154_SEND_MASK);
    le_uint16_t dev_pan = byteorder_htols(state->pan);

    flags |= IEEE802154_FCF_TYPE_DATA;
    if (pkt == NULL) {
        DEBUG("_send_ieee802154: pkt was NULL\n");
        return -EINVAL;
    }
    if (pkt->type != GNRC_NETTYPE_NETIF) {
        DEBUG("_send_ieee802154: first header is not generic netif header\n");
        return -EBADMSG;
    }
    netif_hdr = pkt->data;
    if (netif_hdr->flags & GNRC_NETIF_HDR_FLAGS_MORE_DATA) {
        /* Set frame pending field */
        flags |= IEEE802154_FCF_FRAME_PEND;
    }
    /* prepare destination address */
    if (netif_hdr->flags & /* If any of these flags is set assume broadcast */
        (GNRC_NETIF_HDR_FLAGS_BROADCAST | GNRC_NETIF_HDR_FLAGS_MULTICAST)) {
        dst = ieee802154_addr_bcast;
        dst_len = IEEE802154_ADDR_BCAST_LEN;
    }
    else {
        dst = gnrc_netif_hdr_get_dst_addr(netif_hdr);
        dst_len = netif_hdr->dst_l2addr_len;
    }
    if (flags & NETDEV_IEEE802154_SECURITY_EN) {
        /* need to include long source address because the recipient
           will need it to decrypt the frame */
        src_len = IEEE802154_LONG_ADDRESS_LEN;
        src = state->long_addr;
    }
    else {
        src_len = netif_hdr->src_l2addr_len;
        if (src_len > 0) {
            src = gnrc_netif_hdr_get_src_addr(netif_hdr);
        }
        else {
            src_len = netif->l2addr_len;
            src = netif->l2addr;
        }
    }
    /* fill MAC header, seq should be set by device */
    if ((res = ieee802154_set_frame_hdr(mhr, src, src_len,
                                        dst, dst_len, dev_pan,
                                        dev_pan, flags, state->seq++)) == 0) {
        DEBUG("_send_ieee802154: Error preperaring frame\n");
        gnrc_pktbuf_release(pkt);
        return -EINVAL;
    }
    mhr_len = res;

    /* prepare iolist for netdev / mac layer */
    iolist_t iolist_header = {
        .iol_next = (iolist_t *)pkt->next,
        .iol_base = mhr,
        .iol_len = mhr_len
    };

#if IS_USED(MODULE_IEEE802154_SECURITY)
    {
        /* write protect `pkt` to set `pkt->next` */
        gnrc_pktsnip_t *tmp = gnrc_pktbuf_start_write(pkt);
        if (!tmp) {
            DEBUG("_send_ieee802154: no write access to pkt");
            gnrc_pktbuf_release(pkt);
            return -ENOMEM;
        }
        pkt = tmp;
        tmp = gnrc_pktbuf_start_write(pkt->next);
        if (!tmp) {
            DEBUG("_send_ieee802154: no write access to pkt->next");
            gnrc_pktbuf_release(pkt);
            return -ENOMEM;
        }
        pkt->next = tmp;
        /* merge snippets to store the L2 payload uniformly in one buffer */
        res = gnrc_pktbuf_merge(pkt->next);
        if (res < 0) {
            DEBUG("_send_ieee802154: failed to merge pktbuf\n");
            gnrc_pktbuf_release(pkt);
            return res;
        }

        iolist_header.iol_next = (iolist_t *)pkt->next;

        uint8_t mic[IEEE802154_SEC_MAX_MAC_SIZE];
        uint8_t mic_size = 0;

        if (flags & NETDEV_IEEE802154_SECURITY_EN) {
            res = ieee802154_sec_encrypt_frame(&state->sec_ctx,
                                               mhr, &mhr_len,
                                               pkt->next->data, pkt->next->size,
                                               mic, &mic_size,
                                               state->long_addr);
            if (res != 0) {
                DEBUG("_send_ieee802154: encryption failedf\n");
                gnrc_pktbuf_release(pkt);
                return res;
            }
        }
        if (mic_size) {
            gnrc_pktsnip_t *pktmic = gnrc_pktbuf_add(pkt->next->next,
                                                     mic, mic_size,
                                                     GNRC_NETTYPE_UNDEF);
            if (!pktmic) {
                DEBUG("_send_ieee802154: no space left in pktbuf to allocate MIC\n");
                gnrc_pktbuf_release(pkt);
                return -ENOMEM;
            }
            pkt->next->next = pktmic;
        }
        iolist_header.iol_len = mhr_len;
    }
#endif
#ifdef MODULE_NETSTATS_L2
    if (netif_hdr->flags &
            (GNRC_NETIF_HDR_FLAGS_BROADCAST | GNRC_NETIF_HDR_FLAGS_MULTICAST)) {
        netif->stats.tx_mcast_count++;
    }
    else {
        netif->stats.tx_unicast_count++;
    }
#endif
#ifdef MODULE_GNRC_MAC
    if (netif->mac.mac_info & GNRC_NETIF_MAC_INFO_CSMA_ENABLED) {
        res = csma_sender_csma_ca_send(dev, &iolist_header, &netif->mac.csma_conf);
    }
    else {
        res = dev->driver->send(dev, &iolist_header);
    }
#else
    res = dev->driver->send(dev, &iolist_header);
#endif

    if (gnrc_netif_netdev_legacy_api(netif)) {
        /* only for legacy drivers we need to release pkt here */
        gnrc_pktbuf_release(pkt);
    }
    return res;
}
