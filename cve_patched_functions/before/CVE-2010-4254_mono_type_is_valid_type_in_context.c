mono_type_is_valid_type_in_context (MonoType *type, MonoGenericContext *context)
{
	int i;
	MonoGenericInst *inst;

	switch (type->type) {
	case MONO_TYPE_VAR:
	case MONO_TYPE_MVAR:
		if (!context)
			return FALSE;
		inst = type->type == MONO_TYPE_VAR ? context->class_inst : context->method_inst;
		if (!inst || mono_type_get_generic_param_num (type) >= inst->type_argc)
			return FALSE;
		break;
	case MONO_TYPE_SZARRAY:
		return mono_type_is_valid_type_in_context (&type->data.klass->byval_arg, context);
	case MONO_TYPE_ARRAY:
		return mono_type_is_valid_type_in_context (&type->data.array->eklass->byval_arg, context);
	case MONO_TYPE_PTR:
		return mono_type_is_valid_type_in_context (type->data.type, context);
	case MONO_TYPE_GENERICINST:
		inst = type->data.generic_class->context.class_inst;
		if (!inst->is_open)
			break;
		for (i = 0; i < inst->type_argc; ++i)
			if (!mono_type_is_valid_type_in_context (inst->type_argv [i], context))
				return FALSE;
		break;
	case MONO_TYPE_CLASS:
	case MONO_TYPE_VALUETYPE: {
		MonoClass *klass = type->data.klass;
		/*
		 * It's possible to encode generic'sh types in such a way that they disguise themselves as class or valuetype.
		 * Fixing the type decoding is really tricky since under some cases this behavior is needed, for example, to
		 * have a 'class' type pointing to a 'genericinst' class.
		 *
		 * For the runtime these non canonical (weird) encodings work fine, they worst they can cause is some
		 * reflection oddities which are harmless  - to security at least.
		 */
		if (klass->byval_arg.type != type->type)
			return mono_type_is_valid_type_in_context (&klass->byval_arg, context);
		break;
	}
	}
	return TRUE;
}
