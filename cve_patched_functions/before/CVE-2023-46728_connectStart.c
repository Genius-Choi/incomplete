FwdState::connectStart()
{
    debugs(17, 3, *destinations << " to " << entry->url());

    Must(!request->pinnedConnection());

    assert(!destinations->empty());
    assert(!transporting());

    // Ditch error page if it was created before.
    // A new one will be created if there's another problem
    delete err;
    err = nullptr;
    request->clearError();

    request->hier.startPeerClock();

    AsyncCall::Pointer callback = asyncCall(17, 5, "FwdState::noteConnection", HappyConnOpener::CbDialer<FwdState>(&FwdState::noteConnection, this));

    HttpRequest::Pointer cause = request;
    const auto cs = new HappyConnOpener(destinations, callback, cause, start_t, n_tries, al);
    cs->setHost(request->url.host());
    bool retriable = checkRetriable();
    if (!retriable && Config.accessList.serverPconnForNonretriable) {
        ACLFilledChecklist ch(Config.accessList.serverPconnForNonretriable, request, nullptr);
        ch.al = al;
        ch.syncAle(request, nullptr);
        retriable = ch.fastCheck().allowed();
    }
    cs->setRetriable(retriable);
    cs->allowPersistent(pconnRace != raceHappened);
    destinations->notificationPending = true; // start() is async
    transportWait.start(cs, callback);
}
