static int32_t rcar_file_open(io_dev_info_t *info, const uintptr_t file_spec,
			      io_entity_t *entity)
{
	const io_drv_spec_t *spec = (io_drv_spec_t *) file_spec;
	uintptr_t partition, offset, dst;
	uint32_t noload, cert, len;
	int32_t rc;

	/*
	 * Only one file open at a time. We need to  track state (ie, file
	 * cursor position). Since the header lives at offset zero, this entry
	 * should never be zero in an active file.
	 * Once the system supports dynamic memory allocation we will allow more
	 * than one open file at a time.
	 */
	if (current_file.offset != 0U) {
		WARN("%s: Only one open file at a time.\n", __func__);
		return IO_RESOURCES_EXHAUSTED;
	}

	rc = file_to_offset(spec->offset, &offset, &cert, &noload, &partition);
	if (rc != IO_SUCCESS) {
		WARN("Failed to open file name %ld (%i)\n", spec->offset, rc);
		return IO_FAIL;
	}

	if (noload != 0U) {
		current_file.offset = 1;
		current_file.dst = 0;
		current_file.size = 1;
		current_file.position = 0;
		current_file.no_load = noload;
		current_file.partition = 0;
		entity->info = (uintptr_t) &current_file;

		return IO_SUCCESS;
	}

	rcar_read_certificate((uint64_t) cert, &len, &dst);

	current_file.partition = partition;
	current_file.no_load = noload;
	current_file.offset = offset;
	current_file.position = 0;
	current_file.size = len;
	current_file.dst = dst;
	entity->info = (uintptr_t) &current_file;

	return IO_SUCCESS;
}
