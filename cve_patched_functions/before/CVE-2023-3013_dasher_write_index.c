static GF_Err dasher_write_index(GF_DasherCtx *ctx, GF_FilterPid *opid)
{
	u8 *data;
	u32 i, pos, count = gf_list_count(ctx->pids);
	u32 nb_rep_pos, nb_reps=0;
	GF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);

	gf_bs_write_u32(bs, GF_4CC('G','H','I','D'));
	gf_bs_write_u32(bs, 0); //for future ext ?
	gf_bs_write_u32 (bs, ctx->mpd->segment_duration);
	gf_bs_write_u32 (bs, ctx->mpd->max_segment_duration);
	gf_bs_write_u64 (bs, ctx->mpd->media_presentation_duration);
	gf_bs_write_u64(bs, ctx->current_period->period->duration);
	gf_bs_write_utf8(bs, ctx->mpd->segment_template);

	nb_rep_pos = (u32) gf_bs_get_position(bs);
	gf_bs_write_u32(bs, 0);

	for (i=0; i<count; i++) {
		u8 flags=0;
		u32 j, nb_segs, rep_start;
		u32 props_start;
		GF_MPD_SegmentURL *s;
		GF_DashStream *ds = gf_list_get(ctx->pids, i);
		if (!ds || !ds->rep || !ds->rep->res_url || !ds->rep->segment_list) continue;

		nb_reps++;
		rep_start = (u32) gf_bs_get_position(bs);
		gf_bs_write_u32(bs, 0);

		gf_bs_write_utf8(bs, ds->rep->id);
		gf_bs_write_utf8(bs, ds->rep->res_url);
		gf_bs_write_u32(bs, ds->rep->trackID);
		s = gf_list_get(ds->rep->segment_list->segment_URLs, 0);
		gf_bs_write_u32(bs, s ? (u32) s->frag_start_offset : 0);
		gf_bs_write_u32(bs, ds->timescale);
		gf_bs_write_u32(bs, ds->rep->segment_list->timescale);
		gf_bs_write_u32(bs, ds->rep->bandwidth);
		gf_bs_write_u32(bs, (ds->pts_minus_cts<0) ? (u32) (-ds->pts_minus_cts) : 0);
		gf_bs_write_u32(bs, ds->rep->segment_list->sample_duration);
		gf_bs_write_u32(bs, ds->rep->segment_list->first_cts_offset);
		gf_bs_write_u32(bs, gf_list_count(ds->rep->segment_list->segment_URLs) );

		GF_MPD_SegmentURL *surl = gf_list_last(ds->rep->segment_list->segment_URLs);
		gf_bs_write_u8(bs, ds->set ? ds->set->starts_with_sap : ds->rep->starts_with_sap);
		if (surl->first_tfdt>0xFFFFFFFFUL) {
			flags |= 1;
		}
		if (surl->first_pck_seq>0xFFFFFFFFUL) {
			flags |= 1<<1;
		}
		if (ds->frag_start_offset) {
			flags |= 1<<2;
			if (surl->frag_start_offset > 0xFFFFFFFFUL) {
				flags |= 1<<3;
			}
		}
		if (ds->frag_first_ftdt) {
			flags |= 1<<4;
			if (surl->frag_tfdt > 0xFFFFFFFFUL) {
				flags |= 1<<5;
			}
		}
		if (ds->rep->segment_list->use_split_dur) {
			flags |= 1<<6;
		}
		gf_bs_write_u8(bs, flags);
		gf_bs_write_u16(bs, 0);
		//serialize all props
		props_start = (u32) gf_bs_get_position(bs);
		gf_bs_write_u32(bs, 0);

		u32 idx=0;
		while (1) {
			u32 k;
			u32 p4cc;
			const char *pname;
			const GF_PropertyValue *p = gf_filter_pid_enum_properties(ds->ipid, &idx, &p4cc, &pname);
			if (!p) break;
			switch (p4cc) {
			case GF_PROP_PID_ID:
			case GF_PROP_PID_URL:
			case GF_PROP_PID_FILEPATH:
			case GF_PROP_PID_FILE_EXT:
			case GF_PROP_PID_FILE_CACHED:
			case GF_PROP_PID_DOWN_SIZE:
			case GF_PROP_PID_DOWNLOAD_SESSION:
			case GF_PROP_PID_TRACK_NUM:
			case GF_PROP_PID_MEDIA_DATA_SIZE:
			case GF_PROP_PID_MAX_FRAME_SIZE:
			case GF_PROP_PID_AVG_FRAME_SIZE:
			case GF_PROP_PID_MAX_TS_DELTA:
			case GF_PROP_PID_CONSTANT_DURATION:
			case GF_PROP_PID_PLAYBACK_MODE:
			case GF_PROP_PID_CHAP_TIMES:
			case GF_PROP_PID_CHAP_NAMES:
				continue;
			default:
				break;
			}
			if (p->type == GF_PROP_POINTER) continue;

			if (p4cc) gf_bs_write_u32(bs, p4cc);
			else {
				gf_bs_write_u32(bs, 0);
				gf_bs_write_utf8(bs, pname);
				gf_bs_write_u32(bs, p->type);
			}

			switch (p->type) {
			case GF_PROP_SINT:
			case GF_PROP_UINT:
			case GF_PROP_4CC:
				gf_bs_write_u32(bs, p->value.uint);
				break;
			case GF_PROP_LSINT:
			case GF_PROP_LUINT:
				gf_bs_write_u64(bs, p->value.longuint);
				break;
			case GF_PROP_BOOL:
				gf_bs_write_u8(bs, p->value.boolean ? 1 : 0);
				break;
			case GF_PROP_FRACTION:
				gf_bs_write_u32(bs, p->value.frac.num);
				gf_bs_write_u32(bs, p->value.frac.den);
				break;
			case GF_PROP_FRACTION64:
				gf_bs_write_u64(bs, p->value.lfrac.num);
				gf_bs_write_u64(bs, p->value.lfrac.den);
				break;
			case GF_PROP_FLOAT:
				gf_bs_write_float(bs, FIX2FLT(p->value.fnumber) );
				break;
			case GF_PROP_DOUBLE:
				gf_bs_write_double(bs, p->value.number);
				break;
			case GF_PROP_VEC2I:
				gf_bs_write_u32(bs, p->value.vec2i.x);
				gf_bs_write_u32(bs, p->value.vec2i.y);
				break;
			case GF_PROP_VEC2:
				gf_bs_write_double(bs, p->value.vec2.x);
				gf_bs_write_double(bs, p->value.vec2.y);
				break;
			case GF_PROP_VEC3I:
				gf_bs_write_u32(bs, p->value.vec3i.x);
				gf_bs_write_u32(bs, p->value.vec3i.y);
				gf_bs_write_u32(bs, p->value.vec3i.z);
				break;
			case GF_PROP_VEC4I:
				gf_bs_write_u32(bs, p->value.vec4i.x);
				gf_bs_write_u32(bs, p->value.vec4i.y);
				gf_bs_write_u32(bs, p->value.vec4i.z);
				gf_bs_write_u32(bs, p->value.vec4i.w);
				break;
			case GF_PROP_STRING:
			case GF_PROP_STRING_NO_COPY:
			case GF_PROP_NAME:
				if (p4cc == GF_PROP_PID_DECODER_CONFIG_ENHANCEMENT) {
					u32 len = (u32) strlen(p->value.string)+1;
					gf_bs_write_u32(bs, len);
					gf_bs_write_data(bs, p->value.string, len);
				} else {
					gf_bs_write_utf8(bs, p->value.string);
				}
				break;

			case GF_PROP_DATA:
			case GF_PROP_DATA_NO_COPY:
			case GF_PROP_CONST_DATA:
				gf_bs_write_u32(bs, p->value.data.size);
				gf_bs_write_data(bs, p->value.data.ptr, p->value.data.size);
				break;

			//string list: memory is ALWAYS duplicated
			case GF_PROP_STRING_LIST:
				gf_bs_write_u32(bs, p->value.string_list.nb_items);
				for (k=0; k<p->value.string_list.nb_items; k++) {
					const char *str = p->value.string_list.vals[k];
					gf_bs_write_utf8(bs, str);
				}
				break;

			case GF_PROP_UINT_LIST:
			case GF_PROP_SINT_LIST:
			case GF_PROP_4CC_LIST:
				gf_bs_write_u32(bs, p->value.uint_list.nb_items);
				for (k=0; k<p->value.uint_list.nb_items; k++) {
					gf_bs_write_u32(bs, p->value.uint_list.vals[k]);
				}
				break;
			case GF_PROP_VEC2I_LIST:
				gf_bs_write_u32(bs, p->value.v2i_list.nb_items);
				for (k=0; k<p->value.uint_list.nb_items; k++) {
					gf_bs_write_u32(bs, p->value.v2i_list.vals[k].x );
					gf_bs_write_u32(bs, p->value.v2i_list.vals[k].y );
				}
				break;
			default:
				break;
			}
		}
		//last prop
		gf_bs_write_u32(bs, 0xFFFFFFFF);

		pos = (u32) gf_bs_get_position(bs);
		u32 psize = pos - props_start;
		gf_bs_seek(bs, props_start);
		gf_bs_write_u32(bs, psize);
		gf_bs_seek(bs, pos);

		//serialize all segments
		nb_segs = gf_list_count(ds->rep->segment_list->segment_URLs);
		for (j=0; j<nb_segs; j++) {
			s = gf_list_get(ds->rep->segment_list->segment_URLs, j);

			if (flags & 1) gf_bs_write_u64(bs, s->first_tfdt);
			else gf_bs_write_u32(bs, (u32) s->first_tfdt);

			if (flags & (1<<1)) gf_bs_write_u64(bs, s->first_pck_seq);
			else gf_bs_write_u32(bs, (u32) s->first_pck_seq);

			gf_bs_write_u32(bs, (u32) s->duration);

			if (flags & (1<<2)) {
				if (flags & (1<<3)) gf_bs_write_u64(bs, s->frag_start_offset);
				else gf_bs_write_u32(bs, (u32) s->frag_start_offset);
			}
			if (flags & (1<<4)) {
				if (flags & (1<<5)) gf_bs_write_u64(bs, s->frag_tfdt);
				else gf_bs_write_u32(bs, (u32) s->frag_tfdt);
			}
			if (flags & (1<<6)) {
				gf_bs_write_u32(bs, s->split_first_dur);
				gf_bs_write_u32(bs, s->split_last_dur);
			}
		}

		pos = (u32) gf_bs_get_position(bs);
		psize = pos - rep_start;
		gf_bs_seek(bs, rep_start);
		gf_bs_write_u32(bs, psize);
		gf_bs_seek(bs, pos);
	}

	pos = (u32) gf_bs_get_position(bs);
	gf_bs_seek(bs, nb_rep_pos);
	gf_bs_write_u32(bs, nb_reps);
	gf_bs_seek(bs, pos);

	GF_FilterPacket *dst = gf_filter_pck_new_alloc(opid, 1, &data);
	gf_free(data);
	u32 osize;
	gf_bs_get_content(bs, &data, &osize);
	gf_filter_pck_check_realloc(dst, data, osize);
	gf_filter_pck_set_framing(dst, GF_TRUE, GF_TRUE);
	gf_filter_pck_send(dst);
	gf_bs_del(bs);
	ctx->mpd->segment_template = NULL;
	return GF_OK;
}
