int graph_paint(
    image_desc_t *im)
{
    int       i, ii;
    int       lazy = lazy_check(im);
    double    areazero = 0.0;
    graph_desc_t *lastgdes = NULL;
    rrd_infoval_t info;

//    PangoFontMap *font_map = pango_cairo_font_map_get_default();

    /* pull the data from the rrd files ... */
    if (data_fetch(im) == -1)
        return -1;
    /* evaluate VDEF and CDEF operations ... */
    if (data_calc(im) == -1)
        return -1;
    /* calculate and PRINT and GPRINT definitions. We have to do it at
     * this point because it will affect the length of the legends
     * if there are no graph elements (i==0) we stop here ...
     * if we are lazy, try to quit ...
     */
    i = print_calc(im);
    if (i < 0)
        return -1;

    /* if we want and can be lazy ... quit now */
    if (i == 0)
        return 0;

/**************************************************************
 *** Calculating sizes and locations became a bit confusing ***
 *** so I moved this into a separate function.              ***
 **************************************************************/
    if (graph_size_location(im, i) == -1)
        return -1;

    info.u_cnt = im->xorigin;
    grinfo_push(im, sprintf_alloc("graph_left"), RD_I_CNT, info);
    info.u_cnt = im->yorigin - im->ysize;
    grinfo_push(im, sprintf_alloc("graph_top"), RD_I_CNT, info);
    info.u_cnt = im->xsize;
    grinfo_push(im, sprintf_alloc("graph_width"), RD_I_CNT, info);
    info.u_cnt = im->ysize;
    grinfo_push(im, sprintf_alloc("graph_height"), RD_I_CNT, info);
    info.u_cnt = im->ximg;
    grinfo_push(im, sprintf_alloc("image_width"), RD_I_CNT, info);
    info.u_cnt = im->yimg;
    grinfo_push(im, sprintf_alloc("image_height"), RD_I_CNT, info);
    info.u_cnt = im->start;
    grinfo_push(im, sprintf_alloc("graph_start"), RD_I_CNT, info);
    info.u_cnt = im->end;
    grinfo_push(im, sprintf_alloc("graph_end"), RD_I_CNT, info);

    /* if we want and can be lazy ... quit now */
    if (lazy)
        return 0;

    /* get actual drawing data and find min and max values */
    if (data_proc(im) == -1)
        return -1;
    if (!im->logarithmic) {
        si_unit(im);
    }

    /* identify si magnitude Kilo, Mega Giga ? */
    if (!im->rigid && !im->logarithmic)
        expand_range(im);   /* make sure the upper and lower limit are
                               sensible values */

    info.u_val = im->minval;
    grinfo_push(im, sprintf_alloc("value_min"), RD_I_VAL, info);
    info.u_val = im->maxval;
    grinfo_push(im, sprintf_alloc("value_max"), RD_I_VAL, info);


    if (!calc_horizontal_grid(im))
        return -1;
    /* reset precalc */
    ytr(im, DNAN);
/*   if (im->gridfit)
     apply_gridfit(im); */
    /* the actual graph is created by going through the individual
       graph elements and then drawing them */
    cairo_surface_destroy(im->surface);
    switch (im->imgformat) {
    case IF_PNG:
        im->surface =
            cairo_image_surface_create(CAIRO_FORMAT_ARGB32,
                                       im->ximg * im->zoom,
                                       im->yimg * im->zoom);
        break;
    case IF_PDF:
        im->gridfit = 0;
        im->surface = strlen(im->graphfile)
            ? cairo_pdf_surface_create(im->graphfile, im->ximg * im->zoom,
                                       im->yimg * im->zoom)
            : cairo_pdf_surface_create_for_stream
            (&cairo_output, im, im->ximg * im->zoom, im->yimg * im->zoom);
        break;
    case IF_EPS:
        im->gridfit = 0;
        im->surface = strlen(im->graphfile)
            ?
            cairo_ps_surface_create(im->graphfile, im->ximg * im->zoom,
                                    im->yimg * im->zoom)
            : cairo_ps_surface_create_for_stream
            (&cairo_output, im, im->ximg * im->zoom, im->yimg * im->zoom);
        break;
    case IF_SVG:
        im->gridfit = 0;
        im->surface = strlen(im->graphfile)
            ?
            cairo_svg_surface_create(im->
                                     graphfile,
                                     im->ximg * im->zoom, im->yimg * im->zoom)
            : cairo_svg_surface_create_for_stream
            (&cairo_output, im, im->ximg * im->zoom, im->yimg * im->zoom);
        cairo_svg_surface_restrict_to_version
            (im->surface, CAIRO_SVG_VERSION_1_1);
        break;
    };
    cairo_destroy(im->cr);
    im->cr = cairo_create(im->surface);
    cairo_set_antialias(im->cr, im->graph_antialias);
    cairo_scale(im->cr, im->zoom, im->zoom);
//    pango_cairo_font_map_set_resolution(PANGO_CAIRO_FONT_MAP(font_map), 100);
    gfx_new_area(im, 0, 0, 0, im->yimg,
                 im->ximg, im->yimg, im->graph_col[GRC_BACK]);
    gfx_add_point(im, im->ximg, 0);
    gfx_close_path(im);
    gfx_new_area(im, im->xorigin,
                 im->yorigin,
                 im->xorigin +
                 im->xsize, im->yorigin,
                 im->xorigin +
                 im->xsize,
                 im->yorigin - im->ysize, im->graph_col[GRC_CANVAS]);
    gfx_add_point(im, im->xorigin, im->yorigin - im->ysize);
    gfx_close_path(im);
    cairo_rectangle(im->cr, im->xorigin, im->yorigin - im->ysize - 1.0,
                    im->xsize, im->ysize + 2.0);
    cairo_clip(im->cr);
    if (im->minval > 0.0)
        areazero = im->minval;
    if (im->maxval < 0.0)
        areazero = im->maxval;
    for (i = 0; i < im->gdes_c; i++) {
        switch (im->gdes[i].gf) {
        case GF_CDEF:
        case GF_VDEF:
        case GF_DEF:
        case GF_PRINT:
        case GF_GPRINT:
        case GF_COMMENT:
        case GF_TEXTALIGN:
        case GF_HRULE:
        case GF_VRULE:
        case GF_XPORT:
        case GF_SHIFT:
            break;
        case GF_TICK:
            for (ii = 0; ii < im->xsize; ii++) {
                if (!isnan(im->gdes[i].p_data[ii])
                    && im->gdes[i].p_data[ii] != 0.0) {
                    if (im->gdes[i].yrule > 0) {
                        gfx_line(im,
                                 im->xorigin + ii,
                                 im->yorigin + 1.0,
                                 im->xorigin + ii,
                                 im->yorigin -
                                 im->gdes[i].yrule *
                                 im->ysize, 1.0, im->gdes[i].col);
                    } else if (im->gdes[i].yrule < 0) {
                        gfx_line(im,
                                 im->xorigin + ii,
                                 im->yorigin - im->ysize - 1.0,
                                 im->xorigin + ii,
                                 im->yorigin - im->ysize -
                                                im->gdes[i].
                                                yrule *
                                 im->ysize, 1.0, im->gdes[i].col);
                    }
                }
            }
            break;
        case GF_LINE:
        case GF_AREA: {
            rrd_value_t diffval = im->maxval - im->minval;
            rrd_value_t maxlimit = im->maxval + 9 * diffval;
            rrd_value_t minlimit = im->minval - 9 * diffval;        
            for (ii = 0; ii < im->xsize; ii++) {
               /* fix data points at oo and -oo */
                if (isinf(im->gdes[i].p_data[ii])) {
                    if (im->gdes[i].p_data[ii] > 0) {
                        im->gdes[i].p_data[ii] = im->maxval;
                    } else {
                        im->gdes[i].p_data[ii] = im->minval;
                    }
                }
                /* some versions of cairo go unstable when trying
                   to draw way out of the canvas ... lets not even try */
                if (im->gdes[i].p_data[ii] > maxlimit) {
                    im->gdes[i].p_data[ii] = maxlimit;
                }
                if (im->gdes[i].p_data[ii] < minlimit) {
                    im->gdes[i].p_data[ii] = minlimit;
                }
            }           /* for */

            /* *******************************************************
               a           ___. (a,t)
               |   |    ___
               ____|   |   |   |
               |       |___|
               -------|--t-1--t--------------------------------

               if we know the value at time t was a then
               we draw a square from t-1 to t with the value a.

               ********************************************************* */
            if (im->gdes[i].col.alpha != 0.0) {
                /* GF_LINE and friend */
                if (im->gdes[i].gf == GF_LINE) {
                    double    last_y = 0.0;
                    int       draw_on = 0;

                    cairo_save(im->cr);
                    cairo_new_path(im->cr);
                    cairo_set_line_width(im->cr, im->gdes[i].linewidth);
                    if (im->gdes[i].dash) {
                        cairo_set_dash(im->cr,
                                       im->gdes[i].p_dashes,
                                       im->gdes[i].ndash, im->gdes[i].offset);
                    }

                    for (ii = 1; ii < im->xsize; ii++) {
                        if (isnan(im->gdes[i].p_data[ii])
                            || (im->slopemode == 1
                                && isnan(im->gdes[i].p_data[ii - 1]))) {
                            draw_on = 0;
                            continue;
                        }
                        if (draw_on == 0) {
                            last_y = ytr(im, im->gdes[i].p_data[ii]);
                            if (im->slopemode == 0) {
                                double    x = ii - 1 + im->xorigin;
                                double    y = last_y;

                                gfx_line_fit(im, &x, &y);
                                cairo_move_to(im->cr, x, y);
                                x = ii + im->xorigin;
                                y = last_y;
                                gfx_line_fit(im, &x, &y);
                                cairo_line_to(im->cr, x, y);
                            } else {
                                double    x = ii - 1 + im->xorigin;
                                double    y =
                                    ytr(im, im->gdes[i].p_data[ii - 1]);
                                gfx_line_fit(im, &x, &y);
                                cairo_move_to(im->cr, x, y);
                                x = ii + im->xorigin;
                                y = last_y;
                                gfx_line_fit(im, &x, &y);
                                cairo_line_to(im->cr, x, y);
                            }
                            draw_on = 1;
                        } else {
                            double    x1 = ii + im->xorigin;
                            double    y1 = ytr(im, im->gdes[i].p_data[ii]);

                            if (im->slopemode == 0
                                && !AlmostEqual2sComplement(y1, last_y, 4)) {
                                double    x = ii - 1 + im->xorigin;
                                double    y = y1;

                                gfx_line_fit(im, &x, &y);
                                cairo_line_to(im->cr, x, y);
                            };
                            last_y = y1;
                            gfx_line_fit(im, &x1, &y1);
                            cairo_line_to(im->cr, x1, y1);
                        };
                    }
                    cairo_set_source_rgba(im->cr,
                                          im->gdes[i].
                                          col.red,
                                          im->gdes[i].
                                          col.green,
                                          im->gdes[i].
                                          col.blue, im->gdes[i].col.alpha);
                    cairo_set_line_cap(im->cr, CAIRO_LINE_CAP_ROUND);
                    cairo_set_line_join(im->cr, CAIRO_LINE_JOIN_ROUND);
                    cairo_stroke(im->cr);
                    cairo_restore(im->cr);
                } else {
                    int       idxI = -1;
                    double   *foreY =
                        (double *) malloc(sizeof(double) * im->xsize * 2);
                    double   *foreX =
                        (double *) malloc(sizeof(double) * im->xsize * 2);
                    double   *backY =
                        (double *) malloc(sizeof(double) * im->xsize * 2);
                    double   *backX =
                        (double *) malloc(sizeof(double) * im->xsize * 2);
                    int       drawem = 0;

                    for (ii = 0; ii <= im->xsize; ii++) {
                        double    ybase, ytop;

                        if (idxI > 0 && (drawem != 0 || ii == im->xsize)) {
                            int       cntI = 1;
                            int       lastI = 0;

                            while (cntI < idxI
                                   &&
                                   AlmostEqual2sComplement(foreY
                                                           [lastI],
                                                           foreY[cntI], 4)
                                   &&
                                   AlmostEqual2sComplement(foreY
                                                           [lastI],
                                                           foreY
                                                           [cntI + 1], 4)) {
                                cntI++;
                            }
                            gfx_new_area(im,
                                         backX[0], backY[0],
                                         foreX[0], foreY[0],
                                         foreX[cntI],
                                         foreY[cntI], im->gdes[i].col);
                            while (cntI < idxI) {
                                lastI = cntI;
                                cntI++;
                                while (cntI < idxI
                                       &&
                                       AlmostEqual2sComplement(foreY
                                                               [lastI],
                                                               foreY[cntI], 4)
                                       &&
                                       AlmostEqual2sComplement(foreY
                                                               [lastI],
                                                               foreY
                                                               [cntI
                                                                + 1], 4)) {
                                    cntI++;
                                }
                                gfx_add_point(im, foreX[cntI], foreY[cntI]);
                            }
                            gfx_add_point(im, backX[idxI], backY[idxI]);
                            while (idxI > 1) {
                                lastI = idxI;
                                idxI--;
                                while (idxI > 1
                                       &&
                                       AlmostEqual2sComplement(backY
                                                               [lastI],
                                                               backY[idxI], 4)
                                       &&
                                       AlmostEqual2sComplement(backY
                                                               [lastI],
                                                               backY
                                                               [idxI
                                                                - 1], 4)) {
                                    idxI--;
                                }
                                gfx_add_point(im, backX[idxI], backY[idxI]);
                            }
                            idxI = -1;
                            drawem = 0;
                            gfx_close_path(im);
                        }
                        if (drawem != 0) {
                            drawem = 0;
                            idxI = -1;
                        }
                        if (ii == im->xsize)
                            break;
                        if (im->slopemode == 0 && ii == 0) {
                            continue;
                        }
                        if (isnan(im->gdes[i].p_data[ii])) {
                            drawem = 1;
                            continue;
                        }
                        ytop = ytr(im, im->gdes[i].p_data[ii]);
                        if (lastgdes && im->gdes[i].stack) {
                            ybase = ytr(im, lastgdes->p_data[ii]);
                        } else {
                            ybase = ytr(im, areazero);
                        }
                        if (ybase == ytop) {
                            drawem = 1;
                            continue;
                        }

                        if (ybase > ytop) {
                            double    extra = ytop;

                            ytop = ybase;
                            ybase = extra;
                        }
                        if (im->slopemode == 0) {
                            backY[++idxI] = ybase - 0.2;
                            backX[idxI] = ii + im->xorigin - 1;
                            foreY[idxI] = ytop + 0.2;
                            foreX[idxI] = ii + im->xorigin - 1;
                        }
                        backY[++idxI] = ybase - 0.2;
                        backX[idxI] = ii + im->xorigin;
                        foreY[idxI] = ytop + 0.2;
                        foreX[idxI] = ii + im->xorigin;
                    }
                    /* close up any remaining area */
                    free(foreY);
                    free(foreX);
                    free(backY);
                    free(backX);
                }       /* else GF_LINE */
            }
            /* if color != 0x0 */
            /* make sure we do not run into trouble when stacking on NaN */
            for (ii = 0; ii < im->xsize; ii++) {
                if (isnan(im->gdes[i].p_data[ii])) {
                    if (lastgdes && (im->gdes[i].stack)) {
                        im->gdes[i].p_data[ii] = lastgdes->p_data[ii];
                    } else {
                        im->gdes[i].p_data[ii] = areazero;
                    }
                }
            }
            lastgdes = &(im->gdes[i]);
            break;
        } /* GF_AREA, GF_LINE, GF_GRAD */
        case GF_STACK:
            rrd_set_error
                ("STACK should already be turned into LINE or AREA here");
            return -1;
            break;
        }               /* switch */
    }
    cairo_reset_clip(im->cr);

    /* grid_paint also does the text */
    if (!(im->extra_flags & ONLY_GRAPH))
        grid_paint(im);
    if (!(im->extra_flags & ONLY_GRAPH))
        axis_paint(im);
    /* the RULES are the last thing to paint ... */
    for (i = 0; i < im->gdes_c; i++) {

        switch (im->gdes[i].gf) {
        case GF_HRULE:
            if (im->gdes[i].yrule >= im->minval
                && im->gdes[i].yrule <= im->maxval) {
                cairo_save(im->cr);
                if (im->gdes[i].dash) {
                    cairo_set_dash(im->cr,
                                   im->gdes[i].p_dashes,
                                   im->gdes[i].ndash, im->gdes[i].offset);
                }
                gfx_line(im, im->xorigin,
                         ytr(im, im->gdes[i].yrule),
                         im->xorigin + im->xsize,
                         ytr(im, im->gdes[i].yrule), 1.0, im->gdes[i].col);
                cairo_stroke(im->cr);
                cairo_restore(im->cr);
            }
            break;
        case GF_VRULE:
            if (im->gdes[i].xrule >= im->start
                && im->gdes[i].xrule <= im->end) {
                cairo_save(im->cr);
                if (im->gdes[i].dash) {
                    cairo_set_dash(im->cr,
                                   im->gdes[i].p_dashes,
                                   im->gdes[i].ndash, im->gdes[i].offset);
                }
                gfx_line(im,
                         xtr(im, im->gdes[i].xrule),
                         im->yorigin, xtr(im,
                                          im->
                                          gdes[i].
                                          xrule),
                         im->yorigin - im->ysize, 1.0, im->gdes[i].col);
                cairo_stroke(im->cr);
                cairo_restore(im->cr);
            }
            break;
        default:
            break;
        }
    }


    switch (im->imgformat) {
    case IF_PNG:
    {
        cairo_status_t status;

        status = strlen(im->graphfile) ?
            cairo_surface_write_to_png(im->surface, im->graphfile)
            : cairo_surface_write_to_png_stream(im->surface, &cairo_output,
                                                im);

        if (status != CAIRO_STATUS_SUCCESS) {
            rrd_set_error("Could not save png to '%s'", im->graphfile);
            return 1;
        }
        break;
    }
    default:
        if (strlen(im->graphfile)) {
            cairo_show_page(im->cr);
        } else {
            cairo_surface_finish(im->surface);
        }
        break;
    }

    return 0;
}
