void fx_TypedArray_prototype_set(txMachine* the)
{
	mxMutableTypedArrayDeclarations;
	txSlot* data = buffer->value.reference->next;
	txInteger delta = dispatch->value.typedArray.dispatch->size;
	txSlot* source = fxArgToInstance(the, 0);
	txInteger target = fxArgToByteLength(the, 1, 0);
	txInteger offset = view->value.dataView.offset + (target * delta);	
	if (source->next && (source->next->kind == XS_TYPED_ARRAY_KIND)) {
		txSlot* sourceDispatch = source->next;
		txSlot* sourceView = sourceDispatch->next;
		txSlot* sourceBuffer = sourceView->next;
		txU2 shift = sourceDispatch->value.typedArray.dispatch->shift;
		txInteger sourceLength = fxCheckDataViewSize(the, sourceView, sourceBuffer, XS_IMMUTABLE) >> shift;
		txInteger sourceOffset = sourceView->value.dataView.offset;	
		txSlot* sourceData = sourceBuffer->value.reference->next;
		txInteger limit = offset + (sourceLength * delta);
		if ((target < 0) || (length - sourceLength < target))
			mxRangeError("invalid offset");
		if (data == sourceData) {
			txSlot* resultBuffer;
			mxPush(mxArrayBufferConstructor);
			mxNew();
			mxPushInteger(sourceLength << shift);
			mxRunCount(1);
			resultBuffer = the->stack->value.reference->next;
			c_memcpy(resultBuffer->value.arrayBuffer.address, sourceData->value.arrayBuffer.address + sourceOffset, sourceLength << shift);
			sourceData = resultBuffer;
			sourceOffset = 0;
		}
		else 
			mxPushUndefined();
		if (dispatch == sourceDispatch) {
			c_memcpy(data->value.arrayBuffer.address + offset, sourceData->value.arrayBuffer.address + sourceOffset, limit - offset);
			mxMeterSome(((txU4)(limit - offset)) * 2);
		}
		else {
			txInteger sourceDelta = 1 << shift;
			mxPushUndefined();
			while (offset < limit) {
				(*sourceDispatch->value.typedArray.dispatch->getter)(the, sourceData, sourceOffset, the->stack, EndianNative);
				(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);
                if (data->value.arrayBuffer.address == C_NULL)
                    mxTypeError("detached buffer");
				(*dispatch->value.typedArray.dispatch->setter)(the, data, offset, the->stack, EndianNative);
				sourceOffset += sourceDelta;
				offset += delta;
			}
			mxPop();
		}
		mxPop();
	}
	else {
		txInteger count, index;
		mxPushSlot(mxArgv(0));
		mxGetID(mxID(_length));
		count = fxToInteger(the, the->stack);
		mxPop();
		if ((target < 0) || (length - count < target))
			mxRangeError("invalid offset");
		index = 0;
		while (index < count) {
			mxPushSlot(mxArgv(0));
			mxGetIndex(index);
			(*dispatch->value.typedArray.dispatch->coerce)(the, the->stack);
			if (data->value.arrayBuffer.address == C_NULL)
				mxTypeError("detached buffer");
			(*dispatch->value.typedArray.dispatch->setter)(the, data, offset, the->stack, EndianNative);
			mxPop();
			offset += delta;
			index++;
		}	
	}
}
