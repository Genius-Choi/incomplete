flush_ber(
    Slapi_PBlock *pb,
    Connection *conn,
    Operation *op,
    BerElement *ber,
    int type)
{
    ber_len_t bytes;
    int rc = 0;

    switch (type) {
    case _LDAP_SEND_RESULT:
        rc = plugin_call_plugins(pb, SLAPI_PLUGIN_PRE_RESULT_FN);
        break;
    case _LDAP_SEND_REFERRAL:
        rc = plugin_call_plugins(pb, SLAPI_PLUGIN_PRE_REFERRAL_FN);
        break;
    case _LDAP_SEND_INTERMED:
        break; /* not a plugin entry point */
    }

    if (rc != 0) {
        ber_free(ber, 1);
        return (rc);
    }

    if ((conn->c_flags & CONN_FLAG_CLOSING) || slapi_op_abandoned(pb)) {
        slapi_log_err(SLAPI_LOG_CONNS, "flush_ber",
                      "Skipped because the connection was marked to be closed or abandoned\n");
        ber_free(ber, 1);
        /* One of the failure can be because the client has reset the connection ( closed )
             * and the status needs to be updated to reflect it */
        op->o_status = SLAPI_OP_STATUS_ABANDONED;
        rc = -1;
    } else {
        ber_get_option(ber, LBER_OPT_BYTES_TO_WRITE, &bytes);

        PR_Lock(conn->c_pdumutex);
        rc = ber_flush(conn->c_sb, ber, 1);
        PR_Unlock(conn->c_pdumutex);

        if (rc != 0) {
            int oserr = errno;
            /* One of the failure can be because the client has reset the connection ( closed )
             * and the status needs to be updated to reflect it */
            op->o_status = SLAPI_OP_STATUS_ABANDONED;

            slapi_log_err(SLAPI_LOG_CONNS, "flush_ber", "Failed, error %d (%s)\n",
                          oserr, slapd_system_strerror(oserr));
            if (op->o_flags & OP_FLAG_PS) {
                /* We need to tell disconnect_server() not to ding
            * all the psearches if one if them disconnected
            * But we do need to terminate all persistent searches that are using
            * this connection
            *    op->o_flags |= OP_FLAG_PS_SEND_FAILED;
            */
            }
            do_disconnect_server(conn, op->o_connid, op->o_opid);
            ber_free(ber, 1);
        } else {
            PRUint64 b;
            slapi_log_err(SLAPI_LOG_BER, "flush_ber",
                          "Wrote %lu bytes to socket %d\n", bytes, conn->c_sd);
            LL_I2L(b, bytes);
            slapi_counter_add(num_bytes_sent, b);

            if (type == _LDAP_SEND_ENTRY) {
                slapi_counter_increment(num_entries_sent);
            }
            if (!config_check_referral_mode())
                slapi_counter_add(g_get_global_snmp_vars()->ops_tbl.dsBytesSent, bytes);
        }
    }

    switch (type) {
    case _LDAP_SEND_RESULT:
        plugin_call_plugins(pb, SLAPI_PLUGIN_POST_RESULT_FN);
        break;
    case _LDAP_SEND_REFERRAL:
        slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsReferralsReturned);
        plugin_call_plugins(pb, SLAPI_PLUGIN_POST_REFERRAL_FN);
        break;
    case _LDAP_SEND_ENTRY:
        slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsEntriesReturned);
        plugin_call_plugins(pb, SLAPI_PLUGIN_POST_ENTRY_FN);
        break;
    case _LDAP_SEND_INTERMED:
        break; /* not a plugin entry point */
    }

    return (rc);
}
