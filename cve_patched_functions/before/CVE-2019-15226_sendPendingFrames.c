void ConnectionImpl::sendPendingFrames() {
  if (dispatching_ || connection_.state() == Network::Connection::State::Closed) {
    return;
  }

  int rc = nghttp2_session_send(session_);
  if (rc != 0) {
    ASSERT(rc == NGHTTP2_ERR_CALLBACK_FAILURE);
    // For errors caused by the pending outbound frame flood the FrameFloodException has
    // to be thrown. However the nghttp2 library returns only the generic error code for
    // all failure types. Check queue limits and throw FrameFloodException if they were
    // exceeded.
    if (outbound_frames_ > max_outbound_frames_ ||
        outbound_control_frames_ > max_outbound_control_frames_) {
      throw FrameFloodException("Too many frames in the outbound queue.");
    }

    throw CodecProtocolException(fmt::format("{}", nghttp2_strerror(rc)));
  }

  // See ConnectionImpl::StreamImpl::resetStream() for why we do this. This is an uncommon event,
  // so iterating through every stream to find the ones that have a deferred reset is not a big
  // deal. Furthermore, queueing a reset frame does not actually invoke the close stream callback.
  // This is only done when the reset frame is sent. Thus, it's safe to work directly with the
  // stream map.
  // NOTE: The way we handle deferred reset is essentially best effort. If we intend to do a
  //       deferred reset, we try to finish the stream, including writing any pending data frames.
  //       If we cannot do this (potentially due to not enough window), we just reset the stream.
  //       In general this behavior occurs only when we are trying to send immediate error messages
  //       to short circuit requests. In the best effort case, we complete the stream before
  //       resetting. In other cases, we just do the reset now which will blow away pending data
  //       frames and release any memory associated with the stream.
  if (pending_deferred_reset_) {
    pending_deferred_reset_ = false;
    for (auto& stream : active_streams_) {
      if (stream->deferred_reset_) {
        stream->resetStreamWorker(stream->deferred_reset_.value());
      }
    }
    sendPendingFrames();
  }
}
