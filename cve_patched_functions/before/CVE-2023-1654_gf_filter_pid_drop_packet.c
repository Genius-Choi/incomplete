void gf_filter_pid_drop_packet(GF_FilterPid *pid)
{
#ifdef GPAC_MEMORY_TRACKING
	u32 prev_nb_allocs, prev_nb_reallocs, nb_allocs, nb_reallocs;
#endif
	u32 timescale = 0;
	u32 nb_pck=0;
	GF_FilterPacket *pck=NULL;
	GF_FilterPacketInstance *pcki;
	GF_FilterPidInst *pidinst = (GF_FilterPidInst *)pid;

	if (PID_IS_OUTPUT(pid)) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, ("Attempt to discard a packet on an output PID in filter %s\n", pid->filter->name));
		return;
	}
	if (pidinst->filter)
		pidinst->filter->nb_pck_io++;

	//remove pck instance
	pcki = gf_fq_pop(pidinst->packets);

	if (!pcki) {
		if (pidinst->filter && !pidinst->filter->finalized && !pidinst->discard_packets) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, ("Attempt to discard a packet already discarded in filter %s\n", pid->filter->name));
		}
		return;
	}

	gf_rmt_begin(pck_drop, GF_RMT_AGGREGATE);
	pck = pcki->pck;
	//move to source pid
	pid = pid->pid;
	if (pck->pid_props)
		timescale = pck->pid_props->timescale;

	//if not detached, undo main_thread flag - cf gf_filter_instance_detach_pid
	if (pidinst->filter && (pck->info.flags & GF_PCKF_FORCE_MAIN)) {
		assert(pidinst->filter->nb_main_thread_forced);
		safe_int_dec(&pidinst->filter->nb_main_thread_forced);
	}

	gf_filter_pidinst_update_stats(pidinst, pck);
	if (timescale && (pck->info.cts!=GF_FILTER_NO_TS)) {
		pidinst->last_ts_drop.num = pck->info.cts;
		pidinst->last_ts_drop.den = timescale;
	}


	//make sure we lock the tasks mutex before getting the packet count, otherwise we might end up with a wrong number of packets
	//if one thread (the caller here) consumes one packet while the dispatching thread is still upddating the state for that pid
	gf_mx_p(pid->filter->tasks_mx);
	nb_pck = gf_fq_count(pidinst->packets);

	if (!nb_pck) {
		safe_int64_sub(&pidinst->buffer_duration, pidinst->buffer_duration);
	} else if (pck->info.duration && (pck->info.flags & GF_PCKF_BLOCK_START) && timescale) {
		s64 d = gf_timestamp_rescale(pck->info.duration, timescale, 1000000);
		if (d > pidinst->buffer_duration) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, ("Corrupted buffer level in PID instance %s (%s -> %s), dropping packet duration "LLD" us greater than buffer duration "LLU" us\n", pid->name, pid->filter->name, pidinst->filter ? pidinst->filter->name : "disconnected", d, pidinst->buffer_duration));
			d = pidinst->buffer_duration;
		}
		assert(d <= pidinst->buffer_duration);
		safe_int64_sub(&pidinst->buffer_duration, (s32) d);
	}

	if ( (pid->num_destinations==1) || (pid->filter->session->blocking_mode==GF_FS_NOBLOCK_FANOUT)) {
		if (nb_pck<pid->nb_buffer_unit) {
			pid->nb_buffer_unit = nb_pck;
		}
		if (!pid->buffer_duration || (pidinst->buffer_duration < (s64) pid->buffer_duration)) {
			pid->buffer_duration = pidinst->buffer_duration;
		}
	}
	//handle fan-out: we must browse all other pid instances and compute max buffer/nb_pck per pids
	//so that we don't unblock the PID if some instance is still blocking
	else {
		u32 i;
		u32 min_pck = nb_pck;
		s64 min_dur = pidinst->buffer_duration;
		for (i=0; i<pid->num_destinations; i++) {
			GF_FilterPidInst *a_pidi = gf_list_get(pid->destinations, i);
			if (a_pidi==pidinst) continue;
			if (a_pidi->buffer_duration > min_dur)
				min_dur = a_pidi->buffer_duration;
			nb_pck = gf_fq_count(a_pidi->packets);
			if (nb_pck>min_pck)
				min_pck = nb_pck;
		}
		pid->buffer_duration = min_dur;
		pid->nb_buffer_unit = min_pck;
	}
	gf_filter_pid_check_unblock(pid);

	gf_mx_v(pid->filter->tasks_mx);

#ifndef GPAC_DISABLE_LOG
	if (gf_log_tool_level_on(GF_LOG_FILTER, GF_LOG_DEBUG)) {
		u8 sap_type = (pck->info.flags & GF_PCK_SAP_MASK) >> GF_PCK_SAP_POS;
		Bool seek_flag = (pck->info.flags & GF_PCKF_SEEK) ? 1 : 0;

		if ((pck->info.dts != GF_FILTER_NO_TS) && (pck->info.cts != GF_FILTER_NO_TS) ) {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s PID %s (%s) drop packet DTS "LLU" CTS "LLU" SAP %d Seek %d - %d packets remaining buffer "LLU" us\n", pidinst->filter ? pidinst->filter->name : "disconnected", pid->name, pid->filter->name, pck->info.dts, pck->info.cts, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));
		} else if ((pck->info.cts != GF_FILTER_NO_TS) ) {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s PID %s (%s) drop packet CTS "LLU" SAP %d Seek %d - %d packets remaining buffer "LLU" us\n", pidinst->filter ? pidinst->filter->name : "disconnected", pid->name, pid->filter->name, pck->info.cts, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));
		} else if ((pck->info.dts != GF_FILTER_NO_TS) ) {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s PID %s (%s) drop packet DTS "LLU" SAP %d Seek %d - %d packets remaining buffer "LLU" us\n", pidinst->filter ? pidinst->filter->name : "disconnected", pid->name, pid->filter->name, pck->info.dts, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));
		} else {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s PID %s (%s) drop packet SAP %d Seek %d - %d packets remaining buffer "LLU" us\n", pidinst->filter ? pidinst->filter->name : "disconnected", pid->name, pid->filter->name, sap_type, seek_flag, nb_pck, pidinst->buffer_duration));
		}
	}
#endif

	//destroy pcki
	pcki->pck = NULL;
	pcki->pid = NULL;

#ifdef GPAC_MEMORY_TRACKING
	if (pid->filter && pid->filter->session->check_allocs) {
		gf_mem_get_stats(&prev_nb_allocs, NULL, &prev_nb_reallocs, NULL);
	}
#endif

	if (pid->filter->pcks_inst_reservoir) {
		gf_fq_add(pid->filter->pcks_inst_reservoir, pcki);
	} else {
		gf_free(pcki);
	}
	//unref pck
	assert(pck->reference_count);
	if (safe_int_dec(&pck->reference_count) == 0) {
		gf_filter_packet_destroy(pck);
	}

#ifdef GPAC_MEMORY_TRACKING
	if (pid->filter && pid->filter->session->check_allocs) {
		gf_mem_get_stats(&nb_allocs, NULL, &nb_reallocs, NULL);

		pid->filter->session->nb_alloc_pck += (nb_allocs - prev_nb_allocs);
		pid->filter->session->nb_realloc_pck += (nb_reallocs - prev_nb_reallocs);
	}
#endif

	//decrement number of pending packet on target filter if this is not a destroy
	if (pidinst->filter) {
		assert(pidinst->filter->pending_packets);
		safe_int_dec(&pidinst->filter->pending_packets);

		gf_filter_forward_clock(pidinst->filter);
	}

	gf_rmt_end();
}
