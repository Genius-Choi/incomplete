int wc_DsaSign(const byte* digest, byte* out, DsaKey* key, WC_RNG* rng)
{
    mp_int  k, kInv, r, s, H;
    mp_int* qMinus1;
    int     ret = 0, sz;
    byte    buffer[DSA_HALF_SIZE];
    byte*   tmp;  /* initial output pointer */

    if (digest == NULL || out == NULL || key == NULL || rng == NULL) {
        return BAD_FUNC_ARG;
    }

    tmp = out;

    sz = min((int)sizeof(buffer), mp_unsigned_bin_size(&key->q));

    if (mp_init_multi(&k, &kInv, &r, &s, &H, 0) != MP_OKAY)
        return MP_INIT_E;
    qMinus1 = &kInv;

    /* NIST FIPS 186-4: B.2.2
     * Per-Message Secret Number Generation by Testing Candidates
     * Generate k in range [1, q-1].
     *   Check that k is less than q-1: range [0, q-2].
     *   Add 1 to k: range [1, q-1].
     */
    if (mp_sub_d(&key->q, 1, qMinus1))
        ret = MP_SUB_E;

    if (ret == 0) {
        do {
            /* Step 4: generate k */
            ret = wc_RNG_GenerateBlock(rng, buffer, sz);

            /* Step 5 */
            if (ret == 0 && mp_read_unsigned_bin(&k, buffer, sz) != MP_OKAY)
                ret = MP_READ_E;

            /* k is a random numnber and it should be less than q-1
             * if k greater than repeat
             */
        /* Step 6 */
        } while (ret == 0 && mp_cmp(&k, qMinus1) != MP_LT);
    }
    /* Step 7 */
    if (ret == 0 && mp_add_d(&k, 1, &k) != MP_OKAY)
        ret = MP_MOD_E;

    /* inverse k mod q */
    if (ret == 0 && mp_invmod(&k, &key->q, &kInv) != MP_OKAY)
        ret = MP_INVMOD_E;

    /* generate r, r = (g exp k mod p) mod q */
    if (ret == 0 && mp_exptmod_ex(&key->g, &k, key->q.used, &key->p,
                                                               &r) != MP_OKAY) {
        ret = MP_EXPTMOD_E;
    }

    if (ret == 0 && mp_mod(&r, &key->q, &r) != MP_OKAY)
        ret = MP_MOD_E;

    /* generate H from sha digest */
    if (ret == 0 && mp_read_unsigned_bin(&H, digest,WC_SHA_DIGEST_SIZE) != MP_OKAY)
        ret = MP_READ_E;

    /* generate s, s = (kInv * (H + x*r)) % q */
    if (ret == 0 && mp_mul(&key->x, &r, &s) != MP_OKAY)
        ret = MP_MUL_E;

    if (ret == 0 && mp_add(&s, &H, &s) != MP_OKAY)
        ret = MP_ADD_E;

    if (ret == 0 && mp_mulmod(&s, &kInv, &key->q, &s) != MP_OKAY)
        ret = MP_MULMOD_E;

    /* detect zero r or s */
    if (ret == 0 && (mp_iszero(&r) == MP_YES || mp_iszero(&s) == MP_YES))
        ret = MP_ZERO_E;

    /* write out */
    if (ret == 0)  {
        int rSz = mp_unsigned_bin_size(&r);
        int sSz = mp_unsigned_bin_size(&s);

        while (rSz++ < DSA_HALF_SIZE) {
            *out++ = 0x00;  /* pad front with zeros */
        }

        if (mp_to_unsigned_bin(&r, out) != MP_OKAY)
            ret = MP_TO_E;
        else {
            out = tmp + DSA_HALF_SIZE;  /* advance to s in output */
            while (sSz++ < DSA_HALF_SIZE) {
                *out++ = 0x00;  /* pad front with zeros */
            }
            ret = mp_to_unsigned_bin(&s, out);
        }
    }

    mp_clear(&H);
    mp_clear(&s);
    mp_clear(&r);
    mp_clear(&kInv);
    mp_clear(&k);

    return ret;
}
