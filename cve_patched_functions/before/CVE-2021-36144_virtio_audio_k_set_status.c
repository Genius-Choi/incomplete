virtio_audio_k_set_status(void *base, uint64_t status)
{
	struct virtio_audio *virt_audio;
	int nvq;
	struct msix_table_entry *mte;
	uint64_t msix_addr = 0;
	uint32_t msix_data = 0;
	int rc, i, j;

	virt_audio = (struct virtio_audio *)base;
	nvq = virt_audio->base.vops->nvq;

	if (virt_audio->vbs_k.kstatus == VIRTIO_DEV_INIT_SUCCESS &&
	    (status & VIRTIO_CONFIG_S_DRIVER_OK)) {
		/* time to kickoff VBS-K side */
		/* init vdev first */
		rc = virtio_audio_kernel_dev_set(
					&virt_audio->vbs_k.kdev,
					virt_audio->base.vops->name,
					virt_audio->base.dev->vmctx->vmid,
					nvq,
					virt_audio->base.negotiated_caps,
					/* currently we let VBS-K handle
					 * kick register
					 *
					 * FIXME: the size should be returned
					 *  by a api in vhost.
					 */
					virt_audio->base.dev->bar[0].addr + 16,
					2);

		for (i = 0; i < nvq; i++) {
			if (virt_audio->vq[i].msix_idx
				!= VIRTIO_MSI_NO_VECTOR) {
				j = virt_audio->vq[i].msix_idx;
				mte = &virt_audio->base.dev->msix.table[j];
				msix_addr = mte->addr;
				msix_data = mte->msg_data;
			}
			rc = virtio_audio_kernel_vq_set(
				&virt_audio->vbs_k.kvqs,
				nvq, i,
				virt_audio->vq[i].qsize,
				virt_audio->vq[i].pfn,
				virt_audio->vq[i].msix_idx,
				msix_addr,
				msix_data);

			if (rc < 0) {
				WPRINTF(("audio: kernel_set_vq failed, "
					 "i %d ret %d\n", i, rc));
				return;
			}
		}
		rc = virtio_audio_kernel_start(virt_audio);
		if (rc < 0) {
			WPRINTF(("virtio_audio: kernel_start() failed\n"));
			virt_audio->vbs_k.kstatus = VIRTIO_DEV_START_FAILED;
		} else {
			virt_audio->vbs_k.kstatus = VIRTIO_DEV_STARTED;
		}
	}
}
