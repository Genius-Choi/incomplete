txBoolean fxTypedArrayDefineOwnProperty(txMachine* the, txSlot* instance, txID id, txIndex index, txSlot* slot, txFlag mask) 
{
	if ((!id) || fxIsCanonicalIndex(the, id)) {
		txSlot* dispatch = instance->next;
		txSlot* view = dispatch->next;
		txSlot* buffer = view->next;
		txU2 shift = dispatch->value.typedArray.dispatch->shift;
		txSlot* arrayBuffer = buffer->value.reference->next;
		txIndex length = fxGetDataViewSize(the, view, buffer) >> shift;
		if (id || (index >= length))
			return 0;
		if ((mask & XS_DONT_DELETE_FLAG) && (slot->flag & XS_DONT_DELETE_FLAG))
			return 0;
		if ((mask & XS_DONT_ENUM_FLAG) && (slot->flag & XS_DONT_ENUM_FLAG))
			return 0;
		if (mask & XS_ACCESSOR_FLAG)
			return 0;
		if ((mask & XS_DONT_SET_FLAG) && (slot->flag & XS_DONT_SET_FLAG))
			return 0;
		if (slot->kind != XS_UNINITIALIZED_KIND) {
			dispatch->value.typedArray.dispatch->coerce(the, slot);
			if (arrayBuffer->flag & XS_DONT_SET_FLAG)
				mxTypeError("read-only buffer");
			length = fxGetDataViewSize(the, view, buffer) >> shift;
			if (index < length)
				(*dispatch->value.typedArray.dispatch->setter)(the, arrayBuffer, view->value.dataView.offset + (index << shift), slot, EndianNative);
		}
		return 1;
	}
	return fxOrdinaryDefineOwnProperty(the, instance, id, index, slot, mask);
}
