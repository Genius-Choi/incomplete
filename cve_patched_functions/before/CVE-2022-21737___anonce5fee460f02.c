    .SetShapeFn([](InferenceContext* c) {
      ShapeHandle unused;
      // The input `input` must be at most matrix.
      TF_RETURN_IF_ERROR(c->WithRankAtMost(c->input(0), 2, &unused));
      // The input `size` must be a scalar.
      TF_RETURN_IF_ERROR(c->WithRank(c->input(1), 0, &unused));

      const Tensor* size_tensor = c->input_tensor(1);
      if (size_tensor == nullptr) {
        // Return unknown shape if size is not known.
        c->set_output(0, c->UnknownShape());
        return Status::OK();
      }

      int64_t size_val;
      DataType dtype;
      TF_RETURN_IF_ERROR(c->GetAttr("Tidx", &dtype));
      if (dtype == DT_INT32) {
        size_val = static_cast<int64_t>(size_tensor->scalar<int32>()());
      } else if (dtype == DT_INT64) {
        size_val = size_tensor->scalar<int64_t>()();
      } else {
        return errors::InvalidArgument("size dtype must be int32 or int64");
      }
      // Return `[size]` shape if size is known.
      if (size_val < 0) {
        return errors::InvalidArgument("size (", size_val,
                                       ") must be non-negative");
      }
      if (c->Rank(c->input(0)) == 1) {
        c->set_output(0, c->MakeShape({size_val}));
      } else if (c->Rank(c->input(0)) == 2) {
        c->set_output(0, c->MakeShape({c->Dim(c->input(0), 0), size_val}));
      }
      return Status::OK();
    });
