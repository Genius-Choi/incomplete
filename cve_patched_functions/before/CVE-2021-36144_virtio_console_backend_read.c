virtio_console_backend_read(int fd __attribute__((unused)),
			    enum ev_type t __attribute__((unused)),
			    void *arg)
{
	struct virtio_console_port *port;
	struct virtio_console_backend *be = arg;
	struct virtio_vq_info *vq;
	struct iovec iov;
	static char dummybuf[2048];
	int len, n;
	uint16_t idx;

	port = be->port;
	vq = virtio_console_port_to_vq(port, true);

	if (!be->open || !port->rx_ready || !vq_ring_ready(vq)) {
		len = read(be->fd, dummybuf, sizeof(dummybuf));
		if (len == 0)
			goto close;
		return;
	}

	if (!vq_has_descs(vq)) {
		len = read(be->fd, dummybuf, sizeof(dummybuf));
		vq_endchains(vq, 1);
		if (len == 0)
			goto close;
		return;
	}

	do {
		n = vq_getchain(vq, &idx, &iov, 1, NULL);
		len = readv(be->fd, &iov, n);
		if (len <= 0) {
			vq_retchain(vq);
			vq_endchains(vq, 0);

			/* no data available */
			if (len == -1 && errno == EAGAIN)
				return;

			/* when client uos reboot or shutdown,
			 * be->fd will be closed, then the return
			 * value of readv function will be 0 */
			if (len == 0 || errno == ECONNRESET)
				goto clear;
			/* any other errors */
			goto close;
		}

		vq_relchain(vq, idx, len);
	} while (vq_has_descs(vq));

	vq_endchains(vq, 1);
	return;

close:
	virtio_console_reset_backend(be);
	WPRINTF(("vtcon: be read failed and close! len = %d, errno = %d\n",
		len, errno));
clear:
	if (be->be_type == VIRTIO_CONSOLE_BE_SOCKET && (be->socket_type == NULL
		|| !strcmp(be->socket_type,"server"))) {
		virtio_console_socket_clear(be);
	} else if (be->be_type == VIRTIO_CONSOLE_BE_SOCKET
		&& !strcmp(be->socket_type,"client")) {
		virtio_console_reset_backend(be);
		WPRINTF(("vtcon: be read failed and close! len = %d, errno = %d\n",
			len, errno));
	}
}
