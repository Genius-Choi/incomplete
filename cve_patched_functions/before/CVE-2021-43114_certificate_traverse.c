certificate_traverse(struct rpp *rpp_parent, struct rpki_uri *cert_uri)
{
/** Is the CA certificate the TA certificate? */
#define IS_TA (rpp_parent == NULL)

	struct validation *state;
	int total_parents;
	STACK_OF(X509_CRL) *rpp_parent_crl;
	X509 *cert;
	struct sia_ca_uris sia_uris;
	struct certificate_refs refs;
	enum rpki_policy policy;
	enum cert_type type;
	struct rpp *pp;
	bool repo_retry;
	bool new_level;
	int error;

	state = state_retrieve();
	if (state == NULL)
		return -EINVAL;
	total_parents = certstack_get_x509_num(validation_certstack(state));
	if (total_parents >= config_get_max_cert_depth())
		return pr_val_err("Certificate chain maximum depth exceeded.");

	/* Debug cert type */
	if (IS_TA)
		pr_val_debug("TA Certificate '%s' {",
		    uri_val_get_printable(cert_uri));
	else
		pr_val_debug("Certificate '%s' {",
		    uri_val_get_printable(cert_uri));

	fnstack_push_uri(cert_uri);

	error = rpp_crl(rpp_parent, &rpp_parent_crl);
	if (error)
		goto revert_fnstack_and_debug;

	/* -- Validate the certificate (@cert) -- */
	error = certificate_load(cert_uri, &cert);
	if (error)
		goto revert_fnstack_and_debug;
	error = certificate_validate_chain(cert, rpp_parent_crl);
	if (error)
		goto revert_cert;

	error = get_certificate_type(cert, IS_TA, &type);
	if (error)
		goto revert_cert;

	/* Debug cert type */
	switch (type) {
	case TA:
		break;
	case CA:
		pr_val_debug("Type: CA");
		break;
	case BGPSEC:
		pr_val_debug("Type: BGPsec EE. Ignoring...");
		goto revert_cert;
	case EE:
		pr_val_debug("Type: unexpected, validated as CA");
		break;
	}

	error = certificate_validate_rfc6487(cert, type);
	if (error)
		goto revert_cert;

	sia_ca_uris_init(&sia_uris);
	memset(&refs, 0, sizeof(refs));

	switch (type) {
	case TA:
		error = certificate_validate_extensions_ta(cert, &sia_uris,
		    &policy);
		break;
	default:
		/* Validate as a CA */
		error = certificate_validate_extensions_ca(cert, &sia_uris,
		    &refs, &policy);
		break;
	}
	if (error)
		goto revert_uris;

	if (!IS_TA) {
		error = certificate_validate_aia(refs.caIssuers, cert);
		if (error)
			goto revert_uris;
	}

	error = refs_validate_ca(&refs, rpp_parent);
	if (error)
		goto revert_uris;

	/* Identify if this is a new repository before fetching it */
	new_level = false;
	error = set_repository_level(IS_TA, state, cert_uri, &sia_uris,
	    &new_level);
	if (error)
		goto revert_uris;

	/*
	 * RFC 6481 section 5: "when the repository publication point contents
	 * are updated, a repository operator cannot assure RPs that the
	 * manifest contents and the repository contents will be precisely
	 * aligned at all times"
	 *
	 * Trying to avoid this issue, download the CA repository and validate
	 * manifest (and its content) again.
	 *
	 * Avoid to re-download the repo if the mft was fetched with RRDP.
	 */
	repo_retry = true;
	error = use_access_method(&sia_uris, exec_rsync_method,
	    exec_rrdp_method, new_level, &repo_retry);
	if (error)
		goto revert_uris;

	do {
		/* Validate the manifest (@mft) pointed by the certificate */
		error = x509stack_push(validation_certstack(state), cert_uri,
		    cert, policy, IS_TA);
		if (error)
			goto revert_uris;

		cert = NULL; /* Ownership stolen */

		error = handle_manifest(sia_uris.mft.uri, !repo_retry, &pp);
		if (error == 0 || !repo_retry)
			break;

		/*
		 * Don't reach here if:
		 * - Manifest is valid.
		 * - Working with local files due to a download error.
		 * - RRDP was utilized to fetch the manifest.
		 * - There was a previous attempt to re-fetch the repository.
		 */
		pr_val_info("Retrying repository download to discard 'transient inconsistency' manifest issue (see RFC 6481 section 5) '%s'",
		    uri_val_get_printable(sia_uris.caRepository.uri));
		error = rsync_download_files(sia_uris.caRepository.uri, false, true);
		if (error)
			break;

		/* Cancel stack, reload certificate (no need to revalidate) */
		x509stack_cancel(validation_certstack(state));
		error = certificate_load(cert_uri, &cert);
		if (error)
			goto revert_uris;

		repo_retry = false;
	} while (true);

	if (error) {
		x509stack_cancel(validation_certstack(state));
		goto revert_uris;
	}

	/* -- Validate & traverse the RPP (@pp) described by the manifest -- */
	rpp_traverse(pp);

	rpp_refput(pp);
revert_uris:
	sia_ca_uris_cleanup(&sia_uris);
	refs_cleanup(&refs);
revert_cert:
	if (cert != NULL)
		X509_free(cert);
revert_fnstack_and_debug:
	fnstack_pop();
	pr_val_debug("}");
	return error;
}
