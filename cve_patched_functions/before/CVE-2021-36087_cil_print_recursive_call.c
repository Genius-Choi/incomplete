void cil_print_recursive_call(struct cil_tree_node *call_node, struct cil_tree_node *terminating_node)
{
	struct cil_list *trace = NULL;
	struct cil_list_item * item = NULL;
	struct cil_tree_node *curr = NULL;

	cil_list_init(&trace, CIL_NODE);

	for (curr = call_node; curr != terminating_node; curr = curr->parent) {
		if (curr->flavor == CIL_CALL) {
			if (curr != call_node) {
				cil_list_prepend(trace, CIL_NODE, NODE(((struct cil_call *)curr->data)->macro));
			}
			cil_list_prepend(trace, CIL_NODE, curr);
		}
	}

	if (terminating_node->flavor == CIL_MACRO) {
		cil_list_prepend(trace, CIL_NODE, terminating_node);
	} else {
		cil_list_prepend(trace, CIL_NODE, NODE(((struct cil_call *)terminating_node->data)->macro));
	}

	cil_list_for_each(item, trace) {
		curr = item->data;
		if (curr->flavor == CIL_MACRO) {
			cil_tree_log(curr, CIL_ERR, "macro %s", DATUM(curr->data)->name);
		} else {
			cil_tree_log(curr, CIL_ERR, "call %s", ((struct cil_call *)curr->data)->macro_str);
		}
	}

	cil_list_destroy(&trace, CIL_FALSE);
}
