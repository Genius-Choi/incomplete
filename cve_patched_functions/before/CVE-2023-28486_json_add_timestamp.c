json_add_timestamp(struct json_container *jsonc, const char *name,
    const struct timespec *ts, bool format_timestamp)
{
    struct json_value json_value;
    int len;
    debug_decl(json_add_timestamp, SUDO_DEBUG_PLUGIN);

    if (!sudo_json_open_object(jsonc, name))
	goto oom;

    json_value.type = JSON_NUMBER;
    json_value.u.number = ts->tv_sec;
    if (!sudo_json_add_value(jsonc, "seconds", &json_value))
	goto oom;

    json_value.type = JSON_NUMBER;
    json_value.u.number = ts->tv_nsec;
    if (!sudo_json_add_value(jsonc, "nanoseconds", &json_value))
	goto oom;

    if (format_timestamp) {
	const struct eventlog_config *evl_conf = eventlog_getconf();
	const char *timefmt = evl_conf->time_fmt;
	time_t secs = ts->tv_sec;
	char timebuf[1024];
	struct tm tm;

	if (gmtime_r(&secs, &tm) != NULL) {
	    timebuf[sizeof(timebuf) - 1] = '\0';
	    len = strftime(timebuf, sizeof(timebuf), "%Y%m%d%H%M%SZ", &tm);
	    if (len != 0 && timebuf[sizeof(timebuf) - 1] == '\0') {
		json_value.type = JSON_STRING;
		json_value.u.string = timebuf; // -V507
		if (!sudo_json_add_value(jsonc, "iso8601", &json_value))
		    goto oom;
	    }
	}

	if (localtime_r(&secs, &tm) != NULL) {
	    timebuf[sizeof(timebuf) - 1] = '\0';
	    len = strftime(timebuf, sizeof(timebuf), timefmt, &tm);
	    if (len != 0 && timebuf[sizeof(timebuf) - 1] == '\0') {
		json_value.type = JSON_STRING;
		json_value.u.string = timebuf; // -V507
		if (!sudo_json_add_value(jsonc, "localtime", &json_value))
		    goto oom;
	    }
	}
    }

    if (!sudo_json_close_object(jsonc))
	goto oom;

    debug_return_bool(true);
oom:
    sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_ERRNO|SUDO_DEBUG_LINENO,
	"%s: %s", __func__, "unable to allocate memory");
    debug_return_bool(false);
}
