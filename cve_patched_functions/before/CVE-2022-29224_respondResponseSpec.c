  void respondResponseSpec(size_t index, ResponseSpec&& spec) {
    const bool trailers_empty = spec.trailers.empty();
    const bool end_stream_on_headers = spec.body_chunks.empty() && trailers_empty;
    auto response_headers = std::make_unique<Http::TestResponseHeaderMapImpl>();
    for (const auto& header : spec.response_headers) {
      response_headers->addCopy(header.first, header.second);
    }
    test_sessions_[index]->stream_response_callbacks_->decodeHeaders(std::move(response_headers),
                                                                     end_stream_on_headers);
    for (size_t i = 0; i < spec.body_chunks.size(); i++) {
      const bool end_stream = i == spec.body_chunks.size() - 1 && trailers_empty;
      const auto& chunk = spec.body_chunks[i];
      if (chunk.valid) {
        const auto data = std::make_unique<Buffer::OwnedImpl>(chunk.data.data(), chunk.data.size());
        test_sessions_[index]->stream_response_callbacks_->decodeData(*data, end_stream);
      } else {
        Buffer::OwnedImpl incorrect_data("incorrect");
        test_sessions_[index]->stream_response_callbacks_->decodeData(incorrect_data, end_stream);
      }
    }
    if (!trailers_empty) {
      auto trailers = std::make_unique<Http::TestResponseTrailerMapImpl>();
      for (const auto& header : spec.trailers) {
        trailers->addCopy(header.first, header.second);
      }
      test_sessions_[index]->stream_response_callbacks_->decodeTrailers(std::move(trailers));
    }
  }
