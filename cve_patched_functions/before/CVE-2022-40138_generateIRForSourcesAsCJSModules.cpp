bool generateIRForSourcesAsCJSModules(
    Module &M,
    sem::SemContext &semCtx,
    const DeclarationFileListTy &declFileList,
    SegmentTable fileBufs,
    SourceMapGenerator *sourceMapGen) {
  auto context = M.shareContext();
  llvh::SmallString<64> rootPath{fileBufs[0][0].file->getBufferIdentifier()};
  llvh::sys::path::remove_filename(rootPath, llvh::sys::path::Style::posix);
  bool generateIR = cl::DumpTarget >= DumpIR;

  // Construct a MemoryBuffer for our global entry point.
  llvh::SmallString<64> entryPointFilename{
      fileBufs[0][0].file->getBufferIdentifier()};
  llvh::sys::path::replace_path_prefix(
      entryPointFilename, rootPath, "./", llvh::sys::path::Style::posix);

  // The top-level function is empty, due to the fact that it is not intended to
  // be executed. The Runtime must choose and execute the correct entry point
  // (main) module, from which other modules may be `require`d.
  auto globalMemBuffer = llvh::MemoryBuffer::getMemBufferCopy("", "<global>");

  auto *globalAST = parseJS(context, semCtx, std::move(globalMemBuffer));
  if (generateIR) {
    // If we aren't planning to do anything with the IR,
    // don't attempt to generate it.
    generateIRFromESTree(globalAST, &M, declFileList, {});
  }

  std::vector<std::unique_ptr<SourceMap>> inputSourceMaps{};
  inputSourceMaps.push_back(nullptr);
  std::vector<std::string> sources{"<global>"};

  Function *topLevelFunction = generateIR ? M.getTopLevelFunction() : nullptr;
  llvh::DenseSet<uint32_t> generatedModuleIDs;
  for (auto &entry : fileBufs) {
    uint32_t segmentID = entry.first;
    for (ModuleInSegment &moduleInSegment : entry.second) {
      auto &fileBuf = moduleInSegment.file;
      llvh::SmallString<64> filename{fileBuf->getBufferIdentifier()};

      if (sourceMapGen && generatedModuleIDs.count(moduleInSegment.id) == 0) {
        // This is the first time we're generating IR for this module.
        sources.push_back(fileBuf->getBufferIdentifier());
        if (moduleInSegment.sourceMap) {
          SourceErrorManager sm;
          auto inputMap =
              SourceMapParser::parse(*moduleInSegment.sourceMap, sm);
          if (!inputMap) {
            // parse() returns nullptr on failure and reports its own errors.
            return false;
          }
          inputSourceMaps.push_back(std::move(inputMap));
        } else {
          inputSourceMaps.push_back(nullptr);
        }
      }

      generatedModuleIDs.insert(moduleInSegment.id);

      llvh::sys::path::replace_path_prefix(
          filename, rootPath, "./", llvh::sys::path::Style::posix);
      // TODO: use sourceMapTranslator for CJS module.
      auto *ast = parseJS(
          context,
          semCtx,
          std::move(fileBuf),
          /*sourceMap*/ nullptr,
          /*sourceMapTranslator*/ nullptr,
          /*wrapCJSModule*/ true);
      if (!ast) {
        return false;
      }
      if (!generateIR) {
        continue;
      }
      generateIRForCJSModule(
          cast<ESTree::FunctionExpressionNode>(ast),
          segmentID,
          moduleInSegment.id,
          llvh::sys::path::remove_leading_dotslash(filename),
          &M,
          topLevelFunction,
          declFileList);
    }
  }

  if (sourceMapGen) {
    for (const auto &source : sources) {
      sourceMapGen->addSource(source);
    }
    sourceMapGen->setInputSourceMaps(std::move(inputSourceMaps));
  }

  return true;
}
