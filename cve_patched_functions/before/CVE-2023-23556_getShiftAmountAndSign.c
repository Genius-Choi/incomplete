static std::tuple<uint32_t, bool> getShiftAmountAndSign(
    ImmutableBigIntRef shiftAmnt) {
  // reallyLargeShiftAmount represents a shift amount that's either going to
  // produce a 0 result (in case of a signed right shift), or an impossibly
  // large one (i.e., one with over BigIntMaxSizeInDigits). It is used as the
  // return value when shiftAmnt is outsize
  // [MinNegativeShiftAmountInBits, MaxPositiveShiftAmountInBits].
  const BigIntDigitType reallyLargeShiftAmount =
      numDigitsForSizeInBytes(MaxPositiveShiftAmountInBits + 1);

  const bool shiftAmntIsNeg = isNegative(shiftAmnt);

  if (compare(shiftAmnt, MinNegativeShiftAmountInBits) < 0 ||
      compare(shiftAmnt, MaxPositiveShiftAmountInBits) > 0) {
    // shiftAmnt is outside of the
    // [MinNegativeShiftAmountInBits, MaxPositiveShiftAmountInBits]; thus return
    // a really large shift amount.
    return std::make_tuple(
        static_cast<uint32_t>(reallyLargeShiftAmount), shiftAmntIsNeg);
  }

  const SignedBigIntDigitType sa = (shiftAmnt.numDigits == 0)
      ? 0ll
      : static_cast<SignedBigIntDigitType>(shiftAmnt.digits[0]);
  assert(
      (shiftAmnt.numDigits == 0 ||
       shiftAmnt.digits[0] != std::numeric_limits<BigIntDigitType>::min()) &&
      "shiftAmnt is MIN_INT, hence -signedShiftAmnt is MIN_INT");
  // Always return a positive result -- thus negate sa if shiftAmnt is negative.
  return std::make_tuple(
      static_cast<uint32_t>(shiftAmntIsNeg ? -sa : sa), shiftAmntIsNeg);
}
