static ERL_NIF_TERM rsa_verify(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{/* (Type, Data, Signature, Key=[E,N]) */
    ErlNifBinary data_bin, sign_bin;
    unsigned char hmacbuf[SHA_DIGEST_LENGTH];
    ERL_NIF_TERM head, tail, ret;
    int i, is_sha;
    RSA* rsa = RSA_new();

    if (argv[0] == atom_sha) is_sha = 1;
    else if (argv[0] == atom_md5) is_sha = 0;
    else goto badarg;

    if (!inspect_mpint(env, argv[1], &data_bin)
	|| !inspect_mpint(env, argv[2], &sign_bin)
	|| !enif_get_list_cell(env, argv[3], &head, &tail)
	|| !get_bn_from_mpint(env, head, &rsa->e)
	|| !enif_get_list_cell(env, tail, &head, &tail)
	|| !get_bn_from_mpint(env, head, &rsa->n)
	|| !enif_is_empty_list(env, tail)) {
    badarg:
	ret = enif_make_badarg(env);
    }
    else {
	if (is_sha) {
	    SHA1(data_bin.data+4, data_bin.size-4, hmacbuf);
	    i = RSA_verify(NID_sha1, hmacbuf, SHA_DIGEST_LENGTH,
			   sign_bin.data+4, sign_bin.size-4, rsa);
	}
	else {
	    MD5(data_bin.data+4, data_bin.size-4, hmacbuf);
	    i = RSA_verify(NID_md5, hmacbuf, MD5_DIGEST_LENGTH,
			   sign_bin.data+4, sign_bin.size-4, rsa);
	}
	ret = (i==1 ? atom_true : atom_false);
    }
    RSA_free(rsa);
    return ret;
}
