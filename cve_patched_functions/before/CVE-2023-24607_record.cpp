QSqlRecord QODBCDriver::record(const QString& tablename) const
{
    Q_D(const QODBCDriver);
    QSqlRecord fil;
    if (!isOpen())
        return fil;

    SQLHANDLE hStmt;
    QString catalog, schema, table;
    const_cast<QODBCDriverPrivate*>(d)->splitTableQualifier(tablename, catalog, schema, table);

    if (isIdentifierEscaped(catalog, QSqlDriver::TableName))
        catalog = stripDelimiters(catalog, QSqlDriver::TableName);
    else
        catalog = d->adjustCase(catalog);

    if (isIdentifierEscaped(schema, QSqlDriver::TableName))
        schema = stripDelimiters(schema, QSqlDriver::TableName);
    else
        schema = d->adjustCase(schema);

    if (isIdentifierEscaped(table, QSqlDriver::TableName))
        table = stripDelimiters(table, QSqlDriver::TableName);
    else
        table = d->adjustCase(table);

    SQLRETURN r = SQLAllocHandle(SQL_HANDLE_STMT,
                                  d->hDbc,
                                  &hStmt);
    if (r != SQL_SUCCESS) {
        qSqlWarning("QODBCDriver::record: Unable to allocate handle"_L1, d);
        return fil;
    }
    r = SQLSetStmtAttr(hStmt,
                        SQL_ATTR_CURSOR_TYPE,
                        (SQLPOINTER)SQL_CURSOR_FORWARD_ONLY,
                        SQL_IS_UINTEGER);
    r =  SQLColumns(hStmt,
                     catalog.length() == 0 ? NULL : toSQLTCHAR(catalog).data(),
                     catalog.length(),
                     schema.length() == 0 ? NULL : toSQLTCHAR(schema).data(),
                     schema.length(),
                     toSQLTCHAR(table).data(),
                     table.length(),
                     NULL,
                     0);
    if (r != SQL_SUCCESS)
        qSqlWarning("QODBCDriver::record: Unable to execute column list"_L1, d);

    if (d->hasSQLFetchScroll)
        r = SQLFetchScroll(hStmt,
                           SQL_FETCH_NEXT,
                           0);
    else
        r = SQLFetch(hStmt);

    // Store all fields in a StringList because some drivers can't detail fields in this FETCH loop
    while (r == SQL_SUCCESS) {

        fil.append(qMakeFieldInfo(hStmt, d));

        if (d->hasSQLFetchScroll)
            r = SQLFetchScroll(hStmt,
                               SQL_FETCH_NEXT,
                               0);
        else
            r = SQLFetch(hStmt);
    }

    r = SQLFreeHandle(SQL_HANDLE_STMT, hStmt);
    if (r!= SQL_SUCCESS)
        qSqlWarning("QODBCDriver: Unable to free statement handle "_L1 + QString::number(r), d);

    return fil;
}
