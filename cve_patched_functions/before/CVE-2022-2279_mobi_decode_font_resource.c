MOBI_RET mobi_decode_font_resource(unsigned char **decoded_font, size_t *decoded_size, MOBIPart *part) {
    if (part->size < FONT_HEADER_LEN) {
        debug_print("Font resource record too short (%zu)\n", part->size);
        return MOBI_DATA_CORRUPT;
    }
    MOBIBuffer *buf = mobi_buffer_init(part->size);
    if (buf == NULL) {
        debug_print("Memory allocation failed%s", "\n");
        return MOBI_MALLOC_FAILED;
    }
    memcpy(buf->data, part->data, part->size);
    struct header {
        char magic[5];
        uint32_t decoded_size;
        uint32_t flags;
        uint32_t data_offset;
        uint32_t xor_key_len;
        uint32_t xor_data_off;
    };
    struct header h;
    mobi_buffer_getstring(h.magic, buf, 4);
    if (strncmp(h.magic, FONT_MAGIC, 4) != 0) {
        debug_print("Wrong magic for font resource: %s\n", h.magic);
        mobi_buffer_free(buf);
        return MOBI_DATA_CORRUPT;
    }
    h.decoded_size = mobi_buffer_get32(buf);
    if (h.decoded_size == 0 || h.decoded_size > FONT_SIZEMAX) {
        debug_print("Invalid declared font resource size: %u\n", h.decoded_size);
        mobi_buffer_free(buf);
        return MOBI_DATA_CORRUPT;
    }
    h.flags = mobi_buffer_get32(buf);
    h.data_offset = mobi_buffer_get32(buf);
    h.xor_key_len = mobi_buffer_get32(buf);
    h.xor_data_off = mobi_buffer_get32(buf);
    const uint32_t zlib_flag = 1; /* bit 0 */
    const uint32_t xor_flag = 2; /* bit 1 */
    if (h.flags & xor_flag && h.xor_key_len > 0) {
        /* deobfuscate */
        if (h.data_offset > buf->maxlen || h.xor_data_off + h.xor_key_len > buf->maxlen) {
            debug_print("%s\n", "Invalid obfuscated font data offsets");
            mobi_buffer_free(buf);
            return MOBI_DATA_CORRUPT;
        }
        mobi_buffer_setpos(buf, h.data_offset);
        const unsigned char *xor_key = buf->data + h.xor_data_off;
        size_t i = 0;
        const size_t xor_limit = h.xor_key_len * MOBI_FONT_OBFUSCATED_BUFFER_COUNT;
        while (buf->offset < buf->maxlen && i < xor_limit) {
            buf->data[buf->offset++] ^= xor_key[i % h.xor_key_len];
            i++;
        }
    }
    mobi_buffer_setpos(buf, h.data_offset);
    *decoded_size = h.decoded_size;
    *decoded_font = malloc(h.decoded_size);
    if (*decoded_font == NULL) {
        mobi_buffer_free(buf);
        debug_print("%s", "Memory allocation failed\n");
        return MOBI_MALLOC_FAILED;
    }
    const unsigned char *encoded_font = buf->data + buf->offset;
    const unsigned long encoded_size = buf->maxlen - buf->offset;
    if (h.flags & zlib_flag) {
        /* unpack */
        int ret = m_uncompress(*decoded_font, (unsigned long *) decoded_size, encoded_font, encoded_size);
        if (ret != M_OK) {
            mobi_buffer_free(buf);
            free(*decoded_font);
            debug_print("%s", "Font resource decompression failed\n");
            return MOBI_DATA_CORRUPT;
        }
        if (*decoded_size != h.decoded_size) {
            mobi_buffer_free(buf);
            free(*decoded_font);
            debug_print("Decompressed font size (%zu) differs from declared (%i)\n", *decoded_size, h.decoded_size);
            return MOBI_DATA_CORRUPT;
        }
    } else {
        if (*decoded_size < encoded_size) {
            mobi_buffer_free(buf);
            free(*decoded_font);
            debug_print("Font size in record (%lu) larger then declared (%zu)\n", encoded_size, *decoded_size);
            return MOBI_DATA_CORRUPT;
        }
        memcpy(*decoded_font, encoded_font, encoded_size);
    }

    mobi_buffer_free(buf);
    return MOBI_SUCCESS;
}
