static void disasm_strings(RCore *core, const char *input, RAnalFunction *fcn) {
	const char *linecolor = NULL;
	char *ox, *qo, *string = NULL;
	char *line, *s, *string2 = NULL;
	char *switchcmp = NULL;
	int i, count, use_color = r_config_get_i (core->config, "scr.color");
	bool show_comments = r_config_get_b (core->config, "asm.comments");
	bool show_offset = r_config_get_b (core->config, "asm.offset");
	int asm_tabs = r_config_get_i (core->config, "asm.tabs");
	bool scr_html = r_config_get_b (core->config, "scr.html");
	bool asm_dwarf = r_config_get_b (core->config, "asm.dwarf");
	bool asm_flags = r_config_get_b (core->config, "asm.flags");
	bool asm_cmt_right = r_config_get_b (core->config, "asm.cmt.right");
	bool asm_emu = r_config_get_b (core->config, "asm.emu");
	bool emu_str = r_config_get_b (core->config, "emu.str");
	r_config_set_i (core->config, "emu.str", true);
	RConsPrintablePalette *pal = &core->cons->context->pal;
	// force defaults
	r_config_set_i (core->config, "scr.color", COLOR_MODE_DISABLED);
	r_config_set_b (core->config, "asm.offset", true);
	r_config_set_b (core->config, "asm.dwarf", true);
	r_config_set_i (core->config, "asm.tabs", 0);
	r_config_set_b (core->config, "scr.html", false);
	r_config_set_b (core->config, "asm.cmt.right", true);

	r_cons_push ();
	line = NULL;
	s = NULL;
	if (!strncmp (input, "dsb", 3)) {
		RAnalBlock *bb = r_anal_bb_from_offset (core->anal, core->offset);
		if (bb) {
			line = s = r_core_cmd_strf (core, "pD %"PFMT64u" @ 0x%08"PFMT64x, bb->size, bb->addr);
		}
	} else if (!strncmp (input, "dsf", 3) || !strncmp (input, "dsr", 3)) {
		RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, core->offset, R_ANAL_FCN_TYPE_NULL);
		if (fcn) {
			line = s = r_core_cmd_str (core, "pdr");
		} else {
			R_LOG_ERROR ("Cannot find function");
			r_config_set_i (core->config, "scr.color", use_color);
			r_config_set_i (core->config, "asm.cmt.right", asm_cmt_right);
			goto restore_conf;
		}
	} else if (!strncmp (input, "ds ", 3)) {
		line = s = r_core_cmd_strf (core, "pD %s", input + 3);
	} else {
		line = s = r_core_cmd_str (core, "pd");
	}
	r_cons_pop ();

	r_config_set_i (core->config, "scr.html", scr_html);
	r_config_set_i (core->config, "scr.color", use_color);
	r_config_set_i (core->config, "asm.cmt.right", asm_cmt_right);
	count = r_str_split (s, '\n');
	if (!line || !*line || count < 1) {
	//	R_FREE (s);
		goto restore_conf;
	}
	for (i = 0; i < count; i++) {
		ut64 addr = UT64_MAX;
		char *str;
		ox = strstr (line, "0x");
		qo = strchr (line, '\"');
		R_FREE (string);
		if (ox) {
			addr = r_num_get (NULL, ox);
		}
		if (qo) {
			char *qoe = strrchr (qo + 1, '"');
			if (qoe) {
				int raw_len = qoe - qo - 1;
				int actual_len = 0;
				char *ptr = qo + 1;
				for (; ptr < qoe; ptr++) {
					if (*ptr == '\\' && ptr + 1 < qoe) {
						int i, body_len;
						switch (*(ptr + 1)) {
						case 'x':
							body_len = 3;
							break;
						case 'u':
							body_len = 5;
							break;
						case 'U':
							body_len = 9;
							break;
						default:
							body_len = 1;
						}
						for (i = 0; i < body_len && ptr < qoe; i++) {
							ptr++;
						}
					}
					actual_len++;
				}
				if (actual_len > 2) {
					string = r_str_ndup (qo, raw_len + 2);
				}
				linecolor = R_CONS_COLOR (comment);
			}
		}
		ox = strstr (line, "; 0x");
		if (!ox) {
			ox = strstr (line, "@ 0x");
		}
		if (ox) {
			char *qoe = strchr (ox + 3, ' ');
			if (!qoe) {
				qoe = strchr (ox + 3, '\x1b');
			}
			int len = qoe? qoe - ox: strlen (ox + 3);
			string2 = r_str_ndup (ox + 2, len - 1);
			if (r_num_get (NULL, string2) < 0x100) {
				R_FREE (string2);
			}
		}
		if (asm_flags) {
			str = strstr (line, ";-- ");
			if (str) {
				if (!r_str_startswith (str + 4, "case")) {
					r_cons_printf ("%s\n", str);
				}
			}
		}
#define USE_PREFIXES 1
#if USE_PREFIXES
		// XXX leak
		str = strstr (line, " obj.");
		if (!str) {
			str = strstr (line, " str.");
			if (!str) {
				str = strstr (line, " imp.");
				if (!str) {
					str = strstr (line, " fcn.");
					if (!str) {
						str = strstr (line, " sub.");
					}
				}
			}
		}
#else
		if (strchr (line, ';')) {
			const char *dot = r_str_rchr (line, NULL, '.');
			if (dot) {
				const char *o = r_str_rchr (line, dot, ' ');
				if (o) {
					str = (char*)o;
				} else {
					R_LOG_WARN ("missing summary reference: %s", dot);
				}
			}
		}
#endif
		if (str) {
			char *qoe = NULL;
			if (!qoe) {
				qoe = strchr (str + 1, '\x1b');
			}
			if (!qoe) {
				qoe = strchr (str + 1, ';');
			}
			if (!qoe) {
				qoe = strchr (str + 1, ' ');
			}
			if (qoe) {
				free (string2);
				string2 = r_str_ndup (str + 1, qoe - str - 1);
			} else {
				free (string2);
				string2 = strdup (str + 1);
			}
			if (string2) {
				R_FREE (string);
				string = string2;
				string2 = NULL;
			}
		}
		R_FREE (string2);
		_handle_call (core, line, &str);
		if (!str) {
			str = strstr (line, "sym.");
			if (!str) {
				str = strstr (line, "fcn.");
			}
		}
		if (str) {
			char *qoe = strchr (str, ';');
			if (qoe) {
				str = r_str_ndup (str, qoe - str);
			} else {
				str = strdup (str);
			}
		}
		if (str) {
			string2 = strdup (str);
			linecolor = R_CONS_COLOR (call);
		}
		if (!string && string2) {
			string = string2;
			string2 = NULL;
		}
		if (strstr (line, "XREF")) {
			addr = UT64_MAX;
		}
		if (addr != UT64_MAX) {
			const char *str = NULL;
			if (show_comments) {
				char *comment = r_core_anal_get_comments (core, addr);
				if (comment) {
					if (switchcmp) {
						if (strcmp (comment, switchcmp)) {
							if (show_offset) {
								r_cons_printf ("%s0x%08"PFMT64x" ", use_color? pal->offset: "", addr);
							}
							r_cons_printf ("%s%s\n", use_color? pal->comment: "", comment);
						}
					}
					else {
						if (show_offset) {
							r_cons_printf ("%s0x%08"PFMT64x" ", use_color? pal->offset: "", addr);
						}
						r_cons_printf ("%s%s\n", use_color? pal->comment: "", comment);
					}
					if (r_str_startswith (comment, "switch table")) {
						free (switchcmp);
						switchcmp = strdup (comment);
					}
					R_FREE (comment);
				}
			}

			if (fcn) {
				bool label = false;
				/* show labels, basic blocks and (conditional) branches */
				RAnalBlock *bb;
				RListIter *iter;
				r_list_foreach (fcn->bbs, iter, bb) {
					if (addr == bb->jump) {
						if (show_offset) {
							r_cons_printf ("%s0x%08"PFMT64x ":\n", use_color? Color_YELLOW: "", addr);
						}
						label = true;
						break;
					}
				}
				if (!label && strstr (line, "->")) {
					r_cons_printf ("%s0x%08"PFMT64x ":\n", use_color? Color_YELLOW: "", addr);
				}
				if (strstr (line, "=<")) {
					r_list_foreach (fcn->bbs, iter, bb) {
						if (addr >= bb->addr && addr < bb->addr + bb->size) {
							const char *op;
							if (use_color) {
								op = (bb->fail == UT64_MAX)? Color_GREEN "jmp": "cjmp";
							} else {
								op = (bb->fail == UT64_MAX)? "jmp": "cjmp";
							}
							if (show_offset) {
								r_cons_printf ("%s0x%08"PFMT64x" "Color_RESET, use_color? pal->offset: "", addr);
							}
							r_cons_printf ("%s 0x%08"PFMT64x "%s\n",
								op, bb->jump, use_color? Color_RESET: "");
							break;
						}
					}
				}
			}
			if (string && *string) {
				if (string && !strncmp (string, "0x", 2)) {
					str = string;
				}
				if (string2 && !strncmp (string2, "0x", 2)) {
					str = string2;
				}
				ut64 ptr = r_num_math (NULL, str);
				RFlagItem *flag = NULL;
				if (str) {
					flag = r_core_flag_get_by_spaces (core->flags, ptr);
				}
				if (!flag) {
					if (string && !strncmp (string, "0x", 2)) {
						R_FREE (string);
					}
					if (string2 && !strncmp (string2, "0x", 2)) {
						R_FREE (string2);
					}
				}
				if (string && addr != UT64_MAX && addr != UT32_MAX) {
					r_str_trim (string);
					if (string2) {
						r_str_trim (string2);
					}
					//// TODO implememnt avoid duplicated strings
					// eprintf ("---> %s\n", string);
					if (use_color) {
						if (show_offset) {
							r_cons_printf ("%s0x%08"PFMT64x" "Color_RESET, use_color? pal->offset: "", addr);
						}
						r_cons_printf ("%s%s%s%s%s%s%s\n",
							r_str_get (linecolor),
							r_str_get (string2), string2? " ": "", string,
							flag? " ": "", flag? flag->name: "", Color_RESET);
					} else {
						if (show_offset) {
							r_cons_printf ("0x%08"PFMT64x" ", addr);
						}
						r_cons_printf ("%s%s%s%s%s\n",
							r_str_get (string2), string2? " ": "", string,
							flag? " ": "", flag? flag->name: "");
					}
				}
			}
		}
		free (str);
		line += strlen (line) + 1;
	}
	// r_cons_printf ("%s", s);
	R_FREE (string2);
	R_FREE (string);
	R_FREE (s);
	R_FREE (switchcmp);
restore_conf:
	r_config_set_b (core->config, "asm.offset", show_offset);
	r_config_set_b (core->config, "asm.dwarf", asm_dwarf);
	r_config_set_i (core->config, "asm.tabs", asm_tabs);
	r_config_set_b (core->config, "scr.html", scr_html);
	r_config_set_b (core->config, "asm.emu", asm_emu);
	r_config_set_b (core->config, "emu.str", emu_str);
}
