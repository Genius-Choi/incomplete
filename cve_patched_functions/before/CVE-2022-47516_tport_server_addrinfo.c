int tport_server_addrinfo(tport_master_t *mr,
			  char const *canon,
			  int family,
			  char const *host,
			  char const *service,
			  char const *protocol,
			  char const * const transports[],
			  su_addrinfo_t **return_addrinfo)
{
  int i, N;
  su_addrinfo_t hints[TPORT_N + 1];

  *return_addrinfo = NULL;

  /*
   * Resolve all the transports requested by the protocol
   */
  for (i = 0, N = 0; transports[i] && N < TPORT_N; i++) {
    su_addrinfo_t *ai = &hints[N];

    if (!su_casematch(protocol, transports[i]) && !su_strmatch(protocol, "*"))
      continue;

    /* Resolve protocol, skip unknown transport protocols. */
    if (getprotohints(ai, transports[i], AI_PASSIVE) < 0)
      continue;

    ai->ai_family = family;
    ai->ai_next = &hints[++N];
  }

  if (N == 0)
    return su_seterrno(EPROTONOSUPPORT);
  if (transports[i] /* Too many protocols */)
    return su_seterrno(ENOMEM);

  hints[N - 1].ai_next = NULL;

  if (host) {
    int error = tport_getaddrinfo(host, service, hints, return_addrinfo);
    if (error || !*return_addrinfo) {
      SU_DEBUG_3(("%s(%p): su_getaddrinfo(%s, %s) for %s: %s\n",
		  __func__, (void *)mr,
		  host ? host : "\"\"", service, protocol,
		  su_gai_strerror(error)));
      return su_seterrno(error != EAI_MEMORY ? ENOENT : ENOMEM);
    }
    return 0;
  }

  return tport_get_local_addrinfo(mr, service, hints, return_addrinfo);
}
