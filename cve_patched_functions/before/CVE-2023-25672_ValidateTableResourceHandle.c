Status ValidateTableResourceHandle(InferenceContext* c, ShapeHandle keys,
                                   const string& key_dtype_attr,
                                   const string& value_dtype_attr,
                                   ShapeAndType* output_shape_and_type) {
  auto* handle_data = c->input_handle_shapes_and_types(0);
  if (handle_data == nullptr || handle_data->size() != 2) {
    output_shape_and_type->shape = c->UnknownShape();
    output_shape_and_type->dtype = DT_INVALID;
  } else {
    const ShapeAndType& key_shape_and_type = (*handle_data)[0];
    const ShapeAndType& value_shape_and_type = (*handle_data)[1];
    TF_RETURN_IF_ERROR(ValidateTableType(c, key_shape_and_type, key_dtype_attr,
                                         value_shape_and_type,
                                         value_dtype_attr));
    output_shape_and_type->dtype = value_shape_and_type.dtype;
    if (c->RankKnown(key_shape_and_type.shape) && c->RankKnown(keys)) {
      int keys_rank = c->Rank(keys);
      int key_suffix_rank = c->Rank(key_shape_and_type.shape);
      if (keys_rank < key_suffix_rank) {
        return errors::InvalidArgument(
            "Expected keys to have suffix ",
            c->DebugString(key_shape_and_type.shape),
            " but saw shape: ", c->DebugString(keys));
      }
      for (int d = 0; d < key_suffix_rank; d++) {
        // Ensure the suffix of keys match what's in the Table.
        DimensionHandle dim = c->Dim(key_shape_and_type.shape, d);
        TF_RETURN_IF_ERROR(
            c->ReplaceDim(keys, keys_rank - key_suffix_rank + d, dim, &keys));
      }
      std::vector<DimensionHandle> keys_prefix_vec;
      keys_prefix_vec.reserve(keys_rank - key_suffix_rank);
      for (int d = 0; d < keys_rank - key_suffix_rank; ++d) {
        keys_prefix_vec.push_back(c->Dim(keys, d));
      }
      ShapeHandle keys_prefix = c->MakeShape(keys_prefix_vec);
      TF_RETURN_IF_ERROR(c->Concatenate(keys_prefix, value_shape_and_type.shape,
                                        &output_shape_and_type->shape));
    } else {
      output_shape_and_type->shape = c->UnknownShape();
    }
  }
  return OkStatus();
}
