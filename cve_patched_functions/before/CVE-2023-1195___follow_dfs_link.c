static int __follow_dfs_link(struct mount_ctx *mnt_ctx)
{
	int rc;
	struct cifs_sb_info *cifs_sb = mnt_ctx->cifs_sb;
	struct smb3_fs_context *ctx = mnt_ctx->fs_ctx;
	char *full_path;
	struct dfs_cache_tgt_list tl = DFS_CACHE_TGT_LIST_INIT(tl);
	struct dfs_cache_tgt_iterator *tit;

	full_path = build_unc_path_to_root(ctx, cifs_sb, true);
	if (IS_ERR(full_path))
		return PTR_ERR(full_path);

	kfree(mnt_ctx->leaf_fullpath);
	mnt_ctx->leaf_fullpath = dfs_cache_canonical_path(full_path, cifs_sb->local_nls,
							  cifs_remap(cifs_sb));
	if (IS_ERR(mnt_ctx->leaf_fullpath)) {
		rc = PTR_ERR(mnt_ctx->leaf_fullpath);
		mnt_ctx->leaf_fullpath = NULL;
		goto out;
	}

	/* Get referral from dfs link */
	rc = dfs_cache_find(mnt_ctx->xid, mnt_ctx->root_ses, cifs_sb->local_nls,
			    cifs_remap(cifs_sb), mnt_ctx->leaf_fullpath + 1, NULL, &tl);
	if (rc)
		goto out;

	/* Try all dfs link targets.  If an I/O fails from currently connected DFS target with an
	 * error other than STATUS_PATH_NOT_COVERED (-EREMOTE), then retry it from other targets as
	 * specified in MS-DFSC "3.1.5.2 I/O Operation to Target Fails with an Error Other Than
	 * STATUS_PATH_NOT_COVERED."
	 */
	for (rc = -ENOENT, tit = dfs_cache_get_tgt_iterator(&tl);
	     tit; tit = dfs_cache_get_next_tgt(&tl, tit)) {
		rc = connect_dfs_target(mnt_ctx, full_path, mnt_ctx->leaf_fullpath + 1, tit);
		if (!rc) {
			rc = is_path_remote(mnt_ctx);
			if (!rc || rc == -EREMOTE)
				break;
		}
	}

out:
	kfree(full_path);
	dfs_cache_free_tgts(&tl);
	return rc;
}
