void ByteCodeGenerator::InitBlockScopedNonTemps(ParseNode *pnode, FuncInfo *funcInfo)
{
    // Initialize all non-temp register variables on entry to the enclosing func - in particular,
    // those with lifetimes that begin after the start of user code and may not be initialized normally.
    // This protects us from, for instance, trying to restore garbage on bailout.
    // It was originally done in debugger mode only, but we do it always to avoid issues with boxing
    // garbage on exit from jitted loop bodies.
    while (pnode)
    {
        switch (pnode->nop)
        {
        case knopFncDecl:
        {
            // If this is a block-scoped function, initialize it.
            ParseNode *pnodeName = pnode->sxFnc.pnodeName;
            if (!pnode->sxFnc.IsMethod() && pnodeName && pnodeName->nop == knopVarDecl)
            {
                Symbol *sym = pnodeName->sxVar.sym;
                Assert(sym);
                if (sym->GetLocation() != Js::Constants::NoRegister &&
                    sym->GetScope()->IsBlockScope(funcInfo) &&
                    sym->GetScope()->GetFunc() == funcInfo)
                {
                    this->m_writer.Reg1(Js::OpCode::LdUndef, sym->GetLocation());
                }
            }

            // No need to recurse to the nested scopes, as they belong to a nested function.
            pnode = pnode->sxFnc.pnodeNext;
            break;
        }

        case knopBlock:
        {
            Scope *scope = pnode->sxBlock.scope;
            if (scope)
            {
                if (scope->IsBlockScope(funcInfo))
                {
                    Js::RegSlot scopeLoc = scope->GetLocation();
                    if (scopeLoc != Js::Constants::NoRegister && !funcInfo->IsTmpReg(scopeLoc))
                    {
                        this->m_writer.Reg1(Js::OpCode::LdUndef, scopeLoc);
                    }
                }
                auto fnInit = [this, funcInfo](ParseNode *pnode)
                {
                    Symbol *sym = pnode->sxVar.sym;
                    if (!sym->IsInSlot(funcInfo) && !sym->GetIsGlobal() && !sym->GetIsModuleImport())
                    {
                        this->m_writer.Reg1(Js::OpCode::InitUndecl, pnode->sxVar.sym->GetLocation());
                    }
                };
                IterateBlockScopedVariables(pnode, fnInit);
            }
            InitBlockScopedNonTemps(pnode->sxBlock.pnodeScopes, funcInfo);
            pnode = pnode->sxBlock.pnodeNext;
            break;
        }
        case knopCatch:
            InitBlockScopedNonTemps(pnode->sxCatch.pnodeScopes, funcInfo);
            pnode = pnode->sxCatch.pnodeNext;
            break;

        case knopWith:
        {
            Js::RegSlot withLoc = pnode->location;
            AssertMsg(withLoc != Js::Constants::NoRegister && !funcInfo->IsTmpReg(withLoc),
                "We should put with objects at known stack locations in debug mode");
            this->m_writer.Reg1(Js::OpCode::LdUndef, withLoc);
            InitBlockScopedNonTemps(pnode->sxWith.pnodeScopes, funcInfo);
            pnode = pnode->sxWith.pnodeNext;
            break;
        }

        default:
            Assert(false);
            return;
        }
    }
}
