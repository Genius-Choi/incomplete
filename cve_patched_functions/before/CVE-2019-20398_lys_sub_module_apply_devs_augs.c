lys_sub_module_apply_devs_augs(struct lys_module *module)
{
    uint8_t u, v;
    struct unres_schema *unres;

    assert(module->implemented);

    unres = calloc(1, sizeof *unres);
    LY_CHECK_ERR_RETURN(!unres, LOGMEM(module->ctx), );

    /* apply deviations */
    for (u = 0; u < module->deviation_size; ++u) {
        apply_dev(&module->deviation[u], module, unres);
    }
    /* apply augments */
    for (u = 0; u < module->augment_size; ++u) {
        apply_aug(&module->augment[u], unres);
    }

    /* apply deviations and augments defined in submodules */
    for (v = 0; v < module->inc_size; ++v) {
        for (u = 0; u < module->inc[v].submodule->deviation_size; ++u) {
            apply_dev(&module->inc[v].submodule->deviation[u], module, unres);
        }

        for (u = 0; u < module->inc[v].submodule->augment_size; ++u) {
            apply_aug(&module->inc[v].submodule->augment[u], unres);
        }
    }

    if (unres->count) {
        resolve_unres_schema(module, unres);
    }
    /* nothing else left to do even if something is not resolved */
    unres_schema_free(module, &unres, 1);
}
