static void dasher_forward_mpd(GF_DasherCtx *ctx, const char *manifest)
{
	u32 i, count, nb_periods, nb_streams;
	GF_XMLAttribute *cenc_att = NULL;
	GF_XMLAttribute *xlink_att = NULL;
	GF_XMLAttribute *ck_att = NULL;
	FILE *tmp = NULL;
	GF_MPD *mpd = gf_mpd_new();
	GF_List *recompute_sets = NULL;
	GF_DOMParser *dom = gf_xml_dom_new();
	GF_Err e = gf_xml_dom_parse_string(dom, (char *)manifest);
	if (e) goto err_exit;

	e = gf_mpd_init_from_dom(gf_xml_dom_get_root(dom), mpd, NULL);
	if (e) goto err_exit;

	nb_streams = gf_list_count(ctx->pids);
	nb_periods = gf_list_count(mpd->periods);
	for (i=0; i<nb_periods; i++) {
		u32 j;
		GF_MPD_AdaptationSet *set = NULL;
		GF_MPD_Representation *rep = NULL;
		GF_MPD_Period *period = gf_list_get(mpd->periods, i);
		for (j=0; j<nb_streams; j++) {
			Bool invalidate_set;
			GF_DashStream *ds = gf_list_get(ctx->pids, j);
			if (ds->muxed_base) continue;
			const GF_PropertyValue *ps = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_DASH_PERIOD_START);
			const GF_PropertyValue *repid = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_REP_ID);
			if (!ps || !repid) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[Dasher] Couldn't fetch period start or rep ID in forward mode, cannot forward\n"));
				goto err_exit;
			}
			if (period->start != ps->value.longuint) continue;
			dasher_get_set_and_rep(period, repid->value.string, &set, &rep);
			if (!set || !rep) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[Dasher] Couldn't locate adaptation set and period in source manifest in forward mode, cannot forward\n"));
				goto err_exit;
			}
			//copy/reset common encryption
			if (set->content_protection) {
				gf_mpd_del_list(set->content_protection, gf_mpd_descriptor_free, 1);
			}
			if (rep->content_protection) {
				gf_mpd_del_list(rep->content_protection, gf_mpd_descriptor_free, 1);
			}
			if (gf_list_count(ds->rep->content_protection)) {
				gf_list_del(rep->content_protection);
				rep->content_protection = dasher_get_content_protection_desc(ctx, ds, NULL);
			}
			if (gf_list_count(ds->set->content_protection)) {
				gf_list_del(set->content_protection);
				set->content_protection = dasher_get_content_protection_desc(ctx, ds, ds->set);
			}
			invalidate_set = dasher_merge_rep(ds, rep);
			//wait until we are all done
			if (invalidate_set) {
				if (!recompute_sets) recompute_sets = gf_list_new();
				if (gf_list_find(recompute_sets, set)<0)
					gf_list_add(recompute_sets, set);
			}
		}
	}
	//update sets - TODO

	//insert xmlns if needed
	count = gf_list_count(mpd->x_attributes);
	for (i=0; i<count; i++) {
		GF_XMLAttribute * att = gf_list_get(mpd->x_attributes, i);
		if (!strcmp(att->name, "xmlns:cenc")) cenc_att = att;
		if (!strcmp(att->name, "xmlns:xlink")) xlink_att = att;
		if (!strcmp(att->name, "xmlns:ck")) ck_att = att;

	}
	if (ctx->use_cenc && !cenc_att) {
		cenc_att = gf_xml_dom_create_attribute("xmlns:cenc", "urn:mpeg:cenc:2013");
		gf_list_add(mpd->x_attributes, cenc_att);
	}
	if (ctx->use_xlink && !xlink_att) {
		xlink_att = gf_xml_dom_create_attribute("xmlns:xlink", "http://www.w3.org/1999/xlink");
		gf_list_add(mpd->x_attributes, xlink_att);
	}
	if (ctx->use_clearkey && !ck_att) {
		ck_att = gf_xml_dom_create_attribute("xmlns:ck", "http://dashif.org/guidelines/clearKey");
		gf_list_add(mpd->x_attributes, ck_att);
	}


	dasher_check_chaining(ctx, "urn:mpeg:dash:mpd-chaining:2016", ctx->chain);
	dasher_check_chaining(ctx, "urn:mpeg:dash:fallback:2016", ctx->chain_fbk);


	//and send
	tmp = gf_file_temp(NULL);
	mpd->xml_namespace = ctx->mpd->xml_namespace;
	mpd->publishTime = dasher_get_utc(ctx);
	e = gf_mpd_write(mpd, tmp, ctx->cmpd);
	if (e) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[Dasher] Error serializing manifest in forward mode: %s\n", gf_error_to_string(e) ));
		e = GF_OK;
		goto err_exit;
	}
	dasher_transfer_file(tmp, ctx->opid, NULL, NULL);

err_exit:
	if (tmp) gf_fclose(tmp);
	gf_mpd_del(mpd);
	gf_xml_dom_del(dom);
	gf_list_del(recompute_sets);
	if (e)
		ctx->in_error = GF_TRUE;
}
