static Variant php_ldap_do_search(const Variant& link, const Variant& base_dn,
                                  const Variant& filter,
                                  const Variant& attributes,
                                  int attrsonly, int sizelimit, int timelimit,
                                  int deref, int scope) {
  const Array& arr_attributes = attributes.isNull()
                              ? null_array
                              : attributes.toArray();
  int num_attribs = arr_attributes.size();
  int old_sizelimit = -1, old_timelimit = -1, old_deref = -1;
  auto ldap_attrs = std::unique_ptr<char*[]>{new char*[num_attribs+1]};
  Array stringHolder = Array::CreateVec();
  char *ldap_base_dn = nullptr;
  char *ldap_filter = nullptr;

  for (int i = 0; i < num_attribs; i++) {
    if (!arr_attributes.exists(i)) {
      raise_warning("Array initialization wrong");
      return false;
    }
    String attr = arr_attributes[i].toString();
    stringHolder.append(attr);
    ldap_attrs[i] = (char*)attr.data();
  }
  ldap_attrs[num_attribs] = nullptr;

  /* parallel search? */
  if (link.isArray()) {
    int nlinks = link.toArray().size();
    if (nlinks == 0) {
      raise_warning("No links in link array");
      return false;
    }

    int nbases;
    if (base_dn.isArray()) {
      nbases = base_dn.toArray().size();
      if (nbases != nlinks) {
        raise_warning("Base must either be a string, or an array with the "
                      "same number of elements as the links array");
        return false;
      }
    } else {
      nbases = 0; /* this means string, not array */
      /* If anything else than string is passed, ldap_base_dn = nullptr */
      if (base_dn.isString()) {
        ldap_base_dn = (char*)base_dn.toString().data();
      } else {
        ldap_base_dn = nullptr;
      }
    }

    int nfilters;
    if (filter.isArray()) {
      nfilters = filter.toArray().size();
      if (nfilters != nlinks) {
        raise_warning("Filter must either be a string, or an array with the "
                      "same number of elements as the links array");
        return false;
      }
    } else {
      nfilters = 0; /* this means string, not array */
      String sfilter = filter.toString();
      stringHolder.append(sfilter);
      ldap_filter = (char*)sfilter.data();
    }

    req::vector<req::ptr<LdapLink>> lds;
    lds.resize(nlinks);

    req::vector<int> rcs;
    rcs.resize(nlinks);

    Array ret = Array::CreateVArray();
    ArrayIter iter(link.toArray());
    ArrayIter iterdn(base_dn.toArray());
    ArrayIter iterfilter(filter.toArray());
    for (int i = 0; i < nlinks; i++) {
      auto ld = get_valid_ldap_link_resource(iter.second());
      if (!ld) {
        return false;
      }
      if (nbases != 0) { /* base_dn an array? */
        Variant entry = iterdn.second();
        ++iterdn;

        /* If anything else than string is passed, ldap_base_dn = nullptr */
        if (entry.isString()) {
          ldap_base_dn = (char*)entry.toString().data();
        } else {
          ldap_base_dn = nullptr;
        }
      }
      if (nfilters != 0) { /* filter an array? */
        Variant entry = iterfilter.second();
        ++iterfilter;
        String sentry = entry.toString();
        stringHolder.append(sentry);
        ldap_filter = (char*)sentry.data();
      }

      php_set_opts(ld->link,
                   sizelimit, timelimit, deref,
                   &old_sizelimit, &old_timelimit, &old_deref);

      /* Run the actual search */
      rcs[i] = ldap_search(ld->link, ldap_base_dn, scope, ldap_filter,
                           ldap_attrs.get(), attrsonly);

      php_set_opts(ld->link,
                   old_sizelimit, old_timelimit, old_deref,
                   nullptr, nullptr, nullptr);

      lds[i] = ld;
      ++iter;
    }

    /* Collect results from the searches */
    for (int i = 0; i < nlinks; i++) {
      LDAPMessage *ldap_res;
      if (rcs[i] != -1) {
        rcs[i] = ldap_result(lds[i]->link, rcs[i], LDAP_MSG_ALL,
                             nullptr, &ldap_res);
      }
      if (rcs[i] != -1) {
        ret.append(Variant(req::make<LdapResult>(ldap_res)));
      } else {
        ret.append(false);
      }
    }

    return ret;
  }

  /* not parallel search */
  String sfilter = filter.toString();
  ldap_filter = (char*)sfilter.data();

  /* If anything else than string is passed, ldap_base_dn = nullptr */
  if (base_dn.isString()) {
    ldap_base_dn = (char*)base_dn.toString().data();
  }

  auto ld = get_valid_ldap_link_resource(link);
  if (!ld) {
    return false;
  }

  php_set_opts(ld->link, sizelimit, timelimit, deref, &old_sizelimit,
               &old_timelimit, &old_deref);

  /* Run the actual search */
  LDAPMessage *ldap_res;
  int rc = ldap_search_s(ld->link, ldap_base_dn, scope, ldap_filter,
                         ldap_attrs.get(), attrsonly, &ldap_res);

  auto result = req::make<LdapResult>(ldap_res);
  php_set_opts(ld->link,
               old_sizelimit, old_timelimit, old_deref,
               nullptr, nullptr, nullptr);

  if (rc != LDAP_SUCCESS && rc != LDAP_SIZELIMIT_EXCEEDED
#ifdef LDAP_ADMINLIMIT_EXCEEDED
      && rc != LDAP_ADMINLIMIT_EXCEEDED
#endif
#ifdef LDAP_REFERRAL
      && rc != LDAP_REFERRAL
#endif
     ) {
    raise_warning("Search: %s", ldap_err2string(rc));
    return false;
  }

  if (rc == LDAP_SIZELIMIT_EXCEEDED) {
    raise_warning("Partial search results returned: Sizelimit exceeded");
  }
#ifdef LDAP_ADMINLIMIT_EXCEEDED
  else if (rc == LDAP_ADMINLIMIT_EXCEEDED) {
    raise_warning("Partial search results returned: Adminlimit exceeded");
  }
#endif
  return Variant{std::move(result)};
}
