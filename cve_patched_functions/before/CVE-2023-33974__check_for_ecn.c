static void _check_for_ecn(gnrc_pktsnip_t *frame)
{
    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_ECN) &&
        (sixlowpan_sfr_rfrag_is(frame->next->data))) {
        int queue_state = 0;
        int queue_size = 0;

        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_ECN_IF_IN)) {
            gnrc_netif_t *netif = gnrc_netif_hdr_get_netif(frame->data);

            assert(frame->type == GNRC_NETTYPE_NETIF);
            assert(frame->next->type == GNRC_NETTYPE_SIXLOWPAN);
            queue_state = msg_avail_thread(netif->pid);
            queue_size = msg_queue_capacity(netif->pid);
            assert(queue_size > 0);

            if ((queue_state * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_IF_IN_DEN) >
                (queue_size * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_IF_IN_NUM)) {
                sixlowpan_sfr_set_ecn(frame->next->data);
            }
        }

        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_ECN_IF_OUT)) {
            queue_state = gnrc_netif_pktq_usage();
            queue_size = CONFIG_GNRC_NETIF_PKTQ_POOL_SIZE;

            if ((queue_state * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_IF_OUT_DEN) >
                (queue_size * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_IF_OUT_NUM)) {
                sixlowpan_sfr_set_ecn(frame->next->data);
            }
        }

        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_ECN_FQUEUE)) {
            queue_state = clist_count(&_frame_queue);
            queue_size = FRAME_QUEUE_POOL_SIZE;

            if ((queue_state * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_FQUEUE_DEN) >
                (queue_size * CONFIG_GNRC_SIXLOWPAN_SFR_ECN_FQUEUE_NUM)) {
                sixlowpan_sfr_set_ecn(frame->next->data);
            }
        }
    }
}
