lyd_is_when_false(struct lyd_node *root, struct lyd_node *last_parent, struct lys_node *schema, int options)
{
    enum int_log_opts prev_ilo;
    struct lyd_node *current, *dummy;

    if ((!(options & LYD_OPT_TYPEMASK) || (options & (LYD_OPT_CONFIG | LYD_OPT_RPC | LYD_OPT_RPCREPLY | LYD_OPT_NOTIF | LYD_OPT_DATA_TEMPLATE)))
            && resolve_applies_when(schema, 1, last_parent ? last_parent->schema : NULL)) {
        /* evaluate when statements on a dummy data node */
        if (schema->nodetype == LYS_CHOICE) {
            schema = (struct lys_node *)lys_getnext(NULL, schema, NULL, LYS_GETNEXT_NOSTATECHECK);
        }
        dummy = lyd_new_dummy(root, last_parent, schema, NULL, 0);
        if (!dummy) {
            return -1;
        }
        if (!dummy->parent && root) {
            /* connect dummy nodes into the data tree, insert it before the root
             * to optimize later unlinking (lyd_free()) */
            lyd_insert_before(root, dummy);
        }
        for (current = dummy; current; current = current->child) {
            ly_ilo_change(NULL, ILO_IGNORE, &prev_ilo, NULL);
            resolve_when(current, 0, NULL);
            ly_ilo_restore(NULL, prev_ilo, NULL, 0);

            if (current->when_status & LYD_WHEN_FALSE) {
                /* when evaluates to false */
                lyd_free(dummy);
                return 1;
            }

            if (current->schema->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA)) {
                /* termination node without a child */
                break;
            }
        }
        lyd_free(dummy);
    }

    return 0;
}
