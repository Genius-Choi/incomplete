ErrorType LibzipPlugin::extractEntry(zip_t *archive, zip_int64_t index, const ExtractionOptions &options, qlonglong &qExtractSize, QString &strFileName, bool &bHandleLongName)
{
    zip_stat_t statBuffer;
    if (zip_stat_index(archive, zip_uint64_t(index), ZIP_FL_ENC_RAW, &statBuffer) != 0) {
        return ET_FileReadError;
    }

    strFileName = m_common->trans2uft8(statBuffer.name, m_mapFileCode[index]);    // 解压文件名（压缩包中）
    if(strFileName.contains(QLatin1Char('\\')))
        strFileName = strFileName.replace(QLatin1Char('\\'), QDir::separator());
    QString strOriginName = strFileName;

    // 针对文件夹名称过长的情况，直接提示解压失败，文件夹名称过长
//    QStringList listPath = strFileName.split(QDir::separator());
//    listPath.removeLast();
//    for (int i = 0; i < listPath.count(); ++i) {
//        if (NAME_MAX < QString(listPath[i]).toLocal8Bit().length()) {
//            emit signalCurFileName(strFileName); // 发送当前正在解压的文件名
//            return ET_LongNameError;
//        }
//    }

    QString strFilePath;
    QString strTempFileName = strFileName;
    int iIndex = strFileName.lastIndexOf(QDir::separator());

    if (iIndex >= 0) {
        strFilePath = strFileName.left(iIndex);   // bug114527 left函数参数为截取的字符串长度
        strTempFileName = strFileName.right(strFileName.length() - iIndex - 1);
    }

    QString tempFilePathName;
    if(!m_bDlnfs) {
        QString sDir = m_common->handleLongNameforPath(strFilePath, strFileName, m_mapLongDirName, m_mapRealDirValue);
        if(sDir.length() > 0) {
           strFilePath = sDir.endsWith(QDir::separator())?sDir.left(sDir.length() -1):sDir;
           if(strFileName.endsWith(QDir::separator())) {
               strFileName = sDir;
           } else if (NAME_MAX >= QString(strTempFileName).toLocal8Bit().length()) {
               strFileName = sDir + strTempFileName;
           }
           if(!m_mapLongDirName.isEmpty()) {
               bHandleLongName = true;
           }
        }
        if (NAME_MAX < QString(strTempFileName).toLocal8Bit().length() && !strTempFileName.endsWith(QDir::separator())) {
            QString strTemp = strTempFileName.left(TRUNCATION_FILE_LONG);

            // 保存文件路径，不同目录下的同名文件分开计数,文件解压结束后才添加计数，
            tempFilePathName = strFilePath + QDir::separator() + strTemp;   // 路径加截取后的文件名
            if (m_mapLongName[tempFilePathName] >= LONGFILE_SAME_FILES ) {
                return ET_LongNameError;
            }
            bHandleLongName = true;
            QString sSuffix = QFileInfo(strTempFileName).completeSuffix();
            if(10 < sSuffix.length()){
                sSuffix = QFileInfo(strTempFileName).suffix();
                if(10 < sSuffix.length()) {
                    sSuffix = sSuffix.right(10);
                }
            }
            strTempFileName = strTemp + QString("(%1)").arg(m_mapLongName[tempFilePathName] + 1, LONGFILE_SUFFIX_FieldWidth, BINARY_NUM, QChar('0')) + "." + sSuffix;

            strFileName = strTempFileName;
            if (iIndex >= 0) {
                strFileName = strFilePath + QDir::separator() + strTempFileName;
            }

        }
    }

    // 提取
    if (!options.strDestination.isEmpty()) {
        if(bHandleLongName) {
            int nCnt = options.strDestination.count(QDir::separator());
            int nIndex = 0;
            for(int i = 0; i < nCnt; i++){
                nIndex = strFileName.indexOf(QDir::separator(), nIndex);
                nIndex++;
            }
            strFileName = strFileName.remove(0, nIndex);
        } else {
            strFileName = strFileName.remove(0, options.strDestination.size());
        }
    }


    if (bHandleLongName) {
        emit signalCurFileName(strOriginName); // 发送当前正在解压的文件名
    } else {
        emit signalCurFileName(strFileName); // 发送当前正在解压的文件名
    }

    bool bIsDirectory = strFileName.endsWith(QDir::separator());    // 是否为文件夹

    // 判断解压路径是否存在，不存在则创建文件夹
    if (QDir().exists(options.strTargetPath) == false)
        QDir().mkpath(options.strTargetPath);

    // 解压完整文件名（含路径）
    QString strDestFileName = options.strTargetPath + QDir::separator() + strFileName;

    QFile file(strDestFileName);

    // Store parent mtime.
    QString parentDir;
    if (strFileName.endsWith(QDir::separator())) {
        QDir pDir = QFileInfo(strDestFileName).dir();
        pDir.cdUp();
        parentDir = pDir.path();
    } else {
        parentDir = QFileInfo(strDestFileName).path();
    }
    // For top-level items, don't restore parent dir mtime.
    const bool restoreParentMtime = (parentDir != options.strTargetPath);

    time_t parent_mtime;
    if (restoreParentMtime) {
        parent_mtime = QFileInfo(parentDir).lastModified().toMSecsSinceEpoch() / 1000;
    }

    // 获取外部信息（权限）
    zip_uint8_t opsys;
    zip_uint32_t attributes;
    if (zip_file_get_external_attributes(archive, zip_uint64_t(index), ZIP_FL_UNCHANGED, &opsys, &attributes) == -1) {
        emit error(("Failed to read metadata for entry: %1"));
    }

    // 从压缩包中获取文件权限
    mode_t value = mode_t();
    switch (opsys) {
    case ZIP_OPSYS_UNIX:
        value = attributes >> 16;
        break;
    default:    // TODO: non-UNIX.
        break;
    }
    bool isLink = false;
    if(S_ISLNK(value)) {
        isLink = true;
    }
    QFileDevice::Permissions per = getPermissions(value);

    if (bIsDirectory && !isLink) {     // 文件夹
        if (PATH_MAX < QString(strFileName).toLocal8Bit().length())
            return ET_LongNameError;

        QDir dir;
        dir.mkpath(strDestFileName);

        // 文件夹加可执行权限
        per = per | QFileDevice::ReadUser | QFileDevice::WriteUser | QFileDevice::ExeUser ;
    } else if(isLink) { //软连接解压
        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);
        char buf[READBYTES] = {0};
        const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));
        if (readBytes > 0) {
            QString strBuf = QString(buf).toLocal8Bit();
            if (QFile::link(strBuf, strDestFileName)) {
                qInfo() << "Symlink's created:" << buf << strFileName;
            } else {
                qInfo() << "Can't create symlink" << buf << strFileName;
            }
        }
        file.close();
        zip_fclose(zipFile);
    } else {        // 普通文件

        // 判断是否有同名文件
        if (file.exists()) {
            if (m_bSkipAll) {       // 全部跳过
                m_mapLongName[tempFilePathName]++;   // 保存文件路径，不同目录下的同名文件分开计数，解压成功，添加计数
                return ET_NoError;
            } else {
                if (!m_bOverwriteAll) {     // 若不是全部覆盖，单条处理

                    OverwriteQuery query(strDestFileName);

                    emit signalQuery(&query);
                    query.waitForResponse();

                    if (query.responseCancelled()) {
                        emit signalCancel();
                        return ET_UserCancelOpertion;
                    } else if (query.responseSkip()) {
                        m_mapLongName[tempFilePathName]++;   // 保存文件路径，不同目录下的同名文件分开计数，解压成功，添加计数
                        return ET_NoError;
                    } else if (query.responseSkipAll()) {
                        m_bSkipAll = true;
                        m_mapLongName[tempFilePathName]++;   // 保存文件路径，不同目录下的同名文件分开计数，解压成功，添加计数
                        return ET_NoError;
                    }  else if (query.responseOverwriteAll()) {
                        m_bOverwriteAll = true;
                    }
                }
            }
        }

        if (bHandleLongName) {
            m_setLongName << strFileName;
        }

        // 若文件存在且不是可写权限，重新创建一个文件
        if (file.exists() && !file.isWritable()) {
            file.remove();
            file.setFileName(strDestFileName);
            file.setPermissions(QFileDevice::WriteUser);
        }

        // 对文件路径做判断，防止特殊包未先解压出文件夹，导致解压失败
        if (QDir().exists(QFileInfo(strDestFileName).path()) == false)
            QDir().mkpath(QFileInfo(strDestFileName).path());

        zip_file_t *zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);
        // 错误处理
        if (nullptr == zipFile) {
            int iErr = zip_error_code_zip(zip_get_error(archive));
            if (ZIP_ER_WRONGPASSWD == iErr) {//密码错误

                // 对密码编码的探测
                bool bCheckFinished = false;
                int iCodecIndex = 0;
                while (nullptr == zipFile && false == bCheckFinished) {
                    if (m_listCodecs.length() == iCodecIndex) {
                        bCheckFinished = true;
                        if (file.exists()) {
                            file.remove();
                        }

                        return ET_WrongPassword;
                    } else {
                        // 115645 【专业版】【1060】【归档管理器】【5.12.0.2】无法解压中文密码的zip压缩包（含有长名称）
                        zip_set_default_password(archive, passwordUnicode(m_strPassword, iCodecIndex).data());
                        iCodecIndex++;
                        zip_error_clear(archive);
                        zipFile = zip_fopen_index(archive, zip_uint64_t(index), 0);
                        iErr = zip_error_code_zip(zip_get_error(archive));
                        if (iErr != ZIP_ER_WRONGPASSWD && zipFile != nullptr) {//密码正确
                            bCheckFinished = true;
                        }
                    }
                }
            } else if (ZIP_ER_NOPASSWD == iErr) {   // 无密码输入
                return ET_NeedPassword;
            } else {
                return ET_FileOpenError;
            }
        }

        // 以只写的方式打开待解压的文件
        if (file.open(QIODevice::WriteOnly) == false) {
            zip_fclose(zipFile);

            QList<QString> entryNameList = strDestFileName.split('/');
            foreach (auto &tmp, entryNameList) {
                // 判断文件名是否过长
                if (NAME_MAX < tmp.toLocal8Bit().length()) {
                    return ET_LongNameError;
                }
            }

            emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());
            return ET_FileWriteError;
        }

        // 写文件
        QDataStream out(&file);
        zip_int64_t sum = 0;
        char buf[READBYTES];
        int writeSize = 0;
        double dScale = 1;
        // 右键解压时按照文件比例计算大小
        if (!options.bExistList) {
            dScale = double(statBuffer.comp_size) / statBuffer.size;
        }
        while (sum != zip_int64_t(statBuffer.size)) {
            if (QThread::currentThread()->isInterruptionRequested()) {
                break;
            }

            if (m_bPause) { //解压暂停
                sleep(1);
                continue;
            }

            const auto readBytes = zip_fread(zipFile, buf, zip_uint64_t(READBYTES));

            if (readBytes < 0) {
                file.close();
                zip_fclose(zipFile);
                emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());
                return ET_FileWriteError;
            }

            if (out.writeRawData(buf, int(readBytes)) != readBytes) {
                file.close();
                zip_fclose(zipFile);

                if (isInsufficientDiskSpace(options.strTargetPath, static_cast<qint64>(readBytes))) {  // 小于readBytes作为磁盘空间不足的判断标准
                    return ET_InsufficientDiskSpace;
                } else {
                    emit signalFileWriteErrorName(QFileInfo(file.fileName()).fileName());
                    return ET_FileWriteError;
                }
            }

            sum += readBytes;
            writeSize += readBytes;

            // 计算进度并显示（右键快捷解压使用压缩包大小，计算比例）
            qExtractSize += readBytes * dScale;
            emit signalprogress((double(qExtractSize)) * m_dScaleSize);
        }

        file.close();
        zip_fclose(zipFile);
    }
    if(!isLink) {
        // 设置文件/文件夹权限
        file.setPermissions(per);

        // Set mtime for entry.
        utimbuf times;
        times.modtime = statBuffer.mtime;
        utime(strDestFileName.toUtf8().constData(), &times);

        if (restoreParentMtime) {
            // Restore mtime for parent dir.
            times.modtime = parent_mtime;
            utime(parentDir.toUtf8().constData(), &times);
        }
    }
    m_mapLongName[tempFilePathName]++;   // 保存文件路径，不同目录下的同名文件分开计数，解压成功，添加计数
    return ET_NoError;
}
