static int amqpvalue_get_encoded_map_size(AMQP_MAP_KEY_VALUE_PAIR* pairs, uint32_t count, uint32_t* encoded_size)
{
    size_t i;
    int result;

    if (encoded_size == NULL)
    {
        LogError("Bad arguments: encoded_size = %p", encoded_size);
        result = MU_FAILURE;
    }
    else
    {
        *encoded_size = 0;

        /* Get the size of all items in the map */
        for (i = 0; i < count; i++)
        {
            size_t item_size;
            if (amqpvalue_get_encoded_size(pairs[i].key, &item_size) != 0)
            {
                LogError("Could not get encoded size for key element %u of the map", (unsigned int)i);
                break;
            }

            if ((item_size > UINT32_MAX) ||
                *encoded_size + (uint32_t)item_size < *encoded_size)
            {
                LogError("Encoded data is more than the max size for a map");
                break;
            }

            *encoded_size = (uint32_t)(*encoded_size + item_size);

            if (amqpvalue_get_encoded_size(pairs[i].value, &item_size) != 0)
            {
                LogError("Could not get encoded size for value element %u of the map", (unsigned int)i);
                break;
            }

            if ((item_size > UINT32_MAX) ||
                *encoded_size + (uint32_t)item_size < *encoded_size)
            {
                LogError("Encoded data is more than the max size for a map");
                break;
            }

            *encoded_size = (uint32_t)(*encoded_size + item_size);
        }

        if (i < count)
        {
            result = MU_FAILURE;
        }
        else
        {
            result = 0;
        }
    }
    return result;
}
