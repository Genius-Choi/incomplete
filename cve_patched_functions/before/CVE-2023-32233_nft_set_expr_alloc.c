static int nft_set_expr_alloc(struct nft_ctx *ctx, struct nft_set *set,
			      const struct nlattr * const *nla,
			      struct nft_expr **exprs, int *num_exprs,
			      u32 flags)
{
	struct nft_expr *expr;
	int err, i;

	if (nla[NFTA_SET_EXPR]) {
		expr = nft_set_elem_expr_alloc(ctx, set, nla[NFTA_SET_EXPR]);
		if (IS_ERR(expr)) {
			err = PTR_ERR(expr);
			goto err_set_expr_alloc;
		}
		exprs[0] = expr;
		(*num_exprs)++;
	} else if (nla[NFTA_SET_EXPRESSIONS]) {
		struct nlattr *tmp;
		int left;

		if (!(flags & NFT_SET_EXPR)) {
			err = -EINVAL;
			goto err_set_expr_alloc;
		}
		i = 0;
		nla_for_each_nested(tmp, nla[NFTA_SET_EXPRESSIONS], left) {
			if (i == NFT_SET_EXPR_MAX) {
				err = -E2BIG;
				goto err_set_expr_alloc;
			}
			if (nla_type(tmp) != NFTA_LIST_ELEM) {
				err = -EINVAL;
				goto err_set_expr_alloc;
			}
			expr = nft_set_elem_expr_alloc(ctx, set, tmp);
			if (IS_ERR(expr)) {
				err = PTR_ERR(expr);
				goto err_set_expr_alloc;
			}
			exprs[i++] = expr;
			(*num_exprs)++;
		}
	}

	return 0;

err_set_expr_alloc:
	for (i = 0; i < *num_exprs; i++)
		nft_expr_destroy(ctx, exprs[i]);

	return err;
}
