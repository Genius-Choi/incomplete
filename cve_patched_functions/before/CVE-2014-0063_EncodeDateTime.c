EncodeDateTime(struct tm * tm, fsec_t fsec, bool print_tz, int tz, const char *tzn, int style, char *str, bool EuroDates)
{
	int			day,
				hour,
				min;

	/*
	 * Negative tm_isdst means we have no valid time zone translation.
	 */
	if (tm->tm_isdst < 0)
		print_tz = false;

	switch (style)
	{
		case USE_ISO_DATES:
			/* Compatible with ISO-8601 date formats */

			sprintf(str, "%04d-%02d-%02d %02d:%02d",
					(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1),
					tm->tm_mon, tm->tm_mday, tm->tm_hour, tm->tm_min);

			/*
			 * Print fractional seconds if any.  The field widths here should
			 * be at least equal to MAX_TIMESTAMP_PRECISION.
			 *
			 * In float mode, don't print fractional seconds before 1 AD,
			 * since it's unlikely there's any precision left ...
			 */
#ifdef HAVE_INT64_TIMESTAMP
			if (fsec != 0)
			{
				sprintf(str + strlen(str), ":%02d.%06d", tm->tm_sec, fsec);
#else
			if ((fsec != 0) && (tm->tm_year > 0))
			{
				sprintf(str + strlen(str), ":%09.6f", tm->tm_sec + fsec);
#endif
				TrimTrailingZeros(str);
			}
			else
				sprintf(str + strlen(str), ":%02d", tm->tm_sec);

			if (tm->tm_year <= 0)
				sprintf(str + strlen(str), " BC");

			if (print_tz)
			{
				hour = -(tz / SECS_PER_HOUR);
				min = (abs(tz) / MINS_PER_HOUR) % MINS_PER_HOUR;
				if (min != 0)
					sprintf(str + strlen(str), "%+03d:%02d", hour, min);
				else
					sprintf(str + strlen(str), "%+03d", hour);
			}
			break;

		case USE_SQL_DATES:
			/* Compatible with Oracle/Ingres date formats */

			if (EuroDates)
				sprintf(str, "%02d/%02d", tm->tm_mday, tm->tm_mon);
			else
				sprintf(str, "%02d/%02d", tm->tm_mon, tm->tm_mday);

			sprintf(str + 5, "/%04d %02d:%02d",
					(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1),
					tm->tm_hour, tm->tm_min);

			/*
			 * Print fractional seconds if any.  The field widths here should
			 * be at least equal to MAX_TIMESTAMP_PRECISION.
			 *
			 * In float mode, don't print fractional seconds before 1 AD,
			 * since it's unlikely there's any precision left ...
			 */
#ifdef HAVE_INT64_TIMESTAMP
			if (fsec != 0)
			{
				sprintf(str + strlen(str), ":%02d.%06d", tm->tm_sec, fsec);
#else
			if (fsec != 0 && tm->tm_year > 0)
			{
				sprintf(str + strlen(str), ":%09.6f", tm->tm_sec + fsec);
#endif
				TrimTrailingZeros(str);
			}
			else
				sprintf(str + strlen(str), ":%02d", tm->tm_sec);

			if (tm->tm_year <= 0)
				sprintf(str + strlen(str), " BC");

			/*
			 * Note: the uses of %.*s in this function would be risky if the
			 * timezone names ever contain non-ASCII characters.  However, all
			 * TZ abbreviations in the Olson database are plain ASCII.
			 */

			if (print_tz)
			{
				if (tzn)
					sprintf(str + strlen(str), " %.*s", MAXTZLEN, tzn);
				else
				{
					hour = -(tz / SECS_PER_HOUR);
					min = (abs(tz) / MINS_PER_HOUR) % MINS_PER_HOUR;
					if (min != 0)
						sprintf(str + strlen(str), "%+03d:%02d", hour, min);
					else
						sprintf(str + strlen(str), "%+03d", hour);
				}
			}
			break;

		case USE_GERMAN_DATES:
			/* German variant on European style */

			sprintf(str, "%02d.%02d", tm->tm_mday, tm->tm_mon);

			sprintf(str + 5, ".%04d %02d:%02d",
					(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1),
					tm->tm_hour, tm->tm_min);

			/*
			 * Print fractional seconds if any.  The field widths here should
			 * be at least equal to MAX_TIMESTAMP_PRECISION.
			 *
			 * In float mode, don't print fractional seconds before 1 AD,
			 * since it's unlikely there's any precision left ...
			 */
#ifdef HAVE_INT64_TIMESTAMP
			if (fsec != 0)
			{
				sprintf(str + strlen(str), ":%02d.%06d", tm->tm_sec, fsec);
#else
			if (fsec != 0 && tm->tm_year > 0)
			{
				sprintf(str + strlen(str), ":%09.6f", tm->tm_sec + fsec);
#endif
				TrimTrailingZeros(str);
			}
			else
				sprintf(str + strlen(str), ":%02d", tm->tm_sec);

			if (tm->tm_year <= 0)
				sprintf(str + strlen(str), " BC");

			if (print_tz)
			{
				if (tzn)
					sprintf(str + strlen(str), " %.*s", MAXTZLEN, tzn);
				else
				{
					hour = -(tz / SECS_PER_HOUR);
					min = (abs(tz) / MINS_PER_HOUR) % MINS_PER_HOUR;
					if (min != 0)
						sprintf(str + strlen(str), "%+03d:%02d", hour, min);
					else
						sprintf(str + strlen(str), "%+03d", hour);
				}
			}
			break;

		case USE_POSTGRES_DATES:
		default:
			/* Backward-compatible with traditional Postgres abstime dates */

			day = date2j(tm->tm_year, tm->tm_mon, tm->tm_mday);
			tm->tm_wday = (int) ((day + date2j(2000, 1, 1) + 1) % 7);

			strncpy(str, days[tm->tm_wday], 3);
			strcpy(str + 3, " ");

			if (EuroDates)
				sprintf(str + 4, "%02d %3s", tm->tm_mday, months[tm->tm_mon - 1]);
			else
				sprintf(str + 4, "%3s %02d", months[tm->tm_mon - 1], tm->tm_mday);

			sprintf(str + 10, " %02d:%02d", tm->tm_hour, tm->tm_min);

			/*
			 * Print fractional seconds if any.  The field widths here should
			 * be at least equal to MAX_TIMESTAMP_PRECISION.
			 *
			 * In float mode, don't print fractional seconds before 1 AD,
			 * since it's unlikely there's any precision left ...
			 */
#ifdef HAVE_INT64_TIMESTAMP
			if (fsec != 0)
			{
				sprintf(str + strlen(str), ":%02d.%06d", tm->tm_sec, fsec);
#else
			if (fsec != 0 && tm->tm_year > 0)
			{
				sprintf(str + strlen(str), ":%09.6f", tm->tm_sec + fsec);
#endif
				TrimTrailingZeros(str);
			}
			else
				sprintf(str + strlen(str), ":%02d", tm->tm_sec);

			sprintf(str + strlen(str), " %04d",
					(tm->tm_year > 0) ? tm->tm_year : -(tm->tm_year - 1));
			if (tm->tm_year <= 0)
				sprintf(str + strlen(str), " BC");

			if (print_tz)
			{
				if (tzn)
					sprintf(str + strlen(str), " %.*s", MAXTZLEN, tzn);
				else
				{
					/*
					 * We have a time zone, but no string version. Use the
					 * numeric form, but be sure to include a leading space to
					 * avoid formatting something which would be rejected by
					 * the date/time parser later. - thomas 2001-10-19
					 */
					hour = -(tz / SECS_PER_HOUR);
					min = (abs(tz) / MINS_PER_HOUR) % MINS_PER_HOUR;
					if (min != 0)
						sprintf(str + strlen(str), " %+03d:%02d", hour, min);
					else
						sprintf(str + strlen(str), " %+03d", hour);
				}
			}
			break;
	}

	return TRUE;
}	/* EncodeDateTime() */
