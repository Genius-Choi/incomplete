static int epoll_process(ogs_pollset_t *pollset, ogs_time_t timeout)
{
    struct epoll_context_s *context = NULL;
    int num_of_poll;
    int i;

    ogs_assert(pollset);
    context = pollset->context;
    ogs_assert(context);

    num_of_poll = epoll_wait(context->epfd, context->event_list,
            pollset->capacity,
            timeout == OGS_INFINITE_TIME ? OGS_INFINITE_TIME :
                ogs_time_to_msec(timeout));
    if (num_of_poll < 0) {
        ogs_log_message(OGS_LOG_ERROR, ogs_socket_errno, "epoll failed");
        return OGS_ERROR;
    } else if (num_of_poll == 0) {
        return OGS_TIMEUP;
    }

    for (i = 0; i < num_of_poll; i++) {
        struct epoll_map_s *map = NULL;
        uint32_t received;
        short when = 0;
        ogs_socket_t fd;

        received = context->event_list[i].events;
        if (received & EPOLLERR) {
        /*
         * The libevent library has OGS_POLLOUT turned on in EPOLLERR.
         *
         * However, SIGPIPE can occur if write() is called
         * when the peer connection is closed.
         *
         * Therefore, Open5GS turns off OGS_POLLOUT
         * so that write() cannot be called in case of EPOLLERR.
         *
         * See also #2411 and #2312
         */
#if 0
            when = OGS_POLLIN|OGS_POLLOUT;
#else
            when = OGS_POLLIN;
#endif
        } else if ((received & EPOLLHUP) && !(received & EPOLLRDHUP)) {
            when = OGS_POLLIN|OGS_POLLOUT;
        } else {
            if (received & EPOLLIN) {
                when |= OGS_POLLIN;
            }
            if (received & EPOLLOUT) {
                when |= OGS_POLLOUT;
            }
            if (received & EPOLLRDHUP) {
                when |= OGS_POLLIN;
            }
        }

        if (!when)
            continue;

        fd = context->event_list[i].data.fd;
        ogs_assert(fd != INVALID_SOCKET);

        map = ogs_hash_get(context->map_hash, &fd, sizeof(fd));
        if (!map) continue;

        if (map->read && map->write && map->read == map->write) {
            map->read->handler(when, map->read->fd, map->read->data);
        } else {
            if ((when & OGS_POLLIN) && map->read)
                map->read->handler(when, map->read->fd, map->read->data);

            /*
             * map->read->handler() can call ogs_remove_epoll()
             * So, we need to check map instance
             */
            map = ogs_hash_get(context->map_hash, &fd, sizeof(fd));
            if (!map) continue;

            if ((when & OGS_POLLOUT) && map->write)
                map->write->handler(when, map->write->fd, map->write->data);
        }
    }
    
    return OGS_OK;
}
