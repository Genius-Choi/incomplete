process_tgs_req(krb5_kdc_req *request, krb5_data *pkt,
                const krb5_fulladdr *from, kdc_realm_t *realm,
                krb5_data **response)
{
    krb5_context context = realm->realm_context;
    krb5_error_code ret;
    struct tgs_req_info t = { 0 };
    struct kdc_request_state *fast_state = NULL;
    krb5_audit_state *au_state = NULL;
    krb5_pa_data **e_data = NULL;
    krb5_flags tktflags;
    krb5_ticket_times times = { 0 };
    const char *emsg = NULL, *status = NULL;

    ret = kdc_make_rstate(realm, &fast_state);
    if (ret)
        goto cleanup;
    ret = kau_init_kdc_req(context, request, from, &au_state);
    if (ret)
        goto cleanup;
    kau_tgs_req(context, TRUE, au_state);

    ret = gather_tgs_req_info(realm, &request, pkt, from, fast_state, au_state,
                              &t, &status);
    if (ret)
        goto cleanup;

    ret = check_tgs_req(realm, &t, au_state, &tktflags, &times, &status,
                        &e_data);
    if (ret)
        goto cleanup;

    ret = tgs_issue_ticket(realm, &t, tktflags, &times, pkt, from, fast_state,
                           au_state, &status, response);
    if (ret)
        goto cleanup;

cleanup:
    if (status == NULL)
        status = "UNKNOWN_REASON";

    if (ret) {
        emsg = krb5_get_error_message(context, ret);
        log_tgs_req(context, from, t.req, NULL, t.cprinc, t.sprinc,
                    t.s4u_cprinc, t.authtime, t.flags, status, ret, emsg);
        krb5_free_error_message(context, emsg);

        if (au_state != NULL) {
            au_state->status = status;
            kau_tgs_req(context, FALSE, au_state);
        }
    }

    if (ret && fast_state != NULL) {
        ret = prepare_error_tgs(fast_state, t.req, t.header_tkt, ret,
                                (t.server != NULL) ? t.server->princ : NULL,
                                response, status, e_data);
    }

    krb5_free_kdc_req(context, request);
    kdc_free_rstate(fast_state);
    kau_free_kdc_req(au_state);
    free_req_info(context, &t);
    krb5_free_pa_data(context, e_data);
    return ret;
}
