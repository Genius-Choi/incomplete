sync_lbs(struct northd_input *input_data, struct ovsdb_idl_txn *ovnsb_txn,
         struct hmap *datapaths, struct hmap *lbs)
{
    struct hmap dp_groups = HMAP_INITIALIZER(&dp_groups);
    struct ovn_northd_lb *lb;

    /* Delete any stale SB load balancer rows and collect existing valid
     * datapath groups. */
    struct hmapx existing_sb_dp_groups =
        HMAPX_INITIALIZER(&existing_sb_dp_groups);
    struct hmapx existing_lbs = HMAPX_INITIALIZER(&existing_lbs);
    const struct sbrec_load_balancer *sbrec_lb;
    SBREC_LOAD_BALANCER_TABLE_FOR_EACH_SAFE (sbrec_lb,
                            input_data->sbrec_load_balancer_table) {
        const char *nb_lb_uuid = smap_get(&sbrec_lb->external_ids, "lb_id");
        struct uuid lb_uuid;
        if (!nb_lb_uuid || !uuid_from_string(&lb_uuid, nb_lb_uuid)) {
            sbrec_load_balancer_delete(sbrec_lb);
            continue;
        }

        /* Delete any SB load balancer entries that refer to NB load balancers
         * that don't exist anymore or are not applied to switches anymore.
         *
         * There is also a special case in which duplicate LBs might be created
         * in the SB, e.g., due to the fact that OVSDB only ensures
         * "at-least-once" consistency for clustered database tables that
         * are not indexed in any way.
         */
        lb = ovn_northd_lb_find(lbs, &lb_uuid);
        if (!lb || !lb->n_nb_ls || !hmapx_add(&existing_lbs, lb)) {
            sbrec_load_balancer_delete(sbrec_lb);
            continue;
        }

        lb->slb = sbrec_lb;

        /* Collect the datapath group. */
        struct sbrec_logical_dp_group *dp_group = sbrec_lb->datapath_group;

        if (!dp_group || !hmapx_add(&existing_sb_dp_groups, dp_group)) {
            continue;
        }

        struct ovn_dp_group *dpg = xzalloc(sizeof *dpg);
        size_t i, n = 0;

        dpg->bitmap = bitmap_allocate(n_datapaths);
        for (i = 0; i < dp_group->n_datapaths; i++) {
            struct ovn_datapath *datapath_od;

            datapath_od = ovn_datapath_from_sbrec(datapaths,
                                                  dp_group->datapaths[i]);
            if (!datapath_od || ovn_datapath_is_stale(datapath_od)) {
                break;
            }
            bitmap_set1(dpg->bitmap, datapath_od->index);
            n++;
        }
        if (i == dp_group->n_datapaths) {
            uint32_t hash = hash_int(n, 0);

            if (!ovn_dp_group_find(&dp_groups, dpg->bitmap, hash)) {
                dpg->dp_group = dp_group;
                hmap_insert(&dp_groups, &dpg->node, hash);
                continue;
            }
        }
        bitmap_free(dpg->bitmap);
        free(dpg);
    }
    hmapx_destroy(&existing_lbs);
    hmapx_destroy(&existing_sb_dp_groups);

    /* Create SB Load balancer records if not present and sync
     * the SB load balancer columns. */
    HMAP_FOR_EACH (lb, hmap_node, lbs) {

        if (!lb->n_nb_ls) {
            continue;
        }

        /* Store the fact that northd provides the original (destination IP +
         * transport port) tuple.
         */
        struct smap options;
        smap_clone(&options, &lb->nlb->options);
        smap_replace(&options, "hairpin_orig_tuple", "true");

        if (!lb->slb) {
            sbrec_lb = sbrec_load_balancer_insert(ovnsb_txn);
            lb->slb = sbrec_lb;
            char *lb_id = xasprintf(
                UUID_FMT, UUID_ARGS(&lb->nlb->header_.uuid));
            const struct smap external_ids =
                SMAP_CONST1(&external_ids, "lb_id", lb_id);
            sbrec_load_balancer_set_external_ids(sbrec_lb, &external_ids);
            free(lb_id);
        }

        /* Find datapath group for this load balancer. */
        struct ovn_dp_group *dpg;
        uint32_t hash;

        hash = hash_int(lb->n_nb_ls, 0);
        dpg = ovn_dp_group_find(&dp_groups, lb->nb_ls_map, hash);
        if (!dpg) {
            dpg = xzalloc(sizeof *dpg);
            dpg->dp_group = ovn_sb_insert_logical_dp_group(ovnsb_txn,
                                                           lb->nb_ls_map);
            dpg->bitmap = bitmap_clone(lb->nb_ls_map, n_datapaths);
            hmap_insert(&dp_groups, &dpg->node, hash);
        }

        /* Update columns. */
        sbrec_load_balancer_set_name(lb->slb, lb->nlb->name);
        sbrec_load_balancer_set_vips(lb->slb, ovn_northd_lb_get_vips(lb));
        sbrec_load_balancer_set_protocol(lb->slb, lb->nlb->protocol);
        sbrec_load_balancer_set_datapath_group(lb->slb, dpg->dp_group);
        sbrec_load_balancer_set_options(lb->slb, &options);
        /* Clearing 'datapaths' column, since 'dp_group' is in use. */
        sbrec_load_balancer_set_datapaths(lb->slb, NULL, 0);
        smap_destroy(&options);
    }

    struct ovn_dp_group *dpg;
    HMAP_FOR_EACH_POP (dpg, node, &dp_groups) {
        bitmap_free(dpg->bitmap);
        free(dpg);
    }
    hmap_destroy(&dp_groups);

    /* Datapath_Binding.load_balancers is not used anymore, it's still in the
     * schema for compatibility reasons.  Reset it to empty, just in case.
     */
    struct ovn_datapath *od;
    HMAP_FOR_EACH (od, key_node, datapaths) {
        if (!od->nbs) {
            continue;
        }

        if (od->sb->n_load_balancers) {
            sbrec_datapath_binding_set_load_balancers(od->sb, NULL, 0);
        }
    }
}
