static void flush_stashed_error_work(struct work_struct *work)
{
	struct ext4_sb_info *sbi = container_of(work, struct ext4_sb_info,
						s_error_work);
	journal_t *journal = sbi->s_journal;
	handle_t *handle;

	/*
	 * If the journal is still running, we have to write out superblock
	 * through the journal to avoid collisions of other journalled sb
	 * updates.
	 *
	 * We use directly jbd2 functions here to avoid recursing back into
	 * ext4 error handling code during handling of previous errors.
	 */
	if (!sb_rdonly(sbi->s_sb) && journal) {
		struct buffer_head *sbh = sbi->s_sbh;
		handle = jbd2_journal_start(journal, 1);
		if (IS_ERR(handle))
			goto write_directly;
		if (jbd2_journal_get_write_access(handle, sbh)) {
			jbd2_journal_stop(handle);
			goto write_directly;
		}
		ext4_update_super(sbi->s_sb);
		if (buffer_write_io_error(sbh) || !buffer_uptodate(sbh)) {
			ext4_msg(sbi->s_sb, KERN_ERR, "previous I/O error to "
				 "superblock detected");
			clear_buffer_write_io_error(sbh);
			set_buffer_uptodate(sbh);
		}

		if (jbd2_journal_dirty_metadata(handle, sbh)) {
			jbd2_journal_stop(handle);
			goto write_directly;
		}
		jbd2_journal_stop(handle);
		ext4_notify_error_sysfs(sbi);
		return;
	}
write_directly:
	/*
	 * Write through journal failed. Write sb directly to get error info
	 * out and hope for the best.
	 */
	ext4_commit_super(sbi->s_sb);
	ext4_notify_error_sysfs(sbi);
}
