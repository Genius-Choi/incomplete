time_t find_first_time(
    time_t start,       /* what is the initial time */
    enum tmt_en baseint,    /* what is the basic interval */
    long basestep       /* how many if these do we jump a time */
    )
{
    struct tm tm;

    localtime_r(&start, &tm);
    /* let mktime figure this dst on its own */
    tm.tm_isdst = -1;

    switch (baseint) {
    case TMT_SECOND:
        tm.       tm_sec -= tm.tm_sec % basestep;

        break;
    case TMT_MINUTE:
        tm.       tm_sec = 0;
        tm.       tm_min -= tm.tm_min % basestep;

        break;
    case TMT_HOUR:
        tm.       tm_sec = 0;
        tm.       tm_min = 0;
        tm.       tm_hour -= tm.tm_hour % basestep;

        break;
    case TMT_DAY:
        /* we do NOT look at the basestep for this ... */
        tm.       tm_sec = 0;
        tm.       tm_min = 0;
        tm.       tm_hour = 0;

        break;
    case TMT_WEEK:
        /* we do NOT look at the basestep for this ... */
        tm.       tm_sec = 0;
        tm.       tm_min = 0;
        tm.       tm_hour = 0;
        tm.       tm_mday -= tm.tm_wday - find_first_weekday();

        if (tm.tm_wday == 0 && find_first_weekday() > 0)
            tm.       tm_mday -= 7; /* we want the *previous* week */

        break;
    case TMT_MONTH:
        tm.       tm_sec = 0;
        tm.       tm_min = 0;
        tm.       tm_hour = 0;
        tm.       tm_mday = 1;
        tm.       tm_mon -= tm.tm_mon % basestep;

        break;

    case TMT_YEAR:
        tm.       tm_sec = 0;
        tm.       tm_min = 0;
        tm.       tm_hour = 0;
        tm.       tm_mday = 1;
        tm.       tm_mon = 0;
        tm.       tm_year -= (
    tm.tm_year + 1900) %basestep;

    }
    return mktime(&tm);
}
