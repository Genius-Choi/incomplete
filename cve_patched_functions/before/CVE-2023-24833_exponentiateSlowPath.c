OperationStatus exponentiateSlowPath(
    MutableBigIntRef dst,
    ImmutableBigIntRef lhs,
    uint32_t exponent) {
  // At each iteration i, runningSquare will have the current value for
  // lhs ** 2 ** i, and nextRunningSquare will be used to compute
  // runningSquare * runningSquare (i.e.,
  // nextRunningSquare = runningSquare ** 2) which will be used by the next
  // iteration in the algorithm. This is necessary because multiply()
  // requires/assumes dst's digits don't overload with lhs' or rhs'.
  uint32_t runningSquareSize0 = BigIntMaxSizeInDigits;
  uint32_t runningSquareSize1 = BigIntMaxSizeInDigits;
  uint32_t tmpResultTmpSize = BigIntMaxSizeInDigits;
  TmpStorage tmpBuffers(
      runningSquareSize0 + runningSquareSize1 + tmpResultTmpSize);
  MutableBigIntRef runningSquare0{
      tmpBuffers.requestNumDigits(runningSquareSize0), runningSquareSize0};
  MutableBigIntRef runningSquare1{
      tmpBuffers.requestNumDigits(runningSquareSize1), runningSquareSize1};

  // at each iteration i, result is the exponentiation result, i.e.,
  //
  //   result = result * runningSquare, if lhs_i is 1
  //   result = result                , otherwise
  //
  // Thus, a temporary result buffer is needed (because multiply() requires).

  MutableBigIntRef tmpResult{
      tmpBuffers.requestNumDigits(tmpResultTmpSize), tmpResultTmpSize};

  // These are the MutableBigIntRef "adapters". Besides being implicitly
  // converted to ImmutableBigIntRef and MutableBigIntRef, their contents can
  // also be swapp()ed with one another.
  MutableBigIntAndMaxSize runningSquare = runningSquare0;
  MutableBigIntAndMaxSize tmpRunningSquare = runningSquare1;
  MutableBigIntAndMaxSize result = dst;
  MutableBigIntAndMaxSize nextResult = tmpResult;

  // runningSquare is initialized to base, i.e., lhs ** 2 ** 0.
  auto res = initWithDigits(runningSquare, lhs);
  if (LLVM_UNLIKELY(res != OperationStatus::RETURNED)) {
    return res;
  }

  // initialize the result. It is either 0 (if x_0 = 0), or lhs (otherwise).
  if ((exponent & 1) == 0) {
    result.ref().numDigits = 0;
  } else {
    res = initWithDigits(result, lhs);
    if (LLVM_UNLIKELY(res != OperationStatus::RETURNED)) {
      return res;
    }
  }

  // now iterate over the exponent until there are no more bits set in it.
  for (exponent >>= 1; exponent > 0; exponent >>= 1) {
    // runningSquare <<= 2;
    tmpRunningSquare.resetRefNumDigits();
    res = multiply(tmpRunningSquare, runningSquare, runningSquare);
    res = multiplyStatusToExponentiateStatus(
        res, tmpRunningSquare.getMaxDigits());
    tmpRunningSquare.swap(runningSquare);

    if (LLVM_UNLIKELY(res != OperationStatus::RETURNED)) {
      return res;
    }

    // include runningSquare in the result if lhs_i is 1.
    if ((exponent & 1) != 0) {
      nextResult.resetRefNumDigits();
      if (compare(result, 0) == 0) {
        res = initWithDigits(nextResult, runningSquare);
      } else {
        res = multiply(nextResult, result, runningSquare);
        res =
            multiplyStatusToExponentiateStatus(res, nextResult.getMaxDigits());
      }
      if (LLVM_UNLIKELY(res != OperationStatus::RETURNED)) {
        return res;
      }
      nextResult.swap(result);
    }
  }

  res = OperationStatus::RETURNED;
  if (&result.ref() != &dst) {
    nextResult.resetRefNumDigits();
    res = initNonCanonicalWithReadOnlyBigInt(nextResult, result);
  }

  return res;
}
