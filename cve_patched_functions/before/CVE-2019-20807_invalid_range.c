invalid_range(exarg_T *eap)
{
    buf_T	*buf;
    if (       eap->line1 < 0
	    || eap->line2 < 0
	    || eap->line1 > eap->line2)
	return _(e_invrange);

    if (eap->argt & RANGE)
    {
	switch(eap->addr_type)
	{
	    case ADDR_LINES:
		if (!(eap->argt & NOTADR)
			&& eap->line2 > curbuf->b_ml.ml_line_count
#ifdef FEAT_DIFF
			    + (eap->cmdidx == CMD_diffget)
#endif
		   )
		    return _(e_invrange);
		break;
	    case ADDR_ARGUMENTS:
		/* add 1 if ARGCOUNT is 0 */
		if (eap->line2 > ARGCOUNT + (!ARGCOUNT))
		    return _(e_invrange);
		break;
	    case ADDR_BUFFERS:
		if (eap->line1 < firstbuf->b_fnum
			|| eap->line2 > lastbuf->b_fnum)
		    return _(e_invrange);
		break;
	    case ADDR_LOADED_BUFFERS:
		buf = firstbuf;
		while (buf->b_ml.ml_mfp == NULL)
		{
		    if (buf->b_next == NULL)
			return _(e_invrange);
		    buf = buf->b_next;
		}
		if (eap->line1 < buf->b_fnum)
		    return _(e_invrange);
		buf = lastbuf;
		while (buf->b_ml.ml_mfp == NULL)
		{
		    if (buf->b_prev == NULL)
			return _(e_invrange);
		    buf = buf->b_prev;
		}
		if (eap->line2 > buf->b_fnum)
		    return _(e_invrange);
		break;
	    case ADDR_WINDOWS:
		if (eap->line2 > LAST_WIN_NR)
		    return _(e_invrange);
		break;
	    case ADDR_TABS:
		if (eap->line2 > LAST_TAB_NR)
		    return _(e_invrange);
		break;
	    case ADDR_TABS_RELATIVE:
		/* Do nothing */
		break;
#ifdef FEAT_QUICKFIX
	    case ADDR_QUICKFIX:
		if (eap->line2 != 1 && eap->line2 > qf_get_size(eap))
		    return _(e_invrange);
		break;
#endif
	}
    }
    return NULL;
}
