FwdState::connectedToPeer(Security::EncryptorAnswer &answer)
{
    encryptionWait.finish();

    ErrorState *error = nullptr;
    if ((error = answer.error.get())) {
        assert(!answer.conn);
        answer.error.clear(); // preserve error for errorSendComplete()
    } else if (answer.tunneled) {
        assert(!answer.conn);
        // TODO: When ConnStateData establishes tunnels, its state changes
        // [in ways that may affect logging?]. Consider informing
        // ConnStateData about our tunnel or otherwise unifying tunnel
        // establishment [side effects].
        flags.dont_retry = true; // TunnelStateData took forwarding control
        entry->abort();
        complete(); // destroys us
        return;
    } else if (!Comm::IsConnOpen(answer.conn) || fd_table[answer.conn->fd].closing()) {
        // The socket could get closed while our callback was queued. Sync
        // Connection. XXX: Connection::fd may already be stale/invalid here.
        closePendingConnection(answer.conn, "conn was closed while waiting for connectedToPeer");
        error = new ErrorState(ERR_CANNOT_FORWARD, Http::scServiceUnavailable, request, al);
    }

    if (error) {
        fail(error);
        retryOrBail();
        return;
    }

    successfullyConnectedToPeer(answer.conn);
}
