    OFCondition operator()(ImagePixel& pixel)
    {
        // Avoid compiler warning about unused parameter "pixel"
        (void)pixel;
        // Input data is checked before
        Uint16 rows = 0;
        Uint16 cols = 0;
        m_CT.getRows(rows);
        m_CT.getColumns(cols);
        const size_t numFrames      = m_CT.m_Frames.size();
        const size_t numBytesFrame  = m_CT.m_Frames[0]->length;
        const size_t numPixelsFrame = rows * cols;
        // Creates the correct pixel data element, based on the image pixel module used.
        DcmPixelData* pixData = new DcmPixelData(DCM_PixelData);
        OFCondition result;
        if (pixData)
        {
            pixData->setVR(EVR_OW);
            Uint16* ptr          = NULL;
            size_t numBytesTotal = numBytesFrame * numFrames / 2;
            if (numBytesTotal <= 4294967294UL)
            {
                result = pixData->createUint16Array(OFstatic_cast(Uint32, numBytesTotal), ptr);
                // copy all frames into CT's frame structure
                if (ptr)
                {
                    for (size_t f = 0; f < numFrames; ++f)
                    {
                        memcpy(ptr, m_CT.m_Frames[f]->pixData, numBytesFrame);
                        ptr += numPixelsFrame;
                    }
                    return m_Item.insert(pixData);
                }
            }
            else
            {
                result = FG_EC_PixelDataTooLarge;
                delete pixData;
            }
        }
        return result;
    }
