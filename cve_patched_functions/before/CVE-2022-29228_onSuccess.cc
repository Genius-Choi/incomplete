void OAuth2ClientImpl::onSuccess(const Http::AsyncClient::Request&,
                                 Http::ResponseMessagePtr&& message) {
  in_flight_request_ = nullptr;

  ASSERT(state_ == OAuthState::PendingAccessToken);
  state_ = OAuthState::Idle;

  // Check that the auth cluster returned a happy response.
  const auto response_code = message->headers().Status()->value().getStringView();
  if (response_code != "200") {
    ENVOY_LOG(debug, "Oauth response code: {}", response_code);
    ENVOY_LOG(debug, "Oauth response body: {}", message->bodyAsString());
    parent_->sendUnauthorizedResponse();
    return;
  }

  const std::string response_body = message->bodyAsString();

  envoy::extensions::http_filters::oauth2::OAuthResponse response;
  try {
    MessageUtil::loadFromJson(response_body, response, ProtobufMessage::getNullValidationVisitor());
  } catch (EnvoyException& e) {
    ENVOY_LOG(debug, "Error parsing response body, received exception: {}", e.what());
    ENVOY_LOG(debug, "Response body: {}", response_body);
    parent_->sendUnauthorizedResponse();
    return;
  }

  // TODO(snowp): Should this be a pgv validation instead? A more readable log
  // message might be good enough reason to do this manually?
  if (!response.has_access_token() || !response.has_expires_in()) {
    ENVOY_LOG(debug, "No access token or expiration after asyncGetAccessToken");
    parent_->sendUnauthorizedResponse();
    return;
  }

  const std::string access_token{PROTOBUF_GET_WRAPPED_REQUIRED(response, access_token)};
  const std::string id_token{PROTOBUF_GET_WRAPPED_OR_DEFAULT(response, id_token, EMPTY_STRING)};
  const std::string refresh_token{
      PROTOBUF_GET_WRAPPED_OR_DEFAULT(response, refresh_token, EMPTY_STRING)};
  const std::chrono::seconds expires_in{PROTOBUF_GET_WRAPPED_REQUIRED(response, expires_in)};

  parent_->onGetAccessTokenSuccess(access_token, id_token, refresh_token, expires_in);
}
