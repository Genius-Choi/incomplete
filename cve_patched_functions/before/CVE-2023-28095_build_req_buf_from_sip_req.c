char * build_req_buf_from_sip_req( struct sip_msg* msg,
								unsigned int *returned_len,
								struct socket_info* send_sock, int proto,
								str *via_params, unsigned int flags)
{
	unsigned int len, new_len, received_len, rport_len, uri_len, via_len, body_delta;
	char *line_buf, *received_buf, *rport_buf, *new_buf, *buf, *id_buf;
	unsigned int offset, s_offset, size, id_len;
	struct lump *anchor, *via_insert_param;
	str branch, extra_params, body;
	struct hostport hp;

	id_buf=0;
	id_len=0;
	via_insert_param=0;
	extra_params.len=0;
	extra_params.s=0;
	uri_len=0;
	buf=msg->buf;
	len=msg->len;
	received_len=0;
	rport_len=0;
	new_buf=0;
	received_buf=0;
	rport_buf=0;
	line_buf=0;
	int via1_deleted = 0;

	if (msg->path_vec.len) {
		if (insert_path_as_route(msg, &msg->path_vec) < 0) {
			LM_ERR("adding path lumps failed\n");
			goto error;
		}
	}

	/* Calculate message body difference and adjust
	 * Content-Length
	 */
	body_delta = calculate_body_diff( msg, send_sock);
	if (adjust_clen(msg, body_delta, proto) < 0) {
		LM_ERR("failed to adjust Content-Length\n");
		goto error;
	}

	if (flags&MSG_TRANS_NOVIA_FLAG)
		goto build_msg;

	/* add id if tcp-based protocol  */
	if (is_tcp_based_proto(msg->rcv.proto)) {
		if  ((id_buf=id_builder(msg, &id_len))==0){
			LM_ERR("id_builder failed\n");
			goto error; /* we don't need to free anything,
			                 nothing alloc'ed yet*/
		}
		LM_DBG("id added: <%.*s>, rcv proto=%d\n",
				(int)id_len, id_buf, msg->rcv.proto);
		/* if there was already something there, simply copy them */
		if (via_params && via_params->len != 0) {
			extra_params.len = id_len + via_params->len;
			extra_params.s=pkg_malloc(extra_params.len);
			if(extra_params.s==0) {
				LM_ERR("extra params building failed\n");
				pkg_free(id_buf);
				goto error;
			}
			memcpy(extra_params.s, via_params->s, via_params->len);
			memcpy(extra_params.s + via_params->len, id_buf, id_len);
		} else {
			extra_params.s=id_buf;
			extra_params.len=id_len;
		}
	}

	/* check whether to add rport parameter to local via */
	if(msg->msg_flags&FL_FORCE_LOCAL_RPORT) {
		id_buf=extra_params.s;
		id_len=extra_params.len;
		if (via_params && !extra_params.len) {
			/* if no other parameters were added yet, consider via_params */
			extra_params.len = via_params->len;
			/* otherwise, the via_params were already copied in the id block */
		}
		extra_params.len += RPORT_LEN-1; /* last char in RPORT define is '='
										which is not added, but the new buffer
										will be null terminated */
		extra_params.s = (char*)pkg_malloc(extra_params.len+1);
		if(extra_params.s==0) {
			LM_ERR("extra params building failed\n");
			if (id_buf) pkg_free(id_buf);
			goto error;
		}

		if(id_buf!=0) {
			memcpy(extra_params.s, id_buf, id_len);
			pkg_free(id_buf);
		} else if (via_params)
			memcpy(extra_params.s, via_params->s, via_params->len);
		memcpy(extra_params.s+id_len, RPORT, RPORT_LEN-1);
		extra_params.s[extra_params.len]='\0';
		LM_DBG("extra param added: <%.*s>\n",extra_params.len, extra_params.s);
	}

	branch.s=msg->add_to_branch_s;
	branch.len=msg->add_to_branch_len;
	set_hostport(&hp, msg);
	line_buf = via_builder( &via_len, send_sock, &branch,
						extra_params.len?&extra_params:via_params, proto, &hp);
	if (!line_buf){
		LM_ERR("no via received!\n");
		goto error00;
	}

	via1_deleted = is_del_via1_lump(msg);
	/* check if received needs to be added:
	 *  - if the VIA address and the received address are different
	 *  - if the rport was forced (rport requires received)
	 *  - if the rport was received in the VIA hdr
	 *  - and there is no lump that delets VIA1 hdr */
	if ( (msg->via1->rport || (msg->msg_flags&FL_FORCE_RPORT) ||
			received_test(msg) ) && !via1_deleted) {
		if ((received_buf=received_builder(msg,&received_len))==0){
			LM_ERR("received_builder failed\n");
			goto error01;  /* free also line_buf */
		}
	}

	/* check if rport needs to be updated:
	 *  - if FL_FORCE_RPORT is set add it (and del. any previous version)
	 *  - if via already contains an rport add it and overwrite the previous
	 *  rport value if present (if you don't want to overwrite the previous
	 *  version remove the comments) */
	if (((msg->msg_flags&FL_FORCE_RPORT)||
			(msg->via1->rport /*&& msg->via1->rport->value.s==0*/)) && !via1_deleted){
		if ((rport_buf=rport_builder(msg, &rport_len))==0){
			LM_ERR("rport_builder failed\n");
			goto error01; /* free everything */
		}
	}

	/* add via header to the list */
	/* try to add it before msg. 1st via */
	/* add first via, as an anchor for second via*/
	anchor=anchor_lump(msg, msg->via1->hdr.s-buf, HDR_VIA_T);
	if (anchor==0) goto error01;
	if (insert_new_lump_before(anchor, line_buf, via_len, HDR_VIA_T)==0)
		goto error01;
	/* find out where the offset of the first parameter that should be added
	 * (after host:port), needed by add receive & maybe rport */
	if (msg->via1->params.s){
			size= msg->via1->params.s-msg->via1->hdr.s-1; /*compensate
														  for ';' */
	}else{
			size= msg->via1->host.s-msg->via1->hdr.s+msg->via1->host.len;
			if (msg->via1->port!=0){
				/*size+=strlen(msg->via1->hdr.s+size+1)+1;*/
				size += msg->via1->port_str.len + 1; /* +1 for ':'*/
			}
	}
	/* if received needs to be added, add anchor after host and add it, or
	 * overwrite the previous one if already present */
	if (received_len){
		if (msg->via1->received){ /* received already present => overwrite it*/
			via_insert_param=del_lump(msg,
								msg->via1->received->start-buf-1, /*;*/
								msg->via1->received->size+1, /*;*/ HDR_VIA_T);
		}else if (via_insert_param==0){ /* receive not present, ok */
			via_insert_param=anchor_lump(msg,
										msg->via1->hdr.s-buf+size, HDR_VIA_T);
		}
		if (via_insert_param==0) goto error02; /* free received_buf */
		if (insert_new_lump_after(via_insert_param, received_buf, received_len,
					HDR_VIA_T) ==0 ) goto error02; /* free received_buf */
	}
	/* if rport needs to be updated, delete it if present and add it's value */
	if (rport_len){
		if (msg->via1->rport){ /* rport already present */
			via_insert_param=del_lump(msg,
								msg->via1->rport->start-buf-1, /*';'*/
								msg->via1->rport->size+1 /* ; */, HDR_VIA_T);
		}else if (via_insert_param==0){ /*force rport, no rport present */
			/* no rport, add it */
			via_insert_param=anchor_lump(msg,
									msg->via1->hdr.s-buf+size, HDR_VIA_T);
		}
		if (via_insert_param==0) goto error03; /* free rport_buf */
		if (insert_new_lump_after(via_insert_param, rport_buf, rport_len,
									HDR_VIA_T) ==0 )
			goto error03; /* free rport_buf */
	}

build_msg:
	/* adjust len to the useful part of the message */
	if (get_body(msg, &body) == 0 && body.len)
		len -= (msg->buf + msg->len - body.s - body.len);

	/* compute new msg len and fix overlapping zones*/
	new_len=len+body_delta+lumps_len(msg, msg->add_rm, send_sock,-1);
#ifdef XL_DEBUG
	LM_DBG("new_len(%d)=len(%d)+lumps_len\n", new_len, len);
#endif

	if (msg->new_uri.s){
		uri_len=msg->new_uri.len;
		new_len=new_len-msg->first_line.u.request.uri.len+uri_len;
	}
	if (flags&MSG_TRANS_SHM_FLAG)
		new_buf=(char*)shm_malloc(new_len+1);
	else
		new_buf=(char*)pkg_malloc(new_len+1);
	if (new_buf==0){
		ser_error=E_OUT_OF_MEM;
		LM_ERR("out of pkg memory\n");
		goto error00;
	}

	offset=s_offset=0;
	if (msg->new_uri.s){
		/* copy message up to uri */
		size=msg->first_line.u.request.uri.s-buf;
		memcpy(new_buf, buf, size);
		offset+=size;
		s_offset+=size;
		/* add our uri */
		memcpy(new_buf+offset, msg->new_uri.s, uri_len);
		offset+=uri_len;
		s_offset+=msg->first_line.u.request.uri.len; /* skip original uri */
	}

	/* apply changes over SIP hdrs and body */
	apply_msg_changes( msg, new_buf, &offset, &s_offset, send_sock, len);
	if (offset!=new_len) {
		LM_BUG("len mismatch : calculated %d, written %d\n", new_len, offset);
		abort();
	}

	new_buf[new_len]=0;

	*returned_len=new_len;
	/* cleanup */
	if (extra_params.s) pkg_free(extra_params.s);
	return new_buf;

error01:
	if (line_buf) pkg_free(line_buf);
error02:
	if (received_buf) pkg_free(received_buf);
error03:
	if (rport_buf) pkg_free(rport_buf);
error00:
	if (extra_params.s) pkg_free(extra_params.s);
error:
	*returned_len=0;
	return 0;
}
