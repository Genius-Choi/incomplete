static void test_privacy(const char* raw_header,const char* values[],size_t number_values) {

	belle_sip_list_t* list;
	belle_sip_header_privacy_t* L_tmp;
	belle_sip_header_privacy_t* L_privacy = belle_sip_header_privacy_parse(raw_header);
	char* l_raw_header = belle_sip_object_to_string(BELLE_SIP_OBJECT(L_privacy));
	size_t i=0;
	belle_sip_object_unref(BELLE_SIP_OBJECT(L_privacy));
	L_tmp = belle_sip_header_privacy_parse(l_raw_header);
	L_privacy = BELLE_SIP_HEADER_PRIVACY(belle_sip_object_clone(BELLE_SIP_OBJECT(L_tmp)));
	belle_sip_object_unref(BELLE_SIP_OBJECT(L_tmp));

	belle_sip_free(l_raw_header);

	list = belle_sip_header_privacy_get_privacy(L_privacy);

	for(i=0;i<number_values;i++){
		BC_ASSERT_PTR_NOT_NULL(list);
		BC_ASSERT_STRING_EQUAL((const char *)(list->data),values[i]);
		list=list->next;
	}
	belle_sip_object_unref(BELLE_SIP_OBJECT(L_privacy));
	BC_ASSERT_PTR_NULL(belle_sip_header_privacy_parse("nimportequoi"));

}
