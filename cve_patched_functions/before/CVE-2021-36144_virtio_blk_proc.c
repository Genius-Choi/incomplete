virtio_blk_proc(struct virtio_blk *blk, struct virtio_vq_info *vq)
{
	struct virtio_blk_hdr *vbh;
	struct virtio_blk_ioreq *io;
	int i, n;
	int err;
	ssize_t iolen;
	int writeop, type;
	struct iovec iov[BLOCKIF_IOV_MAX + 2];
	uint16_t idx, flags[BLOCKIF_IOV_MAX + 2];

	idx = vq->qsize;
	n = vq_getchain(vq, &idx, iov, BLOCKIF_IOV_MAX + 2, flags);

	/*
	 * The first descriptor will be the read-only fixed header,
	 * and the last is for status (hence +2 above and below).
	 * The remaining iov's are the actual data I/O vectors.
	 *
	 * XXX - note - this fails on crash dump, which does a
	 * VIRTIO_BLK_T_FLUSH with a zero transfer length
	 */
	if (n < 2 || n > BLOCKIF_IOV_MAX + 2) {
		WPRINTF(("%s: vq_getchain failed\n", __func__));
		virtio_blk_abort(vq, idx);
		return;
	}

	io = &blk->ios[idx];
	if ((flags[0] & VRING_DESC_F_WRITE) != 0) {
		WPRINTF(("%s: the type for hdr should not be VRING_DESC_F_WRITE\n", __func__));
		virtio_blk_abort(vq, idx);
		return;
	}
	if (iov[0].iov_len != sizeof(struct virtio_blk_hdr)) {
		WPRINTF(("%s: the size for hdr %ld should be %ld \n",
						__func__,
						iov[0].iov_len,
						sizeof(struct virtio_blk_hdr)));
		virtio_blk_abort(vq, idx);
		return;
	}
	vbh = iov[0].iov_base;
	memcpy(&io->req.iov, &iov[1], sizeof(struct iovec) * (n - 2));
	io->req.iovcnt = n - 2;
	io->req.offset = vbh->sector * DEV_BSIZE;
	io->status = iov[--n].iov_base;
	if (iov[n].iov_len != 1 || ((flags[n] & VRING_DESC_F_WRITE) == 0)) {
		WPRINTF(("%s: status iov is invalid!\n", __func__));
		virtio_blk_abort(vq, idx);
		return;
	}

	/*
	 * XXX
	 * The guest should not be setting the BARRIER flag because
	 * we don't advertise the capability.
	 */
	type = vbh->type & ~VBH_FLAG_BARRIER;
	writeop = ((type == VBH_OP_WRITE) ||
			(type == VBH_OP_DISCARD));

	if (blk->dummy_bctxt) {
		WPRINTF(("Block context invalid: Operation cannot be permitted!\n"));
		virtio_blk_done(&io->req, EPERM);
		return;
	}

	if (writeop && blockif_is_ro(blk->bc)) {
		WPRINTF(("Cannot write to a read-only storage!\n"));
		virtio_blk_done(&io->req, EROFS);
		return;
	}

	iolen = 0;
	for (i = 1; i < n; i++) {
		/*
		 * - write/discard op implies read-only descriptor,
		 * - read/ident op implies write-only descriptor,
		 * therefore test the inverse of the descriptor bit
		 * to the op.
		 */
		if (((flags[i] & VRING_DESC_F_WRITE) == 0) != writeop) {
			WPRINTF(("%s: flag is confict with operation\n", __func__));
			virtio_blk_done(&io->req, EINVAL);
			return;
		}
		iolen += iov[i].iov_len;
	}
	io->req.resid = iolen;

	DPRINTF(("virtio_blk: %s op, %zd bytes, %d segs, offset %ld\n\r",
		 writeop ? "write/discard" : "read/ident", iolen, i - 1,
		 io->req.offset));

	switch (type) {
	case VBH_OP_READ:
	case VBH_OP_WRITE:
		/*
		 * VirtIO v1.0 spec 04 5.2.5:
		 * - Protocol unit size is always 512 bytes.
		 * - blk_size (logical block size) and physical_block_exp
		 *   (physical block size) do not affect the units in the
		 *   protocol, only performance.
		 *
		 * VirtIO v1.0 spec 04 5.2.6.1:
		 * - A driver MUST NOT submit a request which would cause a
		 *   read or write beyond capacity.
		 */
		if ((iolen & (DEV_BSIZE - 1)) ||
		    vbh->sector + iolen / DEV_BSIZE > blk->cfg.capacity) {
			DPRINTF(("virtio_blk: invalid request, iolen = %ld, "
			         "sector = %lu, capacity = %lu\n\r", iolen,
			         vbh->sector, blk->cfg.capacity));
			virtio_blk_done(&io->req, EINVAL);
			return;
		}

		err = ((type == VBH_OP_READ) ? blockif_read : blockif_write)
				(blk->bc, &io->req);
		break;
	case VBH_OP_DISCARD:
		err = blockif_discard(blk->bc, &io->req);
		break;
	case VBH_OP_FLUSH:
	case VBH_OP_FLUSH_OUT:
		err = blockif_flush(blk->bc, &io->req);
		break;
	case VBH_OP_IDENT:
		/* Assume a single buffer */
		/* S/n equal to buffer is not zero-terminated. */
		memset(iov[1].iov_base, 0, iov[1].iov_len);
		strncpy(iov[1].iov_base, blk->ident,
		    MIN(iov[1].iov_len, sizeof(blk->ident)));
		virtio_blk_done(&io->req, 0);
		return;
	default:
		virtio_blk_done(&io->req, EOPNOTSUPP);
		return;
	}
	if (err)
		WPRINTF(("%s: request process failed\n", __func__));
}
