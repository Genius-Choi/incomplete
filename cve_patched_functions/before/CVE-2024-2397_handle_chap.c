handle_chap(netdissect_options *ndo,
            const u_char *p, u_int length)
{
	u_int code, len;
	u_int val_size, name_size, msg_size;
	const u_char *p0;
	u_int i;

	p0 = p;
	if (length < 1) {
		ND_PRINT("[|chap]");
		return;
	} else if (length < 4) {
		ND_PRINT("[|chap 0x%02x]", GET_U_1(p));
		return;
	}

	code = GET_U_1(p);
	ND_PRINT("CHAP, %s (0x%02x)",
               tok2str(chapcode_values,"unknown",code),
               code);
	p++;

	ND_PRINT(", id %u", GET_U_1(p));	/* ID */
	p++;

	len = GET_BE_U_2(p);
	p += 2;

	/*
	 * Note that this is a generic CHAP decoding routine. Since we
	 * don't know which flavor of CHAP (i.e. CHAP-MD5, MS-CHAPv1,
	 * MS-CHAPv2) is used at this point, we can't decode packet
	 * specifically to each algorithms. Instead, we simply decode
	 * the GCD (Greatest Common Denominator) for all algorithms.
	 */
	switch (code) {
	case CHAP_CHAL:
	case CHAP_RESP:
		if (length - (p - p0) < 1)
			return;
		val_size = GET_U_1(p);	/* value size */
		p++;
		if (length - (p - p0) < val_size)
			return;
		ND_PRINT(", Value ");
		for (i = 0; i < val_size; i++) {
			ND_PRINT("%02x", GET_U_1(p));
			p++;
		}
		name_size = len - (u_int)(p - p0);
		ND_PRINT(", Name ");
		for (i = 0; i < name_size; i++) {
			fn_print_char(ndo, GET_U_1(p));
			p++;
		}
		break;
	case CHAP_SUCC:
	case CHAP_FAIL:
		msg_size = len - (u_int)(p - p0);
		ND_PRINT(", Msg ");
		for (i = 0; i< msg_size; i++) {
			fn_print_char(ndo, GET_U_1(p));
			p++;
		}
		break;
	}
}
