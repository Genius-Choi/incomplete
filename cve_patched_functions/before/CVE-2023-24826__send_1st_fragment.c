static uint16_t _send_1st_fragment(gnrc_netif_t *netif,
                                   gnrc_sixlowpan_frag_fb_t *fbuf,
                                   unsigned page, gnrc_pktsnip_t **tx_sync)
{
    gnrc_pktsnip_t *frag, *pkt = fbuf->pkt;
    sixlowpan_sfr_rfrag_t *hdr;
    uint8_t *data;
    size_t comp_form_size = gnrc_pkt_len(pkt->next);
    uint16_t frag_size = (uint16_t)netif->sixlo.max_frag_size -
                         sizeof(sixlowpan_sfr_rfrag_t);

    assert((fbuf->sfr.cur_seq == 0) && (fbuf->sfr.frags_sent == 0));
    assert(fbuf->sfr.window.next == NULL);
    assert(comp_form_size <= UINT16_MAX);
    /* restrict tag to value space of SFR, so that later RFRAG ACK can find
     * it in reverse look-up */
    fbuf->tag &= UINT8_MAX;
    DEBUG("6lo sfr: determined frag_size = %u\n", frag_size);

    /* packet was compressed */
    if (fbuf->datagram_size > comp_form_size) {
        /* add slack to first fragment */
        frag_size -= (fbuf->datagram_size - comp_form_size);
        /* use compressed form */
        fbuf->datagram_size = (uint16_t)gnrc_pkt_len(pkt->next);
    }
    else {
        /* Add uncompressed datagram dispatch to "compressed form"
         * datagram_size */
        fbuf->datagram_size++;
    }
    fbuf->sfr.arq_timeout = CONFIG_GNRC_SIXLOWPAN_SFR_OPT_ARQ_TIMEOUT_MS;

    frag = _build_frag_from_fbuf(pkt, fbuf, frag_size);
    if (frag == NULL) {
        DEBUG("6lo sfr: error allocating first fragment\n");
        return 0;
    }
    hdr = frag->next->data;
    data = (uint8_t *)(hdr + 1);
    sixlowpan_sfr_rfrag_set_offset(hdr, fbuf->datagram_size);
    /* don't copy netif header of pkt => pkt->next */
    frag_size = _copy_pkt_to_frag(data, pkt->next, frag_size, 0);
    if (IS_USED(MODULE_GNRC_TX_SYNC) && *tx_sync && (frag_size >= fbuf->datagram_size)) {
        gnrc_pkt_append(frag, *tx_sync);
        *tx_sync = NULL;
    }

    DEBUG("6lo sfr: send first fragment (tag: %u, X: %i, seq: %u, "
          "frag_size: %u, datagram_size: %u)\n",
          hdr->base.tag, sixlowpan_sfr_rfrag_ack_req(hdr),
          sixlowpan_sfr_rfrag_get_seq(hdr),
          sixlowpan_sfr_rfrag_get_frag_size(hdr),
          sixlowpan_sfr_rfrag_get_offset(hdr));
    if (!_send_fragment(frag, fbuf, page, 0)) {
        frag_size = 0;
    }
    return frag_size;
}
