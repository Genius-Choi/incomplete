ReadOrParseState Filter::parseBuffer(Network::ListenerFilterBuffer& buffer) {
  Network::ConnectionSocket& socket = cb_->socket();

  // We return if a) we do not yet have the header, b) we have the header but not yet all
  // the extension data.
  if (!proxy_protocol_header_.has_value()) {
    const ReadOrParseState read_header_state = readProxyHeader(buffer);
    if (read_header_state != ReadOrParseState::Done) {
      return read_header_state;
    }
  }

  // After parse the header, the extensions size is discovered. Then extend the buffer
  // size to receive the extensions.
  if (proxy_protocol_header_.value().wholeHeaderLength() > max_proxy_protocol_len_) {
    max_proxy_protocol_len_ = proxy_protocol_header_.value().wholeHeaderLength();
    // The expected header size is changed, waiting for more data.
    return ReadOrParseState::TryAgainLater;
  }

  if (proxy_protocol_header_.has_value()) {
    const ReadOrParseState read_ext_state = readExtensions(buffer);
    if (read_ext_state != ReadOrParseState::Done) {
      return read_ext_state;
    }
  }

  if (proxy_protocol_header_.has_value() &&
      !cb_->filterState().hasData<Network::ProxyProtocolFilterState>(
          Network::ProxyProtocolFilterState::key())) {
    auto buf = reinterpret_cast<const uint8_t*>(buffer.rawSlice().mem_);
    if (proxy_protocol_header_.value().local_command_) {
      ENVOY_LOG(trace, "Parsed proxy protocol header, cmd: LOCAL, length: {}, buffer: {}",
                proxy_protocol_header_.value().wholeHeaderLength(),
                Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()));

      cb_->filterState().setData(
          Network::ProxyProtocolFilterState::key(),
          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{
              socket.connectionInfoProvider().remoteAddress(),
              socket.connectionInfoProvider().localAddress(), parsed_tlvs_}),
          StreamInfo::FilterState::StateType::Mutable,
          StreamInfo::FilterState::LifeSpan::Connection);
    } else {
      ENVOY_LOG(
          trace,
          "Parsed proxy protocol header, cmd: PROXY, length: {}, buffer: {}, TLV length: {}, TLV "
          "buffer: {}",
          proxy_protocol_header_.value().wholeHeaderLength(),
          Envoy::Hex::encode(buf, proxy_protocol_header_.value().wholeHeaderLength()),
          proxy_protocol_header_.value().extensions_length_,
          Envoy::Hex::encode(buf + proxy_protocol_header_.value().headerLengthWithoutExtension(),
                             proxy_protocol_header_.value().extensions_length_));
      cb_->filterState().setData(
          Network::ProxyProtocolFilterState::key(),
          std::make_unique<Network::ProxyProtocolFilterState>(Network::ProxyProtocolData{
              proxy_protocol_header_.value().remote_address_,
              proxy_protocol_header_.value().local_address_, parsed_tlvs_}),
          StreamInfo::FilterState::StateType::Mutable,
          StreamInfo::FilterState::LifeSpan::Connection);
    }
  }

  if (proxy_protocol_header_.has_value() && !proxy_protocol_header_.value().local_command_) {
    // If this is a local_command, we are not to override address
    // Error check the source and destination fields. Most errors are caught by the address
    // parsing above, but a malformed IPv6 address may combine with a malformed port and parse as
    // an IPv6 address when parsing for an IPv4 address(for v1 mode). Remote address refers to the
    // source address.
    const auto remote_version = proxy_protocol_header_.value().remote_address_->ip()->version();
    const auto local_version = proxy_protocol_header_.value().local_address_->ip()->version();
    if (remote_version != proxy_protocol_header_.value().protocol_version_ ||
        local_version != proxy_protocol_header_.value().protocol_version_) {
      ENVOY_LOG(debug, "failed to read proxy protocol");
      return ReadOrParseState::Error;
    }
    // Check that both addresses are valid unicast addresses, as required for TCP
    if (!proxy_protocol_header_.value().remote_address_->ip()->isUnicastAddress() ||
        !proxy_protocol_header_.value().local_address_->ip()->isUnicastAddress()) {
      ENVOY_LOG(debug, "failed to read proxy protocol");
      return ReadOrParseState::Error;
    }

    // Only set the local address if it really changed, and mark it as address being restored.
    if (*proxy_protocol_header_.value().local_address_ !=
        *socket.connectionInfoProvider().localAddress()) {
      socket.connectionInfoProvider().restoreLocalAddress(
          proxy_protocol_header_.value().local_address_);
    }
    socket.connectionInfoProvider().setRemoteAddress(
        proxy_protocol_header_.value().remote_address_);
  }

  if (!buffer.drain(proxy_protocol_header_.value().wholeHeaderLength())) {
    return ReadOrParseState::Error;
  }
  return ReadOrParseState::Done;
}
