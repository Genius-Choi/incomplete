mg_start_domain(struct mg_context *ctx, const char **options)
{
	const char *name;
	const char *value;
	const char *default_value;
	struct mg_domain_context *new_dom;
	struct mg_domain_context *dom;
	int idx, i;

	if ((ctx == NULL) || (ctx->stop_flag != 0) || (options == NULL)) {
		return -1;
	}

	new_dom = (struct mg_domain_context *)
	    mg_calloc_ctx(1, sizeof(struct mg_domain_context), ctx);

	if (!new_dom) {
		/* Out of memory */
		return -6;
	}

	/* Store options - TODO: unite duplicate code */
	while (options && (name = *options++) != NULL) {
		if ((idx = get_option_index(name)) == -1) {
			mg_cry_internal(fc(ctx), "Invalid option: %s", name);
			mg_free(new_dom);
			return -2;
		} else if ((value = *options++) == NULL) {
			mg_cry_internal(fc(ctx), "%s: option value cannot be NULL", name);
			mg_free(new_dom);
			return -2;
		}
		if (new_dom->config[idx] != NULL) {
			mg_cry_internal(fc(ctx), "warning: %s: duplicate option", name);
			mg_free(new_dom->config[idx]);
		}
		new_dom->config[idx] = mg_strdup_ctx(value, ctx);
		DEBUG_TRACE("[%s] -> [%s]", name, value);
	}

	/* Authentication domain is mandatory */
	/* TODO: Maybe use a new option hostname? */
	if (!new_dom->config[AUTHENTICATION_DOMAIN]) {
		mg_cry_internal(fc(ctx), "%s", "authentication domain required");
		mg_free(new_dom);
		return -4;
	}

	/* Set default value if needed. Take the config value from
	 * ctx as a default value. */
	for (i = 0; config_options[i].name != NULL; i++) {
		default_value = ctx->dd.config[i];
		if ((new_dom->config[i] == NULL) && (default_value != NULL)) {
			new_dom->config[i] = mg_strdup_ctx(default_value, ctx);
		}
	}

	new_dom->handlers = NULL;
	new_dom->next = NULL;
	new_dom->nonce_count = 0;
	new_dom->auth_nonce_mask =
	    (uint64_t)get_random() ^ ((uint64_t)get_random() << 31);

#if defined(USE_LUA) && defined(USE_WEBSOCKET)
	new_dom->shared_lua_websockets = NULL;
#endif

	if (!init_ssl_ctx(ctx, new_dom)) {
		/* Init SSL failed */
		mg_free(new_dom);
		return -3;
	}

	/* Add element to linked list. */
	mg_lock_context(ctx);

	idx = 0;
	dom = &(ctx->dd);
	for (;;) {
		if (!strcasecmp(new_dom->config[AUTHENTICATION_DOMAIN],
		                dom->config[AUTHENTICATION_DOMAIN])) {
			/* Domain collision */
			mg_cry_internal(fc(ctx),
			                "domain %s already in use",
			                new_dom->config[AUTHENTICATION_DOMAIN]);
			mg_free(new_dom);
			return -5;
		}

		/* Count number of domains */
		idx++;

		if (dom->next == NULL) {
			dom->next = new_dom;
			break;
		}
		dom = dom->next;
	}

	mg_unlock_context(ctx);

	/* Return domain number */
	return idx;
}
