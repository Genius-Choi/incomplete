int gnrc_sixlowpan_frag_sfr_forward(gnrc_pktsnip_t *pkt,
                                    sixlowpan_sfr_rfrag_t *rfrag,
                                    gnrc_sixlowpan_frag_vrb_t *vrbe,
                                    unsigned page)
{
    _generic_rb_entry_t entry = { .type = _VRB, .entry = { .vrb = vrbe } };
    gnrc_pktsnip_t *hdrsnip = gnrc_pktbuf_add(pkt, rfrag, sizeof(*rfrag),
                                              GNRC_NETTYPE_SIXLOWPAN);

    /* free all intervals associated to the VRB entry, as we don't need them
     * with SFR, so throw them out, to save this resource */
    while (vrbe->super.ints) {
        vrbe->super.ints->end = 0U;
        vrbe->super.ints = vrbe->super.ints->next;
    }
    if (hdrsnip == NULL) {
        DEBUG("6lo sfr: Unable to allocate new rfrag header\n");
        gnrc_pktbuf_release(pkt);
        return -ENOMEM;
    }
    DEBUG("6lo sfr: adapting old fragment size (%u) for forwarding to %u\n",
          sixlowpan_sfr_rfrag_get_frag_size(hdrsnip->data),
          (unsigned)gnrc_pkt_len(pkt));
    /* due to compression, packet length of the original fragment might have
     * changed */
    sixlowpan_sfr_rfrag_set_frag_size(hdrsnip->data, gnrc_pkt_len(pkt));
    /* offset is adapted in `_forward_rfrag()` */
    return _forward_rfrag(hdrsnip, &entry, sixlowpan_sfr_rfrag_get_offset(rfrag),
                          page);
}
