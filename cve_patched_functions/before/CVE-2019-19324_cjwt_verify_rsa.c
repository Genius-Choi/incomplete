static int cjwt_verify_rsa( cjwt_t *jwt, const char *p_enc, const char *p_sigb64 )
{
    int ret = EINVAL, sz_sigb64 = 0;
    RSA *rsa = NULL;
    size_t enc_len = 0, sig_desize = 0;
    uint8_t *decoded_sig = NULL;
    unsigned char digest[EVP_MAX_MD_SIZE];

    if( jwt->header.key_len == 0 ) {
        cjwt_error( "invalid rsa key\n" );
        return EINVAL;
    }

    rsa = cjwt_create_rsa( jwt->header.key, jwt->header.key_len, 1 );

    if( rsa == NULL ) {
        cjwt_error( "key to rsa conversion failed\n" );
        return EINVAL;
    }

    //decode p_sigb64
    sz_sigb64 = strlen( ( char * )p_sigb64 );
    sig_desize = b64url_get_decoded_buffer_size( sz_sigb64 );
    //Because b64url_decode() always writes in blocks of 3 bytes for every 4 
    //characters even when the last 2 bytes are not used, we need up to 2 
    //extra bytes of output buffer to avoid a buffer overrun 
    decoded_sig = malloc( sig_desize + 2 );

    if( !decoded_sig ) {
        cjwt_error( "memory allocation failed\n" );
        //free rsa
        RSA_free( rsa );
        cjwt_rsa_error();
        return ENOMEM;
    }

    memset( decoded_sig, 0, sig_desize + 2 );
    sig_desize = b64url_decode( ( uint8_t * )p_sigb64, sz_sigb64, decoded_sig );
    cjwt_info( "----------------- signature ----------------- \n" );
    cjwt_info( "Bytes = %d\n", ( int )sig_desize );
    cjwt_info( "--------------------------------------------- \n" );

    if( !sig_desize ) {
        cjwt_error( "b64url_decode failed\n" );
        goto end;
    }

    decoded_sig[sig_desize] = '\0';
    //verify rsa
    enc_len = strlen( p_enc );

    switch( jwt->header.alg ) {
        case alg_rs256:
            SHA256( ( const unsigned char* ) p_enc, enc_len, digest );
            ret = RSA_verify
                  ( NID_sha256, digest, SHA256_DIGEST_LENGTH, decoded_sig,
                    ( unsigned int ) sig_desize, rsa );
            break;
        case alg_rs384:
            SHA384( ( const unsigned char * ) p_enc, enc_len, digest );
            ret = RSA_verify
                  ( NID_sha384, digest, SHA384_DIGEST_LENGTH, decoded_sig,
                    ( unsigned int ) sig_desize, rsa );
            break;
        case alg_rs512:
            SHA512( ( const unsigned char* ) p_enc, enc_len, digest );
            ret = RSA_verify
                  ( NID_sha512, digest, SHA512_DIGEST_LENGTH, decoded_sig,
                    ( unsigned int ) sig_desize, rsa );
            break;
        default:
            cjwt_error( "invalid rsa algorithm\n" );
            ret = EINVAL;
            break;
    }

end:
    RSA_free( rsa );
    free( decoded_sig );

    if( ret ==  1 ) {
        return 0;
    }

    cjwt_rsa_error();
    return EINVAL;
}
