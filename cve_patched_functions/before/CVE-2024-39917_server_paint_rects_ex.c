server_paint_rects_ex(struct xrdp_mod *mod,
                      int num_drects, short *drects,
                      int num_crects, short *crects,
                      char *data, int left, int top,
                      int width, int height,
                      int flags, int frame_id,
                      void *shmem_ptr, int shmem_bytes)
{
    struct xrdp_wm *wm;
    struct xrdp_mm *mm;
    struct xrdp_painter *p;
    struct xrdp_bitmap *b;
    short *s;
    int index;
    XRDP_ENC_DATA *enc_data;

    wm = (struct xrdp_wm *)(mod->wm);
    mm = wm->mm;

    LOG(LOG_LEVEL_TRACE, "server_paint_rects_ex: %p", mm->encoder);

    if (mm->encoder != 0)
    {
        /* copy formal params to XRDP_ENC_DATA */
        enc_data = (XRDP_ENC_DATA *) g_malloc(sizeof(XRDP_ENC_DATA), 1);
        if (enc_data == 0)
        {
            if (shmem_ptr != NULL)
            {
                g_munmap(shmem_ptr, shmem_bytes);
            }
            return 1;
        }

        enc_data->u.sc.drects = (short *)
                                g_malloc(sizeof(short) * num_drects * 4, 0);
        if (enc_data->u.sc.drects == 0)
        {
            if (shmem_ptr != NULL)
            {
                g_munmap(shmem_ptr, shmem_bytes);
            }
            g_free(enc_data);
            return 1;
        }

        enc_data->u.sc.crects = (short *)
                                g_malloc(sizeof(short) * num_crects * 4, 0);
        if (enc_data->u.sc.crects == 0)
        {
            if (shmem_ptr != NULL)
            {
                g_munmap(shmem_ptr, shmem_bytes);
            }
            g_free(enc_data->u.sc.drects);
            g_free(enc_data);
            return 1;
        }

        g_memcpy(enc_data->u.sc.drects, drects, sizeof(short) * num_drects * 4);
        g_memcpy(enc_data->u.sc.crects, crects, sizeof(short) * num_crects * 4);

        enc_data->mod = mod;
        enc_data->u.sc.num_drects = num_drects;
        enc_data->u.sc.num_crects = num_crects;
        enc_data->u.sc.data = data;
        enc_data->u.sc.left = left;
        enc_data->u.sc.top = top;
        enc_data->u.sc.width = width;
        enc_data->u.sc.height = height;
        enc_data->u.sc.flags = flags;
        enc_data->u.sc.frame_id = frame_id;
        enc_data->shmem_ptr = shmem_ptr;
        enc_data->shmem_bytes = shmem_bytes;
        if (width == 0 || height == 0)
        {
            LOG_DEVEL(LOG_LEVEL_WARNING, "server_paint_rects: error");
        }

        /* insert into fifo for encoder thread to process */
        tc_mutex_lock(mm->encoder->mutex);
        fifo_add_item(mm->encoder->fifo_to_proc, (void *) enc_data);
        tc_mutex_unlock(mm->encoder->mutex);

        /* signal xrdp_encoder thread */
        g_set_wait_obj(mm->encoder->xrdp_encoder_event_to_proc);

        return 0;
    }

    if (wm->client_info->gfx)
    {
        LOG(LOG_LEVEL_DEBUG, "server_paint_rects: gfx session and no encoder");
        mm->mod->mod_frame_ack(mm->mod, flags, frame_id);
        return 0;
    }

    p = (struct xrdp_painter *)(mod->painter);
    if (p == 0)
    {
        return 0;
    }
    b = xrdp_bitmap_create_with_data(width, height, wm->screen->bpp,
                                     data, wm);
    s = crects;
    for (index = 0; index < num_crects; index++)
    {
        xrdp_painter_copy(p, b, wm->target_surface, s[0], s[1], s[2], s[3],
                          s[0], s[1]);
        s += 4;
    }
    xrdp_bitmap_delete(b);
    mm->mod->mod_frame_ack(mm->mod, flags, frame_id);
    if (shmem_ptr != NULL)
    {
        g_munmap(shmem_ptr, shmem_bytes);
    }
    return 0;
}
