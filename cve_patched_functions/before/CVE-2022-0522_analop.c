static int analop(RAnal *a, RAnalOp *op, ut64 addr, const ut8 *buf, int len, RAnalOpMask mask) {
	static csh handle = 0;
	static int omode = -1;
	static int obits = 32;
	cs_insn *insn = NULL;
	int mode = (a->bits==16)? CS_MODE_THUMB: CS_MODE_ARM;
	int n, ret;
	mode |= (a->big_endian)? CS_MODE_BIG_ENDIAN: CS_MODE_LITTLE_ENDIAN;
	if (a->cpu && strstr (a->cpu, "cortex")) {
		mode |= CS_MODE_MCLASS;
	}

	if (mode != omode || a->bits != obits) {
		cs_close (&handle);
		handle = 0; // unnecessary
		omode = mode;
		obits = a->bits;
	}
	op->size = (a->bits==16)? 2: 4;
	op->addr = addr;
	if (handle == 0) {
		ret = (a->bits == 64)?
			cs_open (CS_ARCH_ARM64, mode, &handle):
			cs_open (CS_ARCH_ARM, mode, &handle);
		cs_option (handle, CS_OPT_DETAIL, CS_OPT_ON);
		if (ret != CS_ERR_OK) {
			handle = 0;
			return -1;
		}
	}
	int haa = hackyArmAnal (a, op, buf, len);
	if (haa > 0) {
		return haa;
	}

	n = cs_disasm (handle, (ut8*)buf, len, addr, 1, &insn);
	if (n < 1) {
		op->type = R_ANAL_OP_TYPE_ILL;
		if (mask & R_ANAL_OP_MASK_DISASM) {
			op->mnemonic = strdup ("invalid");
		}
	} else {
		if (mask & R_ANAL_OP_MASK_DISASM) {
			op->mnemonic = r_str_newf ("%s%s%s",
				insn->mnemonic,
				insn->op_str[0]?" ":"",
				insn->op_str);
		}
		//bool thumb = cs_insn_group (handle, insn, ARM_GRP_THUMB);
		bool thumb = a->bits == 16;
		op->size = insn->size;
		op->id = insn->id;
		if (a->bits == 64) {
			anop64 (handle, op, insn);
			if (mask & R_ANAL_OP_MASK_OPEX) {
				opex64 (&op->opex, handle, insn);
			}
			if (mask & R_ANAL_OP_MASK_ESIL) {
				analop64_esil (a, op, addr, buf, len, &handle, insn);
			}
		} else {
			anop32 (a, handle, op, insn, thumb, (ut8*)buf, len);
			if (mask & R_ANAL_OP_MASK_OPEX) {
				opex (&op->opex, handle, insn);
			}
			if (mask & R_ANAL_OP_MASK_ESIL) {
				analop_esil (a, op, addr, buf, len, &handle, insn, thumb);
			}
		}
		set_opdir (op);
		if (mask & R_ANAL_OP_MASK_VAL) {
			op_fillval (a, op, handle, insn, a->bits);
		}
		cs_free (insn, n);
	}
//	cs_close (&handle);
	return op->size;
}
