static int rtp_transport_wide_cc_feedback_produce(const void *data)
{
	struct ast_rtp_instance *instance = (struct ast_rtp_instance *) data;
	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
	unsigned char *rtcpheader;
	char bdata[1024];
	struct rtp_transport_wide_cc_packet_statistics *first_packet;
	struct rtp_transport_wide_cc_packet_statistics *previous_packet;
	int i;
	int status_vector_chunk_bits = 14;
	uint16_t status_vector_chunk = (1 << 15) | (1 << 14);
	int run_length_chunk_count = 0;
	int run_length_chunk_status = -1;
	int packet_len = 20;
	int delta_len = 0;
	int packet_count = 0;
	unsigned int received_msw;
	unsigned int received_lsw;
	struct ast_sockaddr remote_address = { { 0, } };
	int res;
	int ice;
	unsigned int large_delta_count = 0;
	unsigned int small_delta_count = 0;
	unsigned int lost_count = 0;

	if (!rtp || !rtp->rtcp || rtp->transport_wide_cc.schedid == -1) {
		ao2_ref(instance, -1);
		return 0;
	}

	ao2_lock(instance);

	/* If no packets have been received then do nothing */
	if (!AST_VECTOR_SIZE(&rtp->transport_wide_cc.packet_statistics)) {
		ao2_unlock(instance);
		return 1000;
	}

	rtcpheader = (unsigned char *)bdata;

	/* The first packet in the vector acts as our base sequence number and reference time */
	first_packet = AST_VECTOR_GET_ADDR(&rtp->transport_wide_cc.packet_statistics, 0);
	previous_packet = first_packet;

	/* We go through each packet that we have statistics for, adding it either to a status
	 * vector chunk or a run length chunk. The code tries to be as efficient as possible to
	 * reduce packet size and will favor run length chunks when it makes sense.
	 */
	for (i = 0; i < AST_VECTOR_SIZE(&rtp->transport_wide_cc.packet_statistics); ++i) {
		struct rtp_transport_wide_cc_packet_statistics *statistics;
		int lost = 0;
		int res = 0;

		statistics = AST_VECTOR_GET_ADDR(&rtp->transport_wide_cc.packet_statistics, i);

		packet_count++;

		if (first_packet != statistics) {
			/* The vector stores statistics in a sorted fashion based on the sequence
			 * number. This ensures we can detect any packets that have been lost/not
			 * received by comparing the sequence numbers.
			 */
			lost = statistics->seqno - (previous_packet->seqno + 1);
			lost_count += lost;
		}

		while (lost) {
			/* We append a not received status until all the lost packets have been accounted for */
			rtp_transport_wide_cc_feedback_status_append(rtcpheader, &packet_len, &status_vector_chunk_bits,
				&status_vector_chunk, &run_length_chunk_count, &run_length_chunk_status, 0);
			packet_count++;

			/* If there is no more room left for storing packets stop now, we leave 20
			 * extra bits at the end just in case.
			 */
			if (packet_len + delta_len + 20 > sizeof(bdata)) {
				res = -1;
				break;
			}

			lost--;
		}

		/* If the lost packet appending bailed out because we have no more space, then exit here too */
		if (res) {
			break;
		}

		/* Per the spec the delta is in increments of 250 */
		statistics->delta = ast_tvdiff_us(statistics->received, previous_packet->received) / 250;

		/* Based on the delta determine the status of this packet */
		if (statistics->delta < 0 || statistics->delta > 127) {
			/* Large or negative delta */
			rtp_transport_wide_cc_feedback_status_append(rtcpheader, &packet_len, &status_vector_chunk_bits,
				&status_vector_chunk, &run_length_chunk_count, &run_length_chunk_status, 2);
			delta_len += 2;
			large_delta_count++;
		} else {
			/* Small delta */
			rtp_transport_wide_cc_feedback_status_append(rtcpheader, &packet_len, &status_vector_chunk_bits,
				&status_vector_chunk, &run_length_chunk_count, &run_length_chunk_status, 1);
			delta_len += 1;
			small_delta_count++;
		}

		previous_packet = statistics;

		/* If there is no more room left in the packet stop handling of any subsequent packets */
		if (packet_len + delta_len + 20 > sizeof(bdata)) {
			break;
		}
	}

	if (status_vector_chunk_bits != 14) {
		/* If the status vector chunk has packets in it then place it in the RTCP packet */
		put_unaligned_uint16(rtcpheader + packet_len, htons(status_vector_chunk));
		packet_len += 2;
	} else if (run_length_chunk_count) {
		/* If there is a run length chunk in progress then place it in the RTCP packet */
		put_unaligned_uint16(rtcpheader + packet_len, htons((0 << 15) | (run_length_chunk_status << 13) | run_length_chunk_count));
		packet_len += 2;
	}

	/* We iterate again to build delta chunks */
	for (i = 0; i < AST_VECTOR_SIZE(&rtp->transport_wide_cc.packet_statistics); ++i) {
		struct rtp_transport_wide_cc_packet_statistics *statistics;

		statistics = AST_VECTOR_GET_ADDR(&rtp->transport_wide_cc.packet_statistics, i);

		if (statistics->delta < 0 || statistics->delta > 127) {
			/* We need 2 bytes to store this delta */
			put_unaligned_uint16(rtcpheader + packet_len, htons(statistics->delta));
			packet_len += 2;
		} else {
			/* We can store this delta in 1 byte */
			rtcpheader[packet_len] = statistics->delta;
			packet_len += 1;
		}

		/* If this is the last packet handled by the run length chunk or status vector chunk code
		 * then we can go no further.
		 */
		if (statistics == previous_packet) {
			break;
		}
	}

	/* Zero pad the end of the packet */
	while (packet_len % 4) {
		rtcpheader[packet_len++] = 0;
	}

	/* Add the general RTCP header information */
	put_unaligned_uint32(rtcpheader, htonl((2 << 30) | (AST_RTP_RTCP_FMT_TRANSPORT_WIDE_CC << 24)
		| (AST_RTP_RTCP_RTPFB << 16) | ((packet_len / 4) - 1)));
	put_unaligned_uint32(rtcpheader + 4, htonl(rtp->ssrc));
	put_unaligned_uint32(rtcpheader + 8, htonl(rtp->themssrc));

	/* Add the transport-cc specific header information */
	put_unaligned_uint32(rtcpheader + 12, htonl((first_packet->seqno << 16) | packet_count));

	timeval2ntp(first_packet->received, &received_msw, &received_lsw);
	put_unaligned_time24(rtcpheader + 16, received_msw, received_lsw);
	rtcpheader[19] = rtp->transport_wide_cc.feedback_count;

	/* The packet is now fully constructed so send it out */
	ast_sockaddr_copy(&remote_address, &rtp->rtcp->them);

	ast_debug_rtcp(2, "(%p) RTCP sending transport-cc feedback packet of size '%d' on '%s' with packet count of %d (small = %d, large = %d, lost = %d)\n",
		instance, packet_len, ast_rtp_instance_get_channel_id(instance), packet_count, small_delta_count, large_delta_count, lost_count);

	res = rtcp_sendto(instance, (unsigned int *)rtcpheader, packet_len, 0, &remote_address, &ice);
	if (res < 0) {
		ast_log(LOG_ERROR, "RTCP transport-cc feedback error to %s due to %s\n",
			ast_sockaddr_stringify(&remote_address), strerror(errno));
	}

	AST_VECTOR_RESET(&rtp->transport_wide_cc.packet_statistics, AST_VECTOR_ELEM_CLEANUP_NOOP);

	rtp->transport_wide_cc.feedback_count++;

	ao2_unlock(instance);

	return 1000;
}
