x509_verify_ctx_validate_legacy_chain(struct x509_verify_ctx *ctx,
    struct x509_verify_chain *chain, size_t depth)
{
	int ret = 0, trust;

	if (ctx->xsc == NULL)
		return 1;

	/*
	 * If we have a legacy xsc, choose a validated chain, and
	 * apply the extensions, revocation, and policy checks just
	 * like the legacy code did. We do this here instead of as
	 * building the chains to more easily support the callback and
	 * the bewildering array of VERIFY_PARAM knobs that are there
	 * for the fiddling.
	 */

	/* These may be set in one of the following calls. */
	ctx->xsc->error = X509_V_OK;
	ctx->xsc->error_depth = 0;

	trust = x509_vfy_check_trust(ctx->xsc);
	if (trust == X509_TRUST_REJECTED)
		goto err;

	if (!x509_verify_ctx_set_xsc_chain(ctx, chain, 0, 1))
		goto err;

	/*
	 * XXX currently this duplicates some work done in chain
	 * build, but we keep it here until we have feature parity
	 */
	if (!x509_vfy_check_chain_extensions(ctx->xsc))
		goto err;

#ifndef OPENSSL_NO_RFC3779
	if (!X509v3_asid_validate_path(ctx->xsc))
		goto err;

	if (!X509v3_addr_validate_path(ctx->xsc))
		goto err;
#endif

	if (!x509_constraints_chain(ctx->xsc->chain,
		&ctx->xsc->error, &ctx->xsc->error_depth)) {
		X509 *cert = sk_X509_value(ctx->xsc->chain, depth);
		if (!x509_verify_cert_error(ctx, cert,
			ctx->xsc->error_depth, ctx->xsc->error, 0))
			goto err;
	}

	if (!x509_vfy_check_revocation(ctx->xsc))
		goto err;

	if (!x509_vfy_check_policy(ctx->xsc))
		goto err;

	if ((!(ctx->xsc->param->flags & X509_V_FLAG_PARTIAL_CHAIN)) &&
	    trust != X509_TRUST_TRUSTED)
		goto err;

	ret = 1;

 err:
	/*
	 * The above checks may have set ctx->xsc->error and
	 * ctx->xsc->error_depth - save these for later on.
	 */
	if (ctx->xsc->error != X509_V_OK) {
		if (ctx->xsc->error_depth < 0 ||
		    ctx->xsc->error_depth >= X509_VERIFY_MAX_CHAIN_CERTS)
			return 0;
		chain->cert_errors[ctx->xsc->error_depth] =
		    ctx->xsc->error;
		ctx->error_depth = ctx->xsc->error_depth;
	}

	return ret;
}
