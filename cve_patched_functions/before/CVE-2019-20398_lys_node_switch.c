lys_node_switch(struct lys_node *node1, struct lys_node *node2)
{
    const size_t mem_size = 104;
    uint8_t mem[mem_size];
    size_t offset, size;

    assert((node1->module == node2->module) && ly_strequal(node1->name, node2->name, 1) && (node1->nodetype == node2->nodetype));

    /*
     * Initially, the nodes were really switched in the tree which
     * caused problems for some other nodes with pointers (augments, leafrefs, ...)
     * because their pointers were not being updated. Code kept in case there is
     * a use of it in future (it took some debugging to cover all the cases).

    * sibling next *
    if (node1->prev->next) {
        node1->prev->next = node2;
    }

    * sibling prev *
    if (node1->next) {
        node1->next->prev = node2;
    } else {
        for (child = node1->prev; child->prev->next; child = child->prev);
        child->prev = node2;
    }

    * next *
    node2->next = node1->next;
    node1->next = NULL;

    * prev *
    if (node1->prev != node1) {
        node2->prev = node1->prev;
    }
    node1->prev = node1;

    * parent child *
    if (node1->parent) {
        if (node1->parent->child == node1) {
            node1->parent->child = node2;
        }
    } else if (lys_main_module(node1->module)->data == node1) {
        lys_main_module(node1->module)->data = node2;
    }

    * parent *
    node2->parent = node1->parent;
    node1->parent = NULL;

    * child parent *
    LY_TREE_FOR(node1->child, child) {
        if (child->parent == node1) {
            child->parent = node2;
        }
    }

    * child *
    node2->child = node1->child;
    node1->child = NULL;
    */

    /* switch common node part */
    offset = 3 * sizeof(char *);
    size = sizeof(uint16_t) + 6 * sizeof(uint8_t) + sizeof(struct lys_ext_instance **) + sizeof(struct lys_iffeature *);
    memcpy(mem, ((uint8_t *)node1) + offset, size);
    memcpy(((uint8_t *)node1) + offset, ((uint8_t *)node2) + offset, size);
    memcpy(((uint8_t *)node2) + offset, mem, size);

    /* switch node-specific data */
    offset = sizeof(struct lys_node);
    switch (node1->nodetype) {
    case LYS_CONTAINER:
        size = sizeof(struct lys_node_container) - offset;
        break;
    case LYS_CHOICE:
        size = sizeof(struct lys_node_choice) - offset;
        break;
    case LYS_LEAF:
        size = sizeof(struct lys_node_leaf) - offset;
        break;
    case LYS_LEAFLIST:
        size = sizeof(struct lys_node_leaflist) - offset;
        break;
    case LYS_LIST:
        size = sizeof(struct lys_node_list) - offset;
        break;
    case LYS_ANYDATA:
    case LYS_ANYXML:
        size = sizeof(struct lys_node_anydata) - offset;
        break;
    case LYS_CASE:
        size = sizeof(struct lys_node_case) - offset;
        break;
    case LYS_INPUT:
    case LYS_OUTPUT:
        size = sizeof(struct lys_node_inout) - offset;
        break;
    case LYS_NOTIF:
        size = sizeof(struct lys_node_notif) - offset;
        break;
    case LYS_RPC:
    case LYS_ACTION:
        size = sizeof(struct lys_node_rpc_action) - offset;
        break;
    default:
        assert(0);
        LOGINT(node1->module->ctx);
        return;
    }
    assert(size <= mem_size);
    memcpy(mem, ((uint8_t *)node1) + offset, size);
    memcpy(((uint8_t *)node1) + offset, ((uint8_t *)node2) + offset, size);
    memcpy(((uint8_t *)node2) + offset, mem, size);

    /* typedefs were not copied to the backup node, so always reuse them,
     * in leaves/leaf-lists we must correct the type parent pointer */
    switch (node1->nodetype) {
    case LYS_CONTAINER:
        ((struct lys_node_container *)node1)->tpdf_size = ((struct lys_node_container *)node2)->tpdf_size;
        ((struct lys_node_container *)node1)->tpdf = ((struct lys_node_container *)node2)->tpdf;
        ((struct lys_node_container *)node2)->tpdf_size = 0;
        ((struct lys_node_container *)node2)->tpdf = NULL;
        break;
    case LYS_LIST:
        ((struct lys_node_list *)node1)->tpdf_size = ((struct lys_node_list *)node2)->tpdf_size;
        ((struct lys_node_list *)node1)->tpdf = ((struct lys_node_list *)node2)->tpdf;
        ((struct lys_node_list *)node2)->tpdf_size = 0;
        ((struct lys_node_list *)node2)->tpdf = NULL;
        break;
    case LYS_RPC:
    case LYS_ACTION:
        ((struct lys_node_rpc_action *)node1)->tpdf_size = ((struct lys_node_rpc_action *)node2)->tpdf_size;
        ((struct lys_node_rpc_action *)node1)->tpdf = ((struct lys_node_rpc_action *)node2)->tpdf;
        ((struct lys_node_rpc_action *)node2)->tpdf_size = 0;
        ((struct lys_node_rpc_action *)node2)->tpdf = NULL;
        break;
    case LYS_NOTIF:
        ((struct lys_node_notif *)node1)->tpdf_size = ((struct lys_node_notif *)node2)->tpdf_size;
        ((struct lys_node_notif *)node1)->tpdf = ((struct lys_node_notif *)node2)->tpdf;
        ((struct lys_node_notif *)node2)->tpdf_size = 0;
        ((struct lys_node_notif *)node2)->tpdf = NULL;
        break;
    case LYS_INPUT:
    case LYS_OUTPUT:
        ((struct lys_node_inout *)node1)->tpdf_size = ((struct lys_node_inout *)node2)->tpdf_size;
        ((struct lys_node_inout *)node1)->tpdf = ((struct lys_node_inout *)node2)->tpdf;
        ((struct lys_node_inout *)node2)->tpdf_size = 0;
        ((struct lys_node_inout *)node2)->tpdf = NULL;
        break;
    case LYS_LEAF:
    case LYS_LEAFLIST:
        ((struct lys_node_leaf *)node1)->type.parent = (struct lys_tpdf *)node1;
        ((struct lys_node_leaf *)node2)->type.parent = (struct lys_tpdf *)node2;
    default:
        break;
    }
}
