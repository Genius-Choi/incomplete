R_API void r_core_af(RCore *core, ut64 addr, const char *name, bool anal_calls) {
	int depth = r_config_get_i (core->config, "anal.depth");
	RAnalFunction *fcn = NULL;

	//r_core_anal_undefine (core, core->offset);
	r_core_anal_fcn (core, addr, UT64_MAX, R_ANAL_REF_TYPE_NULL, depth);
	fcn = r_anal_get_fcn_in (core->anal, addr, 0);
	if (fcn) {
		/* ensure we use a proper name */
		__setFunctionName (core, addr, fcn->name, false);
		if (core->anal->opt.vars) {
			r_core_recover_vars (core, fcn, true);
		}
		__add_vars_sdb (core, fcn);
	} else {
		if (core->anal->verbose) {
			eprintf ("Warning: Unable to analyze function at 0x%08"PFMT64x"\n", addr);
		}
	}
	if (anal_calls) {
		fcn = r_anal_get_fcn_in (core->anal, addr, 0); /// XXX wrong in case of nopskip
		if (fcn) {
			RAnalRef *ref;
			RListIter *iter;
			RList *refs = r_anal_function_get_refs (fcn);
			r_list_foreach (refs, iter, ref) {
				if (ref->addr == UT64_MAX) {
					//eprintf ("Warning: ignore 0x%08"PFMT64x" call 0x%08"PFMT64x"\n", ref->at, ref->addr);
					continue;
				}
				if (ref->type != R_ANAL_REF_TYPE_CODE && ref->type != R_ANAL_REF_TYPE_CALL) {
					/* only follow code/call references */
					continue;
				}
				if (!r_io_is_valid_offset (core->io, ref->addr, !core->anal->opt.noncode)) {
					continue;
				}
				r_core_anal_fcn (core, ref->addr, fcn->addr, R_ANAL_REF_TYPE_CALL, depth - 1);
				/* use recursivity here */
#if 1
				RAnalFunction *f = r_anal_get_function_at (core->anal, ref->addr);
				if (f) {
					RListIter *iter;
					RAnalRef *ref;
					RList *refs1 = r_anal_function_get_refs (f);
					r_list_foreach (refs1, iter, ref) {
						if (!r_io_is_valid_offset (core->io, ref->addr, !core->anal->opt.noncode)) {
							continue;
						}
						if (ref->type != 'c' && ref->type != 'C') {
							continue;
						}
						r_core_anal_fcn (core, ref->addr, f->addr, R_ANAL_REF_TYPE_CALL, depth - 1);
						// recursively follow fcn->refs again and again
					}
					r_list_free (refs1);
				} else {
					f = r_anal_get_fcn_in (core->anal, fcn->addr, 0);
					if (f) {
						/* cut function */
						r_anal_function_resize (f, addr - fcn->addr);
						r_core_anal_fcn (core, ref->addr, fcn->addr, R_ANAL_REF_TYPE_CALL, depth - 1);
						f = r_anal_get_function_at (core->anal, fcn->addr);
					}
					if (!f) {
						eprintf ("af: Cannot find function at 0x%08" PFMT64x "\n", fcn->addr);
					}
				}
#endif
			}
			r_list_free (refs);
			if (core->anal->opt.vars) {
				r_core_recover_vars (core, fcn, true);
			}
		}
	}
	if (name) {
		if (*name && !__setFunctionName (core, addr, name, true)) {
			eprintf ("af: Cannot find function at 0x%08" PFMT64x "\n", addr);
		}
	}
#if SLOW_ANALYSIS
	// r_core_anal_propagate_noreturn (core, addr);
#if 0
	// XXX THIS IS VERY SLOW
	if (core->anal->opt.vars) {
		RListIter *iter;
		RAnalFunction *fcni = NULL;
		r_list_foreach (core->anal->fcns, iter, fcni) {
			if (r_cons_is_breaked ()) {
				break;
			}
			r_core_recover_vars (core, fcni, true);
		}
	}
#endif
//	flag_every_function (core);
#endif
}
