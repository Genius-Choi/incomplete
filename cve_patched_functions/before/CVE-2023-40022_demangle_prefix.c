demangle_prefix(work, mangled, declp)
struct work_stuff *work;
const char **mangled;
string *declp;
{
	int success = 1;
	const char *scan;
	int i;

	if (strlen(*mangled) > 6 && (strncmp(*mangled, "_imp__", 6) == 0 || strncmp(*mangled, "__imp_", 6) == 0)) {
		/* it's a symbol imported from a PE dynamic library. Check for both
		   new style prefix _imp__ and legacy __imp_ used by older versions
		   of dlltool. */
		(*mangled) += 6;
		work->dllimported = 1;
	} else if (strlen(*mangled) >= 11 && strncmp(*mangled, "_GLOBAL_", 8) == 0) {
		char *marker = strchr(cplus_markers, (*mangled)[8]);
		if (marker != NULL && *marker == (*mangled)[10]) {
			if ((*mangled)[9] == 'D') {
				/* it's a GNU global destructor to be executed at program exit */
				(*mangled) += 11;
				work->destructor = 2;
				if (gnu_special(work, mangled, declp))
					return success;
			} else if ((*mangled)[9] == 'I') {
				/* it's a GNU global constructor to be executed at program init */
				(*mangled) += 11;
				work->constructor = 2;
				if (gnu_special(work, mangled, declp))
					return success;
			}
		}
	} else if ((ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) && strncmp(*mangled, "__std__", 7) == 0) {
		/* it's a ARM global destructor to be executed at program exit */
		(*mangled) += 7;
		work->destructor = 2;
	} else if ((ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) && strncmp(*mangled, "__sti__", 7) == 0) {
		/* it's a ARM global constructor to be executed at program initial */
		(*mangled) += 7;
		work->constructor = 2;
	}

	/*  This block of code is a reduction in strength time optimization
	    of:
	    scan = mystrstr (*mangled, "__"); */

	{
		scan = *mangled;

		do {
			scan = strchr(scan, '_');
		} while (scan != NULL && *++scan != '_');

		if (scan != NULL)
			--scan;
	}

	if (scan != NULL) {
		/* We found a sequence of two or more '_', ensure that we start at
		   the last pair in the sequence.  */
		i = strspn(scan, "_");
		if (i > 2) {
			scan += (i - 2);
		}
	}

	if (scan == NULL) {
		success = 0;
	} else if (work->static_type) {
		if (!isdigit((unsigned char)scan[0]) && (scan[0] != 't')) {
			success = 0;
		}
	} else if ((scan == *mangled) && (isdigit((unsigned char)scan[2]) || (scan[2] == 'Q') || (scan[2] == 't') || (scan[2] == 'K') || (scan[2] == 'H'))) {
		/* The ARM says nothing about the mangling of local variables.
		   But cfront mangles local variables by prepending __<nesting_level>
		   to them. As an extension to ARM demangling we handle this case.  */
		if ((LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING) && isdigit((unsigned char)scan[2])) {
			*mangled = scan + 2;
			consume_count(mangled);
			string_append(declp, *mangled);
			*mangled += strlen(*mangled);
			success = 1;
		} else {
			/* A GNU style constructor starts with __[0-9Qt].  But cfront uses
			   names like __Q2_3foo3bar for nested type names.  So don't accept
			   this style of constructor for cfront demangling.  A GNU
			   style member-template constructor starts with 'H'. */
			if (!(LUCID_DEMANGLING || ARM_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING))
				work->constructor += 1;
			*mangled = scan + 2;
		}
	} else if (ARM_DEMANGLING && scan[2] == 'p' && scan[3] == 't') {
		/* Cfront-style parameterized type.  Handled later as a signature. */
		success = 1;

		/* ARM template? */
		demangle_arm_hp_template(work, mangled, strlen(*mangled), declp);
	} else if (EDG_DEMANGLING && ((scan[2] == 't' && scan[3] == 'm') || (scan[2] == 'p' && scan[3] == 's') || (scan[2] == 'p' && scan[3] == 't'))) {
		/* EDG-style parameterized type.  Handled later as a signature. */
		success = 1;

		/* EDG template? */
		demangle_arm_hp_template(work, mangled, strlen(*mangled), declp);
	} else if ((scan == *mangled) && !isdigit((unsigned char)scan[2]) && (scan[2] != 't')) {
		/* Mangled name starts with "__".  Skip over any leading '_' characters,
		   then find the next "__" that separates the prefix from the signature.
		   */
		if (!(ARM_DEMANGLING || LUCID_DEMANGLING || HP_DEMANGLING || EDG_DEMANGLING) || (arm_special(mangled, declp) == 0)) {
			while (*scan == '_') {
				scan++;
			}
			if ((scan = mystrstr(scan, "__")) == NULL || (*(scan + 2) == '\0')) {
				/* No separator (I.E. "__not_mangled"), or empty signature
				   (I.E. "__not_mangled_either__") */
				success = 0;
			} else {
				const char *tmp;

				/* Look for the LAST occurrence of __, allowing names to
				   have the '__' sequence embedded in them. */
				if (!(ARM_DEMANGLING || HP_DEMANGLING)) {
					while ((tmp = mystrstr(scan + 2, "__")) != NULL)
						scan = tmp;
				}
				if (*(scan + 2) == '\0')
					success = 0;
				else
					demangle_function_name(work, mangled, declp, scan);
			}
		}
	} else if (*(scan + 2) != '\0') {
		/* Mangled name does not start with "__" but does have one somewhere
		   in there with non empty stuff after it.  Looks like a global
		   function name.  */
		demangle_function_name(work, mangled, declp, scan);
	} else {
		/* Doesn't look like a mangled name */
		success = 0;
	}

	if (!success && (work->constructor == 2 || work->destructor == 2)) {
		string_append(declp, *mangled);
		*mangled += strlen(*mangled);
		success = 1;
	}
	return (success);
}
