static size_t fio_tls_handshake(intptr_t uuid, void *udata) {
  fio_tls_connection_s *c = udata;
  int ri;
  if (c->is_server) {
    ri = SSL_accept(c->ssl);
  } else {
    ri = SSL_connect(c->ssl);
  }
  if (ri != 1) {
    ri = SSL_get_error(c->ssl, ri);
    switch (ri) {
    case SSL_ERROR_NONE:
      // FIO_LOG_DEBUG("SSL_accept/SSL_connect %p state: SSL_ERROR_NONE",
      //               (void *)uuid);
      return 0;
    case SSL_ERROR_WANT_WRITE:
      // FIO_LOG_DEBUG("SSL_accept/SSL_connect %p state: SSL_ERROR_WANT_WRITE",
      //               (void *)uuid);
      //   fio_force_event(uuid, FIO_EVENT_ON_READY);
      return 0;
    case SSL_ERROR_WANT_READ:
      // FIO_LOG_DEBUG("SSL_accept/SSL_connect %p state: SSL_ERROR_WANT_READ",
      //               (void *)uuid);
      // fio_force_event(uuid, FIO_EVENT_ON_DATA);
      return 0;
    case SSL_ERROR_SYSCALL:
      FIO_LOG_DEBUG(
          "SSL_accept/SSL_connect %p error: SSL_ERROR_SYSCALL, errno: %s",
          (void *)uuid, strerror(errno));
      // fio_force_event(uuid, FIO_EVENT_ON_DATA);
      return 0;
    case SSL_ERROR_SSL:
      FIO_LOG_DEBUG("SSL_accept/SSL_connect %p error: SSL_ERROR_SSL",
                    (void *)uuid);
      break;
    case SSL_ERROR_ZERO_RETURN:
      FIO_LOG_DEBUG("SSL_accept/SSL_connect %p error: SSL_ERROR_ZERO_RETURN",
                    (void *)uuid);
      break;
    case SSL_ERROR_WANT_CONNECT:
      FIO_LOG_DEBUG("SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_CONNECT",
                    (void *)uuid);
      break;
    case SSL_ERROR_WANT_ACCEPT:
      FIO_LOG_DEBUG("SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_ACCEPT",
                    (void *)uuid);
      break;
    case SSL_ERROR_WANT_X509_LOOKUP:
      FIO_LOG_DEBUG(
          "SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_X509_LOOKUP",
          (void *)uuid);
      break;
#ifdef SSL_ERROR_WANT_ASYNC
    case SSL_ERROR_WANT_ASYNC:
      FIO_LOG_DEBUG("SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_ASYNC",
                    (void *)uuid);
      break;
#endif
#ifdef SSL_ERROR_WANT_CLIENT_HELLO_CB
    case SSL_ERROR_WANT_CLIENT_HELLO_CB:
      FIO_LOG_DEBUG(
          "SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_CLIENT_HELLO_CB",
          (void *)uuid);
      break;
#endif
    default:
      FIO_LOG_DEBUG("SSL_accept/SSL_connect %p error: unknown (%d).",
                    (void *)uuid, ri);
      break;
    }
    fio_defer(fio_tls_delayed_close, (void *)uuid, NULL);
    return 0;
  }
  if (!c->alpn_ok) {
    c->alpn_ok = 1;
    if (c->is_server) {
      fio_tls_alpn_fallback(c);
    } else {
      const unsigned char *proto;
      unsigned int proto_len;
      SSL_get0_alpn_selected(c->ssl, &proto, &proto_len);
      alpn_s *alpn = NULL;
      if (proto_len > 0) {
        alpn = alpn_find(c->tls, (char *)proto, proto_len);
      }
      if (!alpn) {
        alpn = alpn_default(c->tls);
        FIO_LOG_DEBUG("ALPN missing for TLS client %p", (void *)uuid);
      }
      if (alpn)
        FIO_LOG_DEBUG("setting ALPN %s for TLS client %p",
                      fio_str_data(&alpn->name), (void *)uuid);
      alpn_select(alpn, c->uuid, c->alpn_arg);
    }
  }
  if (fio_rw_hook_replace_unsafe(uuid, &FIO_TLS_HOOKS, udata) == 0) {
    FIO_LOG_DEBUG("Completed TLS handshake for %p", (void *)uuid);
  } else {
    FIO_LOG_DEBUG("Something went wrong during TLS handshake for %p",
                  (void *)uuid);
    return 0;
  }
  /* make sure the connection is re-added to the reactor */
  fio_force_event(uuid, FIO_EVENT_ON_DATA);
  /* log session ID for WireShark */
#if FIO_TLS_PRINT_SECRET
  if (FIO_LOG_LEVEL >= FIO_LOG_LEVEL_DEBUG) {
    unsigned char buff[SSL_MAX_MASTER_KEY_LENGTH + 2];
    size_t ret = SSL_SESSION_get_master_key(SSL_get_session(c->ssl), buff,
                                            SSL_MAX_MASTER_KEY_LENGTH + 1);
    buff[ret] = 0;
    unsigned char buff2[(SSL_MAX_MASTER_KEY_LENGTH + 2) << 1];
    for (size_t i = 0; i < ret; ++i) {
      buff2[i] = ((buff[i] >> 4) >= 10) ? ('A' + (buff[i] >> 4) - 10)
                                        : ('0' + (buff[i] >> 4));
      buff2[i + 1] = ((buff[i] & 15) >= 10) ? ('A' + (buff[i] & 15) - 10)
                                            : ('0' + (buff[i] & 15));
    }
    buff2[(ret << 1)] = 0;
    FIO_LOG_DEBUG("OpenSSL Master Key for uuid %p:\n\t\t%s", (void *)uuid,
                  buff2);
  }
#endif
  return 1;
}
