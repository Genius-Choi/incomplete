struct cil_list *__cil_ordered_lists_merge_all(struct cil_list **ordered_lists, struct cil_list **unordered_lists)
{
	struct cil_list *composite = NULL;
	struct cil_list_item *curr = NULL;
	int changed = CIL_TRUE;
	int waiting = 1;
	int rc = SEPOL_ERR;

	cil_list_init(&composite, CIL_LIST_ITEM);

	while (waiting && changed == CIL_TRUE) {
		changed = CIL_FALSE;
		waiting = 0;
		cil_list_for_each(curr, *ordered_lists) {
			struct cil_ordered_list *ordered_list = curr->data;
			if (ordered_list->merged == CIL_FALSE) {
				rc = __cil_ordered_lists_merge(composite, ordered_list->list);
				if (rc != SEPOL_OK) {
					/* Can't merge yet */
					waiting++;
				} else {
					ordered_list->merged = CIL_TRUE;
					changed = CIL_TRUE;
				}
			}
		}
		if (waiting > 0 && changed == CIL_FALSE) {
			cil_list_for_each(curr, *ordered_lists) {
				struct cil_ordered_list *ordered_list = curr->data;
				if (ordered_list->merged == CIL_FALSE) {
					cil_tree_log(ordered_list->node, CIL_ERR, "Unable to merge ordered list");
				}
			}
			goto exit;
		}
	}

	if (unordered_lists != NULL) {
		rc = insert_unordered(composite, *unordered_lists);
		if (rc != SEPOL_OK) {
			goto exit;
		}
	}

	__cil_ordered_lists_destroy(ordered_lists);
	__cil_ordered_lists_destroy(unordered_lists);

	return composite;

exit:
	__cil_ordered_lists_destroy(ordered_lists);
	__cil_ordered_lists_destroy(unordered_lists);
	cil_list_destroy(&composite, CIL_FALSE);
	return NULL;
}
