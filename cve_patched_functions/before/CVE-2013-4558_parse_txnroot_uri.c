parse_txnroot_uri(dav_resource_combined *comb,
                  const char *path,
                  const char *label,
                  int use_checked_in)
{
  /* format: !svn/txr/TXN_NAME/[PATH]

     In HTTP protocol v2, this represents a path within a specific
     uncommitted transaction.  Clients perform PUT, COPY, DELETE, MOVE
     against it to modify the path.
   */
  const char *slash;

  /* Note that we're calling this a WORKING resource, rather than
     PRIVATE, so that we can let prep_working() do the same work for
     us that it does on DeltaV 'working resources'.  */
  comb->res.type = DAV_RESOURCE_TYPE_WORKING;

  /* ...but setting this restype can let parse_working() know whether
     this is a !svn/wrk/ (DeltaV) or a !svn/txr (protocol v2) */
  comb->priv.restype = DAV_SVN_RESTYPE_TXNROOT_COLLECTION;
  comb->res.working = TRUE;
  comb->res.versioned = TRUE;

  slash = ap_strchr_c(path, '/');

  /* This sucker starts with a slash.  That's bogus. */
  if (slash == path)
    return TRUE;

  if (slash == NULL)
    {
      /* There's no slash character in our path.  Assume it's just an
         TXN_NAME pointing to the root path.  That should be cool.
         We'll just drop through to the normal case handling below. */
      comb->priv.root.txn_name = apr_pstrdup(comb->res.pool, path);
      comb->priv.repos_path = "/";
    }
  else
    {
      comb->priv.root.txn_name = apr_pstrndup(comb->res.pool, path,
                                              slash - path);
      comb->priv.repos_path = slash;
    }

  return FALSE;
}
