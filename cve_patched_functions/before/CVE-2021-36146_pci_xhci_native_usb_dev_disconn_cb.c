pci_xhci_native_usb_dev_disconn_cb(void *hci_data, void *dev_data)
{
	struct pci_xhci_vdev *xdev;
	struct pci_xhci_dev_emu *edev;
	struct usb_native_devinfo *di;
	uint8_t vport, slot;
	uint16_t state;
	int need_intr = 1;
	int index;
	int rc;
	int i;

	xdev = hci_data;
	di = dev_data;
	if (!pci_xhci_is_valid_portnum(ROOTHUB_PORT(di->path))) {
		UPRINTF(LFTL, "invalid physical port %d\r\n",
				ROOTHUB_PORT(di->path));
		return -1;
	}

	index = pci_xhci_get_native_port_index_by_path(xdev, &di->path);
	if (index < 0) {
		UPRINTF(LFTL, "fail to find physical port %d\r\n",
				ROOTHUB_PORT(di->path));
		return -1;
	}

	if (di->type == USB_TYPE_EXTHUB) {
		rc = pci_xhci_unassign_hub_ports(xdev, di);
		if (rc < 0)
			UPRINTF(LFTL, "fail to unassign the ports of hub"
					" %d-%s\r\n", di->path.bus,
					usb_dev_path(&di->path));
		return 0;
	}

	state = xdev->native_ports[index].state;
	vport = xdev->native_ports[index].vport;

	if (state == VPORT_CONNECTED && vport > 0) {
		/*
		 * When this place is reached, it means the physical
		 * USB device is disconnected before the emulation
		 * procedure is started. The related states should be
		 * cleared for future connecting.
		 */
		UPRINTF(LFTL, "disconnect VPORT_CONNECTED device: "
				"%d-%s vport %d\r\n", di->path.bus,
				usb_dev_path(&di->path), vport);
		pci_xhci_disconnect_port(xdev, vport, 0);
		xdev->native_ports[index].state = VPORT_ASSIGNED;
		return 0;
	}

	edev = xdev->devices[vport];
	for (slot = 1; slot <= XHCI_MAX_SLOTS; ++slot)
		if (xdev->slots[slot] == edev)
			break;

	for (i = 0; xdev->vbdp_dev_num && i < XHCI_MAX_VIRT_PORTS; ++i) {
		if (xdev->vbdp_devs[i].state != S3_VBDP_START)
			continue;

		if (!usb_dev_path_cmp(&xdev->vbdp_devs[i].path, &di->path))
			continue;

		/*
		 * we do nothing here for device that is in the middle of
		 * S3 resuming process.
		 */
		UPRINTF(LINF, "disconnect device %d-%s on vport %d with "
				"state %d and return.\r\n", di->path.bus,
				usb_dev_path(&di->path), vport, state);
		return 0;
	}

	if (!(state == VPORT_EMULATED || state == VPORT_CONNECTED))
		UPRINTF(LFTL, "error: unexpected state %d\r\n", state);

	xdev->native_ports[index].state = VPORT_ASSIGNED;
	xdev->native_ports[index].vport = 0;

	UPRINTF(LINF, "disconnect device %d-%s on vport %d with state %d\r\n",
			di->path.bus, usb_dev_path(&di->path), vport, state);
	if (pci_xhci_disconnect_port(xdev, vport, need_intr)) {
		UPRINTF(LFTL, "fail to report event\r\n");
		return -1;
	}

	/*
	 * At this point, the resources allocated for virtual device
	 * should not be released, it should be released in the
	 * pci_xhci_cmd_disable_slot function.
	 */
	return 0;
}
