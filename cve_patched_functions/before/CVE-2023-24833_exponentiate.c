OperationStatus exponentiate(
    MutableBigIntRef dst,
    ImmutableBigIntRef lhs,
    ImmutableBigIntRef rhs) {
  if (compare(rhs, 0) < 0) {
    return OperationStatus::NEGATIVE_EXPONENT;
  }

  // |rhs| is limited to the BigInt's maximum number of digits when |lhs| >= 2.
  // Therefore, to simplify the code, a copy of rhs' first digit is made on a
  // scalar that's large enough to fit said max exponent.
  static constexpr auto maxExponent = BigIntMaxSizeInBits;
  const uint32_t exponent = rhs.numDigits ? rhs.digits[0] : 0;
  // sanity-check: ensure the max bigint exponent when |lhs| >= 2 first
  // exponent.
  static_assert(
      maxExponent <= std::numeric_limits<decltype(exponent)>::max(),
      "exponent is too large");

  // Avoid exponentiate's slow path by special handling the easy cases (e.g.,
  // 0 ** y, x ** 0, x ** 1, 1 ** x).
  OperationStatus res = OperationStatus::RETURNED;
  if (compare(rhs, 0) == 0) {
    // lhs ** 0 => 1, for all lhs
    // N.B.: JS defines 0n ** 0n == 1.
    if (dst.numDigits < 1) {
      res = OperationStatus::DEST_TOO_SMALL;
    } else {
      dst.numDigits = 1;
      dst.digits[0] = 1;
    }
  } else if (compare(lhs, 0) == 0) {
    // 0 ** rhs => 0, for rhs > 0
    dst.numDigits = 0;
  } else if (dst.numDigits < 1) {
    // |lhs| != 0, rhs > 0 =>  |result| != 0, i.e., the result requires at least
    // one digit.
    res = OperationStatus::DEST_TOO_SMALL;
  } else if (compare(lhs, 1) == 0) {
    // 1 ** rhs => 1, for all rhs
    assert(rhs.numDigits > 0 && "should have handled 0n");
    dst.numDigits = 1;
    dst.digits[0] = 1;
  } else if (compare(lhs, -1) == 0) {
    // -1 ** rhs => 1, for even rhs, -1 for odd
    assert(rhs.numDigits > 0 && "should have handled 0n");
    dst.numDigits = 1;
    // Note that rhs > 0, therefore rhs % 2n === exponent % 2.
    dst.digits[0] = (exponent % 2 == 0) ? 1ull : -1ull;
  } else if (rhs.numDigits > 1 || exponent >= maxExponent) {
    // Exponent is too large, hence the result would be too big.
    res = OperationStatus::TOO_MANY_DIGITS;
  } else if (exponent == 1) {
    // lhs ** 1n => lhs, for any lhs
    res = initWithDigits(dst, lhs);
  } else if (compare(lhs, 2) == 0) {
    // Fast-path for 2n ** rhs
    res = exponentiatePowerOf2(dst, exponent);
  } else if (compare(lhs, -2) == 0) {
    // Fast-path for -2n ** rhs
    res = exponentiatePowerOf2(dst, exponent);
    if (exponent % 2 != 0) {
      llvh::APInt::tcNegate(dst.digits, dst.numDigits);
    }
  } else {
    // Slow path
    res = exponentiateSlowPath(dst, lhs, exponent);
  }

  if (LLVM_UNLIKELY(res != OperationStatus::RETURNED)) {
    return res;
  }

  ensureCanonicalResult(dst);
  return OperationStatus::RETURNED;
}
