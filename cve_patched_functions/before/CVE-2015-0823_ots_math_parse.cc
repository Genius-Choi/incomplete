bool ots_math_parse(OpenTypeFile *file, const uint8_t *data, size_t length) {
  // Grab the number of glyphs in the file from the maxp table to check
  // GlyphIDs in MATH table.
  if (!file->maxp) {
    return OTS_FAILURE();
  }
  const uint16_t num_glyphs = file->maxp->num_glyphs;

  Buffer table(data, length);

  OpenTypeMATH* math = new OpenTypeMATH;
  file->math = math;

  uint32_t version = 0;
  if (!table.ReadU32(&version)) {
    return OTS_FAILURE();
  }
  if (version != 0x00010000) {
    DROP_THIS_TABLE("bad MATH version");
    return true;
  }

  uint16_t offset_math_constants = 0;
  uint16_t offset_math_glyph_info = 0;
  uint16_t offset_math_variants = 0;
  if (!table.ReadU16(&offset_math_constants) ||
      !table.ReadU16(&offset_math_glyph_info) ||
      !table.ReadU16(&offset_math_variants)) {
    return OTS_FAILURE();
  }

  if (offset_math_constants >= length ||
      offset_math_constants < kMathHeaderSize ||
      offset_math_glyph_info >= length ||
      offset_math_glyph_info < kMathHeaderSize ||
      offset_math_variants >= length ||
      offset_math_variants < kMathHeaderSize) {
    DROP_THIS_TABLE("bad offset in MATH header");
    return true;
  }

  if (!ParseMathConstantsTable(file, data + offset_math_constants,
                               length - offset_math_constants)) {
    DROP_THIS_TABLE("failed to parse MathConstants table");
    return true;
  }
  if (!ParseMathGlyphInfoTable(file, data + offset_math_glyph_info,
                               length - offset_math_glyph_info, num_glyphs)) {
    DROP_THIS_TABLE("failed to parse MathGlyphInfo table");
    return true;
  }
  if (!ParseMathVariantsTable(file, data + offset_math_variants,
                              length - offset_math_variants, num_glyphs)) {
    DROP_THIS_TABLE("failed to parse MathVariants table");
    return true;
  }

  math->data = data;
  math->length = length;
  return true;
}
