callout_function(pcre2_callout_block_8 *cb, void *callout_data_ptr)
{
FILE *f, *fdefault;
uint32_t i, pre_start, post_start, subject_length;
PCRE2_SIZE current_position;
BOOL utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;
BOOL callout_capture = (dat_datctl.control & CTL_CALLOUT_CAPTURE) != 0;
BOOL callout_where = (dat_datctl.control2 & CTL2_CALLOUT_NO_WHERE) == 0;

/* The FILE f is used for echoing the subject string if it is non-NULL. This
happens only once in simple cases, but we want to repeat after any additional
output caused by CALLOUT_EXTRA. */

fdefault = (!first_callout && !callout_capture && cb->callout_string == NULL)?
  NULL : outfile;

if ((dat_datctl.control2 & CTL2_CALLOUT_EXTRA) != 0)
  {
  f = outfile;
  switch (cb->callout_flags)
    {
    case PCRE2_CALLOUT_BACKTRACK:
    fprintf(f, "Backtrack\n");
    break;

    case PCRE2_CALLOUT_STARTMATCH|PCRE2_CALLOUT_BACKTRACK:
    fprintf(f, "Backtrack\nNo other matching paths\n");
    /* Fall through */

    case PCRE2_CALLOUT_STARTMATCH:
    fprintf(f, "New match attempt\n");
    break;

    default:
    f = fdefault;
    break;
    }
  }
else f = fdefault;

/* For a callout with a string argument, show the string first because there
isn't a tidy way to fit it in the rest of the data. */

if (cb->callout_string != NULL)
  {
  uint32_t delimiter = CODE_UNIT(cb->callout_string, -1);
  fprintf(outfile, "Callout (%" SIZ_FORM "): %c",
    cb->callout_string_offset, delimiter);
  PCHARSV(cb->callout_string, 0,
    cb->callout_string_length, utf, outfile);
  for (i = 0; callout_start_delims[i] != 0; i++)
    if (delimiter == callout_start_delims[i])
      {
      delimiter = callout_end_delims[i];
      break;
      }
  fprintf(outfile, "%c", delimiter);
  if (!callout_capture) fprintf(outfile, "\n");
  }

/* Show captured strings if required */

if (callout_capture)
  {
  if (cb->callout_string == NULL)
    fprintf(outfile, "Callout %d:", cb->callout_number);
  fprintf(outfile, " last capture = %d\n", cb->capture_last);
  for (i = 2; i < cb->capture_top * 2; i += 2)
    {
    fprintf(outfile, "%2d: ", i/2);
    if (cb->offset_vector[i] == PCRE2_UNSET)
      fprintf(outfile, "<unset>");
    else
      {
      PCHARSV(cb->subject, cb->offset_vector[i],
        cb->offset_vector[i+1] - cb->offset_vector[i], utf, f);
      }
    fprintf(outfile, "\n");
    }
  }

/* Unless suppressed, re-print the subject in canonical form (with escapes for
non-printing characters), the first time, or if giving full details. On
subsequent calls in the same match, we use PCHARS() just to find the printed
lengths of the substrings. */

if (callout_where)
  {
  if (f != NULL) fprintf(f, "--->");

  /* The subject before the match start. */

  PCHARS(pre_start, cb->subject, 0, cb->start_match, utf, f);

  /* If a lookbehind is involved, the current position may be earlier than the
  match start. If so, use the match start instead. */

  current_position = (cb->current_position >= cb->start_match)?
    cb->current_position : cb->start_match;

  /* The subject between the match start and the current position. */

  PCHARS(post_start, cb->subject, cb->start_match,
    current_position - cb->start_match, utf, f);

  /* Print from the current position to the end. */

  PCHARSV(cb->subject, current_position, cb->subject_length - current_position,
    utf, f);

  /* Calculate the total subject printed length (no print). */

  PCHARS(subject_length, cb->subject, 0, cb->subject_length, utf, NULL);

  if (f != NULL) fprintf(f, "\n");

  /* For automatic callouts, show the pattern offset. Otherwise, for a
  numerical callout whose number has not already been shown with captured
  strings, show the number here. A callout with a string argument has been
  displayed above. */

  if (cb->callout_number == 255)
    {
    fprintf(outfile, "%+3d ", (int)cb->pattern_position);
    if (cb->pattern_position > 99) fprintf(outfile, "\n    ");
    }
  else
    {
    if (callout_capture || cb->callout_string != NULL) fprintf(outfile, "    ");
      else fprintf(outfile, "%3d ", cb->callout_number);
    }

  /* Now show position indicators */

  for (i = 0; i < pre_start; i++) fprintf(outfile, " ");
  fprintf(outfile, "^");

  if (post_start > 0)
    {
    for (i = 0; i < post_start - 1; i++) fprintf(outfile, " ");
    fprintf(outfile, "^");
    }

  for (i = 0; i < subject_length - pre_start - post_start + 4; i++)
    fprintf(outfile, " ");

  if (cb->next_item_length != 0)
    fprintf(outfile, "%.*s", (int)(cb->next_item_length),
      pbuffer8 + cb->pattern_position);
  else
    fprintf(outfile, "End of pattern");

  fprintf(outfile, "\n");
  }

first_callout = FALSE;

/* Show any mark info */

if (cb->mark != last_callout_mark)
  {
  if (cb->mark == NULL)
    fprintf(outfile, "Latest Mark: <unset>\n");
  else
    {
    fprintf(outfile, "Latest Mark: ");
    PCHARSV(cb->mark, -1, -1, utf, outfile);
    putc('\n', outfile);
    }
  last_callout_mark = cb->mark;
  }

/* Show callout data */

if (callout_data_ptr != NULL)
  {
  int callout_data = *((int32_t *)callout_data_ptr);
  if (callout_data != 0)
    {
    fprintf(outfile, "Callout data = %d\n", callout_data);
    return callout_data;
    }
  }

/* Keep count and give the appropriate return code */

callout_count++;

if (cb->callout_number == dat_datctl.cerror[0] &&
    callout_count >= dat_datctl.cerror[1])
  return PCRE2_ERROR_CALLOUT;

if (cb->callout_number == dat_datctl.cfail[0] &&
    callout_count >= dat_datctl.cfail[1])
  return 1;

return 0;
}
