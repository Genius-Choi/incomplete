unsigned int prep_reassemble_body_parts( struct sip_msg* msg,
												struct socket_info* send_sock)
{
	struct body_part *part;
	struct lump* lump;
	struct lump* ct;
	unsigned int size;
	unsigned int len = 0;
	unsigned int orig_offs;
	struct hdr_field hf;
	char *hdr, *it;

	/* set the offset (in the original buffer) at the beginning of the body */
	orig_offs = msg->body->part_count ? msg->body->body.s-msg->buf : msg->len ;

	if (msg->body->updated_part_count==0) {

		/* no body to be placed in the new msg !
		 * simply skip the entire body */
		LM_DBG("no part to be added\n");

		/* Remove Content-Type hdr if present */
		if (msg->content_type && msg->content_type->name.s
		&& msg->content_type->name.len
		&& del_lump(msg, msg->content_type->name.s- msg->buf,
		msg->content_type->len, HDR_CONTENTTYPE_T)==0) {
			LM_ERR("failed to add lump to delete content type header\n");
		}

	} else if (msg->body->updated_part_count==1) {

		/* there is only one part to be added, so iterate
		 * and find it */
		LM_DBG("only one part to be added\n");

		for( part=&msg->body->first ; part ; part=part->next)
			if ( (part->flags & SIP_BODY_PART_FLAG_DELETED)==0 ) break;

		if (part==NULL) {
			LM_BUG("updated count is 1, but no non-deleted part found :-/\n");
			return len /* 0 */;
		}

		LM_DBG("handing part with flags %x, mime %.*s, dump function %p\n",
			part->flags, part->mime_s.len, part->mime_s.s, part->dump_f);

		if (part->dump_f) {
			/* trigger the the dump function link the resulting buffer
			 * as 'dump' (and to be used and freed when the body buffer
			 * is actually built) */
			if (part->dump_f( part->parsed ,msg, &part->dump)<0) {
				LM_ERR("failed to build part, inserting empty\n");
				part->dump.s = "";
				part->dump.len = 0;
			} else
				len += part->dump.len;
		} else {
			if ( part->flags & SIP_BODY_PART_FLAG_NEW ) {
				/* simpy copy the body of the part */
				len += part->body.len;
			} else {
				/* this is one part that was received (so potentially
				 * modified during runtime) -> apply all body lumps
				 * inside this part */
				orig_offs = part->body.s - msg->buf;
				lump = msg->body_lumps;
				while ( lump && lump->u.offset<(part->body.s-msg->buf) )
					lump=lump->next;
				if (lump) {
					LM_DBG("lumps found in the part, applying...\n");
					len += lumps_len( msg, lump, send_sock, 
						part->body.s+part->body.len-msg->buf);
				}
				/* and copy whatever is left, all the way to the end of part */
				len += (part->body.s+part->body.len-msg->buf)-orig_offs;
			}
		}

		/* if the part is new (0->1 addition or 1->1 replacement) or
		 * if the part is kept from a stipped multi-part  (n->1)
		 *   =>  replace the msg content-type with the new one */
		if ( (part->flags & SIP_BODY_PART_FLAG_NEW)
		|| msg->body->part_count>1 ) {
			/* replace the Content-Type hdr */
			if (msg->content_type)
				ct = del_lump(msg, msg->content_type->name.s-msg->buf,
					msg->content_type->len, HDR_CONTENTTYPE_T);
			else
				ct = anchor_lump(msg, msg->unparsed - msg->buf,
					HDR_CONTENTTYPE_T);
			if (ct==NULL) {
				LM_ERR("failed to remove old CT / create anchor\n");
			} else {
				/* if a new part, we need to build the CT header; if a 
				 * received part, simply copied from the part */
				if (part->flags & SIP_BODY_PART_FLAG_NEW) {
					hdr = (char*)pkg_malloc( 14 + part->mime_s.len +CRLF_LEN +
						part->headers.len);
					if (hdr==NULL) {
						LM_ERR("failed to allocate new ct hdr\n");
					} else {
						memcpy( hdr, "Content-Type: ", 14);
						memcpy( hdr+14, part->mime_s.s, part->mime_s.len);
						memcpy( hdr+14+part->mime_s.len, CRLF, CRLF_LEN);
						if (part->headers.len)
							memcpy( hdr+14+part->mime_s.len+CRLF_LEN,
								part->headers.s, part->headers.len);
						if (insert_new_lump_before(ct, hdr,
						14+part->mime_s.len+CRLF_LEN+part->headers.len,
						HDR_CONTENTTYPE_T) == NULL) {
							LM_ERR("failed to create insert lump\n");
							pkg_free(hdr);
						}
					}
				} else {
					/* iterate all the SIP hdrs from this part and keep all
					 * except the "Content-Length" */
					it = part->headers.s;
					while ( it<part->headers.s+part->headers.len ) {
						memset( &hf, 0, sizeof(struct hdr_field));
						it = get_hdr_field( it, part->headers.s+part->headers.len, &hf);
						if (hf.type==HDR_ERROR_T || hf.type==HDR_EOH_T)
							break;
						if (hf.type==HDR_CONTENTLENGTH_T)
							continue;
						/* add this hdr */
						hdr = (char*)pkg_malloc( hf.len);
						if (hdr==NULL) {
							LM_ERR("failed to allocate new ct hdr\n");
						} else {
							memcpy( hdr, hf.name.s, hf.len);
							if (insert_new_lump_before(ct, hdr,
							hf.len, HDR_CONTENTTYPE_T) == NULL) {
								LM_ERR("failed to create insert lump\n");
								pkg_free(hdr);
							}
						}
					}
				}
			}
		} else
			/* if it is an 1->1 keeping the part, try to preserve the
			 * the packing (multi-part or not) of this part */
			if ( (part->flags & SIP_BODY_PART_FLAG_NEW)==0 &&
			msg->body->part_count==1 &&
			msg->body->flags & SIP_BODY_RCV_MULTIPART) {
				/* preserve the original multi-part packing by preserving
				 * the before and after padding between part and body */
				len += msg->body->body.len - part->body.len;
			}

	} else if (msg->body->part_count<2) {

		/* transition from 0/1 to multiple parts,
		 * so we need to add boundries */

		LM_DBG("transition from 0/1 parts to multi part body\n");
		lump = msg->body_lumps;

		for( part=&msg->body->first ; part ; part=part->next) {

			LM_DBG("handing part with flags %x, mime %.*s, dump function %p\n",
				part->flags, part->mime_s.len, part->mime_s.s, part->dump_f);

			/* skip deleted parts */
			if ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {
				if ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)
					/* reposition at the end of the skipped body */
					orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;
				continue;
			}

			/* separator and CT header */
			len += 2 /* "--" */ + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN +
			 14/* "Content-Type: " */ + part->mime_s.len +
			 CRLF_LEN + part->headers.len + CRLF_LEN ;

			/* part with dump function ? */
			if (part->dump_f) {
				if (part->dump_f( part->parsed ,msg, &part->dump)<0) {
					LM_ERR("failed to build part, inserting empty\n");
					part->dump.s = "";
					part->dump.len = 0;
				} else
					len += part->dump.len;
				len += CRLF_LEN;
			} else
			/* new part with body attached */
			if ( part->flags & SIP_BODY_PART_FLAG_NEW ) {
				/* simpy copy the body of the part */
				len += part->body.len;
				len += CRLF_LEN;
			} else
			/* old part with lumps */
			{
				/* first find the first lump inside our body part */
				while ( lump && lump->u.offset<(part->body.s-msg->buf) )
					lump=lump->next;
				if (lump) {
					LM_DBG("lumps found in the part, applying...\n");
					/* apply the lumps */
					len += lumps_len( msg, lump, send_sock,
						part->body.s+part->body.len-msg->buf);
				}
				/* and copy whatever is left, all the way to the end of part */
				size = (part->body.s+part->body.len-msg->buf)-orig_offs;
				len += size + CRLF_LEN;
			}

			/* reposition at the end of the processed body */
			if ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)
				orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;

		} /* end for(over the parts) */

		/* the final separator */
		len += 2 /* "--" */ + sizeof(OSS_BOUNDARY)-1 + 2 /* "--" */ + CRLF_LEN;

		/* replace the Content-Type hdr */
		if (msg->content_type)
			ct = del_lump(msg, msg->content_type->name.s-msg->buf,
				msg->content_type->len, HDR_CONTENTTYPE_T);
		else
			ct = anchor_lump(msg, msg->unparsed - msg->buf,
				HDR_CONTENTTYPE_T);
		if (ct==NULL) {
			LM_ERR("failed to remove old CT / create anchor\n");
		} else {
			/* "Content-Type: multipart/mixed;boundary=OSS_BOUNDARY CRLF" */
			hdr = (char*)pkg_malloc( 39 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN );
			if (hdr==NULL) {
				LM_ERR("failed to allocate new ct hdr\n");
			} else {
				memcpy( hdr,
				"Content-Type: multipart/mixed;boundary=" OSS_BOUNDARY CRLF,
				39 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN);
				if (insert_new_lump_before(ct, hdr,
				39 + sizeof(OSS_BOUNDARY)-1 + CRLF_LEN,
				HDR_CONTENTTYPE_T) == NULL) {
					LM_ERR("failed to create insert lump\n");
					pkg_free(hdr);
				}
			}
		}

	} else {

		/* multi to multi parts - iterate the list, handle insert new parts,
		 * remove old ones, and modify the kept ones (if the case) */

		LM_DBG("multi to multi part body reconstruction\n");
		lump = msg->body_lumps;

		for( part=&msg->body->first ; part ; part=part->next) {
			/* skip deleted parts */
			if ( (part->flags & SIP_BODY_PART_FLAG_DELETED) ) {
				if ( (part->flags & SIP_BODY_PART_FLAG_NEW) == 0 )
					/* reposition at the end of the skipped body */
					orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;
				continue;
			}

			LM_DBG("handing part with flags %x, mime %.*s, dump function %p\n",
				part->flags, part->mime_s.len, part->mime_s.s, part->dump_f);

			/* new part ? */
			if ( part->flags & SIP_BODY_PART_FLAG_NEW ) {
				/* separator and CT header */
				len += 2 /* "--" */ + msg->body->boundary.len +
					CRLF_LEN + 14 /* "Content-Type: " */ + part->mime_s.len +
					CRLF_LEN + part->headers.len + CRLF_LEN ;
				/* simpy copy the body of the part */
				if (part->dump_f) {
					if (part->dump_f( part->parsed ,msg, &part->dump)<0) {
						LM_ERR("failed to build part, inserting empty\n");
						part->dump.s = "";
						part->dump.len = 0;
					} else
						len += part->dump.len;
				} else
					len += part->body.len;
				len += CRLF_LEN;
			} else
			/* old part with dump function */
			if (part->dump_f) {
				/* copy separator and headers from original message */
				len += (part->body.s - msg->buf) - orig_offs;
				/* put in the new body */
				if (part->dump_f( part->parsed ,msg, &part->dump)<0) {
					LM_ERR("failed to build part, inserting empty\n");
					part->dump.s = "";
					part->dump.len = 0;
				} else
					len += part->dump.len;
				len += CRLF_LEN;
				/* skip the old body */
			} else
			/* old part with lumps -> apply changes */
			{
				/* first find the first lump inside our body part
				 * NOTE: we do not need to explicitly copy the separtor and
				 * the headers as they will be automatically got by the 
				 * first lup or by the final copy */
				while ( lump && lump->u.offset<(part->body.s-msg->buf) )
					lump=lump->next;
				if (lump) {
					LM_DBG("lumps found in the part, applying...\n");
					/* apply the lumps */
					len += lumps_len( msg, lump, send_sock,
							part->body.s+part->body.len-msg->buf);
				}
				/* and copy whatever is left, all the way to the end of part */
				size = (part->body.s+part->body.len-msg->buf+CRLF_LEN)-orig_offs;
				len += size;
			}

			/* reposition at the end of the processed body */
			if ((part->flags & SIP_BODY_PART_FLAG_NEW) == 0)
				orig_offs = part->body.s+part->body.len-msg->buf+CRLF_LEN;
		} /* end for(over the parts) */

		/* the final separator */
		size = msg->len - orig_offs;
		len += size;

		/* Content-Type hdr does not require changes in this case */
	}

	LM_DBG("resulting body len is %d\n",len);
	return len;
}
