STATIC mp_obj_t poll_iternext(mp_obj_t self_in) {
    mp_obj_poll_t *self = MP_OBJ_TO_PTR(self_in);

    if (self->iter_cnt == 0) {
        return MP_OBJ_STOP_ITERATION;
    }

    self->iter_cnt--;

    for (mp_uint_t i = self->iter_idx; i < self->poll_set.map.alloc; ++i) {
        self->iter_idx++;
        if (!mp_map_slot_is_filled(&self->poll_set.map, i)) {
            continue;
        }
        poll_obj_t *poll_obj = MP_OBJ_TO_PTR(self->poll_set.map.table[i].value);
        if (poll_obj_get_revents(poll_obj) != 0) {
            mp_obj_tuple_t *t = MP_OBJ_TO_PTR(self->ret_tuple);
            t->items[0] = poll_obj->obj;
            t->items[1] = MP_OBJ_NEW_SMALL_INT(poll_obj_get_revents(poll_obj));
            if (self->flags & FLAG_ONESHOT) {
                // Don't poll next time, until new event mask will be set explicitly
                poll_obj_set_events(poll_obj, 0);
            }
            return MP_OBJ_FROM_PTR(t);
        }
    }

    assert(!"inconsistent number of poll active entries");
    self->iter_cnt = 0;
    return MP_OBJ_STOP_ITERATION;
}
