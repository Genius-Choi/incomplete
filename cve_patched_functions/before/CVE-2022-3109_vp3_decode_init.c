static av_cold int vp3_decode_init(AVCodecContext *avctx)
{
    Vp3DecodeContext *s = avctx->priv_data;
    int i, inter, plane, ret;
    int c_width;
    int c_height;
    int y_fragment_count, c_fragment_count;
#if CONFIG_VP4_DECODER
    int j;
#endif

    ret = init_frames(s);
    if (ret < 0)
        return ret;

    if (avctx->codec_tag == MKTAG('V', 'P', '4', '0')) {
        s->version = 3;
#if !CONFIG_VP4_DECODER
        av_log(avctx, AV_LOG_ERROR, "This build does not support decoding VP4.\n");
        return AVERROR_DECODER_NOT_FOUND;
#endif
    } else if (avctx->codec_tag == MKTAG('V', 'P', '3', '0'))
        s->version = 0;
    else
        s->version = 1;

    s->avctx  = avctx;
    s->width  = FFALIGN(avctx->coded_width, 16);
    s->height = FFALIGN(avctx->coded_height, 16);
    if (avctx->codec_id != AV_CODEC_ID_THEORA)
        avctx->pix_fmt = AV_PIX_FMT_YUV420P;
    avctx->chroma_sample_location = AVCHROMA_LOC_CENTER;
    ff_hpeldsp_init(&s->hdsp, avctx->flags | AV_CODEC_FLAG_BITEXACT);
    ff_videodsp_init(&s->vdsp, 8);
    ff_vp3dsp_init(&s->vp3dsp, avctx->flags);

    for (i = 0; i < 64; i++) {
#define TRANSPOSE(x) (((x) >> 3) | (((x) & 7) << 3))
        s->idct_permutation[i] = TRANSPOSE(i);
        s->idct_scantable[i]   = TRANSPOSE(ff_zigzag_direct[i]);
#undef TRANSPOSE
    }

    /* initialize to an impossible value which will force a recalculation
     * in the first frame decode */
    for (i = 0; i < 3; i++)
        s->qps[i] = -1;

    ret = av_pix_fmt_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_x_shift, &s->chroma_y_shift);
    if (ret)
        return ret;

    s->y_superblock_width  = (s->width  + 31) / 32;
    s->y_superblock_height = (s->height + 31) / 32;
    s->y_superblock_count  = s->y_superblock_width * s->y_superblock_height;

    /* work out the dimensions for the C planes */
    c_width                = s->width >> s->chroma_x_shift;
    c_height               = s->height >> s->chroma_y_shift;
    s->c_superblock_width  = (c_width  + 31) / 32;
    s->c_superblock_height = (c_height + 31) / 32;
    s->c_superblock_count  = s->c_superblock_width * s->c_superblock_height;

    s->superblock_count   = s->y_superblock_count + (s->c_superblock_count * 2);
    s->u_superblock_start = s->y_superblock_count;
    s->v_superblock_start = s->u_superblock_start + s->c_superblock_count;

    s->macroblock_width  = (s->width  + 15) / 16;
    s->macroblock_height = (s->height + 15) / 16;
    s->macroblock_count  = s->macroblock_width * s->macroblock_height;
    s->c_macroblock_width  = (c_width  + 15) / 16;
    s->c_macroblock_height = (c_height + 15) / 16;
    s->c_macroblock_count  = s->c_macroblock_width * s->c_macroblock_height;
    s->yuv_macroblock_count = s->macroblock_count + 2 * s->c_macroblock_count;

    s->fragment_width[0]  = s->width / FRAGMENT_PIXELS;
    s->fragment_height[0] = s->height / FRAGMENT_PIXELS;
    s->fragment_width[1]  = s->fragment_width[0] >> s->chroma_x_shift;
    s->fragment_height[1] = s->fragment_height[0] >> s->chroma_y_shift;

    /* fragment count covers all 8x8 blocks for all 3 planes */
    y_fragment_count     = s->fragment_width[0] * s->fragment_height[0];
    c_fragment_count     = s->fragment_width[1] * s->fragment_height[1];
    s->fragment_count    = y_fragment_count + 2 * c_fragment_count;
    s->fragment_start[1] = y_fragment_count;
    s->fragment_start[2] = y_fragment_count + c_fragment_count;

    if (!s->theora_tables) {
        const uint8_t (*bias_tabs)[32][2];

        for (i = 0; i < 64; i++) {
            s->coded_dc_scale_factor[0][i] = s->version < 2 ? vp31_dc_scale_factor[i] : vp4_y_dc_scale_factor[i];
            s->coded_dc_scale_factor[1][i] = s->version < 2 ? vp31_dc_scale_factor[i] : vp4_uv_dc_scale_factor[i];
            s->coded_ac_scale_factor[i] = s->version < 2 ? vp31_ac_scale_factor[i] : vp4_ac_scale_factor[i];
            s->base_matrix[0][i]        = s->version < 2 ? vp31_intra_y_dequant[i] : vp4_generic_dequant[i];
            s->base_matrix[1][i]        = s->version < 2 ? vp31_intra_c_dequant[i] : vp4_generic_dequant[i];
            s->base_matrix[2][i]        = s->version < 2 ? vp31_inter_dequant[i]   : vp4_generic_dequant[i];
            s->filter_limit_values[i]   = s->version < 2 ? vp31_filter_limit_values[i] : vp4_filter_limit_values[i];
        }

        for (inter = 0; inter < 2; inter++) {
            for (plane = 0; plane < 3; plane++) {
                s->qr_count[inter][plane]   = 1;
                s->qr_size[inter][plane][0] = 63;
                s->qr_base[inter][plane][0] =
                s->qr_base[inter][plane][1] = 2 * inter + (!!plane) * !inter;
            }
        }

        /* init VLC tables */
        bias_tabs = CONFIG_VP4_DECODER && s->version >= 2 ? vp4_bias : vp3_bias;
        for (int i = 0; i < FF_ARRAY_ELEMS(s->coeff_vlc); i++) {
            ret = ff_init_vlc_from_lengths(&s->coeff_vlc[i], 11, 32,
                                           &bias_tabs[i][0][1], 2,
                                           &bias_tabs[i][0][0], 2, 1,
                                           0, 0, avctx);
            if (ret < 0)
                return ret;
        }
    } else {
        for (i = 0; i < FF_ARRAY_ELEMS(s->coeff_vlc); i++) {
            const HuffTable *tab = &s->huffman_table[i];

            ret = ff_init_vlc_from_lengths(&s->coeff_vlc[i], 11, tab->nb_entries,
                                           &tab->entries[0].len, sizeof(*tab->entries),
                                           &tab->entries[0].sym, sizeof(*tab->entries), 1,
                                           0, 0, avctx);
            if (ret < 0)
                return ret;
        }
    }

    ret = ff_init_vlc_from_lengths(&s->superblock_run_length_vlc, SUPERBLOCK_VLC_BITS, 34,
                                   superblock_run_length_vlc_lens, 1,
                                   NULL, 0, 0, 1, 0, avctx);
    if (ret < 0)
        return ret;

    ret = ff_init_vlc_from_lengths(&s->fragment_run_length_vlc, 5, 30,
                                   fragment_run_length_vlc_len, 1,
                                   NULL, 0, 0, 0, 0, avctx);
    if (ret < 0)
        return ret;

    ret = ff_init_vlc_from_lengths(&s->mode_code_vlc, 3, 8,
                                   mode_code_vlc_len, 1,
                                   NULL, 0, 0, 0, 0, avctx);
    if (ret < 0)
        return ret;

    ret = ff_init_vlc_from_lengths(&s->motion_vector_vlc, VP3_MV_VLC_BITS, 63,
                                   &motion_vector_vlc_table[0][1], 2,
                                   &motion_vector_vlc_table[0][0], 2, 1,
                                   -31, 0, avctx);
    if (ret < 0)
        return ret;

#if CONFIG_VP4_DECODER
    for (j = 0; j < 2; j++)
        for (i = 0; i < 7; i++) {
            ret = ff_init_vlc_from_lengths(&s->vp4_mv_vlc[j][i], VP4_MV_VLC_BITS, 63,
                                           &vp4_mv_vlc[j][i][0][1], 2,
                                           &vp4_mv_vlc[j][i][0][0], 2, 1, -31,
                                           0, avctx);
            if (ret < 0)
                return ret;
        }

    /* version >= 2 */
    for (i = 0; i < 2; i++)
        if ((ret = init_vlc(&s->block_pattern_vlc[i], 3, 14,
                            &vp4_block_pattern_vlc[i][0][1], 2, 1,
                            &vp4_block_pattern_vlc[i][0][0], 2, 1, 0)) < 0)
            return ret;
#endif

    return allocate_tables(avctx);
}
