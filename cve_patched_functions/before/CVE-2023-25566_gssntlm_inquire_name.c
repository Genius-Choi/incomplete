uint32_t gssntlm_inquire_name(uint32_t *minor_status,
                              gss_name_t name,
                              int *name_is_MN,
                              gss_OID *MN_mech,
                              gss_buffer_set_t *attrs)
{
    uint32_t retmin = 0;
    uint32_t retmaj = 0;
    uint32_t tmpmin;
    const struct gssntlm_name *in = (const struct gssntlm_name *)name;

    if (!attrs) {
        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_WRITE);
    }
    *attrs = GSS_C_NO_BUFFER_SET;

    if (name == GSS_C_NO_NAME) {
        return GSSERRS(GSS_S_BAD_NAME, GSS_S_CALL_INACCESSIBLE_READ);
    }

    for (size_t i = 0; in->attrs && in->attrs[i].attr_name != NULL; i++) {
        struct gssntlm_name_attribute *attr = &in->attrs[i];
        size_t attr_name_len = strlen(attr->attr_name);
        gss_buffer_desc buf;
        gss_buffer_t attr_value = &attr->attr_value;
        /* +1 for '=' separator and +1 for EOL */
        size_t full_string_len = attr_value->length + attr_name_len + 2;
        size_t offset = 0;
        char *attr_string = malloc(full_string_len);
        if (attr_string == NULL) {
            set_GSSERR(ENOMEM);
            goto done;
        }

        /* Construct 'attr_name=<attr_value>\0' string */
        memcpy(attr_string, attr->attr_name, attr_name_len);
        offset += attr_name_len;

        attr_string[offset++] = '=';

        memcpy(attr_string + offset, attr_value->value, attr_value->length);
        offset += attr_value->length;

        attr_string[offset] = 0;

        /* now add a buffer to output set */
        buf.length = full_string_len;
        buf.value = attr_string;
        retmaj = gss_add_buffer_set_member(&retmin, &buf, attrs);
        free(attr_string);
        if (retmaj != GSS_S_COMPLETE) goto done;
    }

done:
    if (retmaj) {
        (void)gss_release_buffer_set(&tmpmin, attrs);
    }
    return GSSERRS(retmin, retmaj);
}
