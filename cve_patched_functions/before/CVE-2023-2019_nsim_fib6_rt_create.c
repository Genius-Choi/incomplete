nsim_fib6_rt_create(struct nsim_fib_data *data,
		    struct fib6_info **rt_arr, unsigned int nrt6)
{
	struct fib6_info *rt = rt_arr[0];
	struct nsim_fib6_rt *fib6_rt;
	int i = 0;
	int err;

	fib6_rt = kzalloc(sizeof(*fib6_rt), GFP_KERNEL);
	if (!fib6_rt)
		return ERR_PTR(-ENOMEM);

	nsim_fib_rt_init(data, &fib6_rt->common, &rt->fib6_dst.addr,
			 sizeof(rt->fib6_dst.addr), rt->fib6_dst.plen, AF_INET6,
			 rt->fib6_table->tb6_id);

	/* We consider a multipath IPv6 route as one entry, but it can be made
	 * up from several fib6_info structs (one for each nexthop), so we
	 * add them all to the same list under the entry.
	 */
	INIT_LIST_HEAD(&fib6_rt->nh_list);

	for (i = 0; i < nrt6; i++) {
		err = nsim_fib6_rt_nh_add(fib6_rt, rt_arr[i]);
		if (err)
			goto err_fib6_rt_nh_del;
	}

	return fib6_rt;

err_fib6_rt_nh_del:
	for (i--; i >= 0; i--) {
		nsim_fib6_rt_nh_del(fib6_rt, rt_arr[i]);
	}
	nsim_fib_rt_fini(&fib6_rt->common);
	kfree(fib6_rt);
	return ERR_PTR(err);
}
