R_API RBinDwarfDebugInfo *r_bin_dwarf_parse_info(RBinDwarfDebugAbbrev *da, RBin *bin, int mode) {
	RBinDwarfDebugInfo *info = NULL;
	RBinSection *debug_str;
	RBinSection *section = getsection (bin, "debug_info");
	RBinFile *binfile = bin ? bin->cur : NULL;

	ut64 debug_str_len = 0;
	ut8 *debug_str_buf = NULL;

	if (binfile && section) {
		debug_str = getsection (bin, "debug_str");
		if (debug_str) {
			debug_str_len = debug_str->size;
			debug_str_buf = calloc (1, debug_str_len + 1);
			if (!debug_str_buf) {
				goto cleanup;
			}
			st64 ret = r_buf_read_at (binfile->buf, debug_str->paddr,
				debug_str_buf, debug_str_len);
			if (!ret) {
				goto cleanup;
			}
		}

		ut64 len = section->size;
		// what is this checking for?
		if (len > (UT32_MAX >> 1) || len < 1) {
			goto cleanup;
		}
		ut8 *buf = calloc (1, len);
		if (!buf) {
			goto cleanup;
		}
		if (!r_buf_read_at (binfile->buf, section->paddr, buf, len)) {
			free (buf);
			goto cleanup;
		}
		/* set the endianity global [HOTFIX] */
		big_end = r_bin_is_big_endian (bin);
		info = parse_info_raw (binfile->sdb_addrinfo, da, buf, len,
			debug_str_buf, debug_str_len);

		if (mode == R_MODE_PRINT && info) {
			print_debug_info (info, bin->cb_printf);
		}
		// build hashtable after whole parsing because of possible relocations
		if (info) {
			size_t i, j;
			for (i = 0; i < info->count; i++) {
				RBinDwarfCompUnit *unit = &info->comp_units[i];
				for (j = 0; j < unit->count; j++) {
					RBinDwarfDie *die = &unit->dies[j];
					ht_up_insert (info->lookup_table, die->offset, die); // optimization for further processing}
				}
			}
		}
		free (debug_str_buf);
		free (buf);
		return info;
	}
cleanup:
	free (debug_str_buf);
	return NULL;
}
