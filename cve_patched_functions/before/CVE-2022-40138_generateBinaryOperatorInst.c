void HBCISel::generateBinaryOperatorInst(
    BinaryOperatorInst *Inst,
    BasicBlock *next) {
  auto left = encodeValue(Inst->getLeftHandSide());
  auto right = encodeValue(Inst->getRightHandSide());
  auto res = encodeValue(Inst);

  bool isBothNumber = Inst->getLeftHandSide()->getType().isNumberType() &&
      Inst->getRightHandSide()->getType().isNumberType();

  using OpKind = BinaryOperatorInst::OpKind;

  switch (Inst->getOperatorKind()) {
    case OpKind::EqualKind: // ==
      // TODO: optimize the case for null check.
      BCFGen_->emitEq(res, left, right);
      break;
    case OpKind::NotEqualKind: // !=
      // TODO: optimize the case for null check.
      BCFGen_->emitNeq(res, left, right);
      break;
    case OpKind::StrictlyEqualKind: // ===
      BCFGen_->emitStrictEq(res, left, right);
      break;
    case OpKind::StrictlyNotEqualKind: // !===
      BCFGen_->emitStrictNeq(res, left, right);
      break;
    case OpKind::LessThanKind: // <
      BCFGen_->emitLess(res, left, right);
      break;
    case OpKind::LessThanOrEqualKind: // <=
      BCFGen_->emitLessEq(res, left, right);
      break;
    case OpKind::GreaterThanKind: // >
      BCFGen_->emitGreater(res, left, right);
      break;
    case OpKind::GreaterThanOrEqualKind: // >=
      BCFGen_->emitGreaterEq(res, left, right);
      break;
    case OpKind::LeftShiftKind: // <<  (<<=)
      BCFGen_->emitLShift(res, left, right);
      break;
    case OpKind::RightShiftKind: // >>  (>>=)
      BCFGen_->emitRShift(res, left, right);
      break;
    case OpKind::UnsignedRightShiftKind: // >>> (>>>=)
      BCFGen_->emitURshift(res, left, right);
      break;
    case OpKind::AddKind: // +   (+=)
      if (isBothNumber) {
        BCFGen_->emitAddN(res, left, right);
      } else {
        BCFGen_->emitAdd(res, left, right);
      }
      break;
    case OpKind::SubtractKind: // -   (-=)
      if (isBothNumber) {
        BCFGen_->emitSubN(res, left, right);
      } else {
        BCFGen_->emitSub(res, left, right);
      }
      break;
    case OpKind::MultiplyKind: // *   (*=)
      if (isBothNumber) {
        BCFGen_->emitMulN(res, left, right);
      } else {
        BCFGen_->emitMul(res, left, right);
      }
      break;
    case OpKind::DivideKind: // /   (/=)
      if (isBothNumber) {
        BCFGen_->emitDivN(res, left, right);
      } else {
        BCFGen_->emitDiv(res, left, right);
      }
      break;
    case OpKind::ExponentiationKind: // ** (**=)
      llvm_unreachable("ExponentiationKind emits a HermesInternal call");
      break;
    case OpKind::ModuloKind: // %   (%=)
      BCFGen_->emitMod(res, left, right);
      break;
    case OpKind::OrKind: // |   (|=)
      BCFGen_->emitBitOr(res, left, right);
      break;
    case OpKind::XorKind: // ^   (^=)
      BCFGen_->emitBitXor(res, left, right);
      break;
    case OpKind::AndKind: // &   (^=)
      BCFGen_->emitBitAnd(res, left, right);
      break;
    case OpKind::InKind: // "in"
      BCFGen_->emitIsIn(res, left, right);
      break;
    case OpKind::InstanceOfKind: // instanceof
      BCFGen_->emitInstanceOf(res, left, right);
      break;

    default:
      break;
  }
}
