void TCDeleteDeviceObject (PDEVICE_OBJECT DeviceObject, PEXTENSION Extension)
{
	UNICODE_STRING Win32NameString;
	NTSTATUS ntStatus;

	Dump ("TCDeleteDeviceObject BEGIN\n");

	if (Extension->bRootDevice)
	{
		RtlInitUnicodeString (&Win32NameString, (LPWSTR) DOS_ROOT_PREFIX);
		ntStatus = IoDeleteSymbolicLink (&Win32NameString);
		if (!NT_SUCCESS (ntStatus))
			Dump ("IoDeleteSymbolicLink failed ntStatus = 0x%08x\n", ntStatus);

		RootDeviceObject = NULL;
	}
	else
	{
		if (Extension->peThread != NULL)
			TCStopVolumeThread (DeviceObject, Extension);

		if (Extension->UserSid)
			TCfree (Extension->UserSid);

		if (Extension->SecurityClientContextValid)
		{
			if (OsMajorVersion == 5 && OsMinorVersion == 0)
			{
				ObDereferenceObject (Extension->SecurityClientContext.ClientToken);
			}
			else
			{
				// Windows 2000 does not support PsDereferenceImpersonationToken() used by SeDeleteClientSecurity().
				// TODO: Use only SeDeleteClientSecurity() once support for Windows 2000 is dropped.

				VOID (*PsDereferenceImpersonationTokenD) (PACCESS_TOKEN ImpersonationToken);
				UNICODE_STRING name;
				RtlInitUnicodeString (&name, L"PsDereferenceImpersonationToken");

				PsDereferenceImpersonationTokenD = MmGetSystemRoutineAddress (&name);
				if (!PsDereferenceImpersonationTokenD)
					TC_BUG_CHECK (STATUS_NOT_IMPLEMENTED);

#				define PsDereferencePrimaryToken
#				define PsDereferenceImpersonationToken PsDereferenceImpersonationTokenD

				SeDeleteClientSecurity (&Extension->SecurityClientContext);

#				undef PsDereferencePrimaryToken
#				undef PsDereferenceImpersonationToken
			}
		}

		VirtualVolumeDeviceObjects[Extension->nDosDriveNo] = NULL;
	}

	IoDeleteDevice (DeviceObject);

	Dump ("TCDeleteDeviceObject END\n");
}
