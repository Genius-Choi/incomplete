static void _check_failed_frags(sixlowpan_sfr_ack_t *ack,
                                gnrc_sixlowpan_frag_fb_t *fbuf,
                                uint32_t ack_recv_time)
{
    _frag_desc_t *frag_desc;
    clist_node_t not_received = { .next = NULL };
    ztimer_now_t earliest_send = UINT32_MAX;

    DEBUG("6lo sfr: checking which fragments to resend for datagram %u\n",
          fbuf->tag);
    for (frag_desc = (_frag_desc_t *)clist_lpop(&fbuf->sfr.window);
         frag_desc != NULL;
         frag_desc = (_frag_desc_t *)clist_lpop(&fbuf->sfr.window)) {
        uint8_t seq;

        seq = _frag_seq(frag_desc);
        if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) &&
            (earliest_send > frag_desc->super.send_time)) {
            earliest_send = frag_desc->super.send_time;
        }
        if (bf_isset(ack->bitmap, seq)) {
            DEBUG("6lo sfr: fragment %u (offset: %u, frag_size: %u) "
                  "for datagram %u was received\n", seq,
                  frag_desc->offset, _frag_size(frag_desc), fbuf->tag);
            fbuf->sfr.frags_sent--;
            clist_rpush(&_frag_descs_free, &frag_desc->super.super);
            if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE)) {
                congure_snd_ack_t ack = {
                    .recv_time = ack_recv_time,
                    .id = seq,
                    .clean = 1U,
                };
                gnrc_sixlowpan_frag_sfr_congure_snd_report_frag_acked(
                    fbuf, &frag_desc->super, &ack
                );
            }
        }
        else {
            DEBUG("6lo sfr: fragment %u (offset: %u, frag_size: %u) "
                  "for datagram %u was not received\n", seq,
                  frag_desc->offset, _frag_size(frag_desc), fbuf->tag);
            if ((frag_desc->super.resends++) < CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES) {
                DEBUG("6lo sfr: %u retries left\n",
                      CONFIG_GNRC_SIXLOWPAN_SFR_FRAG_RETRIES -
                      (frag_desc->super.resends - 1));
                /* put fragment in "not received" list */
                clist_rpush(&not_received, &frag_desc->super.super);
                frag_desc->ar_seq_fs &= ~(SIXLOWPAN_SFR_ACK_REQ << 8U);
            }
            else {
                DEBUG("6lo sfr: no more retries for fragment %u\n", seq);
                if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) &&
                    IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_SFR_USE_ECN) &&
                    sixlowpan_sfr_ecn(&ack->base)) {
                    gnrc_sixlowpan_frag_sfr_congure_snd_report_ecn(
                        fbuf, earliest_send
                    );
                }
                clist_rpush(&_frag_descs_free, &frag_desc->super.super);
                /* retry to resend whole datagram */
                _retry_datagram(fbuf);
                return;
            }
        }
    }
    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR_CONGURE) &&
        sixlowpan_sfr_ecn(&ack->base)) {
        gnrc_sixlowpan_frag_sfr_congure_snd_report_ecn(fbuf, earliest_send);
    }
    /* all fragments were received of the current window were received and
     * the datagram was transmitted completely */
    if ((clist_lpeek(&not_received) == NULL) &&
        (fbuf->offset == fbuf->datagram_size)) {
        /* release fragmentation buffer */
        _clean_up_fbuf(fbuf, GNRC_NETERR_SUCCESS);
    }
    /* at least one fragment was not received */
    else {
        gnrc_sixlowpan_frag_sfr_congure_snd_report_frags_lost(
            fbuf,
            (congure_snd_msg_t *)&not_received
        );
        fbuf->sfr.window = not_received;
        _shrink_window(fbuf);
        assert(fbuf->sfr.frags_sent == clist_count(&fbuf->sfr.window));
        /* use _resend_failed_frag here instead of loop above, so
         * _resend_frag can know if the fragment is the last in the window by
         * using clist_rpeek() on fbuf->sfr.window */
        if (clist_foreach(&fbuf->sfr.window, _resend_failed_frag, fbuf) != NULL) {
            /* XXX: it is unlikely that allocating an abort RFRAG will be
             * successful since the resources missing to cause the abort are
             * still in use, but we should at least try */
            if (_send_abort_frag(fbuf->pkt, fbuf, true, 0)) {
                /* wait for ACK before fbuf is deleted */
                _sched_abort_timeout(fbuf);
            }
            else {
                /* we have no memory resources left to send neither the
                 * resent fragment nor the abort ACK to signalize that fact to
                 * the reassembling endpoint */
                _clean_up_fbuf(fbuf, ENOMEM);
            }
        }
        if (gnrc_sixlowpan_frag_sfr_congure_snd_in_cwnd(fbuf) &&
            (fbuf->offset < fbuf->datagram_size)) {
            DEBUG("6lo sfr: trigger send of further fragments of datagram %u\n",
                  fbuf->tag);
            gnrc_sixlowpan_frag_fb_send(fbuf);
        }
    }
}
