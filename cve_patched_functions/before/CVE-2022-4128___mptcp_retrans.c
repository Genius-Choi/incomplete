static void __mptcp_retrans(struct sock *sk)
{
	struct mptcp_sock *msk = mptcp_sk(sk);
	struct mptcp_sendmsg_info info = {};
	struct mptcp_data_frag *dfrag;
	size_t copied = 0;
	struct sock *ssk;
	int ret;

	mptcp_clean_una_wakeup(sk);

	/* first check ssk: need to kick "stale" logic */
	ssk = mptcp_subflow_get_retrans(msk);
	dfrag = mptcp_rtx_head(sk);
	if (!dfrag) {
		if (mptcp_data_fin_enabled(msk)) {
			struct inet_connection_sock *icsk = inet_csk(sk);

			icsk->icsk_retransmits++;
			mptcp_set_datafin_timeout(sk);
			mptcp_send_ack(msk);

			goto reset_timer;
		}

		if (!mptcp_send_head(sk))
			return;

		goto reset_timer;
	}

	if (!ssk)
		goto reset_timer;

	lock_sock(ssk);

	/* limit retransmission to the bytes already sent on some subflows */
	info.sent = 0;
	info.limit = READ_ONCE(msk->csum_enabled) ? dfrag->data_len : dfrag->already_sent;
	while (info.sent < info.limit) {
		ret = mptcp_sendmsg_frag(sk, ssk, dfrag, &info);
		if (ret <= 0)
			break;

		MPTCP_INC_STATS(sock_net(sk), MPTCP_MIB_RETRANSSEGS);
		copied += ret;
		info.sent += ret;
	}
	if (copied) {
		dfrag->already_sent = max(dfrag->already_sent, info.sent);
		tcp_push(ssk, 0, info.mss_now, tcp_sk(ssk)->nonagle,
			 info.size_goal);
		WRITE_ONCE(msk->allow_infinite_fallback, false);
	}

	release_sock(ssk);

reset_timer:
	mptcp_check_and_set_pending(sk);

	if (!mptcp_timer_pending(sk))
		mptcp_reset_timer(sk);
}
