FIO_FUNC inline void fio_llist_test(void) {
  fio_ls_s list = FIO_LS_INIT(list);
  size_t counter;
  fprintf(stderr, "=== Testing Core Linked List features (fio_ls and "
                  "fio_ls_embs functions)\n");
  /* test push/shift */
  for (uintptr_t i = 0; i < FIO_LLIST_TEST_LIMIT; ++i) {
    fio_ls_push(&list, (void *)i);
  }
  FIO_ASSERT(fio_ls_any(&list), "List should be populated after fio_ls_push");
  counter = 0;
  FIO_LS_FOR(&list, pos) {
    FIO_ASSERT((size_t)pos->obj == counter,
               "`FIO_LS_FOR` value error (%zu != %zu)", (size_t)pos->obj,
               counter);
    ++counter;
  }
  counter = 0;
  while (fio_ls_any(&list)) {
    FIO_ASSERT(counter < FIO_LLIST_TEST_LIMIT,
               "`fio_ls_any` didn't return false when expected %p<=%p=>%p",
               (void *)list.prev, (void *)&list, (void *)list.next);
    size_t tmp = (size_t)fio_ls_shift(&list);
    FIO_ASSERT(tmp == counter, "`fio_ls_shift` value error (%zu != %zu)", tmp,
               counter);
    ++counter;
  }
  FIO_ASSERT(counter == FIO_LLIST_TEST_LIMIT,
             "List item count error (%zu != %zu)", counter,
             (size_t)FIO_LLIST_TEST_LIMIT);
  /* test unshift/pop */
  for (uintptr_t i = 0; i < FIO_LLIST_TEST_LIMIT; ++i) {
    fio_ls_unshift(&list, (void *)i);
  }
  FIO_ASSERT(fio_ls_any(&list),
             "List should be populated after fio_ls_unshift");
  counter = 0;
  while (!fio_ls_is_empty(&list)) {
    FIO_ASSERT(counter < FIO_LLIST_TEST_LIMIT,
               "`fio_ls_is_empty` didn't return true when expected %p<=%p=>%p",
               (void *)list.prev, (void *)&list, (void *)list.next);
    size_t tmp = (size_t)fio_ls_pop(&list);
    FIO_ASSERT(tmp == counter, "`fio_ls_pop` value error (%zu != %zu)", tmp,
               counter);
    ++counter;
  }
  FIO_ASSERT(counter == FIO_LLIST_TEST_LIMIT,
             "List item count error (%zu != %zu)", counter,
             (size_t)FIO_LLIST_TEST_LIMIT);

  /* Re-test for embeded list */

  struct fio_ls_test_s {
    size_t i;
    fio_ls_embd_s node;
  };

  fio_ls_embd_s emlist = FIO_LS_INIT(emlist);

  /* test push/shift */
  for (uintptr_t i = 0; i < FIO_LLIST_TEST_LIMIT; ++i) {
    struct fio_ls_test_s *n = malloc(sizeof(*n));
    FIO_ASSERT_ALLOC(n);
    n->i = i;
    fio_ls_embd_push(&emlist, &n->node);
    FIO_ASSERT(FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, emlist.next)->i == 0,
               "fio_ls_embd_push should push to the end.");
  }
  FIO_ASSERT(fio_ls_embd_any(&emlist),
             "List should be populated after fio_ls_embd_push");
  counter = 0;
  FIO_LS_EMBD_FOR(&emlist, pos) {
    FIO_ASSERT(FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, pos)->i == counter,
               "`FIO_LS_EMBD_FOR` value error (%zu != %zu)",
               FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, pos)->i, counter);
    ++counter;
  }
  counter = 0;
  while (fio_ls_embd_any(&emlist)) {
    FIO_ASSERT(counter < FIO_LLIST_TEST_LIMIT,
               "`fio_ls_embd_any` didn't return false when expected %p<=%p=>%p",
               (void *)emlist.prev, (void *)&emlist, (void *)emlist.next);
    struct fio_ls_test_s *n =
        FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, fio_ls_embd_shift(&emlist));
    FIO_ASSERT(n->i == counter, "`fio_ls_embd_shift` value error (%zu != %zu)",
               n->i, counter);
    free(n);
    ++counter;
  }
  FIO_ASSERT(counter == FIO_LLIST_TEST_LIMIT,
             "List item count error (%zu != %zu)", counter,
             (size_t)FIO_LLIST_TEST_LIMIT);
  /* test shift/unshift */
  for (uintptr_t i = 0; i < FIO_LLIST_TEST_LIMIT; ++i) {
    struct fio_ls_test_s *n = malloc(sizeof(*n));
    FIO_ASSERT_ALLOC(n)
    n->i = i;
    fio_ls_embd_unshift(&emlist, &n->node);
    FIO_ASSERT(FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, emlist.next)->i == i,
               "fio_ls_embd_unshift should push to the start.");
  }
  FIO_ASSERT(fio_ls_embd_any(&emlist),
             "List should be populated after fio_ls_embd_unshift");
  counter = 0;
  while (!fio_ls_embd_is_empty(&emlist)) {
    FIO_ASSERT(
        counter < FIO_LLIST_TEST_LIMIT,
        "`fio_ls_embd_is_empty` didn't return true when expected %p<=%p=>%p",
        (void *)emlist.prev, (void *)&emlist, (void *)emlist.next);
    struct fio_ls_test_s *n =
        FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, fio_ls_embd_pop(&emlist));
    FIO_ASSERT(n->i == counter, "`fio_ls_embd_pop` value error (%zu != %zu)",
               n->i, counter);
    free(n);
    ++counter;
  }
  FIO_ASSERT(counter == FIO_LLIST_TEST_LIMIT,
             "List item count error (%zu != %zu)", counter,
             (size_t)FIO_LLIST_TEST_LIMIT);
  fprintf(stderr, "* passed.\n");
}
