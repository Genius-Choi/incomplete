int parse_git_diff_header(struct strbuf *root,
			  int *linenr,
			  int p_value,
			  const char *line,
			  int len,
			  unsigned int size,
			  struct patch *patch)
{
	unsigned long offset;
	struct gitdiff_data parse_hdr_state;

	/* A git diff has explicit new/delete information, so we don't guess */
	patch->is_new = 0;
	patch->is_delete = 0;

	/*
	 * Some things may not have the old name in the
	 * rest of the headers anywhere (pure mode changes,
	 * or removing or adding empty files), so we get
	 * the default name from the header.
	 */
	patch->def_name = git_header_name(p_value, line, len);
	if (patch->def_name && root->len) {
		char *s = xstrfmt("%s%s", root->buf, patch->def_name);
		free(patch->def_name);
		patch->def_name = s;
	}

	line += len;
	size -= len;
	(*linenr)++;
	parse_hdr_state.root = root;
	parse_hdr_state.linenr = *linenr;
	parse_hdr_state.p_value = p_value;

	for (offset = len ; size > 0 ; offset += len, size -= len, line += len, (*linenr)++) {
		static const struct opentry {
			const char *str;
			int (*fn)(struct gitdiff_data *, const char *, struct patch *);
		} optable[] = {
			{ "@@ -", gitdiff_hdrend },
			{ "--- ", gitdiff_oldname },
			{ "+++ ", gitdiff_newname },
			{ "old mode ", gitdiff_oldmode },
			{ "new mode ", gitdiff_newmode },
			{ "deleted file mode ", gitdiff_delete },
			{ "new file mode ", gitdiff_newfile },
			{ "copy from ", gitdiff_copysrc },
			{ "copy to ", gitdiff_copydst },
			{ "rename old ", gitdiff_renamesrc },
			{ "rename new ", gitdiff_renamedst },
			{ "rename from ", gitdiff_renamesrc },
			{ "rename to ", gitdiff_renamedst },
			{ "similarity index ", gitdiff_similarity },
			{ "dissimilarity index ", gitdiff_dissimilarity },
			{ "index ", gitdiff_index },
			{ "", gitdiff_unrecognized },
		};
		int i;

		len = linelen(line, size);
		if (!len || line[len-1] != '\n')
			break;
		for (i = 0; i < ARRAY_SIZE(optable); i++) {
			const struct opentry *p = optable + i;
			int oplen = strlen(p->str);
			int res;
			if (len < oplen || memcmp(p->str, line, oplen))
				continue;
			res = p->fn(&parse_hdr_state, line + oplen, patch);
			if (res < 0)
				return -1;
			if (check_header_line(*linenr, patch))
				return -1;
			if (res > 0)
				goto done;
			break;
		}
	}

done:
	if (!patch->old_name && !patch->new_name) {
		if (!patch->def_name) {
			error(Q_("git diff header lacks filename information when removing "
				 "%d leading pathname component (line %d)",
				 "git diff header lacks filename information when removing "
				 "%d leading pathname components (line %d)",
				 parse_hdr_state.p_value),
			      parse_hdr_state.p_value, *linenr);
			return -128;
		}
		patch->old_name = xstrdup(patch->def_name);
		patch->new_name = xstrdup(patch->def_name);
	}
	if ((!patch->new_name && !patch->is_delete) ||
	    (!patch->old_name && !patch->is_new)) {
		error(_("git diff header lacks filename information "
			"(line %d)"), *linenr);
		return -128;
	}
	patch->is_toplevel_relative = 1;
	return offset;
}
