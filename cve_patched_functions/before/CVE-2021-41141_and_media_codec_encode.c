static pj_status_t and_media_codec_encode(pjmedia_codec *codec,
					  const struct pjmedia_frame *input,
					  unsigned output_buf_len,
					  struct pjmedia_frame *output)
{
    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;
    struct and_media_codec *and_media_data =
					&and_media_codec[codec_data->codec_idx];
    unsigned samples_per_frame;
    unsigned nsamples;
    unsigned nframes;
    pj_size_t tx = 0;
    pj_int16_t *pcm_in = (pj_int16_t*)input->buf;
    pj_uint8_t  *bits_out = (pj_uint8_t*) output->buf;
    pj_uint8_t pt;

    /* Invoke external VAD if codec has no internal VAD */
    if (codec_data->vad && codec_data->vad_enabled) {
	pj_bool_t is_silence;
	pj_int32_t silence_duration;

	silence_duration = pj_timestamp_diff32(&codec_data->last_tx, 
					       &input->timestamp);

	is_silence = pjmedia_silence_det_detect(codec_data->vad, 
					        (const pj_int16_t*) input->buf,
						(input->size >> 1),
						NULL);
	if (is_silence &&
	    (PJMEDIA_CODEC_MAX_SILENCE_PERIOD == -1 ||
	     silence_duration < (PJMEDIA_CODEC_MAX_SILENCE_PERIOD *
	 			 (int)and_media_data->clock_rate / 1000)))
	{
	    output->type = PJMEDIA_FRAME_TYPE_NONE;
	    output->buf = NULL;
	    output->size = 0;
	    output->timestamp = input->timestamp;
	    return PJ_SUCCESS;
	} else {
	    codec_data->last_tx = input->timestamp;
	}
    }
    nsamples = input->size >> 1;
    samples_per_frame = and_media_data->samples_per_frame;
    pt = and_media_data->pt;
    nframes = nsamples / samples_per_frame;

    PJ_ASSERT_RETURN(nsamples % samples_per_frame == 0, 
		     PJMEDIA_CODEC_EPCMFRMINLEN);

    /* Encode the frames */
    while (nsamples >= samples_per_frame) {
        pj_ssize_t buf_idx;
        unsigned i;
        pj_size_t output_size;
        pj_uint8_t *output_buf;
        AMediaCodecBufferInfo buf_info;

        buf_idx = AMediaCodec_dequeueInputBuffer(codec_data->enc,
					         CODEC_DEQUEUE_TIMEOUT);

        if (buf_idx >= 0) {
	    media_status_t am_status;
	    pj_size_t output_size;
            unsigned input_size = samples_per_frame << 1;

	    pj_uint8_t *input_buf = AMediaCodec_getInputBuffer(codec_data->enc,
						        buf_idx, &output_size);

	    if (input_buf && output_size >= input_size) {
	        pj_memcpy(input_buf, pcm_in, input_size);

	        am_status = AMediaCodec_queueInputBuffer(codec_data->enc,
				                  buf_idx, 0, input_size, 0, 0);
	        if (am_status != AMEDIA_OK) {
		    PJ_LOG(4, (THIS_FILE, "Encoder queueInputBuffer return %d",
		               am_status));
		    goto on_return;
	        }
	    } else {
	        if (!input_buf) {
		    PJ_LOG(4,(THIS_FILE, "Encoder getInputBuffer "
				         "returns no input buff"));
	        } else {
		    PJ_LOG(4,(THIS_FILE, "Encoder getInputBuffer "
				         "size: %d, expecting %d.",
				         input_buf, output_size, input_size));
	        }
	        goto on_return;
	    }
        } else {
	    PJ_LOG(4,(THIS_FILE, "Encoder dequeueInputBuffer failed[%d]",
                      buf_idx));
	    goto on_return;
        }

        for (i = 0; i < CODEC_WAIT_RETRY; ++i) {
	    buf_idx = AMediaCodec_dequeueOutputBuffer(codec_data->enc,
						      &buf_info,
						      CODEC_DEQUEUE_TIMEOUT);
	    if (buf_idx == -1) {
	        /* Timeout, wait until output buffer is availble. */
	        pj_thread_sleep(CODEC_THREAD_WAIT);
	    } else {
	        break;
	    }
        }

        if (buf_idx < 0) {
	    PJ_LOG(4, (THIS_FILE, "Encoder dequeueOutputBuffer failed %d",
		   buf_idx));
            goto on_return;
        }

        output_buf = AMediaCodec_getOutputBuffer(codec_data->enc,
                                                 buf_idx,
                                                 &output_size);
        if (!output_buf) {
            PJ_LOG(4, (THIS_FILE, "Encoder failed getting output buffer, "
                       "buffer size=%d, flags %d",
                       buf_info.size, buf_info.flags));
            goto on_return;
        }

        pj_memcpy(bits_out, output_buf, buf_info.size);
        AMediaCodec_releaseOutputBuffer(codec_data->enc,
                                        buf_idx,
                                        0);
        bits_out += buf_info.size;
        tx += buf_info.size;
	pcm_in += samples_per_frame;
	nsamples -= samples_per_frame;
    }
    if (and_media_data->pack != NULL) {
	and_media_data->pack(codec_data, nframes, output->buf, &tx,
			     output_buf_len);
    }
    /* Check if we don't need to transmit the frame (DTX) */
    if (tx == 0) {
	output->buf = NULL;
	output->size = 0;
	output->timestamp.u64 = input->timestamp.u64;
	output->type = PJMEDIA_FRAME_TYPE_NONE;
	return PJ_SUCCESS;
    }
    output->size = tx;
    output->type = PJMEDIA_FRAME_TYPE_AUDIO;
    output->timestamp = input->timestamp;

    return PJ_SUCCESS;

on_return:
    output->size = 0;
    output->buf = NULL;
    output->type = PJMEDIA_FRAME_TYPE_NONE;
    output->timestamp.u64 = input->timestamp.u64;
    return PJ_SUCCESS;
}
