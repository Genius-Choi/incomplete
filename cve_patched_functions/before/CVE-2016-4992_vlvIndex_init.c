vlvIndex_init(struct vlvIndex* p, backend *be, struct vlvSearch* pSearch, const Slapi_Entry *e)
{
    struct ldbminfo *li = (struct ldbminfo *) be->be_database->plg_private;
    char *filename= NULL;

    if (NULL == p)
        return;

    /* JCM: Should perform some validation and report errors to the error log */
    /* JCM: Add brackets around the filter if none are there... */
    p->vlv_sortspec= slapi_entry_attr_get_charptr(e,type_vlvSort);
    trimspaces(p->vlv_sortspec);

    p->vlv_name= slapi_entry_attr_get_charptr(e,type_vlvName);
    trimspaces(p->vlv_name);

    p->vlv_search= pSearch;

    /* Convert the textual sort specification into a keylist structure */
    internal_ldap_create_sort_keylist(&(p->vlv_sortkey),p->vlv_sortspec);
    {
        /*
         * For each sort attribute find the appropriate syntax plugin,
         * and if it has a matching rule, create a matching rule indexer object.
         */
        int n;
        for(n=0;p->vlv_sortkey[n]!=NULL;n++);
        p->vlv_mrpb= (Slapi_PBlock**)slapi_ch_calloc(n+1,sizeof(Slapi_PBlock*));
        for(n=0;p->vlv_sortkey[n]!=NULL;n++)
        {
            if(p->vlv_sortkey[n]->sk_matchruleoid!=NULL)
            {
                create_matchrule_indexer(&p->vlv_mrpb[n],p->vlv_sortkey[n]->sk_matchruleoid,p->vlv_sortkey[n]->sk_attrtype);
            }

        }

    }

    /* Create an index filename for the search */
    if(vlvIndex_createfilename(p,&filename))
    {
        p->vlv_filename= slapi_ch_smprintf("%s%s%s",file_prefix,filename,file_suffix);

        /* Create an attrinfo structure */
        p->vlv_attrinfo->ai_type= slapi_ch_smprintf("%s%s",file_prefix,filename);
        p->vlv_attrinfo->ai_indexmask= INDEX_VLV;

        /* Check if the index file actually exists */
        if(li!=NULL)
        {
            vlvIndex_checkforindex(p, be);
        }
        p->vlv_lastchecked= current_time();
    }
    slapi_ch_free((void**)&filename);
}
