static status_t send_client_hello(private_tls_peer_t *this,
								  tls_handshake_type_t *type,
								  bio_writer_t *writer)
{
	tls_cipher_suite_t *suites;
	bio_writer_t *extensions, *curves = NULL, *versions, *key_share, *signatures;
	tls_version_t version_max, version_min;
	diffie_hellman_group_t group;
	tls_named_group_t curve;
	enumerator_t *enumerator;
	int count, i, v;
	rng_t *rng;

	htoun32(&this->client_random, time(NULL));
	rng = lib->crypto->create_rng(lib->crypto, RNG_WEAK);
	if (!rng ||
		!rng->get_bytes(rng, sizeof(this->client_random) - 4,
						this->client_random + 4))
	{
		DBG1(DBG_TLS, "failed to generate client random");
		this->alert->add(this->alert, TLS_FATAL, TLS_INTERNAL_ERROR);
		DESTROY_IF(rng);
		return NEED_MORE;
	}
	rng->destroy(rng);

	/* determine supported suites before the versions as they might change */
	count = this->crypto->get_cipher_suites(this->crypto, &suites);

	/* TLS version_max in handshake protocol */
	version_max = this->tls->get_version_max(this->tls);
	version_min = this->tls->get_version_min(this->tls);
	if (version_max < TLS_1_3)
	{
		this->hello_version = version_max;
	}
	else
	{
		this->hello_version = TLS_1_2;
	}
	writer->write_uint16(writer, this->hello_version);
	writer->write_data(writer, chunk_from_thing(this->client_random));

	/* session identifier */
	this->session = this->crypto->get_session(this->crypto, this->server);
	writer->write_data8(writer, this->session);

	/* add TLS cipher suites */
	if (count <= 0)
	{
		DBG1(DBG_TLS, "no supported TLS cipher suite available");
		this->alert->add(this->alert, TLS_FATAL, TLS_INTERNAL_ERROR);
		return NEED_MORE;
	}
	writer->write_uint16(writer, count * 2);
	for (i = 0; i < count; i++)
	{
		writer->write_uint16(writer, suites[i]);
	}

	/* NULL compression only */
	writer->write_uint8(writer, 1);
	writer->write_uint8(writer, 0);

	extensions = bio_writer_create(32);

	if (this->server->get_type(this->server) == ID_FQDN)
	{
		bio_writer_t *names;

		DBG2(DBG_TLS, "sending extension: Server Name Indication for '%Y'",
			 this->server);
		names = bio_writer_create(8);
		names->write_uint8(names, TLS_NAME_TYPE_HOST_NAME);
		names->write_data16(names, this->server->get_encoding(this->server));
		names->wrap16(names);
		extensions->write_uint16(extensions, TLS_EXT_SERVER_NAME);
		extensions->write_data16(extensions, names->get_buf(names));
		names->destroy(names);
	}

	enumerator = this->crypto->create_ec_enumerator(this->crypto);
	while (enumerator->enumerate(enumerator, &group, &curve))
	{
		if (this->requested_curve && this->requested_curve != curve)
		{
			continue;
		}
		if (!curves)
		{
			extensions->write_uint16(extensions, TLS_EXT_SUPPORTED_GROUPS);
			curves = bio_writer_create(16);
		}
		if (!this->dh)
		{
			this->dh = lib->crypto->create_dh(lib->crypto, group);
			if (!this->dh)
			{
				continue;
			}
		}
		curves->write_uint16(curves, curve);
	}
	enumerator->destroy(enumerator);

	if (curves)
	{
		DBG2(DBG_TLS, "sending extension: %N",
			 tls_extension_names, TLS_EXT_SUPPORTED_GROUPS);

		curves->wrap16(curves);
		extensions->write_data16(extensions, curves->get_buf(curves));
		curves->destroy(curves);

		/* if we support curves, add point format extension */
		extensions->write_uint16(extensions, TLS_EXT_EC_POINT_FORMATS);
		extensions->write_uint16(extensions, 2);
		extensions->write_uint8(extensions, 1);
		extensions->write_uint8(extensions, TLS_EC_POINT_UNCOMPRESSED);
	}

	if (version_max >= TLS_1_3)
	{
		DBG2(DBG_TLS, "sending extension: %N",
			 tls_extension_names, TLS_EXT_SUPPORTED_VERSIONS);
		extensions->write_uint16(extensions, TLS_EXT_SUPPORTED_VERSIONS);
		versions = bio_writer_create(0);
		for (v = version_max; v >= version_min; v--)
		{
			versions->write_uint16(versions, v);
		}
		versions->wrap8(versions);
		extensions->write_data16(extensions, versions->get_buf(versions));
		versions->destroy(versions);
	}

	if (this->cookie.len)
	{
		DBG2(DBG_TLS, "sending extension: %N",
			 tls_extension_names, TLS_EXT_COOKIE);
		extensions->write_uint16(extensions, TLS_EXT_COOKIE);
		extensions->write_uint16(extensions, this->cookie.len + 2);
		extensions->write_data16(extensions, this->cookie);
		chunk_free(&this->cookie);
	}

	DBG2(DBG_TLS, "sending extension: %N",
		 tls_extension_names, TLS_EXT_SIGNATURE_ALGORITHMS);
	extensions->write_uint16(extensions, TLS_EXT_SIGNATURE_ALGORITHMS);
	signatures = bio_writer_create(32);
	this->crypto->get_signature_algorithms(this->crypto, signatures, FALSE);
	extensions->write_data16(extensions, signatures->get_buf(signatures));
	signatures->destroy(signatures);

	DBG2(DBG_TLS, "sending extension: %N",
		 tls_extension_names, TLS_EXT_SIGNATURE_ALGORITHMS_CERT);
	extensions->write_uint16(extensions, TLS_EXT_SIGNATURE_ALGORITHMS_CERT);
	signatures = bio_writer_create(32);
	this->crypto->get_signature_algorithms(this->crypto, signatures, TRUE);
	extensions->write_data16(extensions, signatures->get_buf(signatures));
	signatures->destroy(signatures);

	if (this->tls->get_version_max(this->tls) >= TLS_1_3)
	{
		DBG2(DBG_TLS, "sending extension: %N",
			 tls_extension_names, TLS_EXT_KEY_SHARE);
		extensions->write_uint16(extensions, TLS_EXT_KEY_SHARE);
		if (!tls_write_key_share(&key_share, this->dh))
		{
			this->alert->add(this->alert, TLS_FATAL, TLS_INTERNAL_ERROR);
			extensions->destroy(extensions);
			return NEED_MORE;
		}
		key_share->wrap16(key_share);
		extensions->write_data16(extensions, key_share->get_buf(key_share));
		key_share->destroy(key_share);
	}

	writer->write_data16(writer, extensions->get_buf(extensions));
	extensions->destroy(extensions);

	*type = TLS_CLIENT_HELLO;
	this->state = STATE_HELLO_SENT;
	this->crypto->append_handshake(this->crypto, *type, writer->get_buf(writer));
	return NEED_MORE;
}
