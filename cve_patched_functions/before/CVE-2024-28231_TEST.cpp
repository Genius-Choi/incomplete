TEST(Security, BuiltinAuthenticationPlugin_second_participant_creation_loop)
{
    constexpr size_t n_loops = 101;

    using Log = eprosima::fastdds::dds::Log;
    using LogConsumer = eprosima::fastdds::dds::LogConsumer;

    // A LogConsumer that just counts the number of entries consumed
    struct TestConsumer : public LogConsumer
    {
        TestConsumer(
                std::atomic_size_t& n_logs_ref)
            : n_logs_(n_logs_ref)
        {
        }

        void Consume(
                const Log::Entry&) override
        {
            ++n_logs_;
        }

    private:

        std::atomic_size_t& n_logs_;
    };

    // Counter for log entries
    std::atomic<size_t>n_logs{};

    // Prepare Log module to check that no SECURITY errors are produced
    Log::SetCategoryFilter(std::regex("SECURITY"));
    Log::SetVerbosity(Log::Kind::Error);
    Log::ClearConsumers();
    Log::RegisterConsumer(std::unique_ptr<LogConsumer>(new TestConsumer(n_logs)));

    // Class to allow waiting for the authentication message to be sent
    class AuthMessageSendStatus
    {
        bool message_sent_ = false;
        std::mutex mutex_;
        std::condition_variable cv_;

    public:

        void reset()
        {
            std::lock_guard < std::mutex> guard(mutex_);
            message_sent_ = false;
        }

        void notify()
        {
            std::lock_guard<std::mutex> guard(mutex_);
            message_sent_ = true;
            cv_.notify_one();
        }

        void wait()
        {
            std::unique_lock<std::mutex> lock(mutex_);
            cv_.wait(lock, [this]() -> bool
                    {
                        return message_sent_;
                    });
        }

    };

    // Prepare transport to check that the authentication message is sent
    auto transport = std::make_shared<test_UDPv4TransportDescriptor>();
    AuthMessageSendStatus auth_message_send_status;
    transport->drop_data_messages_filter_ = [&auth_message_send_status](eprosima::fastrtps::rtps::CDRMessage_t& msg)
            -> bool
            {
                auto old_pos = msg.pos;

                // Jump to writer entity id
                msg.pos += 2 + 2 + 4;

                // Read writer entity id
                eprosima::fastrtps::rtps::GUID_t writer_guid;
                eprosima::fastrtps::rtps::CDRMessage::readEntityId(&msg, &writer_guid.entityId);
                msg.pos = old_pos;

                if (writer_guid.entityId == eprosima::fastrtps::rtps::participant_stateless_message_writer_entity_id)
                {
                    auth_message_send_status.notify();
                }

                return false;
            };

    // Prepare participant properties
    PropertyPolicy property_policy;
    property_policy.properties().emplace_back(Property("dds.sec.auth.plugin", "builtin.PKI-DH"));
    property_policy.properties().emplace_back(Property("dds.sec.auth.builtin.PKI-DH.identity_ca",
            "file://" + std::string(certs_path) + "/maincacert.pem"));
    property_policy.properties().emplace_back(Property("dds.sec.auth.builtin.PKI-DH.identity_certificate",
            "file://" + std::string(certs_path) + "/mainpubcert.pem"));
    property_policy.properties().emplace_back(Property("dds.sec.auth.builtin.PKI-DH.private_key",
            "file://" + std::string(certs_path) + "/mainpubkey.pem"));

    // Create the participant being checked
    PubSubReader<HelloWorldPubSubType> main_participant("HelloWorldTopic");
    main_participant.disable_builtin_transport().add_user_transport_to_pparams(transport);
    main_participant.property_policy(property_policy).init();
    EXPECT_TRUE(main_participant.isInitialized());

    // Perform a loop in which we create another participant, and destroy it just after it has been discovered.
    // This is the best reproducer of the issue, as authentication messages should be sent when a remote participant
    // is discovered.
    for (size_t n = 1; n <= n_loops; ++n)
    {
        std::cout << "Iteration " << n << std::endl;

        // Wait for undiscovery so we can wait for discovery below
        EXPECT_TRUE(main_participant.wait_participant_undiscovery());
        auth_message_send_status.reset();

        // Create another participant with authentication enabled
        PubSubParticipant<HelloWorldPubSubType> other_participant(0, 0, 0, 0);
        EXPECT_TRUE(other_participant.property_policy(property_policy).init_participant());

        // Wait for the main participant to send an authentication message to the other participant
        auth_message_send_status.wait();

        // The created participant gets out of scope here, and is destroyed
    }

    // No SECURITY error logs should have been produced
    Log::Flush();
    EXPECT_EQ(0u, n_logs);
}
