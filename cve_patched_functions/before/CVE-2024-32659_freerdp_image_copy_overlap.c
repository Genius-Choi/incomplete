static BOOL freerdp_image_copy_overlap(BYTE* pDstData, DWORD DstFormat, UINT32 nDstStep,
                                       UINT32 nXDst, UINT32 nYDst, UINT32 nWidth, UINT32 nHeight,
                                       const BYTE* pSrcData, DWORD SrcFormat, UINT32 nSrcStep,
                                       UINT32 nXSrc, UINT32 nYSrc, const gdiPalette* palette,
                                       UINT32 flags)
{
	const UINT32 dstByte = FreeRDPGetBytesPerPixel(DstFormat);
	const UINT32 srcByte = FreeRDPGetBytesPerPixel(SrcFormat);
	const UINT32 copyDstWidth = nWidth * dstByte;
	const UINT32 xSrcOffset = nXSrc * srcByte;
	const UINT32 xDstOffset = nXDst * dstByte;
	const BOOL vSrcVFlip = (flags & FREERDP_FLIP_VERTICAL) ? TRUE : FALSE;
	SSIZE_T srcVOffset = 0;
	SSIZE_T srcVMultiplier = 1;
	SSIZE_T dstVOffset = 0;
	SSIZE_T dstVMultiplier = 1;

	if ((nHeight > INT32_MAX) || (nWidth > INT32_MAX))
		return FALSE;

	if (!pDstData || !pSrcData)
		return FALSE;

	if (nDstStep == 0)
		nDstStep = nWidth * FreeRDPGetBytesPerPixel(DstFormat);

	if (nSrcStep == 0)
		nSrcStep = nWidth * FreeRDPGetBytesPerPixel(SrcFormat);

	if (vSrcVFlip)
	{
		srcVOffset = (nHeight - 1ll) * nSrcStep;
		srcVMultiplier = -1;
	}

	if (((flags & FREERDP_KEEP_DST_ALPHA) != 0) && FreeRDPColorHasAlpha(DstFormat))
	{
		for (SSIZE_T y = 0; y < nHeight; y++)
		{
			const BYTE* srcLine = &pSrcData[srcVMultiplier * (y + nYSrc) * nSrcStep + srcVOffset];
			BYTE* dstLine = &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];

			UINT32 color = FreeRDPReadColor(&srcLine[nXSrc * srcByte], SrcFormat);
			UINT32 oldColor = color;
			UINT32 dstColor = FreeRDPConvertColor(color, SrcFormat, DstFormat, palette);
			FreeRDPWriteColorIgnoreAlpha(&dstLine[nXDst * dstByte], DstFormat, dstColor);
			for (UINT32 x = 1; x < nWidth; x++)
			{
				color = FreeRDPReadColor(&srcLine[(x + nXSrc) * srcByte], SrcFormat);
				if (color == oldColor)
				{
					FreeRDPWriteColorIgnoreAlpha(&dstLine[(x + nXDst) * dstByte], DstFormat,
					                             dstColor);
				}
				else
				{
					oldColor = color;
					dstColor = FreeRDPConvertColor(color, SrcFormat, DstFormat, palette);
					FreeRDPWriteColorIgnoreAlpha(&dstLine[(x + nXDst) * dstByte], DstFormat,
					                             dstColor);
				}
			}
		}
	}
	else if (FreeRDPAreColorFormatsEqualNoAlpha(SrcFormat, DstFormat))
	{
		/* Copy down */
		if (nYDst < nYSrc)
		{
			for (SSIZE_T y = 0; y < nHeight; y++)
			{
				const BYTE* srcLine =
				    &pSrcData[(y + nYSrc) * nSrcStep * srcVMultiplier + srcVOffset];
				BYTE* dstLine = &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];
				memcpy(&dstLine[xDstOffset], &srcLine[xSrcOffset], copyDstWidth);
			}
		}
		/* Copy up */
		else if (nYDst > nYSrc)
		{
			for (SSIZE_T y = nHeight - 1; y >= 0; y--)
			{
				const BYTE* srcLine =
				    &pSrcData[srcVMultiplier * (y + nYSrc) * nSrcStep + srcVOffset];
				BYTE* dstLine = &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];
				memcpy(&dstLine[xDstOffset], &srcLine[xSrcOffset], copyDstWidth);
			}
		}
		/* Copy left */
		else if (nXSrc > nXDst)
		{
			for (SSIZE_T y = 0; y < nHeight; y++)
			{
				const BYTE* srcLine =
				    &pSrcData[srcVMultiplier * (y + nYSrc) * nSrcStep + srcVOffset];
				BYTE* dstLine = &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];
				memmove(&dstLine[xDstOffset], &srcLine[xSrcOffset], copyDstWidth);
			}
		}
		/* Copy right */
		else if (nXSrc < nXDst)
		{
			for (SSIZE_T y = nHeight - 1; y >= 0; y--)
			{
				const BYTE* srcLine =
				    &pSrcData[srcVMultiplier * (y + nYSrc) * nSrcStep + srcVOffset];
				BYTE* dstLine = &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];
				memmove(&dstLine[xDstOffset], &srcLine[xSrcOffset], copyDstWidth);
			}
		}
		/* Source and destination are equal... */
		else
		{
		}
	}
	else
	{
		for (SSIZE_T y = 0; y < nHeight; y++)
		{
			const BYTE* srcLine = &pSrcData[srcVMultiplier * (y + nYSrc) * nSrcStep + srcVOffset];
			BYTE* dstLine = &pDstData[dstVMultiplier * (y + nYDst) * nDstStep + dstVOffset];

			UINT32 color = FreeRDPReadColor(&srcLine[nXSrc * srcByte], SrcFormat);
			UINT32 oldColor = color;
			UINT32 dstColor = FreeRDPConvertColor(color, SrcFormat, DstFormat, palette);
			FreeRDPWriteColor(&dstLine[nXDst * dstByte], DstFormat, dstColor);
			for (SSIZE_T x = 1; x < nWidth; x++)
			{
				color = FreeRDPReadColor(&srcLine[(x + nXSrc) * srcByte], SrcFormat);
				if (color == oldColor)
				{
					FreeRDPWriteColor(&dstLine[(x + nXDst) * dstByte], DstFormat, dstColor);
				}
				else
				{
					oldColor = color;
					dstColor = FreeRDPConvertColor(color, SrcFormat, DstFormat, palette);
					FreeRDPWriteColor(&dstLine[(x + nXDst) * dstByte], DstFormat, dstColor);
				}
			}
		}
	}

	return TRUE;
}
