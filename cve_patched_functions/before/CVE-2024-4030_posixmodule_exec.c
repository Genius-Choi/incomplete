posixmodule_exec(PyObject *m)
{
    _posixstate *state = get_posix_state(m);

#if defined(HAVE_PWRITEV)
    if (HAVE_PWRITEV_RUNTIME) {} else {
        PyObject* dct = PyModule_GetDict(m);

        if (dct == NULL) {
            return -1;
        }

        if (PyDict_DelItemString(dct, "pwritev") == -1) {
            PyErr_Clear();
        }
        if (PyDict_DelItemString(dct, "preadv") == -1) {
            PyErr_Clear();
        }
    }
#endif

    /* Initialize environ dictionary */
    if (_PyModule_Add(m, "environ", convertenviron()) != 0) {
        return -1;
    }

    if (all_ins(m))
        return -1;

    if (setup_confname_tables(m))
        return -1;

    if (PyModule_AddObjectRef(m, "error", PyExc_OSError) < 0) {
        return -1;
    }

#if defined(HAVE_WAITID) && !defined(__APPLE__)
    waitid_result_desc.name = MODNAME ".waitid_result";
    state->WaitidResultType = (PyObject *)PyStructSequence_NewType(&waitid_result_desc);
    if (PyModule_AddObjectRef(m, "waitid_result", state->WaitidResultType) < 0) {
        return -1;
    }
#endif

    stat_result_desc.name = "os.stat_result"; /* see issue #19209 */
    stat_result_desc.fields[7].name = PyStructSequence_UnnamedField;
    stat_result_desc.fields[8].name = PyStructSequence_UnnamedField;
    stat_result_desc.fields[9].name = PyStructSequence_UnnamedField;
    state->StatResultType = (PyObject *)PyStructSequence_NewType(&stat_result_desc);
    if (PyModule_AddObjectRef(m, "stat_result", state->StatResultType) < 0) {
        return -1;
    }
    state->statresult_new_orig = ((PyTypeObject *)state->StatResultType)->tp_new;
    ((PyTypeObject *)state->StatResultType)->tp_new = statresult_new;

    statvfs_result_desc.name = "os.statvfs_result"; /* see issue #19209 */
    state->StatVFSResultType = (PyObject *)PyStructSequence_NewType(&statvfs_result_desc);
    if (PyModule_AddObjectRef(m, "statvfs_result", state->StatVFSResultType) < 0) {
        return -1;
    }

#if defined(HAVE_SCHED_SETPARAM) || defined(HAVE_SCHED_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDULER) || defined(POSIX_SPAWN_SETSCHEDPARAM)
    sched_param_desc.name = MODNAME ".sched_param";
    state->SchedParamType = (PyObject *)PyStructSequence_NewType(&sched_param_desc);
    if (PyModule_AddObjectRef(m, "sched_param", state->SchedParamType) < 0) {
        return -1;
    }
    ((PyTypeObject *)state->SchedParamType)->tp_new = os_sched_param;
#endif

    /* initialize TerminalSize_info */
    state->TerminalSizeType = (PyObject *)PyStructSequence_NewType(&TerminalSize_desc);
    if (PyModule_AddObjectRef(m, "terminal_size", state->TerminalSizeType) < 0) {
        return -1;
    }

    /* initialize scandir types */
    PyObject *ScandirIteratorType = PyType_FromModuleAndSpec(m, &ScandirIteratorType_spec, NULL);
    if (ScandirIteratorType == NULL) {
        return -1;
    }
    state->ScandirIteratorType = ScandirIteratorType;

    state->DirEntryType = PyType_FromModuleAndSpec(m, &DirEntryType_spec, NULL);
    if (PyModule_AddObjectRef(m, "DirEntry", state->DirEntryType) < 0) {
        return -1;
    }

    times_result_desc.name = MODNAME ".times_result";
    state->TimesResultType = (PyObject *)PyStructSequence_NewType(&times_result_desc);
    if (PyModule_AddObjectRef(m, "times_result", state->TimesResultType) < 0) {
        return -1;
    }

    state->UnameResultType = (PyObject *)PyStructSequence_NewType(&uname_result_desc);
    if (PyModule_AddObjectRef(m, "uname_result", state->UnameResultType) < 0) {
        return -1;
    }

    if ((state->billion = PyLong_FromLong(1000000000)) == NULL)
        return -1;
#if defined(HAVE_WAIT3) || defined(HAVE_WAIT4)
    state->struct_rusage = PyUnicode_InternFromString("struct_rusage");
    if (state->struct_rusage == NULL)
        return -1;
#endif
    state->st_mode = PyUnicode_InternFromString("st_mode");
    if (state->st_mode == NULL)
        return -1;

    /* suppress "function not used" warnings */
    {
    int ignored;
    fd_specified("", -1);
    follow_symlinks_specified("", 1);
    dir_fd_and_follow_symlinks_invalid("chmod", DEFAULT_DIR_FD, 1);
    dir_fd_converter(Py_None, &ignored);
    dir_fd_unavailable(Py_None, &ignored);
    }

    /*
     * provide list of locally available functions
     * so os.py can populate support_* lists
     */
    PyObject *list = PyList_New(0);
    if (!list) {
        return -1;
    }
    for (const struct have_function *trace = have_functions; trace->label; trace++) {
        PyObject *unicode;
        if (trace->probe && !trace->probe()) continue;
        unicode = PyUnicode_DecodeASCII(trace->label, strlen(trace->label), NULL);
        if (!unicode)
            return -1;
        if (PyList_Append(list, unicode))
            return -1;
        Py_DECREF(unicode);
    }

    return _PyModule_Add(m, "_have_functions", list);
}
