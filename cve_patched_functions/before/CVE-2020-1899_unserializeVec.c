Array VariableUnserializer::unserializeVec() {
  if (m_dvOverrides) m_dvOverrides->push_back(false);

  int64_t size = readInt();
  expectChar(':');
  expectChar('{');

  auto provTag = unserializeProvenanceTag();
  if (!RO::EvalArrProvHackArrays) provTag = {};

  if (size == 0) {
    expectChar('}');
    return Array::attach(provTag
      ? arrprov::tagStaticArr(staticEmptyVec(), provTag)
      : staticEmptyVec()
    );
  }
  if (UNLIKELY(size < 0 || size > std::numeric_limits<int>::max())) {
    throwArraySizeOutOfBounds();
  }
  auto const sizeClass = PackedArray::capacityToSizeIndex(size);
  auto const allocsz = MemoryManager::sizeIndex2Size(sizeClass);

  // For large arrays, do a naive pre-check for OOM.
  if (UNLIKELY(allocsz > kMaxSmallSize && tl_heap->preAllocOOM(allocsz))) {
    check_non_safepoint_surprise();
  }

  Array arr = VecInit(size).toArray();
  reserveForAdd(size);

  for (int64_t i = 0; i < size; i++) {
    unserializeVariant(PackedArray::LvalNewInPlace(arr.get()));
    if (i < size - 1) checkElemTermination();
  }
  check_non_safepoint_surprise();
  expectChar('}');
  if (provTag) arrprov::setTag<arrprov::Mode::Emplace>(arr.get(), provTag);
  return arr;
}
