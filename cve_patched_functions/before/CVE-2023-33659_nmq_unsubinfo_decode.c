nmq_unsubinfo_decode(nng_msg *msg, void *l, uint8_t ver)
{
	char           *topic;
	uint8_t         len_of_topic = 0, *payload_ptr, *var_ptr;
	uint32_t        num = 0, len, len_of_varint = 0, len_of_str = 0;
	size_t          bpos = 0, remain = 0;
	struct subinfo *sn = NULL, *sn2, snode;
	nni_list       *ll = l;

	if (!l || !msg)
		return (-1);

	len = 0;
	len_of_varint = 0;

	// Check the index of property length
	if (nni_msg_len(msg) < 3)
		return (-3);
	if (ver == MQTT_PROTOCOL_VERSION_v5) {
		len = get_var_integer(
		    (uint8_t *) nni_msg_body(msg) + 2, &len_of_varint);
		if (len > nni_msg_remaining_len(msg))
			return -1;
	}

	var_ptr     = (uint8_t *) nni_msg_body(msg);
	payload_ptr = (uint8_t *) nni_msg_body(msg) + 2 + len + len_of_varint;
	int pos = 2 + len_of_varint, target_pos = 2 + len_of_varint + len;

	while (pos < target_pos) {
		switch (*(var_ptr + pos)) {
		case USER_PROPERTY:
			// key
			NNI_GET16(var_ptr + pos, len_of_str);
			pos += (2 + len_of_str);
			// Check the index of properties
			if (pos > target_pos)
				return (-3);
			len_of_str = 0;
			// value
			NNI_GET16(var_ptr + pos, len_of_str);
			pos += (2 + len_of_str);
			// Check the index of properties
			if (pos > target_pos)
				return (-3);
			len_of_str = 0;
			break;
		default:
			log_error("Invalid property id");
			return (-2);
		}
	}
	if (pos > target_pos)
		return (-2);

	remain = nni_msg_remaining_len(msg) - target_pos;

	while (bpos < remain) {
		// Check the index of topic len
		if (bpos + 2 > remain)
			return (-3);
		NNI_GET16(payload_ptr + bpos, len_of_topic);
		bpos += 2;

		if (len_of_topic == 0)
			continue;
		// Check the index of topic body
		if (bpos + len_of_topic > remain)
			return (-3);

		log_trace(
		    "The current process topic is %s", payload_ptr + bpos);
		if ((topic = nng_alloc(len_of_topic + 1)) == NULL)
			return (-2);

		strncpy(topic, (char *) payload_ptr + bpos, len_of_topic);
		topic[len_of_topic] = 0x00;

		bpos += len_of_topic;
		// Check the index of topic option
		if (bpos > remain)
			return (-3);

		snode.topic = topic;
		sn = &snode;
		if (NULL != (sn2 = nmq_subinfol_rm_or(ll, sn))) {
			log_trace("Topic %s free from subinfol", sn2->topic);
			nng_free(sn2->topic, strlen(sn2->topic));
			nng_free(sn2, sizeof(*sn2));
		}
		nng_free(topic, len_of_topic+1);

		num++;
	}

	return num;
}
