int ntlm_encode_auth_msg(struct ntlm_ctx *ctx,
                         uint32_t flags,
                         struct ntlm_buffer *lm_chalresp,
                         struct ntlm_buffer *nt_chalresp,
                         char *domain_name, char *user_name,
                         char *workstation,
                         struct ntlm_buffer *enc_sess_key,
                         struct ntlm_buffer *mic,
                         struct ntlm_buffer *message)
{
    struct wire_auth_msg *msg;
    struct ntlm_buffer buffer;
    struct ntlm_buffer empty_chalresp = { 0 };
    size_t data_offs;
    size_t domain_name_len = 0;
    size_t user_name_len = 0;
    size_t workstation_len = 0;
    int ret = 0;

    if (!ctx) return EINVAL;

    buffer.length = sizeof(struct wire_auth_msg);

    if (lm_chalresp) {
        buffer.length += lm_chalresp->length;
    } else {
        lm_chalresp = &empty_chalresp;
    }
    if (nt_chalresp) {
        buffer.length += nt_chalresp->length;
    } else {
        nt_chalresp = &empty_chalresp;
    }
    if (domain_name) {
        domain_name_len = strlen(domain_name);
        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {
            buffer.length += domain_name_len * 2;
        } else {
            buffer.length += domain_name_len;
        }
    }
    if (user_name) {
        user_name_len = strlen(user_name);
        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {
            buffer.length += user_name_len * 2;
        } else {
            buffer.length += user_name_len;
        }
    }
    if (workstation) {
        workstation_len = strlen(workstation);
        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {
            buffer.length += workstation_len * 2;
        } else {
            buffer.length += workstation_len;
        }
    }
    if (enc_sess_key) {
        buffer.length += enc_sess_key->length;
    }
    if (mic) {
        buffer.length += 16;
    }

    buffer.data = calloc(1, buffer.length);
    if (!buffer.data) return ENOMEM;

    msg = (struct wire_auth_msg *)buffer.data;
    data_offs = (char *)msg->payload - (char *)msg;

    ntlm_encode_header(&msg->header, AUTHENTICATE_MESSAGE);

    /* this must be first as it pushes the payload further down */
    if (flags & NTLMSSP_NEGOTIATE_VERSION) {
        ret = ntlm_encode_version(ctx, &buffer,
                                  (char *)&msg->version - (char *)msg);
        if (ret) goto done;
    }

    /* this pushes the payload further down */
    if (mic) {
        memset(&buffer.data[data_offs], 0, mic->length);
        /* return the actual pointer back in the mic, as it will
         * be backfilled later by the caller */
        mic->data = &buffer.data[data_offs];
        data_offs += mic->length;
    }

    ret = ntlm_encode_field(&msg->lm_chalresp, &buffer,
                            &data_offs, lm_chalresp);
    if (ret) goto done;

    ret = ntlm_encode_field(&msg->nt_chalresp, &buffer,
                            &data_offs, nt_chalresp);
    if (ret) goto done;

    if (domain_name_len) {
        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {
            ret = ntlm_encode_u16l_str_hdr(ctx, &msg->domain_name,
                                           &buffer, &data_offs,
                                           domain_name, domain_name_len);
        } else {
            ret = ntlm_encode_oem_str(&msg->domain_name,
                                      &buffer, &data_offs,
                                      domain_name, domain_name_len);
        }
        if (ret) goto done;
    }
    if (user_name_len) {
        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {
            ret = ntlm_encode_u16l_str_hdr(ctx, &msg->user_name,
                                           &buffer, &data_offs,
                                           user_name, user_name_len);
        } else {
            ret = ntlm_encode_oem_str(&msg->user_name,
                                      &buffer, &data_offs,
                                      user_name, user_name_len);
        }
        if (ret) goto done;
    }
    if (workstation_len) {
        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {
            ret = ntlm_encode_u16l_str_hdr(ctx, &msg->workstation,
                                           &buffer, &data_offs,
                                           workstation, workstation_len);
        } else {
            ret = ntlm_encode_oem_str(&msg->workstation,
                                      &buffer, &data_offs,
                                      workstation, workstation_len);
        }
        if (ret) goto done;
    }
    if (enc_sess_key) {
        ret = ntlm_encode_field(&msg->enc_sess_key, &buffer,
                                &data_offs, enc_sess_key);
        if (ret) goto done;
    }

    msg->neg_flags = htole32(flags);

done:
    if (ret) {
        safefree(buffer.data);
    } else {
        *message = buffer;
    }
    return ret;
}
