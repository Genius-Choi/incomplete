static switch_size_t do_flush(switch_rtp_t *rtp_session, int force, switch_size_t bytes_in)
{
	int was_blocking = 0;
	switch_size_t bytes;
	switch_size_t bytes_out = 0;

	if (!switch_rtp_ready(rtp_session)) {
		return 0;
	}

	reset_jitter_seq(rtp_session);

	if (!force) {
		if ((rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) ||
			rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] ||
			rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] ||
			rtp_session->flags[SWITCH_RTP_FLAG_DTMF_ON]
			) {
			return bytes_in;
		}
	}

	READ_INC(rtp_session);

	if (switch_rtp_ready(rtp_session) ) {

		if (rtp_session->jb && !rtp_session->pause_jb && jb_valid(rtp_session)) {
			//switch_jb_reset(rtp_session->jb);
			bytes_out = bytes_in;
			goto end;
		}

		if (rtp_session->vbw) {
			switch_jb_reset(rtp_session->vbw);
		}

		if (rtp_session->vb) {
			//switch_jb_reset(rtp_session->vb);
			bytes_out = bytes_in;
			goto end;
		}

		if (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_READ]) {
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session),
							  SWITCH_LOG_CONSOLE, "%s FLUSH\n",
							  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : "NoName"
							  );
		}

		if (!rtp_session->flags[SWITCH_RTP_FLAG_NOBLOCK]) {
			was_blocking = 1;
			switch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);
			switch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, TRUE);
		}

		// before processing/flushing packets, if current packet is rfc2833, handle it (else it would be lost)
		if (bytes_in > rtp_header_len && rtp_session->last_rtp_hdr.version == 2 && rtp_session->last_rtp_hdr.pt == rtp_session->recv_te) {
		    int do_cng = 0;
#ifdef DEBUG_2833
			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "*** Handling current RTP packet before flushing. seq=%u ***\n", ntohs(rtp_session->last_rtp_hdr.seq));
#endif
		    handle_rfc2833(rtp_session, bytes_in, &do_cng);
		}

		do {
			if (switch_rtp_ready(rtp_session)) {
				bytes = sizeof(rtp_msg_t);
				switch_socket_recvfrom(rtp_session->from_addr, rtp_session->sock_input, 0, (void *) &rtp_session->recv_msg, &bytes);

				if (bytes) {
					int do_cng = 0;

					if (rtp_session->media_timeout) {
						rtp_session->last_media = switch_micro_time_now();
					}

					/* Make sure to handle RFC2833 packets, even if we're flushing the packets */
					if (bytes > rtp_header_len && rtp_session->recv_msg.header.version == 2 && rtp_session->recv_msg.header.pt == rtp_session->recv_te) {
						rtp_session->last_rtp_hdr = rtp_session->recv_msg.header;
						handle_rfc2833(rtp_session, bytes, &do_cng);
#ifdef DEBUG_2833
						switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "*** RTP packet handled in flush loop %d ***\n", do_cng);
#endif
					}

					rtp_session->stats.inbound.raw_bytes += bytes;
					rtp_session->stats.inbound.flush_packet_count++;
					rtp_session->stats.inbound.packet_count++;
				}
			} else {
				break;
			}
		} while (bytes > 0);

#ifdef DEBUG_2833
        if (flushed) {
            switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "*** do_flush: total flushed packets: %ld ***\n",(long)flushed);
        }
#endif


		if (was_blocking && switch_rtp_ready(rtp_session)) {
			switch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);
			switch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, FALSE);
		}


		if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->session) {
			//int type = 1; // sum flags: 1 encoder; 2; decoder
			//switch_core_media_codec_control(rtp_session->session, SWITCH_MEDIA_TYPE_VIDEO, SWITCH_IO_READ, SCC_VIDEO_RESET, SCCT_INT, (void *)&type, NULL, NULL);
			switch_core_session_request_video_refresh(rtp_session->session);
		}
	}

 end:

	READ_DEC(rtp_session);

	return bytes_out;
}
