extern "C" HRESULT CoreCreateCleanRoomCommandLine(
    __deref_inout_z LPWSTR* psczCommandLine,
    __in BURN_ENGINE_STATE* pEngineState,
    __in_z LPCWSTR wzCleanRoomBundlePath,
    __in_z LPCWSTR wzCurrentProcessPath,
    __inout HANDLE* phFileAttached,
    __inout HANDLE* phFileSelf
    )
{
    HRESULT hr = S_OK;
    BOOTSTRAPPER_COMMAND* pCommand = &pEngineState->command;
    BURN_ENGINE_COMMAND* pInternalCommand = &pEngineState->internalCommand;

    // The clean room switch must always be at the front of the command line so
    // the EngineInCleanRoom function will operate correctly.
    hr = StrAllocFormatted(psczCommandLine, L"-%ls=\"%ls\"", BURN_COMMANDLINE_SWITCH_CLEAN_ROOM, wzCurrentProcessPath);
    ExitOnFailure(hr, "Failed to allocate parameters for unelevated process.");

    // Send a file handle for the child Burn process to access the attached container.
    hr = CoreAppendFileHandleAttachedToCommandLine(pEngineState->section.hEngineFile, phFileAttached, psczCommandLine);
    ExitOnFailure(hr, "Failed to append %ls", BURN_COMMANDLINE_SWITCH_FILEHANDLE_ATTACHED);

    // Grab a file handle for the child Burn process.
    hr = CoreAppendFileHandleSelfToCommandLine(wzCleanRoomBundlePath, phFileSelf, psczCommandLine, NULL);
    ExitOnFailure(hr, "Failed to append %ls", BURN_COMMANDLINE_SWITCH_FILEHANDLE_SELF);

    hr = CoreAppendSplashScreenWindowToCommandLine(pCommand->hwndSplashScreen, psczCommandLine);
    ExitOnFailure(hr, "Failed to append %ls", BURN_COMMANDLINE_SWITCH_SPLASH_SCREEN);

    if (pInternalCommand->sczLogFile)
    {
        LPCWSTR wzLogParameter = (BURN_LOGGING_ATTRIBUTE_EXTRADEBUG & pInternalCommand->dwLoggingAttributes) ? L"xlog" : L"log";
        hr = StrAllocConcatFormatted(psczCommandLine, L" /%ls", wzLogParameter);
        ExitOnFailure(hr, "Failed to append logging switch.");

        hr = AppAppendCommandLineArgument(psczCommandLine, pInternalCommand->sczLogFile);
        ExitOnFailure(hr, "Failed to append custom log path.");
    }

    hr = AppendLayoutToCommandLine(pCommand->action, pCommand->wzLayoutDirectory, psczCommandLine);
    ExitOnFailure(hr, "Failed to append layout.");

    switch (pInternalCommand->automaticUpdates)
    {
    case BURN_AU_PAUSE_ACTION_NONE:
        hr = StrAllocConcat(psczCommandLine, L" /noaupause", 0);
        ExitOnFailure(hr, "Failed to append /noaupause.");
        break;
    case BURN_AU_PAUSE_ACTION_IFELEVATED_NORESUME:
        hr = StrAllocConcat(psczCommandLine, L" /keepaupaused", 0);
        ExitOnFailure(hr, "Failed to append /keepaupaused.");
        break;
    }

    // TODO: This should only be added if it was enabled from the command line.
    if (pInternalCommand->fDisableSystemRestore)
    {
        hr = StrAllocConcat(psczCommandLine, L" /disablesystemrestore", 0);
        ExitOnFailure(hr, "Failed to append /disablesystemrestore.");
    }

    if (pInternalCommand->sczOriginalSource)
    {
        hr = StrAllocConcat(psczCommandLine, L" /originalsource", 0);
        ExitOnFailure(hr, "Failed to append /originalsource.");

        hr = AppAppendCommandLineArgument(psczCommandLine, pInternalCommand->sczOriginalSource);
        ExitOnFailure(hr, "Failed to append original source.");
    }

    if (pEngineState->embeddedConnection.sczName)
    {
        hr = StrAllocConcatFormatted(psczCommandLine, L" -%ls %ls %ls %u", BURN_COMMANDLINE_SWITCH_EMBEDDED, pEngineState->embeddedConnection.sczName, pEngineState->embeddedConnection.sczSecret, pEngineState->embeddedConnection.dwProcessId);
        ExitOnFailure(hr, "Failed to allocate embedded command.");
    }

    if (pInternalCommand->sczIgnoreDependencies)
    {
        hr = StrAllocConcatFormatted(psczCommandLine, L" /%ls=%ls", BURN_COMMANDLINE_SWITCH_IGNOREDEPENDENCIES, pInternalCommand->sczIgnoreDependencies);
        ExitOnFailure(hr, "Failed to append ignored dependencies to command-line.");
    }

    hr = CoreRecreateCommandLine(psczCommandLine, pCommand->action, pInternalCommand, pCommand, pCommand->relationType, pCommand->fPassthrough);
    ExitOnFailure(hr, "Failed to recreate clean room command-line.");

LExit:
    return hr;
}
