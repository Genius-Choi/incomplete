static int rsa(void) {
	int code = RLC_ERR;
	rsa_t pub, prv;
	uint8_t in[10], out[RLC_BN_BITS / 8 + 1], h[RLC_MD_LEN];
	size_t il, ol;
	int result;

	rsa_null(pub);
	rsa_null(prv);

	RLC_TRY {
		rsa_new(pub);
		rsa_new(prv);

		result = cp_rsa_gen(pub, prv, RLC_BN_BITS);

		TEST_CASE("rsa encryption/decryption is correct") {
			TEST_ASSERT(result == RLC_OK, end);
			il = 10;
			ol = RLC_BN_BITS / 8 + 1;
			rand_bytes(in, il);
			TEST_ASSERT(cp_rsa_enc(out, &ol, in, il, pub) == RLC_OK, end);
			TEST_ASSERT(cp_rsa_dec(out, &ol, out, ol, prv) == RLC_OK, end);
			TEST_ASSERT(memcmp(in, out, ol) == 0, end);
		} TEST_END;

		result = cp_rsa_gen(pub, prv, RLC_BN_BITS);

		TEST_CASE("rsa signature/verification is correct") {
			TEST_ASSERT(result == RLC_OK, end);
			il = 10;
			ol = RLC_BN_BITS / 8 + 1;
			rand_bytes(in, il);
			TEST_ASSERT(cp_rsa_sig(out, &ol, in, il, 0, prv) == RLC_OK, end);
			TEST_ASSERT(cp_rsa_ver(out, ol, in, il, 0, pub) == 1, end);
			md_map(h, in, il);
			TEST_ASSERT(cp_rsa_sig(out, &ol, h, RLC_MD_LEN, 1, prv) == RLC_OK, end);
			TEST_ASSERT(cp_rsa_ver(out, ol, h, RLC_MD_LEN, 1, pub) == 1, end);
		} TEST_END;
	} RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;

  end:
	rsa_free(pub);
	rsa_free(prv);
	return code;
}
