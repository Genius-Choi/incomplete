void ConnectionImpl::dumpState(std::ostream& os, int indent_level) const {
  const char* spaces = spacesForLevel(indent_level);
  os << spaces << "Http1::ConnectionImpl " << this << DUMP_MEMBER(dispatching_)
     << DUMP_MEMBER(dispatching_slice_already_drained_) << DUMP_MEMBER(reset_stream_called_)
     << DUMP_MEMBER(handling_upgrade_) << DUMP_MEMBER(deferred_end_stream_headers_)
     << DUMP_MEMBER(processing_trailers_) << DUMP_MEMBER(buffered_body_.length());

  // Dump header parsing state, and any progress on headers.
  os << DUMP_MEMBER(header_parsing_state_);
  os << DUMP_MEMBER_AS(current_header_field_, current_header_field_.getStringView());
  os << DUMP_MEMBER_AS(current_header_value_, current_header_value_.getStringView());

  // Dump Child
  os << '\n';
  dumpAdditionalState(os, indent_level);

  // Dump the first slice of the dispatching buffer if not drained escaping
  // certain characters. We do this last as the slice could be rather large.
  if (current_dispatching_buffer_ == nullptr || dispatching_slice_already_drained_) {
    // Buffer is either null or already drained (in the body).
    // Use the macro for consistent formatting.
    os << DUMP_NULLABLE_MEMBER(current_dispatching_buffer_, "drained");
    return;
  } else {
    absl::string_view front_slice = [](Buffer::RawSlice slice) {
      return absl::string_view(static_cast<const char*>(slice.mem_), slice.len_);
    }(current_dispatching_buffer_->frontSlice());

    // Dump buffer data escaping \r, \n, \t, ", ', and \.
    // This is not the most performant implementation, but we're crashing and
    // cannot allocate memory.
    os << spaces << "current_dispatching_buffer_ front_slice length: " << front_slice.length()
       << " contents: \"";
    StringUtil::escapeToOstream(os, front_slice);
    os << "\"\n";
  }
}
