ExecutionStatus populateInstrumentedStats(Runtime &runtime, AP addProp) {
  constexpr bool addPropTakesValue =
      std::is_invocable_v<AP, const char *, double>;
  constexpr bool addPropGeneratesValue = std::is_invocable_v<AP, const char *>;
  static_assert(
      addPropGeneratesValue || addPropTakesValue, "invalid addProp prototype");

  // PASSTHROUGH_PROP is used to populate the instrumented stats objects with
  // properties that are no longer being returned by hermes, but at one point
  // where, and thus are kept here for synth trace playback compatibility only.
#define PASSTHROUGH_PROP(name)                                          \
  do {                                                                  \
    if constexpr (addPropGeneratesValue) {                              \
      if (LLVM_UNLIKELY(addProp(name) == ExecutionStatus::EXCEPTION)) { \
        return ExecutionStatus::EXCEPTION;                              \
      }                                                                 \
    }                                                                   \
  } while (0)

#define ADD_PROP(name, value)                                                  \
  do {                                                                         \
    if constexpr (addPropGeneratesValue) {                                     \
      PASSTHROUGH_PROP(name);                                                  \
    } else {                                                                   \
      if (LLVM_UNLIKELY(addProp(name, value) == ExecutionStatus::EXCEPTION)) { \
        return ExecutionStatus::EXCEPTION;                                     \
      }                                                                        \
    }                                                                          \
  } while (0)

  auto &heap = runtime.getHeap();
  GCBase::HeapInfo info;
  heap.getHeapInfo(info);

  // To ensure synth trace compatibility, properties should not be removed nor
  // reordered. To "remove" a property use PASSTHROUGH_PROP instead of ADD_PROP.
  PASSTHROUGH_PROP("js_hostFunctionTime");
  PASSTHROUGH_PROP("js_hostFunctionCPUTime");
  PASSTHROUGH_PROP("js_hostFunctionCount");
  PASSTHROUGH_PROP("js_evaluateJSTime");
  PASSTHROUGH_PROP("js_evaluateJSCPUTime");
  PASSTHROUGH_PROP("js_evaluateJSCount");
  PASSTHROUGH_PROP("js_incomingFunctionTime");
  PASSTHROUGH_PROP("js_incomingFunctionCPUTime");
  PASSTHROUGH_PROP("js_incomingFunctionCount");
  ADD_PROP("js_VMExperiments", runtime.getVMExperimentFlags());
  PASSTHROUGH_PROP("js_hermesTime");
  PASSTHROUGH_PROP("js_hermesCPUTime");
  PASSTHROUGH_PROP("js_hermesThreadMinorFaults");
  PASSTHROUGH_PROP("js_hermesThreadMajorFaults");
  ADD_PROP("js_numGCs", heap.getNumGCs());
  ADD_PROP("js_gcCPUTime", heap.getGCCPUTime());
  ADD_PROP("js_gcTime", heap.getGCTime());
  ADD_PROP("js_totalAllocatedBytes", info.totalAllocatedBytes);
  ADD_PROP("js_allocatedBytes", info.allocatedBytes);
  ADD_PROP("js_heapSize", info.heapSize);
  ADD_PROP("js_mallocSizeEstimate", info.mallocSizeEstimate);
  ADD_PROP("js_vaSize", info.va);
  ADD_PROP("js_markStackOverflows", info.numMarkStackOverflows);
  PASSTHROUGH_PROP("js_hermesVolCtxSwitches");
  PASSTHROUGH_PROP("js_hermesInvolCtxSwitches");
  PASSTHROUGH_PROP("js_pageSize");
  PASSTHROUGH_PROP("js_threadAffinityMask");
  PASSTHROUGH_PROP("js_threadCPU");
  PASSTHROUGH_PROP("js_bytecodePagesResident");
  PASSTHROUGH_PROP("js_bytecodePagesResidentRuns");
  PASSTHROUGH_PROP("js_bytecodePagesAccessed");
  PASSTHROUGH_PROP("js_bytecodeSize");
  PASSTHROUGH_PROP("js_bytecodePagesTraceHash");
  PASSTHROUGH_PROP("js_bytecodeIOTime");
  PASSTHROUGH_PROP("js_bytecodePagesTraceSample");

#undef PASSTHROUGH_PROP
#undef ADD_PROP

  return ExecutionStatus::RETURNED;
}
