void OSDMonitor::create_initial()
{
  dout(10) << "create_initial for " << mon->monmap->fsid << dendl;

  OSDMap newmap;

  bufferlist bl;
  mon->store->get("mkfs", "osdmap", bl);

  if (bl.length()) {
    newmap.decode(bl);
    newmap.set_fsid(mon->monmap->fsid);
  } else {
    newmap.build_simple(cct, 0, mon->monmap->fsid, 0);
  }
  newmap.set_epoch(1);
  newmap.created = newmap.modified = ceph_clock_now();

  // new clusters should sort bitwise by default.
  newmap.set_flag(CEPH_OSDMAP_SORTBITWISE);

  newmap.flags |=
    CEPH_OSDMAP_RECOVERY_DELETES |
    CEPH_OSDMAP_PURGED_SNAPDIRS;
  newmap.full_ratio = g_conf->mon_osd_full_ratio;
  if (newmap.full_ratio > 1.0) newmap.full_ratio /= 100;
  newmap.backfillfull_ratio = g_conf->mon_osd_backfillfull_ratio;
  if (newmap.backfillfull_ratio > 1.0) newmap.backfillfull_ratio /= 100;
  newmap.nearfull_ratio = g_conf->mon_osd_nearfull_ratio;
  if (newmap.nearfull_ratio > 1.0) newmap.nearfull_ratio /= 100;

  // new cluster should require latest by default
  if (g_conf->get_val<bool>("mon_debug_no_require_nautilus")) {
    if (g_conf->mon_debug_no_require_mimic) {
      derr << __func__ << " mon_debug_no_require_mimic=true and nautilus=true" << dendl;
      newmap.require_osd_release = CEPH_RELEASE_LUMINOUS;
    } else {
      derr << __func__ << " mon_debug_no_require_nautilus=true" << dendl;
      newmap.require_osd_release = CEPH_RELEASE_MIMIC;
    }
  } else {
    newmap.require_osd_release = CEPH_RELEASE_NAUTILUS;
    int r = ceph_release_from_name(
      g_conf->mon_osd_initial_require_min_compat_client.c_str());
    if (r <= 0) {
      assert(0 == "mon_osd_initial_require_min_compat_client is not valid");
    }
    newmap.require_min_compat_client = r;
  }

  // encode into pending incremental
  uint64_t features = newmap.get_encoding_features();
  newmap.encode(pending_inc.fullmap,
                features | CEPH_FEATURE_RESERVED);
  pending_inc.full_crc = newmap.get_crc();
  dout(20) << " full crc " << pending_inc.full_crc << dendl;
}
