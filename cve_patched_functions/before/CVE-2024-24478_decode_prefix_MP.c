decode_prefix_MP(proto_tree *tree, int hf_path_id, int hf_addr4, int hf_addr6,
                 guint16 afi, guint8 safi, gint tlen, tvbuff_t *tvb, gint offset,
                 const char *tag, packet_info *pinfo)
{
    int                 start_offset = offset;
    proto_item          *ti;
    proto_tree          *prefix_tree;
    proto_item          *nlri_ti;
    proto_tree          *nlri_tree;
    proto_item          *disting_item;
    proto_tree          *disting_tree;

    int                 total_length=0;     /* length of the entire item */
    int                 length;             /* length of the prefix address, in bytes */
    int                 tmp_length;
    guint               plen;               /* length of the prefix address, in bits */
    guint               labnum;             /* number of labels             */
    guint16             tnl_id;             /* Tunnel Identifier */
    ws_in4_addr         ip4addr;            /* IPv4 address                 */
    address addr;
    ws_in6_addr         ip6addr;            /* IPv6 address                 */
    guint16             nlri_type;          /* NLRI Type                    */
    guint16             tmp16;
    guint32             path_identifier=0;
    gint                end=0;              /* Message End                  */

    wmem_strbuf_t      *stack_strbuf;       /* label stack                  */
    wmem_strbuf_t      *comm_strbuf;

    switch (afi) {

    case AFNUM_INET:
        switch (safi) {

            case SAFNUM_UNICAST:
            case SAFNUM_MULCAST:
            case SAFNUM_UNIMULC:
                /* parse each prefix */

                end = offset + tlen;

                /* Heuristic to detect if IPv4 prefix are using Path Identifiers */
                if( detect_add_path_prefix4(tvb, offset, end) ) {
                    /* IPv4 prefixes with Path Id */
                    total_length = decode_path_prefix4(tree, pinfo, hf_path_id, hf_addr4, tvb, offset, tag);
                } else {
                    total_length = decode_prefix4(tree, pinfo, NULL,hf_addr4, tvb, offset, tag);
                }
                if (total_length < 0)
                    return -1;
                break;

            case SAFNUM_MPLS_LABEL:
                end = offset + tlen;
                /* Heuristic to detect if IPv4 prefix are using Path Identifiers */
                if( detect_add_path_prefix46(tvb, offset, end, 255) ) {
                    /* snarf path identifier */
                    path_identifier = tvb_get_ntohl(tvb, offset);
                    offset += 4;
                    total_length += 4;
                }
                /* snarf length */
                plen =  tvb_get_guint8(tvb, offset);
                stack_strbuf = wmem_strbuf_create(pinfo->pool);
                labnum = decode_MPLS_stack(tvb, offset + 1, stack_strbuf);

                offset += (1 + labnum * 3);
                if (plen <= (labnum * 3*8)) {
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_prefix_length_invalid, tvb, start_offset, 1,
                                        "%s Labeled IPv4 prefix length %u invalid",
                                        tag, plen);
                    return -1;
                }
                plen -= (labnum * 3*8);
                length = tvb_get_ipv4_addr_with_prefix_len(tvb, offset, &ip4addr, plen);
                if (length < 0) {
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_prefix_length_invalid, tvb, start_offset, 1,
                                        "%s Labeled IPv4 prefix length %u invalid",
                                        tag, plen + (labnum * 3*8));
                    return -1;
                }

                set_address(&addr, AT_IPv4, 4, &ip4addr);
                if (total_length > 0) {
                    prefix_tree = proto_tree_add_subtree_format(tree, tvb, start_offset,
                                         (offset + length) - start_offset,
                                         ett_bgp_prefix, NULL,
                                         "Label Stack=%s IPv4=%s/%u PathID %u",
                                         wmem_strbuf_get_str(stack_strbuf),
                                         address_to_str(pinfo->pool, &addr), plen, path_identifier);
                    proto_tree_add_item(prefix_tree, hf_path_id, tvb, start_offset, 4, ENC_BIG_ENDIAN);
                    start_offset += 4;
                } else {
                    prefix_tree = proto_tree_add_subtree_format(tree, tvb, start_offset,
                                        (offset + length) - start_offset,
                                        ett_bgp_prefix, NULL,
                                        "Label Stack=%s IPv4=%s/%u",
                                        wmem_strbuf_get_str(stack_strbuf),
                                        address_to_str(pinfo->pool, &addr), plen);
                }
                proto_tree_add_uint_format(prefix_tree, hf_bgp_prefix_length, tvb, start_offset, 1, plen + labnum * 3 * 8,
                                        "%s Prefix length: %u", tag, plen + labnum * 3 * 8);
                proto_tree_add_string_format(prefix_tree, hf_bgp_label_stack, tvb, start_offset + 1, 3 * labnum, wmem_strbuf_get_str(stack_strbuf),
                                        "%s Label Stack: %s", tag, wmem_strbuf_get_str(stack_strbuf));
                total_length += (1 + labnum*3) + length;
                proto_tree_add_ipv4(prefix_tree, hf_addr4, tvb, offset, length, ip4addr);
                break;
            case SAFNUM_MCAST_VPN:
                total_length = decode_mcast_vpn_nlri(tree, tvb, offset, afi, pinfo);
                if (total_length < 0)
                    return -1;
                break;
            case SAFNUM_MDT:
                total_length = decode_mdt_safi(pinfo, tree, tvb, offset);
                if (total_length < 0)
                    return -1;
                break;
            case SAFNUM_ROUTE_TARGET:
                plen = tvb_get_guint8(tvb, offset);

                if (plen == 0) {
                    proto_tree_add_string(tree, hf_bgp_wildcard_route_target, tvb, offset, 1, tag);
                    total_length = 1;
                    break;
                }

                if ((plen < 32) || (plen > 96)) {
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_length_invalid, tvb, offset, 1,
                                        "%s Route target length %u invalid",
                                        tag, plen);
                    return -1;
                }

                length = (plen + 7)/8;
                comm_strbuf = wmem_strbuf_create(pinfo->pool);

                switch (tvb_get_ntohs(tvb, offset + 1 + 4)) {
                case BGP_EXT_COM_RT_AS2:
                    wmem_strbuf_append_printf(comm_strbuf, "%u:%u",
                                              tvb_get_ntohs(tvb, offset + 1 + 6),
                                              tvb_get_ntohl(tvb, offset + 1 + 8));
                    break;
                case BGP_EXT_COM_RT_IP4:
                    wmem_strbuf_append_printf(comm_strbuf, "%s:%u",
                                              tvb_ip_to_str(pinfo->pool, tvb, offset + 1 + 6),
                                              tvb_get_ntohs(tvb, offset + 1 + 10));
                    break;
                case BGP_EXT_COM_RT_AS4:
                    wmem_strbuf_append_printf(comm_strbuf, "%u:%u",
                                              tvb_get_ntohl(tvb, 6),
                                              tvb_get_ntohs(tvb, offset + 1 + 10));
                    break;
                default:
                    wmem_strbuf_append_printf(comm_strbuf, "Invalid RT type");
                    break;
                }
                prefix_tree = proto_tree_add_subtree_format(tree, tvb, offset + 1, length,
                                    ett_bgp_prefix, NULL, "%s %u:%s/%u",
                                    tag, tvb_get_ntohl(tvb, offset + 1 + 0),
                                    wmem_strbuf_get_str(comm_strbuf),
                                    plen);
                proto_tree_add_item(prefix_tree, hf_bgp_prefix_length, tvb, offset, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(prefix_tree, hf_bgp_originating_as, tvb, offset + 1, 4, ENC_BIG_ENDIAN);
                proto_tree_add_string(prefix_tree, hf_bgp_community_prefix, tvb, offset + 1 + 4, length - 4, wmem_strbuf_get_str(comm_strbuf));
                total_length = 1 + length;
                break;
            case SAFNUM_ENCAPSULATION:
                plen =  tvb_get_guint8(tvb, offset);
                if (plen != 32){
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_length_invalid, tvb, offset, 1,
                                        "%s IPv4 address length %u invalid",
                                        tag, plen);
                    return -1;
                }
                offset += 1;

                proto_tree_add_item(tree, hf_bgp_endpoint_address, tvb, offset, 4, ENC_NA);

                total_length = 5; /* length(1 octet) + address(4 octets) */
                break;
            case SAFNUM_TUNNEL:
                plen =  tvb_get_guint8(tvb, offset);
                if (plen <= 16){
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_prefix_length_invalid, tvb, start_offset, 1,
                                        "%s Tunnel IPv4 prefix length %u invalid",
                                        tag, plen);
                    return -1;
                }
                tnl_id = tvb_get_ntohs(tvb, offset + 1);
                offset += 3; /* Length + Tunnel Id */
                plen -= 16; /* 2-octet Identifier */
                length = tvb_get_ipv4_addr_with_prefix_len(tvb, offset, &ip4addr, plen);
                if (length < 0) {
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_prefix_length_invalid, tvb, start_offset, 1,
                                        "%s Tunnel IPv4 prefix length %u invalid",
                                        tag, plen + 16);
                    return -1;
                }
                set_address(&addr, AT_IPv4, 4, &ip4addr);
                prefix_tree = proto_tree_add_subtree_format(tree, tvb, start_offset,
                                         (offset + length) - start_offset,
                                         ett_bgp_prefix, NULL,
                                         "Tunnel Identifier=0x%x IPv4=%s/%u",
                                         tnl_id, address_to_str(pinfo->pool, &addr), plen);

                proto_tree_add_item(prefix_tree, hf_bgp_prefix_length, tvb, start_offset, 1, ENC_BIG_ENDIAN);

                proto_tree_add_item(prefix_tree, hf_bgp_mp_nlri_tnl_id, tvb,
                                    start_offset + 1, 2, ENC_BIG_ENDIAN);
                proto_tree_add_ipv4(prefix_tree, hf_addr4, tvb, offset, length, ip4addr);
                total_length = 1 + 2 + length; /* length field + Tunnel Id + IPv4 len */
                break;
            case SAFNUM_SR_POLICY:
                total_length = decode_sr_policy_nlri(tree, tvb, offset, afi);
                if (total_length < 0)
                    return -1;
                break;
            case SAFNUM_LAB_VPNUNICAST:
            case SAFNUM_LAB_VPNMULCAST:
            case SAFNUM_LAB_VPNUNIMULC:
                plen =  tvb_get_guint8(tvb, offset);
                stack_strbuf = wmem_strbuf_create(pinfo->pool);
                labnum = decode_MPLS_stack(tvb, offset + 1, stack_strbuf);

                offset += (1 + labnum * 3);
                if (plen <= (labnum * 3*8)) {
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_prefix_length_invalid, tvb, start_offset, 1,
                                        "%s Labeled VPN IPv4 prefix length %u invalid",
                                        tag, plen);
                    return -1;
                }
                plen -= (labnum * 3*8);

                if (plen < 8*8) {
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_prefix_length_invalid, tvb, start_offset, 1,
                                        "%s Labeled VPN IPv4 prefix length %u invalid",
                                        tag, plen + (labnum * 3*8));
                    return -1;
                }
                plen -= 8*8;

                length = tvb_get_ipv4_addr_with_prefix_len(tvb, offset + 8, &ip4addr, plen);
                if (length < 0) {
                proto_tree_add_expert_format(tree, pinfo, &ei_bgp_prefix_length_invalid, tvb, start_offset, 1,
                                             "%s Labeled VPN IPv4 prefix length %u invalid",
                                             tag, plen + (labnum * 3*8) + 8*8);
                     return -1;
                }
                set_address(&addr, AT_IPv4, 4, &ip4addr);
                prefix_tree = proto_tree_add_subtree_format(tree, tvb, start_offset,
                                                 (offset + 8 + length) - start_offset,
                                                 ett_bgp_prefix, NULL, "BGP Prefix");

                proto_tree_add_item(prefix_tree, hf_bgp_prefix_length, tvb, start_offset, 1, ENC_NA);
                proto_tree_add_string(prefix_tree, hf_bgp_label_stack, tvb, start_offset + 1, 3 * labnum, wmem_strbuf_get_str(stack_strbuf));
                proto_tree_add_string(prefix_tree, hf_bgp_rd, tvb, start_offset + 1 + 3 * labnum, 8, decode_bgp_rd(pinfo->pool, tvb, offset));

                proto_tree_add_ipv4(prefix_tree, hf_addr4, tvb, offset + 8, length, ip4addr);

                total_length = (1 + labnum * 3 + 8) + length;
                break;

           case SAFNUM_FSPEC_RULE:
           case SAFNUM_FSPEC_VPN_RULE:
             total_length = decode_flowspec_nlri(tree, tvb, offset, afi, safi, pinfo);
             if(total_length < 0)
               return(-1);
             total_length++;
           break;
            case SAFNUM_BGP_MUP:
                total_length = decode_bgp_mup_nlri(tree, tvb, offset, pinfo, afi);
                break;
           default:
                proto_tree_add_expert_format(tree, pinfo, &ei_bgp_unknown_safi, tvb, start_offset, 0,
                                    "Unknown SAFI (%u) for AFI %u", safi, afi);
                return -1;
        } /* switch (safi) */
        break;

    case AFNUM_INET6:
        switch (safi) {

            case SAFNUM_UNICAST:
            case SAFNUM_MULCAST:
            case SAFNUM_UNIMULC:
                /* parse each prefix */

                end = offset + tlen;

                /* Heuristic to detect if IPv6 prefix are using Path Identifiers */
                if( detect_add_path_prefix6(tvb, offset, end) ) {
                    /* IPv6 prefixes with Path Id */
                    total_length = decode_path_prefix6(tree, pinfo, hf_path_id, hf_addr6, tvb, offset, tag);
                } else {
                    total_length = decode_prefix6(tree, pinfo, hf_addr6, tvb, offset, 0, tag);
                }
                if (total_length < 0)
                    return -1;
                break;

            case SAFNUM_MPLS_LABEL:
                end = offset + tlen;
                /* Heuristic to detect if IPv6 prefix are using Path Identifiers */
                if( detect_add_path_prefix46(tvb, offset, end, 255) ) {
                    /* snarf path identifier */
                    path_identifier = tvb_get_ntohl(tvb, offset);
                    offset += 4;
                    total_length += 4;
                }
                /* snarf length */
                plen =  tvb_get_guint8(tvb, offset);
                stack_strbuf = wmem_strbuf_create(pinfo->pool);
                labnum = decode_MPLS_stack(tvb, offset + 1, stack_strbuf);

                offset += (1 + labnum * 3);
                if (plen <= (labnum * 3*8)) {
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_prefix_length_invalid, tvb, start_offset, 1,
                                        "%s Labeled IPv6 prefix length %u invalid", tag, plen);
                    return -1;
                }
                plen -= (labnum * 3*8);

                length = tvb_get_ipv6_addr_with_prefix_len(tvb, offset, &ip6addr, plen);
                if (length < 0) {
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_prefix_length_invalid, tvb, start_offset, 1,
                                        "%s Labeled IPv6 prefix length %u invalid",
                                        tag, plen  + (labnum * 3*8));
                    return -1;
                }

                set_address(&addr, AT_IPv6, 16, ip6addr.bytes);
                if (total_length > 0) {
                    prefix_tree = proto_tree_add_subtree_format(tree, tvb, start_offset,
                                    (offset + length) - start_offset,
                                    ett_bgp_prefix, NULL,
                                    "Label Stack=%s, IPv6=%s/%u PathId %u",
                                    wmem_strbuf_get_str(stack_strbuf),
                                    address_to_str(pinfo->pool, &addr), plen, path_identifier);
                    proto_tree_add_item(prefix_tree, hf_path_id, tvb, start_offset, 4, ENC_BIG_ENDIAN);
                    start_offset += 4;
                } else {
                    prefix_tree = proto_tree_add_subtree_format(tree, tvb, start_offset,
                                    (offset + length) - start_offset,
                                    ett_bgp_prefix, NULL,
                                    "Label Stack=%s, IPv6=%s/%u",
                                    wmem_strbuf_get_str(stack_strbuf),
                                    address_to_str(pinfo->pool, &addr), plen);
                }
                proto_tree_add_uint_format(prefix_tree, hf_bgp_prefix_length, tvb, start_offset, 1, plen + labnum * 3 * 8,
                                        "%s Prefix length: %u", tag, plen + labnum * 3 * 8);
                proto_tree_add_string_format(prefix_tree, hf_bgp_label_stack, tvb, start_offset + 1, 3 * labnum, wmem_strbuf_get_str(stack_strbuf),
                                        "%s Label Stack: %s", tag, wmem_strbuf_get_str(stack_strbuf));
                total_length += (1 + labnum*3) + length;
                proto_tree_add_ipv6(prefix_tree, hf_addr6, tvb, offset, length, &ip6addr);
                break;
            case SAFNUM_MCAST_VPN:
                total_length = decode_mcast_vpn_nlri(tree, tvb, offset, afi, pinfo);
                if (total_length < 0)
                    return -1;
                break;
            case SAFNUM_ENCAPSULATION:
                plen =  tvb_get_guint8(tvb, offset);
                if (plen != 128){
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_length_invalid, tvb, offset, 1,
                                        "%s IPv6 address length %u invalid",
                                        tag, plen);
                    return -1;
                }
                offset += 1;

                proto_tree_add_item(tree, hf_bgp_endpoint_address_ipv6, tvb, offset, 16, ENC_NA);

                total_length = 17; /* length(1 octet) + address(16 octets) */
                break;
            case SAFNUM_TUNNEL:
                plen =  tvb_get_guint8(tvb, offset);
                if (plen <= 16){
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_prefix_length_invalid, tvb, start_offset, 1,
                                        "%s Tunnel IPv6 prefix length %u invalid",
                                        tag, plen);
                    return -1;
                }
                tnl_id = tvb_get_ntohs(tvb, offset + 1);
                offset += 3; /* Length + Tunnel Id */
                plen -= 16; /* 2-octet Identifier */
                length = tvb_get_ipv6_addr_with_prefix_len(tvb, offset, &ip6addr, plen);
                if (length < 0) {
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_prefix_length_invalid, tvb, start_offset, 1,
                                        "%s Tunnel IPv6 prefix length %u invalid",
                                        tag, plen + 16);
                    return -1;
                }
                set_address(&addr, AT_IPv6, 16, ip6addr.bytes);
                prefix_tree = proto_tree_add_subtree_format(tree, tvb, start_offset,
                                    (offset + length) - start_offset,
                                    ett_bgp_prefix, NULL,
                                    "Tunnel Identifier=0x%x IPv6=%s/%u",
                                    tnl_id, address_to_str(pinfo->pool, &addr), plen);
                proto_tree_add_item(prefix_tree, hf_bgp_prefix_length, tvb, start_offset, 1, ENC_BIG_ENDIAN);

                proto_tree_add_item(prefix_tree, hf_bgp_mp_nlri_tnl_id, tvb,
                                    start_offset + 1, 2, ENC_BIG_ENDIAN);
                proto_tree_add_ipv6(prefix_tree, hf_addr6, tvb, offset, length, &ip6addr);

                total_length = (1 + 2) + length; /* length field + Tunnel Id + IPv4 len */
                break;

            case SAFNUM_SR_POLICY:
                total_length = decode_sr_policy_nlri(tree, tvb, offset, afi);
                if (total_length < 0)
                    return -1;
                break;

            case SAFNUM_BGP_MUP:
                total_length = decode_bgp_mup_nlri(tree, tvb, offset, pinfo, afi);
                break;
            case SAFNUM_LAB_VPNUNICAST:
            case SAFNUM_LAB_VPNMULCAST:
            case SAFNUM_LAB_VPNUNIMULC:
                plen =  tvb_get_guint8(tvb, offset);
                stack_strbuf = wmem_strbuf_create(pinfo->pool);
                labnum = decode_MPLS_stack(tvb, offset + 1, stack_strbuf);

                offset += (1 + labnum * 3);
                if (plen <= (labnum * 3*8)) {
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_prefix_length_invalid, tvb, start_offset, 1,
                                        "%s Labeled VPN IPv6 prefix length %u invalid", tag, plen);
                    return -1;
                }
                plen -= (labnum * 3*8);

                if (plen < 8*8) {
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_prefix_length_invalid, tvb, start_offset, 1,
                                        "%s Labeled VPN IPv6 prefix length %u invalid",
                                        tag, plen + (labnum * 3*8));
                    return -1;
                }
                plen -= 8*8;

                length = tvb_get_ipv6_addr_with_prefix_len(tvb, offset + 8, &ip6addr, plen);
                if (length < 0) {
                    proto_tree_add_expert_format(tree, pinfo, &ei_bgp_prefix_length_invalid, tvb, start_offset, 1,
                                                 "%s Labeled VPN IPv6 prefix length %u invalid",
                                                 tag, plen + (labnum * 3*8) + 8*8);
                    return -1;
                }

                proto_tree_add_item(tree, hf_bgp_prefix_length, tvb, start_offset, 1, ENC_NA);
                proto_tree_add_string(tree, hf_bgp_label_stack, tvb, start_offset + 1, labnum * 3, wmem_strbuf_get_str(stack_strbuf));
                proto_tree_add_string(tree, hf_bgp_rd, tvb, offset, 8, decode_bgp_rd(pinfo->pool, tvb, offset));


                set_address(&addr, AT_IPv6, 16, ip6addr.bytes);
                proto_tree_add_ipv6_format_value(tree, hf_addr6, tvb, offset + 8, length,
                                                 &ip6addr, "%s/%u", address_to_str(pinfo->pool, &addr), plen);

                total_length = (1 + labnum * 3 + 8) + length;

                break;
            case SAFNUM_FSPEC_RULE:
            case SAFNUM_FSPEC_VPN_RULE:
                total_length = decode_flowspec_nlri(tree, tvb, offset, afi, safi, pinfo);
                if(total_length < 0)
                    return(-1);
                total_length++;
                break;
            default:
                proto_tree_add_expert_format(tree, pinfo, &ei_bgp_unknown_safi, tvb, start_offset, 0,
                                    "Unknown SAFI (%u) for AFI %u", safi, afi);
                return -1;
        } /* switch (safi) */
        break;

    case AFNUM_L2VPN:
    case AFNUM_L2VPN_OLD:
        switch (safi) {

            case SAFNUM_LAB_VPNUNICAST:
            case SAFNUM_LAB_VPNMULCAST:
            case SAFNUM_LAB_VPNUNIMULC:
            case SAFNUM_VPLS:
                plen =  tvb_get_ntohs(tvb,offset);
                proto_tree_add_item(tree, hf_bgp_vplsad_length, tvb, offset, 2, ENC_BIG_ENDIAN);

                proto_tree_add_string(tree, hf_bgp_vplsad_rd, tvb, offset+2, 8, decode_bgp_rd(pinfo->pool, tvb, offset+2));
                /* RFC6074 Section 7 BGP-AD and VPLS-BGP Interoperability
                   Both BGP-AD and VPLS-BGP [RFC4761] use the same AFI/SAFI.  In order
                   for both BGP-AD and VPLS-BGP to co-exist, the NLRI length must be
                   used as a demultiplexer.

                   The BGP-AD NLRI has an NLRI length of 12 bytes, containing only an
                   8-byte RD and a 4-byte VSI-ID. VPLS-BGP [RFC4761] uses a 17-byte
                   NLRI length.  Therefore, implementations of BGP-AD must ignore NLRI
                   that are greater than 12 bytes.
                */
                if(plen == 12) /* BGP-AD */
                {
                    proto_tree_add_item(tree, hf_bgp_bgpad_pe_addr, tvb, offset+10, 4, ENC_NA);
                }else{ /* VPLS-BGP */

                    proto_tree_add_item(tree, hf_bgp_vplsbgp_ce_id, tvb, offset+10, 2, ENC_BIG_ENDIAN);

                    proto_tree_add_item(tree, hf_bgp_vplsbgp_labelblock_offset, tvb, offset+12, 2, ENC_BIG_ENDIAN);
                    proto_tree_add_item(tree, hf_bgp_vplsbgp_labelblock_size, tvb, offset+14, 2, ENC_BIG_ENDIAN);
                    stack_strbuf = wmem_strbuf_create(pinfo->pool);
                    decode_MPLS_stack(tvb, offset + 16, stack_strbuf);
                    proto_tree_add_string(tree, hf_bgp_vplsbgp_labelblock_base, tvb, offset+16, plen-14, wmem_strbuf_get_str(stack_strbuf));

                }
                /* FIXME there are subTLVs left to decode ... for now lets omit them */
                total_length = plen+2;
                break;

            case SAFNUM_EVPN:
                /* Check for Add Path */
                if (tvb_get_guint8(tvb, offset + 4 ) <= EVPN_S_PMSI_A_D_ROUTE && tvb_get_guint8(tvb, offset ) == 0) {
                    proto_tree_add_item(tree, hf_path_id, tvb, offset, 4, ENC_BIG_ENDIAN);
                    offset += 4;
                    total_length = decode_evpn_nlri(tree, tvb, offset, pinfo) + 4;
                } else {
                     total_length = decode_evpn_nlri(tree, tvb, offset, pinfo);
                }
                break;

            default:
                proto_tree_add_expert_format(tree, pinfo, &ei_bgp_unknown_safi, tvb, start_offset, 0,
                                    "Unknown SAFI (%u) for AFI %u", safi, afi);
                return -1;
        } /* switch (safi) */
        break;
    case AFNUM_BGP_LS:
        nlri_type = tvb_get_ntohs(tvb, offset);
        total_length = tvb_get_ntohs(tvb, offset + 2);
        length = total_length;
        total_length += 4;

        if (safi == SAFNUM_BGP_LS || safi == SAFNUM_BGP_LS_VPN) {
            ti = proto_tree_add_item(tree, hf_bgp_ls_nlri, tvb, offset, total_length , ENC_NA);
        } else if (safi == SAFNUM_LAB_VPNUNICAST) {
            ti = proto_tree_add_item(tree, hf_bgp_ls_safi128_nlri, tvb, offset, total_length , ENC_NA);
        } else
            return -1;

        prefix_tree = proto_item_add_subtree(ti, ett_bgp_mp_reach_nlri);
        proto_tree_add_item(prefix_tree, hf_bgp_ls_nlri_type, tvb, offset, 2, ENC_BIG_ENDIAN);
        proto_tree_add_item(prefix_tree, hf_bgp_ls_nlri_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
        offset += 4;

        /* when SAFI 128, then write route distinguisher */
        if (safi == SAFNUM_LAB_VPNUNICAST) {
            if (length < BGP_ROUTE_DISTINGUISHER_SIZE) {
                if (length == 0) {
                    expert_add_info_format(pinfo, prefix_tree, &ei_bgp_ls_error,
                                           "Unexpected end of SAFI 128 NLRI, Route Distinguisher field is required!");
                }
                if (length > 0) {
                    expert_add_info_format(pinfo, prefix_tree, &ei_bgp_ls_error,
                                           "Unexpected Route Distinguisher length (%u)!",
                                           length);
                }
                break;
            }
            disting_item = proto_tree_add_item(prefix_tree, hf_bgp_ls_safi128_nlri_route_distinguisher,
                                               tvb, offset, BGP_ROUTE_DISTINGUISHER_SIZE, ENC_NA);
            disting_tree = proto_item_add_subtree(disting_item, ett_bgp_mp_reach_nlri);
            tmp16 = tvb_get_ntohs(tvb, offset);
            proto_tree_add_item(disting_tree, hf_bgp_ls_safi128_nlri_route_distinguisher_type,
                                tvb, offset, 2, ENC_BIG_ENDIAN);
            /* Route Distinguisher Type */
            switch (tmp16) {
            case 0:
                proto_tree_add_item(disting_tree, hf_bgp_ls_safi128_nlri_route_dist_admin_asnum_2,
                                    tvb, offset + 2, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(disting_tree, hf_bgp_ls_safi128_nlri_route_dist_asnum_4,
                                    tvb, offset + 4, 4, ENC_BIG_ENDIAN);
                break;

            case 1:
                proto_tree_add_item(disting_tree, hf_bgp_ls_safi128_nlri_route_dist_admin_ipv4,
                                    tvb, offset + 2, 4, ENC_BIG_ENDIAN);
                proto_tree_add_item(disting_tree, hf_bgp_ls_safi128_nlri_route_dist_asnum_2,
                                    tvb, offset + 6, 2, ENC_BIG_ENDIAN);
                break;

            case 2:
                proto_tree_add_item(disting_tree, hf_bgp_ls_safi128_nlri_route_dist_admin_asnum_4,
                                    tvb, offset + 2, 4, ENC_BIG_ENDIAN);
                proto_tree_add_item(disting_tree, hf_bgp_ls_safi128_nlri_route_dist_asnum_2,
                                    tvb, offset + 6, 2, ENC_BIG_ENDIAN);
                break;

            default:
                expert_add_info_format(pinfo, disting_tree, &ei_bgp_ls_error,
                                       "Unknown Route Distinguisher type (%u)", tmp16);
            }
            offset += BGP_ROUTE_DISTINGUISHER_SIZE;
            length -= BGP_ROUTE_DISTINGUISHER_SIZE;
        }

        switch (nlri_type) {
        case LINK_STATE_LINK_NLRI:

            nlri_ti = proto_tree_add_item(prefix_tree,
                    hf_bgp_ls_nlri_link_nlri_type, tvb, offset, length,
                    ENC_NA);
            nlri_tree = proto_item_add_subtree(nlri_ti, ett_bgp_mp_reach_nlri);
            tmp_length = decode_bgp_link_node_nlri_common_fields(tvb, nlri_tree,
                    offset, pinfo, length);
            if (tmp_length < 1)
                return -1;

            offset += tmp_length;
            length -= tmp_length;

            /* dissect Remote Node descriptors TLV */
            if (length > 0 && length < 4) {
                expert_add_info_format(pinfo, nlri_tree, &ei_bgp_ls_error,
                        "Unknown data in Link-State Link NLRI!");
                break;
            }
            if (length < 1)
                break;

           tmp_length = decode_bgp_link_node_nlri_tlvs(tvb, nlri_tree, offset,
                                                       pinfo, BGP_NLRI_TLV_REMOTE_NODE_DESCRIPTORS);
           if (tmp_length < 1)
               return -1;

           offset += tmp_length;
           length -= tmp_length;

           /* dissect Link Descriptor NLRI */
           if (length > 0 && length < 4) {
               expert_add_info_format(pinfo, nlri_tree, &ei_bgp_ls_error,
                       "Unknown data in Link-State Link NLRI, length = %d bytes.", length);
               break;
           }
           if (length < 1)
               break;

           tmp_length = decode_bgp_link_nlri_link_descriptors(tvb, nlri_tree,
                   offset, pinfo, length);
           if (tmp_length < 1)
               return -1;

           break;

       case LINK_STATE_NODE_NLRI:
            nlri_ti = proto_tree_add_item(prefix_tree,
                    hf_bgp_ls_nlri_node_nlri_type, tvb, offset, length,
                    ENC_NA);
            nlri_tree = proto_item_add_subtree(nlri_ti, ett_bgp_mp_reach_nlri);
            tmp_length = decode_bgp_link_node_nlri_common_fields(tvb, nlri_tree,
                    offset, pinfo, length);
            if (tmp_length < 1)
                return -1;

            break;

        case LINK_STATE_IPV4_TOPOLOGY_PREFIX_NLRI:
            nlri_ti = proto_tree_add_item(prefix_tree,
                    hf_bgp_ls_ipv4_topology_prefix_nlri_type, tvb, offset, length,
                    ENC_NA);
            nlri_tree = proto_item_add_subtree(nlri_ti, ett_bgp_mp_reach_nlri);
            tmp_length = decode_bgp_link_node_nlri_common_fields(tvb, nlri_tree,
                                                                 offset, pinfo, length);
            if (tmp_length < 1)
                return -1;

            offset += tmp_length;
            length -= tmp_length;

            /* dissect Prefix Descriptors NLRI */
            if (length > 0 && length < 4) {
                expert_add_info_format(pinfo, nlri_tree, &ei_bgp_ls_error,
                        "Unknown data in Link-State Link NLRI, length = %d bytes.", length);
                break;
            }
            if (length < 1)
                break;

            tmp_length = decode_bgp_link_nlri_prefix_descriptors(tvb, nlri_tree,
                    offset, pinfo, length, IP_PROTO_IPV4);
            if (tmp_length < 1)
                return -1;

            break;

        case LINK_STATE_IPV6_TOPOLOGY_PREFIX_NLRI:
            nlri_ti = proto_tree_add_item(prefix_tree,
                    hf_bgp_ls_ipv6_topology_prefix_nlri_type, tvb, offset, length,
                    ENC_NA);
            nlri_tree = proto_item_add_subtree(nlri_ti, ett_bgp_mp_reach_nlri);
            tmp_length = decode_bgp_link_node_nlri_common_fields(tvb, nlri_tree,
                    offset, pinfo, length);
            if (tmp_length < 1)
                return -1;

            offset += tmp_length;
            length -= tmp_length;

            /* dissect Prefix Descriptors NLRI */
            if (length > 0 && length < 4) {
                expert_add_info_format(pinfo, nlri_tree, &ei_bgp_ls_error,
                        "Unknown data in Link-State Link NLRI!");
                break;
            }
            if (length < 1)
                break;

            tmp_length = decode_bgp_link_nlri_prefix_descriptors(tvb, nlri_tree,
                    offset, pinfo, length, IP_PROTO_IPV6);
            if (tmp_length < 1)
                return -1;

            break;

        case LINK_STATE_SRV6_SID_NLRI:
            nlri_ti = proto_tree_add_item(prefix_tree,
                    hf_bgp_ls_nlri_srv6_sid_nlri_type, tvb, offset, length,
                    ENC_NA);
            nlri_tree = proto_item_add_subtree(nlri_ti, ett_bgp_mp_reach_nlri);
            tmp_length = decode_bgp_link_node_nlri_common_fields(tvb, nlri_tree,
                    offset, pinfo, length);
            if (tmp_length < 1)
                return -1;

            offset += tmp_length;
            length -= tmp_length;

            /* dissect SRv6 SID Descriptors NLRI */
            if (length > 0 && length < 4) {
                expert_add_info_format(pinfo, nlri_tree, &ei_bgp_ls_error,
                        "Unknown data in Link-State SRv6 SID NLRI!");
                break;
            }
            if (length < 1)
                break;

            tmp_length = decode_bgp_link_nlri_srv6_sid_descriptors(tvb, nlri_tree,
                    offset, pinfo, length);
            if (tmp_length < 1)
                return -1;

            break;

        default:
            proto_tree_add_expert_format(tree, pinfo,  &ei_bgp_ls_error, tvb, start_offset, 0,
                                         "Unknown Link-State NLRI type (%u)", afi);

        }
        break;

        default:
            proto_tree_add_expert_format(tree, pinfo, &ei_bgp_unknown_afi, tvb, start_offset, 0,
                                         "Unknown AFI (%u) value", afi);
            return -1;
    } /* switch (afi) */
    return(total_length);
}
