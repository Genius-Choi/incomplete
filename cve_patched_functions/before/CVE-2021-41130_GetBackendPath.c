std::string RequestContext::GetBackendPath() const {
  if (method_call_.method_info == nullptr) {
    return "";
  }

  if (method_call_.method_info->backend_path_translation() ==
      ::google::api::BackendRule_PathTranslation_APPEND_PATH_TO_ADDRESS) {
    if (!method_call_.method_info->backend_path().empty()) {
      return method_call_.method_info->backend_path() +
             request_->GetUnparsedRequestPath();
    } else {
      // Not change to the request path.
      return "";
    }
  } else if (method_call_.method_info->backend_path_translation() ==
             ::google::api::BackendRule_PathTranslation_CONSTANT_ADDRESS) {
    std::string parameters;
    for (std::size_t i = 0; i != method_call_.variable_bindings.size(); i++) {
      auto &variable_binding = method_call_.variable_bindings[i];
      for (std::size_t j = 0; j < variable_binding.field_path.size(); ++j) {
        // If field_path is snake case, need to use corresponding jsonName.
        std::string::size_type found = variable_binding.field_path[j].find("_");
        std::string field_path;
        if (found != std::string::npos &&
            service_context_->config()->GetJsonName(
                variable_binding.field_path[j], &field_path)) {
          parameters.append(field_path);
        } else {
          parameters.append(variable_binding.field_path[j]);
        }

        if (j != variable_binding.field_path.size() - 1) {
          parameters.append(".");
        }
      }

      parameters.append("=");
      parameters.append(variable_binding.value);
      if (i != method_call_.variable_bindings.size() - 1) {
        parameters.append("&");
      }
    }

    if (parameters != "") {
      return method_call_.method_info->backend_path() + "?" + parameters;
    }
    return method_call_.method_info->backend_path();
  } else {
    return "";
  }
}
