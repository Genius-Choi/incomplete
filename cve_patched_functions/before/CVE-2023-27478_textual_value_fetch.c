static memcached_return_t textual_value_fetch(memcached_instance_st *instance, char *buffer,
                                              memcached_result_st *result) {
  char *next_ptr;
  ssize_t read_length = 0;
  size_t value_length;

  WATCHPOINT_ASSERT(instance->root);
  char *end_ptr = buffer + MEMCACHED_DEFAULT_COMMAND_SIZE;

  memcached_result_reset(result);

  char *string_ptr = buffer;
  string_ptr += 6; /* "VALUE " */

  // Just used for cases of AES decrypt currently
  memcached_return_t rc = MEMCACHED_SUCCESS;

  /* We load the key */
  {
    char *key = result->item_key;
    result->key_length = 0;

    for (ptrdiff_t prefix_length = memcached_array_size(instance->root->_namespace);
         !(iscntrl(*string_ptr) || isspace(*string_ptr)); string_ptr++)
    {
      if (prefix_length == 0) {
        *key = *string_ptr;
        key++;
        result->key_length++;
      } else
        prefix_length--;
    }
    result->item_key[result->key_length] = 0;
  }

  if (end_ptr == string_ptr) {
    goto read_error;
  }

  /* Flags fetch move past space */
  string_ptr++;
  if (end_ptr == string_ptr) {
    goto read_error;
  }

  for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {
  };
  errno = 0;
  result->item_flags = (uint32_t) strtoul(next_ptr, &string_ptr, 10);

  if (errno or end_ptr == string_ptr) {
    goto read_error;
  }

  /* Length fetch move past space*/
  string_ptr++;
  if (end_ptr == string_ptr) {
    goto read_error;
  }

  for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {
  };
  errno = 0;
  value_length = (size_t) strtoull(next_ptr, &string_ptr, 10);

  if (errno or end_ptr == string_ptr) {
    goto read_error;
  }

  /* Skip spaces */
  if (*string_ptr == '\r') {
    /* Skip past the \r\n */
    string_ptr += 2;
  } else {
    string_ptr++;
    for (next_ptr = string_ptr; isdigit(*string_ptr); string_ptr++) {
    };
    errno = 0;
    result->item_cas = strtoull(next_ptr, &string_ptr, 10);
  }

  if (errno or end_ptr < string_ptr) {
    goto read_error;
  }

  /* We add two bytes so that we can walk the \r\n */
  if (memcached_failed(memcached_string_check(&result->value, value_length + 2))) {
    return memcached_set_error(*instance, MEMCACHED_MEMORY_ALLOCATION_FAILURE, MEMCACHED_AT);
  }

  {
    char *value_ptr = memcached_string_value_mutable(&result->value);
    /*
      We read the \r\n into the string since not doing so is more
      cycles then the waster of memory to do so.

      We are null terminating through, which will most likely make
      some people lazy about using the return length.
    */
    size_t to_read = (value_length) + 2;
    memcached_return_t rrc = memcached_io_read(instance, value_ptr, to_read, read_length);
    if (memcached_failed(rrc) and rrc == MEMCACHED_IN_PROGRESS) {
      memcached_quit_server(instance, true);
      return memcached_set_error(*instance, MEMCACHED_IN_PROGRESS, MEMCACHED_AT);
    } else if (memcached_failed(rrc)) {
      return rrc;
    }
  }

  if (read_length != (ssize_t)(value_length + 2)) {
    goto read_error;
  }

  /* This next bit blows the API, but this is internal....*/
  {
    char *char_ptr;
    char_ptr = memcached_string_value_mutable(&result->value);
    ;
    char_ptr[value_length] = 0;
    char_ptr[value_length + 1] = 0;
    memcached_string_set_length(&result->value, value_length);
  }

  if (memcached_is_encrypted(instance->root) and memcached_result_length(result)) {
    hashkit_string_st *destination;

    if ((destination = hashkit_decrypt(&instance->root->hashkit, memcached_result_value(result),
                                       memcached_result_length(result)))
        == NULL)
    {
      rc = memcached_set_error(*instance->root, MEMCACHED_FAILURE, MEMCACHED_AT,
                               memcached_literal_param("hashkit_decrypt() failed"));
    } else {
      memcached_result_reset_value(result);
      if (memcached_failed(memcached_result_set_value(result, hashkit_string_c_str(destination),
                                                      hashkit_string_length(destination))))
      {
        rc = memcached_set_error(*instance->root, MEMCACHED_FAILURE, MEMCACHED_AT,
                                 memcached_literal_param("hashkit_decrypt() failed"));
      }
    }

    if (memcached_failed(rc)) {
      memcached_result_reset(result);
    }
    hashkit_string_free(destination);
  }

  return rc;

read_error:
  memcached_io_reset(instance);

  return MEMCACHED_PARTIAL_READ;
}
