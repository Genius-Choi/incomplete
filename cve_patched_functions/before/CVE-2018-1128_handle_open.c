bool DaemonServer::handle_open(MMgrOpen *m)
{
  Mutex::Locker l(lock);

  DaemonKey key;
  if (!m->service_name.empty()) {
    key.first = m->service_name;
  } else {
    key.first = ceph_entity_type_name(m->get_connection()->get_peer_type());
  }
  key.second = m->daemon_name;

  dout(4) << "from " << m->get_connection() << "  " << key << dendl;

  _send_configure(m->get_connection());

  DaemonStatePtr daemon;
  if (daemon_state.exists(key)) {
    daemon = daemon_state.get(key);
  }
  if (daemon) {
    dout(20) << "updating existing DaemonState for " << m->daemon_name << dendl;
    Mutex::Locker l(daemon->lock);
    daemon->perf_counters.clear();
  }

  if (m->service_daemon) {
    if (!daemon) {
      dout(4) << "constructing new DaemonState for " << key << dendl;
      daemon = std::make_shared<DaemonState>(daemon_state.types);
      daemon->key = key;
      if (m->daemon_metadata.count("hostname")) {
        daemon->hostname = m->daemon_metadata["hostname"];
      }
      daemon_state.insert(daemon);
    }
    Mutex::Locker l(daemon->lock);
    daemon->service_daemon = true;
    daemon->metadata = m->daemon_metadata;
    daemon->service_status = m->daemon_status;

    utime_t now = ceph_clock_now();
    auto d = pending_service_map.get_daemon(m->service_name,
					    m->daemon_name);
    if (d->gid != (uint64_t)m->get_source().num()) {
      dout(10) << "registering " << key << " in pending_service_map" << dendl;
      d->gid = m->get_source().num();
      d->addr = m->get_source_addr();
      d->start_epoch = pending_service_map.epoch;
      d->start_stamp = now;
      d->metadata = m->daemon_metadata;
      pending_service_map_dirty = pending_service_map.epoch;
    }
  }

  if (m->get_connection()->get_peer_type() != entity_name_t::TYPE_CLIENT &&
      m->service_name.empty())
  {
    // Store in set of the daemon/service connections, i.e. those
    // connections that require an update in the event of stats
    // configuration changes.
    daemon_connections.insert(m->get_connection());
  }

  m->put();
  return true;
}
