SGXWalletServer::blsSignMessageHashImpl(const string &_keyShareName, const string &_messageHash, int t, int n,
                                        int _signerIndex) {
    Json::Value result;
    result["status"] = -1;
    result["errorMessage"] = "Unknown server error";
    result["signatureShare"] = "";

    char *signature = (char *) calloc(BUF_LEN, 1);

    shared_ptr <string> value = nullptr;

    try {
        if (!checkName(_keyShareName, "BLS_KEY")) {
            throw SGXException(INVALID_POLY_NAME, "Invalid BLSKey name");
        }
        string cutHash = _messageHash;
        if (cutHash[0] == '0' && (cutHash[1] == 'x' || cutHash[1] == 'X')) {
            cutHash.erase(cutHash.begin(), cutHash.begin() + 2);
        }
        while (cutHash[0] == '0') {
            cutHash.erase(cutHash.begin(), cutHash.begin() + 1);
        }

        if (!checkHex(cutHash)) {
            throw SGXException(INVALID_HEX, "Invalid hash");
        }

        value = readFromDb(_keyShareName);
    } catch (SGXException _e) {
        result["status"] = _e.status;
        result["errorMessage"] = _e.errString;
        return result;
    } catch (...) {
        exception_ptr p = current_exception();
        printf("Exception %s \n", p.__cxa_exception_type()->name());
        result["status"] = -1;
        result["errorMessage"] = "Read key share has thrown exception:";
        return result;
    }

    try {
        if (!bls_sign(value->c_str(), _messageHash.c_str(), t, n, _signerIndex, signature)) {
            result["status"] = -1;
            result["errorMessage"] = "Could not sign";
            return result;
        }
    } catch (...) {
        result["status"] = -1;
        result["errorMessage"] = "Sign has thrown exception";
        return result;
    }

    result["status"] = 0;
    result["errorMessage"] = "";
    result["signatureShare"] = signature;
    return result;
}
