const unsigned char * utf8_check(const char * s_orig, size_t len) {
  const unsigned char * s = (unsigned char *)s_orig;
  size_t i = 0;

  while (i<len) {
    if (*s < 0x80) {
      /* 0xxxxxxx */
      s++;
      i++;
    } else if ((s[0] & 0xe0) == 0xc0) {
      /* 110XXXXx 10xxxxxx */
      if ((i+1 >= len) ||
          (s[1] & 0xc0) != 0x80 ||
          (s[0] & 0xfe) == 0xc0) {                  /* overlong? */
        return s;
      } else {
        s += 2;
        i += 2;
      }
    } else if ((s[0] & 0xf0) == 0xe0) {
      /* 1110XXXX 10Xxxxxx 10xxxxxx */
      if ((i+2 >= len) ||
          (s[1] & 0xc0) != 0x80 ||
          (s[2] & 0xc0) != 0x80 ||
          (s[0] == 0xe0 && (s[1] & 0xe0) == 0x80) ||                 /* overlong? */
          (s[0] == 0xed && (s[1] & 0xe0) == 0xa0) ||                 /* surrogate? */
          (s[0] == 0xef && s[1] == 0xbf && (s[2] & 0xfe) == 0xbe && /* U+FFFE or U+FFFF? */
          s[2] != 0xbf && s[2] != 0xbe)) { /* Hideous hack to comply with autobahn testsuite, TODO: fix that one day (and other jokes I tell myself) */
        return s;
      } else {
        s += 3;
        i += 3;
      }
    } else if ((s[0] & 0xf8) == 0xf0) {
      /* 11110XXX 10XXxxxx 10xxxxxx 10xxxxxx */
      if ((i+3 >= len) ||
          (s[1] & 0xc0) != 0x80 ||
          (s[2] & 0xc0) != 0x80 ||
          (s[3] & 0xc0) != 0x80 ||
          (s[0] == 0xf0 && (s[1] & 0xf0) == 0x80) ||      /* overlong? */
          (s[0] == 0xf4 && s[1] > 0x8f) || s[0] > 0xf4) { /* > U+10FFFF? */
        return s;
      } else {
        s += 4;
        i += 4;
      }
    } else {
      return s;
    }
  }
  return NULL;
}
