bool SrvAnsiImpl::WriteAnsiCodes(LPCWSTR lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)
{
	bool lbRc = TRUE;
	LPCWSTR lpEnd = (lpBuffer + nNumberOfCharsToWrite);
	AnsiEscCode Code = {};
	wchar_t szPreDump[SrvAnsi::CEAnsi_MaxPrevPart];
	DWORD cchPrevPart;

	//ExtWriteTextParm write = {sizeof(write), ewtf_Current};
	//write.Private = _WriteConsoleW;

	while (lpBuffer < lpEnd)
	{
		LPCWSTR lpStart = nullptr, lpNext = nullptr; // Required to be nullptr-initialized

		// '^' is ESC
		// ^[0;31;47m   $E[31;47m   ^[0m ^[0;1;31;47m  $E[1;31;47m  ^[0m

		cchPrevPart = 0;

		int iEsc = NextEscCode(lpBuffer, lpEnd, szPreDump, cchPrevPart, lpStart, lpNext, Code);

		if (cchPrevPart)
		{
			m_Owner->ApplyDisplayParm();

			lbRc = WriteText(szPreDump, cchPrevPart, lpNumberOfCharsWritten);
			if (!lbRc)
				goto wrap;
		}

		if (iEsc != 0)
		{
			if (lpStart > lpBuffer)
			{
				_ASSERTEX((lpStart-lpBuffer) < (ssize_t)nNumberOfCharsToWrite);

				m_Owner->ApplyDisplayParm();

				DWORD nWrite = (DWORD)(lpStart - lpBuffer);
				//lbRc = WriteText(lpBuffer, nWrite, lpNumberOfCharsWritten);
				lbRc = WriteText(lpBuffer, nWrite, lpNumberOfCharsWritten);
				if (!lbRc)
					goto wrap;
				//write.Buffer = lpBuffer;
				//write.NumberOfCharsToWrite = nWrite;
				//lbRc = ExtWriteText(&write);
				//if (!lbRc)
				//	goto wrap;
				//else
				//{
				//	if (lpNumberOfCharsWritten)
				//		*lpNumberOfCharsWritten = write.NumberOfCharsWritten;
				//	if (write.ScrolledRowsUp > 0)
				//		gDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));
				//}
			}

			if (iEsc == 1)
			{
				if (Code.Skip)
				{
					DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
				}
				else
				{
					switch (Code.Second)
					{
					case L'[':  // ESC [ xxx
						{
							WriteAnsiCode_CSI(Code);

						} // case L'[':
						break;

					case L']': // ESC ] xxx \ESC
						{
							WriteAnsiCode_OSC(Code);

						} // case L']':
						break;

					case L'|': // ESC | xxx
						{
							// vim-xterm-emulation
							WriteAnsiCode_VIM(Code);
						} // case L'|':
						break;

					case L'7': // ESC 7
					case L'8': // ESC 8
						//TODO: 7 - Save Cursor and _Attributes_
						//TODO: 8 - Restore Cursor and _Attributes_
						XTermSaveRestoreCursor((Code.Second == L'7'));
						break;
					case L'c': // ESC c
						// Full reset
						FullReset();
						break;
					case L'g':
						// User may disable flashing in ConEmu settings
						// #ANSI Implement GuiFlashWindow in common
						DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);
						// GuiFlashWindow(eFlashBeep, gState.realConWnd, FALSE, FLASHW_ALL, 1, 0);
						break;
					case L'H':
						// #ANSI gh-1827: support 'H' to set tab stops
						DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Ignored);
						break;
					case L'M': // ESC M
						ReverseLF();
						break;
					case L'E': // ESC E
						ForwardCRLF();
						break;
					case L'D': // ESC D
						ForwardLF();
						break;
					case L'=': // ESC =
					case L'>': // ESC >
						// xterm "ESC =" - Application Keypad (DECKPAM)
						// xterm "ESC >" - Normal Keypad (DECKPNM)
						DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);
						break;
					case L'(': // ESC (
						// xterm G0..G3?
						switch (Code.Action)
						{
						case L'0':
							m_Owner->mCharSet = SrvAnsi::VTCS_DRAWING;
							//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);
							break;
						case L'B':
							m_Owner->mCharSet = SrvAnsi::VTCS_DEFAULT;
							//DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, de_Comment);
							break;
						default:
							m_Owner->mCharSet = SrvAnsi::VTCS_DEFAULT;
							DumpKnownEscape(Code.pszEscStart, Code.nTotalLen, SrvAnsi::de_Ignored);
						}
						break;

					default:
						DumpUnknownEscape(Code.pszEscStart,Code.nTotalLen);
					}
				}
			}
		}
		else //if (iEsc != 2) // 2 - means "Esc part stored in buffer"
		{
			_ASSERTEX(iEsc == 0);
			if (lpNext > lpBuffer)
			{
				m_Owner->ApplyDisplayParm();

				DWORD nWrite = (DWORD)(lpNext - lpBuffer);
				//lbRc = WriteText(lpBuffer, nWrite, lpNumberOfCharsWritten);
				lbRc = WriteText(lpBuffer, nWrite, lpNumberOfCharsWritten);
				if (!lbRc)
					goto wrap;
				//write.Buffer = lpBuffer;
				//write.NumberOfCharsToWrite = nWrite;
				//lbRc = ExtWriteText(&write);
				//if (!lbRc)
				//	goto wrap;
				//else
				//{
				//	if (lpNumberOfCharsWritten)
				//		*lpNumberOfCharsWritten = write.NumberOfCharsWritten;
				//	if (write.ScrolledRowsUp > 0)
				//		gDisplayCursor.StoredCursorPos.Y = std::max(0,((int)gDisplayCursor.StoredCursorPos.Y - (int)write.ScrolledRowsUp));
				//}
			}
		}

		if (lpNext > lpBuffer)
		{
			lpBuffer = lpNext;
		}
		else
		{
			_ASSERTEX(lpNext > lpBuffer || lpNext == nullptr);
			++lpBuffer;
		}
	}

	if (lbRc && lpNumberOfCharsWritten)
		*lpNumberOfCharsWritten = nNumberOfCharsToWrite;

wrap:
	m_Owner->ApplyDisplayParm();
	return lbRc;
}
