static int lan78xx_reset(struct lan78xx_net *dev)
{
	struct lan78xx_priv *pdata = (struct lan78xx_priv *)(dev->data[0]);
	unsigned long timeout;
	int ret;
	u32 buf;
	u8 sig;

	ret = lan78xx_read_reg(dev, HW_CFG, &buf);
	if (ret < 0)
		return ret;

	buf |= HW_CFG_LRST_;

	ret = lan78xx_write_reg(dev, HW_CFG, buf);
	if (ret < 0)
		return ret;

	timeout = jiffies + HZ;
	do {
		mdelay(1);
		ret = lan78xx_read_reg(dev, HW_CFG, &buf);
		if (ret < 0)
			return ret;

		if (time_after(jiffies, timeout)) {
			netdev_warn(dev->net,
				    "timeout on completion of LiteReset");
			ret = -ETIMEDOUT;
			return ret;
		}
	} while (buf & HW_CFG_LRST_);

	lan78xx_init_mac_address(dev);

	/* save DEVID for later usage */
	ret = lan78xx_read_reg(dev, ID_REV, &buf);
	if (ret < 0)
		return ret;

	dev->chipid = (buf & ID_REV_CHIP_ID_MASK_) >> 16;
	dev->chiprev = buf & ID_REV_CHIP_REV_MASK_;

	/* Respond to the IN token with a NAK */
	ret = lan78xx_read_reg(dev, USB_CFG0, &buf);
	if (ret < 0)
		return ret;

	buf |= USB_CFG_BIR_;

	ret = lan78xx_write_reg(dev, USB_CFG0, buf);
	if (ret < 0)
		return ret;

	/* Init LTM */
	lan78xx_init_ltm(dev);

	ret = lan78xx_write_reg(dev, BURST_CAP, dev->burst_cap);
	if (ret < 0)
		return ret;

	ret = lan78xx_write_reg(dev, BULK_IN_DLY, dev->bulk_in_delay);
	if (ret < 0)
		return ret;

	ret = lan78xx_read_reg(dev, HW_CFG, &buf);
	if (ret < 0)
		return ret;

	buf |= HW_CFG_MEF_;

	ret = lan78xx_write_reg(dev, HW_CFG, buf);
	if (ret < 0)
		return ret;

	ret = lan78xx_read_reg(dev, USB_CFG0, &buf);
	if (ret < 0)
		return ret;

	buf |= USB_CFG_BCE_;

	ret = lan78xx_write_reg(dev, USB_CFG0, buf);
	if (ret < 0)
		return ret;

	/* set FIFO sizes */
	buf = (MAX_RX_FIFO_SIZE - 512) / 512;

	ret = lan78xx_write_reg(dev, FCT_RX_FIFO_END, buf);
	if (ret < 0)
		return ret;

	buf = (MAX_TX_FIFO_SIZE - 512) / 512;

	ret = lan78xx_write_reg(dev, FCT_TX_FIFO_END, buf);
	if (ret < 0)
		return ret;

	ret = lan78xx_write_reg(dev, INT_STS, INT_STS_CLEAR_ALL_);
	if (ret < 0)
		return ret;

	ret = lan78xx_write_reg(dev, FLOW, 0);
	if (ret < 0)
		return ret;

	ret = lan78xx_write_reg(dev, FCT_FLOW, 0);
	if (ret < 0)
		return ret;

	/* Don't need rfe_ctl_lock during initialisation */
	ret = lan78xx_read_reg(dev, RFE_CTL, &pdata->rfe_ctl);
	if (ret < 0)
		return ret;

	pdata->rfe_ctl |= RFE_CTL_BCAST_EN_ | RFE_CTL_DA_PERFECT_;

	ret = lan78xx_write_reg(dev, RFE_CTL, pdata->rfe_ctl);
	if (ret < 0)
		return ret;

	/* Enable or disable checksum offload engines */
	ret = lan78xx_set_features(dev->net, dev->net->features);
	if (ret < 0)
		return ret;

	lan78xx_set_multicast(dev->net);

	/* reset PHY */
	ret = lan78xx_read_reg(dev, PMT_CTL, &buf);
	if (ret < 0)
		return ret;

	buf |= PMT_CTL_PHY_RST_;

	ret = lan78xx_write_reg(dev, PMT_CTL, buf);
	if (ret < 0)
		return ret;

	timeout = jiffies + HZ;
	do {
		mdelay(1);
		ret = lan78xx_read_reg(dev, PMT_CTL, &buf);
		if (ret < 0)
			return ret;

		if (time_after(jiffies, timeout)) {
			netdev_warn(dev->net, "timeout waiting for PHY Reset");
			ret = -ETIMEDOUT;
			return ret;
		}
	} while ((buf & PMT_CTL_PHY_RST_) || !(buf & PMT_CTL_READY_));

	ret = lan78xx_read_reg(dev, MAC_CR, &buf);
	if (ret < 0)
		return ret;

	/* LAN7801 only has RGMII mode */
	if (dev->chipid == ID_REV_CHIP_ID_7801_)
		buf &= ~MAC_CR_GMII_EN_;

	if (dev->chipid == ID_REV_CHIP_ID_7800_) {
		ret = lan78xx_read_raw_eeprom(dev, 0, 1, &sig);
		if (!ret && sig != EEPROM_INDICATOR) {
			/* Implies there is no external eeprom. Set mac speed */
			netdev_info(dev->net, "No External EEPROM. Setting MAC Speed\n");
			buf |= MAC_CR_AUTO_DUPLEX_ | MAC_CR_AUTO_SPEED_;
		}
	}
	ret = lan78xx_write_reg(dev, MAC_CR, buf);
	if (ret < 0)
		return ret;

	ret = lan78xx_set_rx_max_frame_length(dev,
					      RX_MAX_FRAME_LEN(dev->net->mtu));

	return ret;
}
