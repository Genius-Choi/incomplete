int cp_rsa_dec(uint8_t *out, int *out_len, uint8_t *in, int in_len, rsa_t prv) {
	bn_t m, eb;
	int size, pad_len, result = RLC_OK;

	bn_null(m);
	bn_null(eb);

	size = bn_size_bin(prv->crt->n);

	if (prv == NULL || in_len != size || in_len < RSA_PAD_LEN) {
		return RLC_ERR;
	}

	RLC_TRY {
		bn_new(m);
		bn_new(eb);

		bn_read_bin(eb, in, in_len);
#if !defined(CP_CRT)
		bn_mxp(eb, eb, prv->d, prv->crt->n);
#else

		bn_copy(m, eb);

#if MULTI == OPENMP
		omp_set_num_threads(CORES);
		#pragma omp parallel copyin(core_ctx) firstprivate(prv)
		{
			#pragma omp sections
			{
				#pragma omp section
				{
#endif
					/* m1 = c^dP mod p. */
					bn_mxp(eb, eb, prv->crt->dp, prv->crt->p);

#if MULTI == OPENMP
				}
				#pragma omp section
				{
#endif
					/* m2 = c^dQ mod q. */
					bn_mxp(m, m, prv->crt->dq, prv->crt->q);

#if MULTI == OPENMP
				}
			}
		}
#endif
		/* m1 = m1 - m2 mod p. */
		bn_sub(eb, eb, m);
		while (bn_sign(eb) == RLC_NEG) {
			bn_add(eb, eb, prv->crt->p);
		}
		bn_mod(eb, eb, prv->crt->p);
		/* m1 = qInv(m1 - m2) mod p. */
		bn_mul(eb, eb, prv->crt->qi);
		bn_mod(eb, eb, prv->crt->p);
		/* m = m2 + m1 * q. */
		bn_mul(eb, eb, prv->crt->q);
		bn_add(eb, eb, m);

#endif /* CP_CRT */

		if (bn_cmp(eb, prv->crt->n) != RLC_LT) {
			result = RLC_ERR;
		}
#if CP_RSAPD == BASIC
		if (pad_basic(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {
#elif CP_RSAPD == PKCS1
		if (pad_pkcs1(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {
#elif CP_RSAPD == PKCS2
		if (pad_pkcs2(eb, &pad_len, in_len, size, RSA_DEC) == RLC_OK) {
#endif
			size = size - pad_len;

			if (size <= *out_len) {
				memset(out, 0, size);
				bn_write_bin(out, size, eb);
				*out_len = size;
			} else {
				result = RLC_ERR;
			}
		} else {
			result = RLC_ERR;
		}
	}
	RLC_CATCH_ANY {
		result = RLC_ERR;
	}
	RLC_FINALLY {
		bn_free(m);
		bn_free(eb);
	}

	return result;
}
