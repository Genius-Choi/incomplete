dse_updateNumSubordinates(Slapi_Entry *entry, int op)
{
    int ret = 0;
    int mod_op = 0;
    Slapi_Attr *read_attr = NULL;
    size_t current_sub_count = 0;
    int already_present = 0;

    /* For now, we're only interested in subordinatecount.
       We first examine the present value for the attribute.
       If it isn't present and we're adding, we assign value 1 to the attribute and add it.
       If it is present, we increment or decrement depending upon whether we're adding or deleting.
       If the value after decrementing is zero, we remove it.
    */

    /* Get the present value of the subcount attr, or 0 if not present */
    ret = slapi_entry_attr_find(entry, subordinatecount, &read_attr);
    if (0 == ret) {
        /* decode the value */
        Slapi_Value *sval;
        slapi_attr_first_value(read_attr, &sval);
        if (sval != NULL) {
            const struct berval *bval = slapi_value_get_berval(sval);
            if (bval != NULL) {
                already_present = 1;
                current_sub_count = atol(bval->bv_val);
            }
        }
    }

    /* are we adding ? */
    if ((SLAPI_OPERATION_ADD == op) && !already_present) {
        /* If so, and the parent entry does not already have a subcount attribute, we need to add it */
        mod_op = LDAP_MOD_ADD;
    } else {
        if (SLAPI_OPERATION_DELETE == op) {
            if (!already_present) {
                /* This means that something is wrong---deleting a child but no subcount present on parent */
                slapi_log_err(SLAPI_LOG_ERR, "dse_updateNumSubordinates",
                              "numsubordinates assertion failure\n");
                return;
            } else {
                if (current_sub_count == 1) {
                    mod_op = LDAP_MOD_DELETE;
                } else {
                    mod_op = LDAP_MOD_REPLACE;
                }
            }
        } else {
            mod_op = LDAP_MOD_REPLACE;
        }
    }

    /* Now compute the new value */
    if (SLAPI_OPERATION_ADD == op) {
        current_sub_count++;
    } else {
        current_sub_count--;
    }
    {
        char value_buffer[22] = {0}; /* enough digits for 2^64 children */
        struct berval *vals[2];
        struct berval val;
        vals[0] = &val;
        vals[1] = NULL;
        sprintf(value_buffer, "%lu", (long unsigned int)current_sub_count);
        val.bv_val = value_buffer;
        val.bv_len = strlen(val.bv_val);
        switch (mod_op) {
        case LDAP_MOD_ADD:
            attrlist_merge(&entry->e_attrs, subordinatecount, vals);
            break;
        case LDAP_MOD_REPLACE:
            attrlist_replace(&entry->e_attrs, subordinatecount, vals);
            break;
        case LDAP_MOD_DELETE:
            attrlist_delete(&entry->e_attrs, subordinatecount);
            break;
        }
    }
}
