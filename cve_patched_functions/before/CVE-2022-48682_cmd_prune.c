int cmd_prune(struct filegroup *groups, int groupcount, wchar_t *commandarguments, size_t *deletiontally, int *totalgroups, int *cursorgroup, int *cursorfile, int *topline, char *logfile, WINDOW *filewin, WINDOW *statuswin, struct status_text *status)
{
  int deletecount;
  int preservecount;
  int unresolvedcount;
  int totaldeleted = 0;
  int totalfailed = 0;
  double deletedbytes = 0;
  struct log_info *loginfo;
  int g;
  int f;
  int to;
  int adjusttopline;
  int toplineoffset;
  int groupfirstline;
  FILE *file1;
  FILE *file2;
  int ismatch;
  wchar_t *statuscopy;
  struct groupfile *firstnotdeleted;

  if (logfile != 0)
    loginfo = log_open(logfile, 0);
  else
    loginfo = 0;

  for (g = 0; g < *totalgroups; ++g)
  {
    preservecount = 0;
    deletecount = 0;
    unresolvedcount = 0;
    firstnotdeleted = 0;

    for (f = 0; f < groups[g].filecount; ++f)
    {
      switch (groups[g].files[f].action)
      {
        case FILEACTION_DELETE:
          ++deletecount;
          break;

        case FILEACTION_UNRESOLVED:
        case FILEACTION_ERROR:
          ++unresolvedcount;

          if (firstnotdeleted == 0)
            firstnotdeleted = &groups[g].files[f];

          break;

        case FILEACTION_KEEP:
          ++preservecount;

          if (firstnotdeleted == 0)
            firstnotdeleted = &groups[g].files[f];

          break;
      }
    }

    if (loginfo)
      log_begin_set(loginfo);

    /* delete files marked for deletion unless no files left undeleted */
    if (deletecount < groups[g].filecount)
    {
      for (f = 0; f < groups[g].filecount; ++f)
      {
        if (groups[g].files[f].action == FILEACTION_DELETE)
        {
          if (ISFLAG(flags, F_DEFERCONFIRMATION))
          {
            format_status_left(status, L"Confirming duplicates...");
            print_status(statuswin, status);
            wrefresh(statuswin);

            file1 = fopen(groups[g].files[f].file->d_name, "rb");
            file2 = fopen(firstnotdeleted->file->d_name, "rb");

            if (file1 && file2)
              ismatch = confirmmatch(file1, file2);
            else
              ismatch = 0;

            if (file2)
              fclose(file2);

            if (file1)
              fclose(file1);
          }
          else
          {
            ismatch = 1;
          }

          if (ismatch && remove(groups[g].files[f].file->d_name) == 0)
          {
            set_file_action(&groups[g].files[f], FILEACTION_DELIST, deletiontally);

            deletedbytes += groups[g].files[f].file->size;
            ++totaldeleted;

            if (loginfo)
              log_file_deleted(loginfo, groups[g].files[f].file->d_name);
          }
          else
          {
            set_file_action(&groups[g].files[f], FILEACTION_ERROR, deletiontally);
            unresolvedcount++;
            totalfailed++;
          }
        }
      }

      if (loginfo)
      {
        for (f = 0; f < groups[g].filecount; ++f)
        {
          if (groups[g].files[f].action != FILEACTION_DELETE &&
              groups[g].files[f].action != FILEACTION_DELIST)
            log_file_remaining(loginfo, groups[g].files[f].file->d_name);
        }
      }

      deletecount = 0;
    }

    if (loginfo)
      log_end_set(loginfo);

    /* if no files left unresolved, mark preserved files for delisting */
    if (unresolvedcount == 0)
    {
      for (f = 0; f < groups[g].filecount; ++f)
        if (groups[g].files[f].action == FILEACTION_KEEP)
          set_file_action(&groups[g].files[f], FILEACTION_DELIST, deletiontally);

      preservecount = 0;
    }
    /* if only one file left unresolved, mark it for delesting */
    else if (unresolvedcount == 1 && preservecount + deletecount == 0)
    {
      for (f = 0; f < groups[g].filecount; ++f)
        if (groups[g].files[f].action == FILEACTION_UNRESOLVED || groups[g].files[f].action == FILEACTION_ERROR)
          set_file_action(&groups[g].files[f], FILEACTION_DELIST, deletiontally);
    }

    /* delist any files marked for delisting */
    to = 0;
    for (f = 0; f < groups[g].filecount; ++f)
      if (groups[g].files[f].action != FILEACTION_DELIST)
        groups[g].files[to++] = groups[g].files[f];

    groups[g].filecount = to;

    /* reposition cursor, if necessary */
    if (*cursorgroup == g && *cursorfile > 0 && *cursorfile >= groups[g].filecount)
      *cursorfile = groups[g].filecount - 1;
  }

  if (loginfo != 0)
    log_close(loginfo);

  if (deletedbytes < 1000.0)
    format_status_left(status, L"Deleted %ld files (occupying %.0f bytes)%c", totaldeleted, deletedbytes, totalfailed ? ';' : '.');
  else if (deletedbytes <= (1000.0 * 1000.0))
    format_status_left(status, L"Deleted %ld files (occupying %.1f KB)%c", totaldeleted, deletedbytes / 1000.0, totalfailed ? ';' : '.');
  else if (deletedbytes <= (1000.0 * 1000.0 * 1000.0))
    format_status_left(status, L"Deleted %ld files (occupying %.1f MB)%c", totaldeleted, deletedbytes / (1000.0 * 1000.0), totalfailed ? ';' : '.');
  else
    format_status_left(status, L"Deleted %ld files (occupying %.1f GB)%c", totaldeleted, deletedbytes / (1000.0 * 1000.0 * 1000.0), totalfailed ? ';' : '.');

  if (totalfailed > 0)
  {
    statuscopy = malloc(sizeof(wchar_t) * (wcslen(status->left) + 1));
    if (!statuscopy)
    {
      endwin();
      errormsg("out of memory\n");
      exit(1);
    }

    wcsncpy(statuscopy, status->left, wcslen(status->left) + 1);

    format_status_left(status, L"%S %d failed.", statuscopy, totalfailed);

    free(statuscopy);
  }

  /* delist empty groups */
  to = 0;
  for (g = 0; g < *totalgroups; ++g)
  {
    if (groups[g].filecount > 0)
    {
      groups[to] = groups[g];

      /* reposition cursor, if necessary */
      if (to == *cursorgroup && to != g)
        *cursorfile = 0;

      ++to;
    }
    else
    {
      free(groups[g].files);
    }
  }

  *totalgroups = to;

  /* reposition cursor, if necessary */
  if (*cursorgroup >= *totalgroups)
  {
    *cursorgroup = *totalgroups - 1;
    *cursorfile = 0;
  }

  /* recalculate line boundaries */
  adjusttopline = 1;
  toplineoffset = 0;
  groupfirstline = 0;

  for (g = 0; g < *totalgroups; ++g)
  {
    if (adjusttopline && groups[g].endline >= *topline)
      toplineoffset = groups[g].endline - *topline;

    groups[g].startline = groupfirstline;
    groups[g].endline = groupfirstline + 2;

    for (f = 0; f < groups[g].filecount; ++f)
      groups[g].endline += filerowcount(groups[g].files[f].file, COLS, groups[g].filecount);

    if (adjusttopline && toplineoffset > 0)
    {
      *topline = groups[g].endline - toplineoffset;

      if (*topline < 0)
        *topline = 0;

      adjusttopline = 0;
    }

    groupfirstline = groups[g].endline + 1;
  }

  if (*totalgroups > 0 && groups[*totalgroups-1].endline <= *topline)
  {
    *topline = groups[*totalgroups-1].endline - getmaxy(filewin) + 1;

    if (*topline < 0)
      *topline = 0;
  }

  cmd_clear_all_selections(groups, *totalgroups, commandarguments, 0);
}