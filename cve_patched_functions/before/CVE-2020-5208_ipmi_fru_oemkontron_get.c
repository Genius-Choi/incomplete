static void ipmi_fru_oemkontron_get(int argc,
				    char ** argv,
				    uint8_t * fru_data,
				    int off,
				    struct fru_multirec_oem_header *oh)
{
	static bool badParams = false;
	int start = off;
	int offset = start;
	offset += sizeof(struct fru_multirec_oem_header);

	if(!badParams){
		/* the 'OEM' field is already checked in caller */
		if( argc > OEM_KONTRON_SUBCOMMAND_ARG_POS ){
			if(strncmp("oem", argv[OEM_KONTRON_SUBCOMMAND_ARG_POS],3)){
				printf("usage: fru get <id> <oem>\n");
				badParams = true;
				return;
			}
		}
		if( argc<GET_OEM_KONTRON_COMPLETE_ARG_COUNT ){
			printf("usage: oem <iana> <recordid>\n");
			printf("usage: oem 15000 3\n");
			badParams = true;
			return;
		}
	}

	if (badParams) {
		return;
	}

	if (oh->record_id != OEM_KONTRON_INFORMATION_RECORD) {
		return;
	}

	uint8_t version;

	printf("Kontron OEM Information Record\n");
	version = oh->record_version;

	uint8_t blockCount;
	uint8_t blockIndex = 0;

	uint8_t instance = 0;

	if (str2uchar(argv[OEM_KONTRON_INSTANCE_ARG_POS], &instance) != 0) {
		lprintf(LOG_ERR,
			"Instance argument '%s' is either invalid or out of range.",
			argv[OEM_KONTRON_INSTANCE_ARG_POS]);
		badParams = true;
		return;
	}

	blockCount = fru_data[offset++];

	for (blockIndex = 0; blockIndex < blockCount; blockIndex++) {
		void *pRecordData;
		uint8_t nameLen;

		nameLen = (fru_data[offset++] &= 0x3F);
		printf("  Name: %*.*s\n", nameLen, nameLen,
		       (const char *)(fru_data + offset));

		offset += nameLen;

		pRecordData = &fru_data[offset];

		printf("  Record Version: %d\n", version);
		if (version == 0) {
			printf("  Version: %*.*s\n",
			       OEM_KONTRON_FIELD_SIZE,
			       OEM_KONTRON_FIELD_SIZE,
			       ((tOemKontronInformationRecordV0 *)pRecordData)->field1);
			printf("  Build Date: %*.*s\n",
			       OEM_KONTRON_FIELD_SIZE,
			       OEM_KONTRON_FIELD_SIZE,
			       ((tOemKontronInformationRecordV0 *)pRecordData)->field2);
			printf("  Update Date: %*.*s\n",
			       OEM_KONTRON_FIELD_SIZE,
			       OEM_KONTRON_FIELD_SIZE,
			       ((tOemKontronInformationRecordV0 *)pRecordData)->field3);
			printf("  Checksum: %*.*s\n\n",
			       OEM_KONTRON_FIELD_SIZE,
			       OEM_KONTRON_FIELD_SIZE,
			       ((tOemKontronInformationRecordV0 *)pRecordData)->crc32);
			offset += sizeof(tOemKontronInformationRecordV0);
			offset++;
		} else if (version == 1) {
			printf("  Version: %*.*s\n",
			       OEM_KONTRON_VERSION_FIELD_SIZE,
			       OEM_KONTRON_VERSION_FIELD_SIZE,
			       ((tOemKontronInformationRecordV1 *)pRecordData)->field1);
			printf("  Build Date: %*.*s\n",
			       OEM_KONTRON_FIELD_SIZE,
			       OEM_KONTRON_FIELD_SIZE,
			       ((tOemKontronInformationRecordV1 *)pRecordData)->field2);
			printf("  Update Date: %*.*s\n",
			       OEM_KONTRON_FIELD_SIZE,
			       OEM_KONTRON_FIELD_SIZE,
			       ((tOemKontronInformationRecordV1 *)pRecordData)->field3);
			printf("  Checksum: %*.*s\n\n",
			       OEM_KONTRON_FIELD_SIZE,
			       OEM_KONTRON_FIELD_SIZE,
			       ((tOemKontronInformationRecordV1 *)pRecordData)->crc32);
			offset += sizeof(tOemKontronInformationRecordV1);
			offset++;
		} else {
			printf("  Unsupported version %d\n", version);
		}
	}
}
