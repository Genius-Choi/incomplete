static pj_status_t tls_start_read(struct tls_transport *tls)
{
    pj_pool_t *pool;
    pj_uint32_t size;
    pj_sockaddr *rem_addr;
    void *readbuf[1];
    pj_status_t status;

    /* Init rdata */
    pool = pjsip_endpt_create_pool(tls->base.endpt,
				   "rtd%p",
				   PJSIP_POOL_RDATA_LEN,
				   PJSIP_POOL_RDATA_INC);
    if (!pool) {
	tls_perror(tls->base.obj_name, "Unable to create pool", PJ_ENOMEM,
		   NULL);
	return PJ_ENOMEM;
    }

    tls->rdata.tp_info.pool = pool;

    tls->rdata.tp_info.transport = &tls->base;
    tls->rdata.tp_info.tp_data = tls;
    tls->rdata.tp_info.op_key.rdata = &tls->rdata;
    pj_ioqueue_op_key_init(&tls->rdata.tp_info.op_key.op_key, 
			   sizeof(pj_ioqueue_op_key_t));

    tls->rdata.pkt_info.src_addr = tls->base.key.rem_addr;
    tls->rdata.pkt_info.src_addr_len = sizeof(tls->rdata.pkt_info.src_addr);
    rem_addr = &tls->base.key.rem_addr;
    pj_sockaddr_print(rem_addr, tls->rdata.pkt_info.src_name,
                          sizeof(tls->rdata.pkt_info.src_name), 0);
    tls->rdata.pkt_info.src_port = pj_sockaddr_get_port(rem_addr);

    size = sizeof(tls->rdata.pkt_info.packet);
    readbuf[0] = tls->rdata.pkt_info.packet;
    status = pj_ssl_sock_start_read2(tls->ssock, tls->base.pool, size,
				     readbuf, 0);
    if (status != PJ_SUCCESS && status != PJ_EPENDING) {
	PJ_PERROR(4, (tls->base.obj_name, status,
		     "pj_ssl_sock_start_read() error"));
	return status;
    }

    return PJ_SUCCESS;
}
