int ntlm_decode_chal_msg(struct ntlm_ctx *ctx,
                         struct ntlm_buffer *buffer,
                         uint32_t *_flags, char **target_name,
                         struct ntlm_buffer *challenge,
                         struct ntlm_buffer *target_info)
{
    struct wire_chal_msg *msg;
    size_t payload_offs;
    size_t base_chal_size;
    uint32_t flags;
    char *trg = NULL;
    int ret = 0;

    if (!ctx) return EINVAL;

    if (challenge->length < 8) return EINVAL;

    msg = (struct wire_chal_msg *)buffer->data;
    payload_offs = (char *)msg->payload - (char *)msg;

    flags = le32toh(msg->neg_flags);
    base_chal_size = sizeof(struct wire_chal_msg);

    if ((flags & NTLMSSP_NEGOTIATE_VERSION) == 0) {
        /* adjust the payload offset to point to the
         * version field, for compatibility with older
         * clients that completely omitted the structure
         * on the wire */
        payload_offs -= sizeof(struct wire_version);
        base_chal_size -= sizeof(struct wire_version);
    }

    if ((flags & NTLMSSP_TARGET_TYPE_SERVER)
        || (flags & NTLMSSP_TARGET_TYPE_DOMAIN)) {
        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {
            ret = ntlm_decode_u16l_str_hdr(ctx, &msg->target_name, buffer,
                                           payload_offs, &trg);
        } else {
            ret = ntlm_decode_oem_str(&msg->target_name, buffer,
                                      payload_offs, &trg);
        }
        if (ret) goto done;
    }

    memcpy(challenge->data, msg->server_challenge, 8);
    challenge->length = 8;

    /* if we allowed a broken short challenge message from an old
     * server we must stop here */
    if (buffer->length < base_chal_size) {
        if (flags & NTLMSSP_NEGOTIATE_TARGET_INFO) {
            ret = ERR_DECODE;
        }
        goto done;
    }

    if (flags & NTLMSSP_NEGOTIATE_TARGET_INFO) {
        ret = ntlm_decode_field(&msg->target_info, buffer,
                                payload_offs, target_info);
        if (ret) goto done;
    }

done:
    if (ret) {
        safefree(trg);
    } else {
        *_flags = flags;
        *target_name = trg;
    }
    return ret;
}
