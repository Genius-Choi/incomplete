static int minmax_slice16(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)
{
    ColorCorrectContext *s = ctx->priv;
    AVFrame *frame = arg;
    const float imax = s->imax;
    const int width = s->planewidth[1];
    const int height = s->planeheight[1];
    const int slice_start = (height * jobnr) / nb_jobs;
    const int slice_end = (height * (jobnr + 1)) / nb_jobs;
    const ptrdiff_t ulinesize = frame->linesize[1] / 2;
    const ptrdiff_t vlinesize = frame->linesize[2] / 2;
    const uint16_t *uptr = (const uint16_t *)frame->data[1] + slice_start * ulinesize;
    const uint16_t *vptr = (const uint16_t *)frame->data[2] + slice_start * vlinesize;
    int min_u = INT_MAX, min_v = INT_MAX;
    int max_u = INT_MIN, max_v = INT_MIN;

    for (int y = slice_start; y < slice_end; y++) {
        for (int x = 0; x < width; x++) {
            min_u = FFMIN(min_u, uptr[x]);
            min_v = FFMIN(min_v, vptr[x]);
            max_u = FFMAX(max_u, uptr[x]);
            max_v = FFMAX(max_v, vptr[x]);
        }

        uptr += ulinesize;
        vptr += vlinesize;
    }

    s->analyzeret[jobnr][0] = imax * min_u - 0.5f;
    s->analyzeret[jobnr][1] = imax * min_v - 0.5f;
    s->analyzeret[jobnr][2] = imax * max_u - 0.5f;
    s->analyzeret[jobnr][3] = imax * max_v - 0.5f;

    return 0;
}
