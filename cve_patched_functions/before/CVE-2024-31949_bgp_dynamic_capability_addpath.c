static void bgp_dynamic_capability_addpath(uint8_t *pnt, int action,
					   struct capability_header *hdr,
					   struct peer *peer)
{
	uint8_t *data = pnt + 3;
	uint8_t *end = data + hdr->length;
	size_t len = end - data;
	afi_t afi;
	safi_t safi;

	if (action == CAPABILITY_ACTION_SET) {
		if (len % CAPABILITY_CODE_ADDPATH_LEN) {
			flog_warn(EC_BGP_CAPABILITY_INVALID_LENGTH,
				  "Add Path: Received invalid length %zu, non-multiple of 4",
				  len);
			return;
		}

		SET_FLAG(peer->cap, PEER_CAP_ADDPATH_RCV);

		while (data + CAPABILITY_CODE_ADDPATH_LEN <= end) {
			afi_t afi;
			safi_t safi;
			iana_afi_t pkt_afi;
			iana_safi_t pkt_safi;
			struct bgp_addpath_capability bac;

			memcpy(&bac, data, sizeof(bac));
			pkt_afi = ntohs(bac.afi);
			pkt_safi = safi_int2iana(bac.safi);

			/* If any other value (other than 1-3) is received,
			 * then the capability SHOULD be treated as not
			 * understood and ignored.
			 */
			if (!bac.flags || bac.flags > 3) {
				flog_warn(EC_BGP_CAPABILITY_INVALID_LENGTH,
					  "Add Path: Received invalid send/receive value %u in Add Path capability",
					  bac.flags);
				goto ignore;
			}

			if (bgp_debug_neighbor_events(peer))
				zlog_debug("%s OPEN has %s capability for afi/safi: %s/%s%s%s",
					   peer->host,
					   lookup_msg(capcode_str, hdr->code,
						      NULL),
					   iana_afi2str(pkt_afi),
					   iana_safi2str(pkt_safi),
					   (bac.flags & BGP_ADDPATH_RX)
						   ? ", receive"
						   : "",
					   (bac.flags & BGP_ADDPATH_TX)
						   ? ", transmit"
						   : "");

			if (bgp_map_afi_safi_iana2int(pkt_afi, pkt_safi, &afi,
						      &safi)) {
				if (bgp_debug_neighbor_events(peer))
					zlog_debug("%s Addr-family %s/%s(afi/safi) not supported. Ignore the Addpath Attribute for this AFI/SAFI",
						   peer->host,
						   iana_afi2str(pkt_afi),
						   iana_safi2str(pkt_safi));
				goto ignore;
			} else if (!peer->afc[afi][safi]) {
				if (bgp_debug_neighbor_events(peer))
					zlog_debug("%s Addr-family %s/%s(afi/safi) not enabled. Ignore the AddPath capability for this AFI/SAFI",
						   peer->host,
						   iana_afi2str(pkt_afi),
						   iana_safi2str(pkt_safi));
				goto ignore;
			}

			if (CHECK_FLAG(bac.flags, BGP_ADDPATH_RX))
				SET_FLAG(peer->af_cap[afi][safi],
					 PEER_CAP_ADDPATH_AF_RX_RCV);
			else
				UNSET_FLAG(peer->af_cap[afi][safi],
					   PEER_CAP_ADDPATH_AF_RX_RCV);

			if (CHECK_FLAG(bac.flags, BGP_ADDPATH_TX))
				SET_FLAG(peer->af_cap[afi][safi],
					 PEER_CAP_ADDPATH_AF_TX_RCV);
			else
				UNSET_FLAG(peer->af_cap[afi][safi],
					   PEER_CAP_ADDPATH_AF_TX_RCV);

ignore:
			data += CAPABILITY_CODE_ADDPATH_LEN;
		}
	} else {
		FOREACH_AFI_SAFI (afi, safi) {
			UNSET_FLAG(peer->af_cap[afi][safi],
				   PEER_CAP_ADDPATH_AF_RX_RCV);
			UNSET_FLAG(peer->af_cap[afi][safi],
				   PEER_CAP_ADDPATH_AF_TX_RCV);
		}

		UNSET_FLAG(peer->cap, PEER_CAP_ADDPATH_RCV);
	}
}
