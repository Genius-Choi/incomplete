static pj_status_t start_ice(struct transport_ice *tp_ice,
                             pj_pool_t *tmp_pool,
                             const pjmedia_sdp_session *rem_sdp,
                             unsigned media_index)
{
    pjmedia_sdp_media *rem_m = rem_sdp->media[media_index];
    const pjmedia_sdp_attr *ufrag_attr, *pwd_attr;
    pj_ice_sess_cand *cand;
    unsigned i, cand_cnt;
    pj_status_t status;

    get_ice_attr(rem_sdp, rem_m, &ufrag_attr, &pwd_attr);

    /* Allocate candidate array */
    cand = (pj_ice_sess_cand*)
           pj_pool_calloc(tmp_pool, PJ_ICE_MAX_CAND, 
                          sizeof(pj_ice_sess_cand));

    /* Get all candidates in the media */
    cand_cnt = 0;
    for (i=0; i<rem_m->attr_count && cand_cnt < PJ_ICE_MAX_CAND; ++i) {
        pjmedia_sdp_attr *attr;

        attr = rem_m->attr[i];

        if (pj_strcmp(&attr->name, &STR_CANDIDATE)!=0)
            continue;

        /* Parse candidate */
        status = parse_cand(tp_ice->base.name, tmp_pool, &attr->value, 
                            &cand[cand_cnt]);
        if (status != PJ_SUCCESS) {
            PJ_PERROR(4,(tp_ice->base.name, status,
                         "Error in parsing SDP candidate attribute '%.*s', "
                         "candidate is ignored",
                         (int)attr->value.slen, attr->value.ptr));
            continue;
        }

        if (!tp_ice->use_rtcp_mux || cand[cand_cnt].comp_id < 2)
            cand_cnt++;
    }

    /* Start ICE */
    return pj_ice_strans_start_ice(tp_ice->ice_st, &ufrag_attr->value, 
                                   &pwd_attr->value, cand_cnt, cand);
}
