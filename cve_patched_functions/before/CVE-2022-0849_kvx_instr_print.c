int kvx_instr_print(insn_t *insn, ut64 offset, char *buf, size_t len) {
	const char *fmt = insn->opc->format;
	operand_t opr;
	int i = 0;
	int n, w;

	/* print mnemonic */
	w = snprintf (buf, len, "%s%s", insn->opc->mnemonic, fmt[0] != '\0' ? " " : "");
	n = R_MIN (w, len);

	/* append operands */
	while (n < (len - 1) && *fmt != '\0') {
		if (fmt[0] == '%' && fmt[1] == 's') {
			/* decode each operand in order */
			if (i < R_ARRAY_SIZE (insn->opc->decode) && insn->opc->decode[i]) {
				insn->opc->decode[i] (&opr, insn->value);
				if (opr.type == KVX_OPER_TYPE_IMM)
					w = snprintf (buf + n, len - n, "0x%" PFMT64x, (ut64)opr.imm);
				else if (opr.type == KVX_OPER_TYPE_OFF)
					w = snprintf (buf + n, len - n, "0x%" PFMT64x, (ut64)opr.imm + offset);
				else if (opr.type == KVX_OPER_TYPE_REG)
					w = snprintf (buf + n, len - n, "%s", opr.reg);
				else
					w = 0;
				n += R_MIN (w, len - n);

				i++;
				/* advance after the format '%s' */
				fmt += 2;
			}
		} else {
			/* simple copy */
			buf[n] = fmt[0];
			fmt++;
			n++;
		}
	}
	if (!insn->rem) {
		w = snprintf (buf + n, len - n, " ;;");
		n += R_MIN (w, len - n);
	}
	buf[n] = 0;

	return n;
}
