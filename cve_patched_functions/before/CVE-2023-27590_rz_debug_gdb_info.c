static RzDebugInfo *rz_debug_gdb_info(RzDebug *dbg, const char *arg) {
	RzDebugGdbCtx *ctx = dbg->plugin_data;
	RzDebugInfo *rdi;
	if (!(rdi = RZ_NEW0(RzDebugInfo))) {
		return NULL;
	}
	RzList *th_list;
	bool list_alloc = false;
	if (dbg->threads) {
		th_list = dbg->threads;
	} else {
		th_list = rz_debug_gdb_threads(dbg, dbg->pid);
		list_alloc = true;
	}
	RzDebugPid *th;
	RzListIter *it;
	bool found = false;
	rz_list_foreach (th_list, it, th) {
		if (th->pid == dbg->pid) {
			found = true;
			break;
		}
	}
	rdi->pid = dbg->pid;
	rdi->tid = dbg->tid;
	rdi->exe = gdbr_exec_file_read(ctx->desc, dbg->pid);
	rdi->status = found ? th->status : RZ_DBG_PROC_STOP;
	rdi->uid = found ? th->uid : -1;
	rdi->gid = found ? th->gid : -1;
	if (gdbr_stop_reason(ctx->desc) >= 0) {
		eprintf("signal: %d\n", ctx->desc->stop_reason.signum);
		rdi->signum = ctx->desc->stop_reason.signum;
	}
	if (list_alloc) {
		rz_list_free(th_list);
	}
	return rdi;
}
