RZ_API bool rz_reg_set_profile_string(RZ_NONNULL RzReg *reg, RZ_NONNULL const char *profile_str) {
	rz_return_val_if_fail(reg && profile_str, false);
	// Same profile, no need to change
	if (reg->reg_profile_str && !strcmp(reg->reg_profile_str, profile_str)) {
		return true;
	}

	// we should reset all the arenas before setting the new reg profile
	rz_reg_arena_pop(reg);
	// Purge the old registers
	rz_reg_free_internal(reg, true);
	rz_reg_arena_shrink(reg);

	// Cache the profile string
	reg->reg_profile_str = strdup(profile_str);
	reg->reg_profile.defs = rz_list_newf((RzListFree)rz_reg_profile_def_free);
	reg->reg_profile.alias = rz_list_newf((RzListFree)rz_reg_profile_alias_free);
	rz_return_val_if_fail(reg->reg_profile.defs && reg->reg_profile.alias, true);

	if (!parse_reg_profile_str(reg->reg_profile.alias, reg->reg_profile.defs, profile_str)) {
		RZ_LOG_WARN("Could not parse register profile string.\n");
		rz_reg_free_internal(reg, false);
		return false;
	}

	// Check for duplicates
	RzListIter *it, *tmp;
	RzRegProfileDef *def;
	rz_list_foreach_safe (reg->reg_profile.defs, it, tmp, def) {
		if (rz_reg_get(reg, def->name, RZ_REG_TYPE_ANY)) {
			RZ_LOG_WARN("Ignoring duplicated register definition '%s'.\n", def->name);
			rz_list_delete(reg->reg_profile.defs, it);
		}
	}

	if (!rz_reg_set_reg_profile(reg)) {
		RZ_LOG_WARN("Could not set reg profile.\n");
		return false;
	}

	reg->size = 0;
	for (ut32 i = 0; i < RZ_REG_TYPE_LAST; i++) {
		RzRegSet *rs = &reg->regset[i];
		if (rs && rs->arena) {
			reg->size += rs->arena->size; // Sums minimum arena size.
		}
	}

	rz_reg_fit_arena(reg);
	// dup the last arena to allow regdiffing
	rz_reg_arena_push(reg);
	rz_reg_reindex(reg);
	return true;
}
