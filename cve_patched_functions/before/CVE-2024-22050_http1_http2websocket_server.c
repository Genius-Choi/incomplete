static int http1_http2websocket_server(http_s *h, websocket_settings_s *args) {
  // A static data used for all websocket connections.
  static char ws_key_accpt_str[] = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
  static uintptr_t sec_version = 0;
  static uintptr_t sec_key = 0;
  if (!sec_version)
    sec_version = fiobj_hash_string("sec-websocket-version", 21);
  if (!sec_key)
    sec_key = fiobj_hash_string("sec-websocket-key", 17);

  FIOBJ tmp = fiobj_hash_get2(h->headers, sec_version);
  if (!tmp)
    goto bad_request;
  fio_str_info_s stmp = fiobj_obj2cstr(tmp);
  if (stmp.len != 2 || stmp.data[0] != '1' || stmp.data[1] != '3')
    goto bad_request;

  tmp = fiobj_hash_get2(h->headers, sec_key);
  if (!tmp)
    goto bad_request;
  stmp = fiobj_obj2cstr(tmp);

  fio_sha1_s sha1 = fio_sha1_init();
  fio_sha1_write(&sha1, stmp.data, stmp.len);
  fio_sha1_write(&sha1, ws_key_accpt_str, sizeof(ws_key_accpt_str) - 1);
  tmp = fiobj_str_buf(32);
  stmp = fiobj_obj2cstr(tmp);
  fiobj_str_resize(tmp,
                   fio_base64_encode(stmp.data, fio_sha1_result(&sha1), 20));
  http_set_header(h, HTTP_HEADER_CONNECTION, fiobj_dup(HTTP_HVALUE_WS_UPGRADE));
  http_set_header(h, HTTP_HEADER_UPGRADE, fiobj_dup(HTTP_HVALUE_WEBSOCKET));
  http_set_header(h, HTTP_HEADER_WS_SEC_KEY, tmp);
  h->status = 101;
  http1pr_s *pr = handle2pr(h);
  const intptr_t uuid = handle2pr(h)->p.uuid;
  http_settings_s *set = handle2pr(h)->p.settings;
  http_finish(h);
  pr->stop = 1;
  websocket_attach(uuid, set, args, pr->parser.state.next,
                   pr->buf_len - (intptr_t)(pr->parser.state.next - pr->buf));
  return 0;
bad_request:
  http_send_error(h, 400);
  if (args->on_close)
    args->on_close(0, args->udata);
  return -1;
}
