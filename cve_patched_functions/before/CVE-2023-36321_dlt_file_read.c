DltReturnValue dlt_file_read(DltFile *file, int verbose)
{
    long *ptr;
    int found = DLT_RETURN_OK;

    if (file == NULL)
        return DLT_RETURN_WRONG_PARAMETER;

    if (verbose)
        dlt_vlog(LOG_DEBUG, "%s: Message %d:\n", __func__, file->counter_total);

    /* allocate new memory for index if number of messages exceeds a multiple of DLT_COMMON_INDEX_ALLOC (e.g.: 1000) */
    if (file->counter % DLT_COMMON_INDEX_ALLOC == 0) {
        ptr = (long *)malloc(((file->counter / DLT_COMMON_INDEX_ALLOC) + 1) * DLT_COMMON_INDEX_ALLOC * sizeof(long));

        if (ptr == NULL)
            return DLT_RETURN_ERROR;

        if (file->index) {
            memcpy(ptr, file->index, (size_t)(file->counter) * sizeof(long));
            free(file->index);
        }

        file->index = ptr;
    }

    /* set to end of last succesful read message, because of conflicting calls to dlt_file_read and dlt_file_message */
    if (0 != fseek(file->handle, file->file_position, SEEK_SET)) {
        dlt_vlog(LOG_WARNING, "Seek failed to file_position %" PRIu64 "\n",
                 file->file_position);
        return DLT_RETURN_ERROR;
    }

    /* get file position at start of DLT message */
    if (verbose)
        dlt_vlog(LOG_INFO, "Position in file: %" PRIu64 "\n", file->file_position);

    /* read header */
    if (dlt_file_read_header(file, verbose) < DLT_RETURN_OK) {
        /* go back to last position in file */
        fseek(file->handle, file->file_position, SEEK_SET);
        return DLT_RETURN_ERROR;
    }

    if (file->filter) {
        /* read the extended header if filter is enabled and extended header exists */
        if (dlt_file_read_header_extended(file, verbose) < DLT_RETURN_OK) {
            /* go back to last position in file */
            if (0 != fseek(file->handle, file->file_position, SEEK_SET))
                dlt_vlog(LOG_WARNING, "Seek to last file pos failed!\n");

            return DLT_RETURN_ERROR;
        }

        /* check the filters if message is used */
        if (dlt_message_filter_check(&(file->msg), file->filter, verbose) == DLT_RETURN_TRUE) {
            /* filter matched, consequently store current message */
            /* store index pointer to message position in DLT file */
            file->index[file->counter] = file->file_position;
            file->counter++;
            file->position = file->counter - 1;

            found = DLT_RETURN_TRUE;
        }

        /* skip payload data */
        if (fseek(file->handle, file->msg.datasize, SEEK_CUR) != 0) {
            /* go back to last position in file */
            dlt_vlog(LOG_WARNING,
                     "Seek failed to skip payload data of size %u!\n",
                     file->msg.datasize);

            if (0 != fseek(file->handle, file->file_position, SEEK_SET))
                dlt_log(LOG_WARNING, "Seek back also failed!\n");

            return DLT_RETURN_ERROR;
        }
    }
    else {
        /* filter is disabled */
        /* skip additional header parameters and payload data */
        if (fseek(file->handle,
                  (long) (file->msg.headersize - sizeof(DltStorageHeader) - sizeof(DltStandardHeader) + file->msg.datasize),
                  SEEK_CUR)) {

            dlt_vlog(LOG_WARNING,
                     "Seek failed to skip extra header and payload data from file of size %u!\n",
                     file->msg.headersize - (int32_t)sizeof(DltStorageHeader) -
                     (int32_t)sizeof(DltStandardHeader) + file->msg.datasize);

            /* go back to last position in file */
            if (fseek(file->handle, file->file_position, SEEK_SET))
                dlt_log(LOG_WARNING, "Seek back also failed!\n");

            return DLT_RETURN_ERROR;
        }

        /* store index pointer to message position in DLT file */
        file->index[file->counter] = file->file_position;
        file->counter++;
        file->position = file->counter - 1;

        found = DLT_RETURN_TRUE;
    }

    /* increase total message counter */
    file->counter_total++;

    /* store position to next message */
    file->file_position = ftell(file->handle);

    return found;
}
