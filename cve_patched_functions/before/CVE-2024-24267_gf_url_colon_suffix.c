char* gf_url_colon_suffix(const char *path, char assign_sep)
{
	char *sep = strchr(path, ':');
	if (!sep) return NULL;

	//handle Z:\ and Z:/
	if ((path[1]==':') && ( (path[2]=='/') || (path[2]=='\\') ) )
		return gf_url_colon_suffix(path+2, assign_sep);

	if (!strncmp(path, "gfio://", 7) || !strncmp(path, "gmem://", 7)) {
		return strchr(path+7, ':');
	}

	//handle "\\foo\Z:\bar"
	if ((path[0] == '\\') && (path[1] == '\\')) {
		char *next = strchr(path+2, '\\');
		if (next) next = strchr(next + 1, '\\');
		if (next)
			return gf_url_colon_suffix(next + 1, assign_sep);
	}


	//handle PROTO://ADD:PORT/
	if ((sep[1]=='/') && (sep[2]=='/')) {
		char *next_colon, *next_slash, *userpass;
		sep++;
		//skip all // (eg PROTO://////////////mytest/)
		while (sep[0]=='/')
			sep++;
		if (!sep[0]) return NULL;

		/*we may now have C:\ or C:/  (eg file://///C:\crazy\ or  file://///C:/crazy/)
			if sep[1]==':', then sep[2] is valid (0 or something else), no need to check for len
		*/
		if ((sep[1]==':') && ( (sep[2]=='/') || (sep[2]=='\\') ) ) {
			return gf_url_colon_suffix(sep+2, assign_sep);
		}
		//find closest : or /, if : is before / consider this is a port or an IPv6 address and check next : after /
		next_colon = strchr(sep, ':');
		next_slash = strchr(sep, '/');
		userpass = strchr(sep, '@');
		//if ':' is before '@' with '@' before next '/', consider this is `user:pass@SERVER`
		if (userpass && next_colon && next_slash && (userpass<next_slash) && (userpass>next_colon))
			next_colon = strchr(userpass, ':');

		if (next_colon && next_slash && ((next_slash - sep) > (next_colon - sep)) ) {
			const char *last_colon;
			u32 i, port, nb_colons=0, nb_dots=0, nb_non_alnums=0;
			next_slash[0] = 0;
			last_colon = strrchr(next_colon, ':');
			port = atoi(last_colon+1);
			for (i=0; i<strlen(next_colon+1); i++) {
				if (next_colon[i+1] == ':') nb_colons++;
				else if (next_colon[i+1] == '.') nb_dots++;
				//closing bracket of IPv6
				else if (next_colon[i+1] == ']') {}
				else if (!isalnum(next_colon[i+1])) {
					nb_non_alnums++;
					break;
				}
			}
			next_slash[0] = '/';
			//if no non-alphanum, we must have either a port (ipv4) or extra colons but no dots (ipv6)
			if (!nb_non_alnums && (port || (nb_colons && !nb_dots)))
				next_colon = strchr(next_slash, ':');
		}
		return next_colon;
	}

	if (sep && assign_sep) {
		char *file_ext = strchr(path, '.');
		char *assign = strchr(path, assign_sep);
		if (assign && assign>file_ext) assign = NULL;
		if (assign) file_ext = NULL;
		if (file_ext && (file_ext>sep)) {
			sep = strchr(file_ext, ':');
		}
		if (assign && (strlen(assign) > 4)) {
			if ((assign[2] == ':') && ((assign[3] == '\\') || (assign[3] == '/'))) {
				return gf_url_colon_suffix(assign + 1, 0);
			}
			if ((assign[1] == '\\') && (assign[2] == '\\')) {
				char *next = strchr(assign + 3, '\\');
				if (next) next = strchr(next+1, '\\');
				if (next && (next>sep))
					return gf_url_colon_suffix(next, 0);
			}
		}
	}
	return sep;
}
