std::shared_ptr<Context> createContext(
    std::unique_ptr<Context::ResolutionTable> resolutionTable,
    std::vector<uint32_t> segments) {
  CodeGenerationSettings codeGenOpts;
  codeGenOpts.enableTDZ = cl::EnableTDZ;
  codeGenOpts.dumpOperandRegisters = cl::DumpOperandRegisters;
  codeGenOpts.dumpUseList = cl::DumpUseList;
  codeGenOpts.dumpSourceLocation =
      cl::DumpSourceLocation != LocationDumpMode::None;
  codeGenOpts.dumpIRBetweenPasses = cl::DumpBetweenPasses;
  if (cl::BytecodeFormat == cl::BytecodeFormatKind::HBC) {
    codeGenOpts.unlimitedRegisters = false;
  }
  codeGenOpts.instrumentIR = cl::InstrumentIR;

  OptimizationSettings optimizationOpts;

  // Enable aggressiveNonStrictModeOptimizations if the target is HBC.
  optimizationOpts.aggressiveNonStrictModeOptimizations =
      cl::BytecodeFormat == cl::BytecodeFormatKind::HBC;

  optimizationOpts.inlining = cl::OptimizationLevel != cl::OptLevel::O0 &&
      cl::BytecodeFormat == cl::BytecodeFormatKind::HBC && cl::Inline;

  optimizationOpts.reusePropCache = cl::ReusePropCache;

  // When the setting is auto-detect, we will set the correct value after
  // parsing.
  optimizationOpts.staticBuiltins =
      cl::StaticBuiltins == cl::StaticBuiltinSetting::ForceOn;
  optimizationOpts.staticRequire = cl::StaticRequire;

  optimizationOpts.useUnsafeIntrinsics = cl::UseUnsafeIntrinsics;

  auto context = std::make_shared<Context>(
      codeGenOpts,
      optimizationOpts,
      std::move(resolutionTable),
      std::move(segments));

  // Default is non-strict mode.
  context->setStrictMode(!cl::NonStrictMode && cl::StrictMode);
  context->setEnableEval(cl::EnableEval);
  context->getSourceErrorManager().setOutputOptions(guessErrorOutputOptions());

  setWarningsAreErrorsFromFlags(context->getSourceErrorManager());

#define WARNING_CATEGORY(name, specifier, description) \
  context->getSourceErrorManager().setWarningStatus(   \
      Warning::name, cl::name##Warning);
#include "hermes/Support/Warnings.def"

  if (cl::DisableAllWarnings)
    context->getSourceErrorManager().disableAllWarnings();
  context->getSourceErrorManager().setErrorLimit(cl::ErrorLimit);

  {
    // Set default lazy mode using defaults from CompileFlags to keep it in one
    // place.
    hermes::hbc::CompileFlags defaultFlags{};
    context->setPreemptiveFileCompilationThreshold(
        defaultFlags.preemptiveFileCompilationThreshold);
    context->setPreemptiveFunctionCompilationThreshold(
        defaultFlags.preemptiveFunctionCompilationThreshold);
  }

  if (cl::EagerCompilation || cl::DumpTarget == EmitBundle ||
      cl::OptimizationLevel > cl::OptLevel::Og) {
    // Make sure nothing is lazy
    context->setLazyCompilation(false);
  } else if (cl::LazyCompilation) {
    // Make sure everything is lazy
    context->setLazyCompilation(true);
    context->setPreemptiveFileCompilationThreshold(0);
    context->setPreemptiveFunctionCompilationThreshold(0);
  } else {
    // By default with no optimization, use lazy compilation for "large" files
    context->setLazyCompilation(true);
  }

  if (cl::CommonJS) {
    context->setUseCJSModules(true);
  }

#if HERMES_PARSE_JSX
  if (cl::JSX) {
    context->setParseJSX(true);
  }
#endif

#if HERMES_PARSE_FLOW
  if (cl::ParseFlow) {
    context->setParseFlow(ParseFlowSetting::ALL);
  }
#endif

#if HERMES_PARSE_TS
  if (cl::ParseTS) {
    context->setParseTS(true);
  }
#endif

  if (cl::DebugInfoLevel >= cl::DebugLevel::g3) {
    context->setDebugInfoSetting(DebugInfoSetting::ALL);
  } else if (cl::DebugInfoLevel == cl::DebugLevel::g2) {
    context->setDebugInfoSetting(DebugInfoSetting::SOURCE_MAP);
  } else {
    // -g1 or -g0. If -g0, we'll strip debug info later.
    context->setDebugInfoSetting(DebugInfoSetting::THROWING);
  }
  context->setEmitAsyncBreakCheck(cl::EmitAsyncBreakCheck);
  return context;
}
