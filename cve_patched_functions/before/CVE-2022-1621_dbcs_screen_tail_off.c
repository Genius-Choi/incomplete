dbcs_screen_tail_off(char_u *base, char_u *p)
{
    // It can't be the first byte if a double-byte when not using DBCS, at the
    // end of the string or the byte can't start a double-byte.
    // For euc-jp an 0x8e byte always means we have a lead byte in the current
    // cell.
    if (*p == NUL || p[1] == NUL
	    || (enc_dbcs == DBCS_JPNU && *p == 0x8e)
	    || MB_BYTE2LEN(*p) == 1)
	return 0;

    // Return 1 when on the lead byte, 0 when on the tail byte.
    return 1 - dbcs_screen_head_off(base, p);
}
