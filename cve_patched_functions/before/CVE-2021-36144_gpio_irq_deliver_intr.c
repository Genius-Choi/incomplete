gpio_irq_deliver_intr(struct virtio_gpio *gpio, uint64_t mask)
{
	struct virtio_vq_info *vq;
	struct iovec iov[1];
	uint16_t idx;
	uint64_t *data;

	vq = &gpio->queues[2];
	idx = vq->qsize;
	if (vq_has_descs(vq) && mask) {
		vq_getchain(vq, &idx, iov, 1, NULL);
		data = iov[0].iov_base;
		if (sizeof(*data) != iov[0].iov_len) {
			WPRINTF(("virtio gpio, invalid gpio data size %lu\n",
					iov[0].iov_len));
			virtio_gpio_abort(vq, idx);
			return;
		}

		*data = mask;

		/*
		 * Release this chain and handle more
		 */
		vq_relchain(vq, idx, sizeof(*data));

		/* Generate interrupt if appropriate. */
		vq_endchains(vq, 1);

		/* interrupt statistics */
		record_intr_statistics(&gpio->irq_chip, mask);

	} else
		WPRINTF(("virtio gpio failed to send an IRQ, mask %lu", mask));
}
