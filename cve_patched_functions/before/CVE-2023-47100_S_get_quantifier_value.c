S_get_quantifier_value(pTHX_ RExC_state_t *pRExC_state,
                       const char * start, const char * end)
{
    /* This is a helper function for regpiece() to compute, given the
     * quantifier {m,n}, the value of either m or n, based on the starting
     * position 'start' in the string, through the byte 'end-1', returning it
     * if valid, and failing appropriately if not.  It knows the restrictions
     * imposed on quantifier values */

    UV uv;
    STATIC_ASSERT_DECL(REG_INFTY <= U32_MAX);

    PERL_ARGS_ASSERT_GET_QUANTIFIER_VALUE;

    if (grok_atoUV(start, &uv, &end)) {
        if (uv < REG_INFTY) {   /* A valid, small-enough number */
            return (U32) uv;
        }
    }
    else if (*start == '0') { /* grok_atoUV() fails for only two reasons:
                                 leading zeros or overflow */
        RExC_parse = (char * ) end;

        /* Perhaps too generic a msg for what is only failure from having
         * leading zeros, but this is how it's always behaved. */
        vFAIL("Invalid quantifier in {,}");
        NOT_REACHED; /*NOTREACHED*/
    }

    /* Here, found a quantifier, but was too large; either it overflowed or was
     * too big a legal number */
    RExC_parse = (char * ) end;
    vFAIL2("Quantifier in {,} bigger than %d", REG_INFTY - 1);

    NOT_REACHED; /*NOTREACHED*/
    return U32_MAX; /* Perhaps some compilers will be expecting a return */
}
