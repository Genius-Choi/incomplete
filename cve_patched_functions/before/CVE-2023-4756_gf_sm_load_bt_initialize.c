static GF_Err gf_sm_load_bt_initialize(GF_SceneLoader *load, const char *str, Bool input_only)
{
	u32 size;
	gzFile gzInput;
	GF_Err e;
	unsigned char BOM[5];
	GF_BTParser *parser = load->loader_priv;

	parser->last_error = GF_OK;

	if (load->fileName) {
		FILE *test = gf_fopen(load->fileName, "rb");
		if (!test) return GF_URL_ERROR;

		size = (u32) gf_fsize(test);
		gf_fclose(test);

		gzInput = gf_gzopen(load->fileName, "rb");
		if (!gzInput) return GF_IO_ERR;

		parser->line_buffer = (char *) gf_malloc(sizeof(char)*BT_LINE_SIZE);
		memset(parser->line_buffer, 0, sizeof(char)*BT_LINE_SIZE);
		parser->file_size = size;

		parser->line_pos = parser->line_size = 0;
		gf_gzgets(gzInput, (char*) BOM, 5);
		gf_gzseek(gzInput, 0, SEEK_SET);
		parser->gz_in = gzInput;

	} else {
		if (!str || (strlen(str)<5) ) {
			/*wait for first string data to be fed to the parser (for load from string)*/
			parser->initialized = 0;
			return GF_OK;
		}
		strncpy((char *) BOM, str, 5);
	}

	/*0: no unicode, 1: UTF-16BE, 2: UTF-16LE*/
	if ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {
		if (!BOM[2] && !BOM[3]) {
			gf_bt_report(parser, GF_NOT_SUPPORTED, "UTF-32 Text Files not supported");
			return GF_NOT_SUPPORTED;
		} else {
			parser->unicode_type = 2;
			if (parser->gz_in) gf_gzseek(parser->gz_in, 2, SEEK_CUR);
		}
	} else if ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {
		if (!BOM[2] && !BOM[3]) {
			gf_bt_report(parser, GF_NOT_SUPPORTED, "UTF-32 Text Files not supported");
			return GF_NOT_SUPPORTED;
		} else {
			parser->unicode_type = 1;
			if (parser->gz_in) gf_gzseek(parser->gz_in, 2, SEEK_CUR);
		}
	} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {
		/*we handle UTF8 as asci*/
		parser->unicode_type = 0;
		if (parser->gz_in) gf_gzseek(parser->gz_in, 3, SEEK_CUR);
	}
	parser->initialized = 1;

	if ( load->fileName )
	{
		char *sep = gf_file_ext_start(load->fileName);
		if (sep && !strnicmp(sep, ".wrl", 4)) parser->is_wrl = 1;
	}

	if (input_only) return GF_OK;

	/*initalize default streams in the context*/

	/*chunk parsing*/
	if (load->flags & GF_SM_LOAD_CONTEXT_READY) {
		u32 i;
		GF_StreamContext *sc;
		if (!load->ctx) return GF_BAD_PARAM;

		/*restore context - note that base layer are ALWAYS declared BEFORE enhancement layers with gpac parsers*/
		i=0;
		while ((sc = (GF_StreamContext*)gf_list_enum(load->ctx->streams, &i))) {
			switch (sc->streamType) {
			case GF_STREAM_SCENE:
				if (!parser->bifs_es) parser->bifs_es = sc;
				break;
			case GF_STREAM_OD:
				if (!parser->od_es) parser->od_es = sc;
				break;
			default:
				break;
			}
		}
		/*need at least one scene stream*/
		if (!parser->bifs_es) {
			parser->bifs_es = gf_sm_stream_new(load->ctx, 0, GF_STREAM_SCENE, GF_CODECID_BIFS);
			parser->load->ctx->scene_width = 0;
			parser->load->ctx->scene_height = 0;
			parser->load->ctx->is_pixel_metrics = 1;
		}
		else parser->base_bifs_id = parser->bifs_es->ESID;
		if (parser->od_es) parser->base_od_id = parser->od_es->ESID;

		GF_LOG(GF_LOG_INFO, GF_LOG_PARSER, ("BT: MPEG-4 (BT) Scene Chunk Parsing"));
	}
	/*context is not initialized - check for VRML*/
	else {
		GF_Command *com;


		parser->load = NULL;
		gf_bt_check_line(parser);
		parser->load = load;
		if (load->ctx && parser->def_w && parser->def_h) {
			load->ctx->scene_width = parser->def_w;
			load->ctx->scene_height = parser->def_h;
		}

		/*create at least one empty BIFS stream*/
		if (!parser->is_wrl && load->ctx) {
			parser->bifs_es = gf_sm_stream_new(load->ctx, 0, GF_STREAM_SCENE, GF_CODECID_BIFS);
			parser->bifs_au = gf_sm_stream_au_new(parser->bifs_es, 0, 0, 1);
			parser->load->ctx->is_pixel_metrics = 1;
		}

		GF_LOG(GF_LOG_INFO, GF_LOG_PARSER, ( ((parser->is_wrl==2) ? "BT: X3D (WRL) Scene Parsing\n" : (parser->is_wrl ? "BT: VRML Scene Parsing\n" : "BT: MPEG-4 Scene Parsing\n")) ));

		/*default scene replace - we create it no matter what since it is used to store BIFS config when parsing IOD.*/
		com = NULL;
		if (!parser->is_wrl) {
			com = gf_sg_command_new(parser->load->scene_graph, GF_SG_SCENE_REPLACE);
			gf_list_add(parser->bifs_au->commands, com);
		}

		/*and perform initial load*/
		e = gf_bt_loader_run_intern(parser, com, 1);
		if (e) return e;
	}
	return GF_OK;
}
