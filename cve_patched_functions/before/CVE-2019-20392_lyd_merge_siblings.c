lyd_merge_siblings(struct lyd_node *target, struct lyd_node *source, int options)
{
    struct lyd_node *trg, *src, *src_backup, *ins;
    int ret, clear_flag = 0;
    struct ly_ctx *ctx = target->schema->module->ctx; /* shortcut */

    while (target->prev->next) {
        target = target->prev;
    }

    LY_TREE_FOR_SAFE(source, src_backup, src) {
        LY_TREE_FOR(target, trg) {
            /* sibling found, merge it */
            ret = lyd_merge_node_schema_equal(trg, src);
            if (ret == 1) {
                ret = lyd_merge_node_equal(trg, src);
            }
            if (ret > 0) {
                if (ret == 2) {
                    clear_flag = 1;
                }

                switch (trg->schema->nodetype) {
                case LYS_LEAF:
                case LYS_ANYXML:
                case LYS_ANYDATA:
                    lyd_merge_node_update(trg, src);
                    break;
                case LYS_LEAFLIST:
                    /* it's already there, nothing to do */
                    break;
                case LYS_LIST:
                case LYS_CONTAINER:
                case LYS_NOTIF:
                case LYS_RPC:
                case LYS_INPUT:
                case LYS_OUTPUT:
                    ret = lyd_merge_parent_children(trg, src->child, options);
                    if (ret == 2) {
                        clear_flag = 1;
                    } else if (ret) {
                        lyd_free_withsiblings(source);
                        return 1;
                    }
                    break;
                default:
                    LOGINT(ctx);
                    lyd_free_withsiblings(source);
                    return 1;
                }
                break;
            } else if (ret == -1) {
                lyd_free_withsiblings(source);
                return 1;
            } /* else not equal, nothing to do */
        }

        /* sibling not found, insert it */
        if (!trg) {
            if (ctx != src->schema->module->ctx) {
                ins = lyd_dup_to_ctx(src, 1, ctx);
            } else {
                lyd_unlink(src);
                if (src == source) {
                    /* just so source is not freed, we inserted it and need it further */
                    source = src_backup;
                }
                ins = src;
            }
            lyd_insert_after(target->prev, ins);
        }
    }

    lyd_free_withsiblings(source);
    if (clear_flag) {
        return 2;
    }
    return 0;
}
