static esp_err_t process_appended_hash_and_sig(esp_image_metadata_t *data, uint32_t part_offset, uint32_t part_len, bool do_verify, bool silent)
{
    esp_err_t err = ESP_OK;
    if (data->image.hash_appended) {
        // Account for the hash in the total image length
        if (do_verify) {
            CHECK_ERR(bootloader_flash_read(data->start_addr + data->image_len, &data->image_digest, HASH_LEN, true));
        }
        data->image_len += HASH_LEN;
    }

    uint32_t sig_block_len = 0;
    const uint32_t end = data->image_len;
#if CONFIG_SECURE_BOOT || CONFIG_SECURE_SIGNED_APPS_NO_SECURE_BOOT

    // Case I: Bootloader part
    if (part_offset == ESP_BOOTLOADER_OFFSET) {
        // For bootloader with secure boot v1, signature stays in an independant flash
        // sector (offset 0x0)  and does not get appended to the image.
#if CONFIG_SECURE_BOOT_V2_ENABLED
        // Sanity check - secure boot v2 signature block starts on 4K boundary
        sig_block_len = ALIGN_UP(end, FLASH_SECTOR_SIZE) - end;
        sig_block_len += sizeof(ets_secure_boot_signature_t);
#endif
    } else {
    // Case II: Application part
#if CONFIG_SECURE_SIGNED_APPS_ECDSA_SCHEME
        sig_block_len = sizeof(esp_secure_boot_sig_block_t);
#else
        // Sanity check - secure boot v2 signature block starts on 4K boundary
        sig_block_len = ALIGN_UP(end, FLASH_SECTOR_SIZE) - end;
        sig_block_len += sizeof(ets_secure_boot_signature_t);
#endif
    }
#endif // CONFIG_SECURE_BOOT || CONFIG_SECURE_SIGNED_APPS_NO_SECURE_BOOT

    const uint32_t full_image_len = end + sig_block_len;
    if (full_image_len > part_len) {
        FAIL_LOAD("Image length %d doesn't fit in partition length %d", full_image_len, part_len);
    }
    return err;
err:
    if (err == ESP_OK) {
        err = ESP_ERR_IMAGE_INVALID;
    }

    return err;
}
