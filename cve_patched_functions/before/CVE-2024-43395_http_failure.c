static std::string http_failure(lua_State *L, void* data) {
    http_handle_t * handle = (http_handle_t*)data;
    luaL_checkstack(L, 30, "Unable to allocate HTTP handle");
    pushstring(L, handle->url);
    if (!handle->failureReason.empty()) lua_pushstring(L, handle->failureReason.c_str());
    if (handle->stream != NULL) {
        *(http_handle_t**)lua_newuserdata(L, sizeof(http_handle_t*)) = handle;
        lua_createtable(L, 0, 1);
        lua_pushstring(L, "__gc");
        lua_pushcfunction(L, http_handle_free);
        lua_settable(L, -3);
        lua_setmetatable(L, -2);

        lua_createtable(L, 0, 6);
        lua_pushstring(L, "close");
        lua_pushvalue(L, -3);
        lua_pushcclosure(L, http_handle_close, 1);
        lua_settable(L, -3);

        lua_pushstring(L, "readLine");
        lua_pushvalue(L, -3);
        lua_pushcclosure(L, http_handle_readLine, 1);
        lua_settable(L, -3);

        lua_pushstring(L, "readAll");
        lua_pushvalue(L, -3);
        lua_pushcclosure(L, http_handle_readAllByte, 1);
        lua_settable(L, -3);

        lua_pushstring(L, "read");
        lua_pushvalue(L, -3);
        lua_pushcclosure(L, http_handle_readByte, 1);
        lua_settable(L, -3);

        lua_pushstring(L, "seek");
        lua_pushvalue(L, -3);
        lua_pushcclosure(L, http_handle_seek, 1);
        lua_settable(L, -3);

        lua_pushstring(L, "getResponseCode");
        lua_pushvalue(L, -3);
        lua_pushcclosure(L, http_handle_getResponseCode, 1);
        lua_settable(L, -3);

        lua_pushstring(L, "getResponseHeaders");
        lua_pushvalue(L, -3);
        lua_pushcclosure(L, http_handle_getResponseHeaders, 1);
        lua_settable(L, -3);
        lua_remove(L, -2);
    } else {
        delete handle;
    }
    return "http_failure";
}
