static void cmd_aflxj(RCore *core) {
	ut64 addr = faddr (core, core->offset, NULL);
	RAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_ANY);
	Sdb *db = sdb_new0 ();
	RVecAnalRef *xrefs = r_anal_xrefs_get (core->anal, addr);
	if (xrefs) {
		RAnalRef *ref;
		R_VEC_FOREACH (xrefs, ref) {
			bool nr = false;
			ut64 fa = faddr (core, ref->addr, &nr);
			char *key = r_str_newf ("0x%08"PFMT64x, fa);
			sdb_array_add_num (db, key, ref->addr, 0);
		}
	}
	SdbList *keys = sdb_foreach_list (db, true);
	SdbListIter *liter;
	SdbKv *kv;
	PJ * pj = r_core_pj_new (core);
	if (pj) {
		pj_o (pj);
	}
	ls_foreach (keys, liter, kv) {
		const char *key = sdbkv_key (kv);
		const char *value = sdbkv_value (kv);
		ut64 fcn_xref_addr = r_num_get (NULL, key);
		ut64 xref_addr = r_num_get (NULL, value);
		RAnalFunction *xref = r_anal_get_fcn_in (core->anal, fcn_xref_addr, R_ANAL_FCN_TYPE_ANY);
		if (fcn && xref) {
			pj_kn (pj, "address", fcn->addr);
			pj_ks (pj, "name", fcn->name);
			pj_ko (pj, "xrefs");
			pj_ka (pj, xref->name);
			pj_n (pj, xref_addr);
			pj_end (pj);
			pj_end (pj);
		} else {
			R_LOG_WARN ("No function defined here");
		}
	}
	pj_end (pj);
	char *s = pj_drain (pj);
	r_cons_printf ("%s\n", s);
	free (s);
	RVecAnalRef_free (xrefs);
	sdb_free (db);
	ls_free (keys);
}
