dwg_decode_eed (Bit_Chain *restrict dat, Dwg_Object_Object *restrict obj)
{
  BITCODE_BS size;
  int error = 0;
  unsigned int idx = 0;
  Dwg_Data *dwg = obj->dwg;
  Dwg_Object *_obj;
  long unsigned int sav_byte = dat->byte;

  if (!dwg)
    return DWG_ERR_INVALIDEED;
  _obj = &dwg->object[obj->objid]; /* Note that obj->objid may be 0 */
  obj->num_eed = 0;
  while ((size = bit_read_BS (dat)))
    {
      int i;
      BITCODE_BS j;
      long unsigned int end, offset;

      LOG_TRACE ("EED[%u] size: " FORMAT_BS " [BS]\n", idx, size);
      LOG_POS
      if (size > _obj->size || dat->byte == sav_byte)
        {
          LOG_ERROR ("Invalid EED size " FORMAT_BS " > %u", size, _obj->size);
          obj->num_eed = idx;
          dwg_free_eed (_obj);
          return DWG_ERR_INVALIDEED; /* may not continue */
        }

      obj->num_eed = idx + 1;
      if (idx) /* just extend by one. not in chunks for now */
        {
          obj->eed
              = (Dwg_Eed *)realloc (obj->eed, obj->num_eed * sizeof (Dwg_Eed));
          memset (&obj->eed[idx], 0, sizeof (Dwg_Eed));
        }
      else
        {
          obj->eed = (Dwg_Eed *)calloc (1, sizeof (Dwg_Eed));
        }
      obj->eed[idx].size = size;
      error |= bit_read_H (dat, &obj->eed[idx].handle);
      end = dat->byte + size;
      if (error)
        {
          LOG_ERROR ("No EED[%d].handle", idx);
          obj->eed[idx].size = 0;
          obj->num_eed--;
          dat->byte = end; // skip eed
          continue;        // continue for size = bit_read_BS(dat)
        }
      else
        {
          LOG_TRACE ("EED[%u] handle: " FORMAT_H "\n", idx,
                     ARGS_H (obj->eed[idx].handle));
          LOG_POS;
          if (dat->byte >= dat->size)
            end = dat->byte;
          if (_obj->supertype == DWG_SUPERTYPE_OBJECT && _obj->dxfname
              && strEQc (_obj->dxfname, "MLEADERSTYLE"))
            { // check for is_new_format: has extended data for APPID
              // “ACAD_MLEADERVER”
              Dwg_Object_Ref ref;
              ref.obj = NULL;
              ref.handleref = obj->eed[idx].handle;
              ref.absolute_ref = 0L;
              if (dwg_resolve_handleref (&ref, _obj))
                {
                  Dwg_Object_APPID_CONTROL *appid = &dwg->appid_control;
                  // search absref in APPID_CONTROL apps[]
                  for (j = 0; j < appid->num_entries; j++)
                    {
                      if (appid->entries[j]
                          && appid->entries[j]->absolute_ref
                                 == ref.absolute_ref)
                        {
                          Dwg_Object_MLEADERSTYLE *this
                              = obj->tio.MLEADERSTYLE;
                          this->is_new_format = 1;
                          LOG_TRACE (
                              "EED found ACAD_MLEADERVER %lX: new format\n",
                              ref.absolute_ref);
                        }
                    }
                }
            }
        }

      sav_byte = dat->byte;
      obj->eed[idx].raw = bit_read_TF (dat, size);
      if (DWG_LOGLEVEL < DWG_LOGLEVEL_INSANE)
        LOG_TRACE ("EED[0] raw: %d\n", size)
      else
        LOG_INSANE_TF (obj->eed[idx].raw, size);
      dat->byte = sav_byte;
      LOG_POS

      while (dat->byte < end)
        {
          obj->eed[idx].data = (Dwg_Eed_Data *)calloc (size + 8, 1);
          //LOG_TRACE ("EED[%u] ", idx);
          error |= dwg_decode_eed_data (dat, obj->eed[idx].data, end, size);
          // overflow or no advance
          if (dat->byte >= dat->size || dat->byte == sav_byte)
            error |= DWG_ERR_INVALIDEED;
          if (error & DWG_ERR_INVALIDEED)
            {
              free (obj->eed[idx].data);
              LOG_HANDLE ("        invalid eed[%d]: skip\n", idx);
              LOG_POS
              obj->eed[idx].data = NULL;
              obj->num_eed--;
              dat->byte = end; // skip eed
              continue;        // continue for next size = bit_read_BS(dat)
            }

          if (dat->byte < end - 1)
            {
              idx++;
              obj->num_eed = idx + 1;
              size = (long)(end - dat->byte + 1);
              LOG_HANDLE ("        size remaining: %ld\n", (long)size);
              LOG_POS

              obj->eed = (Dwg_Eed *)realloc (obj->eed,
                                             obj->num_eed * sizeof (Dwg_Eed));
              obj->eed[idx].handle = obj->eed[idx - 1].handle;
              obj->eed[idx].size = 0;
              obj->eed[idx].raw = NULL;
              sav_byte = dat->byte;
            }
          else
            {
              break;
            }
        }
      if (obj->eed[idx].raw)
        dat->byte = end;
      //LOG_POS
      idx++;
    }
  LOG_HANDLE ("EED[%u] size: " FORMAT_BS " [BS] (end)\n", idx, size);
  LOG_POS
  return error;
}
