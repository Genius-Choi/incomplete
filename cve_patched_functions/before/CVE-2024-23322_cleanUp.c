void UpstreamRequest::cleanUp() {
  if (cleaned_up_) {
    return;
  }
  cleaned_up_ = true;

  filter_manager_->destroyFilters();

  if (span_ != nullptr) {
    auto tracing_config = parent_.callbacks()->tracingConfig();
    ASSERT(tracing_config.has_value());
    Tracing::HttpTracerUtility::finalizeUpstreamSpan(*span_, stream_info_,
                                                     tracing_config.value().get());
  }

  if (per_try_timeout_ != nullptr) {
    // Allows for testing.
    per_try_timeout_->disableTimer();
  }

  if (per_try_idle_timeout_ != nullptr) {
    // Allows for testing.
    per_try_idle_timeout_->disableTimer();
  }

  if (max_stream_duration_timer_ != nullptr) {
    max_stream_duration_timer_->disableTimer();
  }

  if (upstream_log_flush_timer_ != nullptr) {
    upstream_log_flush_timer_->disableTimer();
  }

  clearRequestEncoder();

  // If desired, fire the per-try histogram when the UpstreamRequest
  // completes.
  if (record_timeout_budget_) {
    Event::Dispatcher& dispatcher = parent_.callbacks()->dispatcher();
    const MonotonicTime end_time = dispatcher.timeSource().monotonicTime();
    const std::chrono::milliseconds response_time =
        std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time_);
    Upstream::ClusterTimeoutBudgetStatsOptRef tb_stats = parent_.cluster()->timeoutBudgetStats();
    tb_stats->get().upstream_rq_timeout_budget_per_try_percent_used_.recordValue(
        FilterUtility::percentageOfTimeout(response_time, parent_.timeout().per_try_timeout_));
  }

  // Ditto for request/response size histograms.
  Upstream::ClusterRequestResponseSizeStatsOptRef req_resp_stats_opt =
      parent_.cluster()->requestResponseSizeStats();
  if (req_resp_stats_opt.has_value() && parent_.downstreamHeaders()) {
    auto& req_resp_stats = req_resp_stats_opt->get();
    req_resp_stats.upstream_rq_headers_size_.recordValue(parent_.downstreamHeaders()->byteSize());
    req_resp_stats.upstream_rq_body_size_.recordValue(stream_info_.bytesSent());

    if (response_headers_size_.has_value()) {
      req_resp_stats.upstream_rs_headers_size_.recordValue(response_headers_size_.value());
      req_resp_stats.upstream_rs_body_size_.recordValue(stream_info_.bytesReceived());
    }
  }

  stream_info_.onRequestComplete();
  upstreamLog(AccessLog::AccessLogType::UpstreamEnd);

  while (downstream_data_disabled_ != 0) {
    parent_.callbacks()->onDecoderFilterBelowWriteBufferLowWatermark();
    parent_.cluster()->trafficStats()->upstream_flow_control_drained_total_.inc();
    --downstream_data_disabled_;
  }
  // The upstream HTTP filter chain callbacks own headers/trailers while they are traversing the
  // filter chain. Make sure to not delete them immediately when the stream ends, as the stream
  // often ends during filter chain processing and it causes use-after-free violations.
  parent_.callbacks()->dispatcher().deferredDelete(std::move(filter_manager_callbacks_));
}
