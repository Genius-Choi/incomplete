void WifiPacket::handle_80211(const u_char * pkt, size_t len /* , int pad */)  
{
    if (debug) std::cerr << "handle_80211(len= " << len << " ";
    if (len < 2) {
	cbs->Handle80211( *this, 0, MAC::null, MAC::null, MAC::null, MAC::null, pkt, len);
	cbs->Handle80211Unknown( *this, -1, pkt, len);
	return;
    }

    u_int16_t fc  = EXTRACT_LE_16BITS(pkt);       //frame control
    size_t hdrlen = extract_header_length(fc);
    /*
      if (pad) {
      hdrlen = roundup2(hdrlen, 4);
      }
    */

    if (debug) std::cerr << "FC_TYPE(fc)= " << FC_TYPE(fc) << " ";

    if (len < IEEE802_11_FC_LEN || len < hdrlen) {
	cbs->Handle80211Unknown( *this, fc, pkt, len);
	return;
    }

    /* Always calculate the frame checksum, but only process the packets if the FCS or if we are ignoring it */
    if (len >= hdrlen + 4) {
        // assume fcs is last 4 bytes (?)
        u_int32_t fcs_sent = EXTRACT_32BITS(pkt+len-4);
        u_int32_t fcs = crc32_802(pkt, len-4);
        
        /*
          if (fcs != fcs_sent) {
          cerr << "bad fcs: ";
          fprintf (stderr, "%08x != %08x\n", fcs_sent, fcs); 
          }
        */
	
        fcs_ok = (fcs == fcs_sent);
    }
    if (cbs->Check80211FCS(*this) && fcs_ok==false){
        cbs->Handle80211Unknown(*this,fc,pkt,len);
        return;
    }


    // fill in current_frame: type, sn
    switch (FC_TYPE(fc)) {
    case T_MGMT:
	if(decode_mgmt_frame(pkt, len, fc, hdrlen)<0)
	    return;
	break;
    case T_DATA:
	if(decode_data_frame(pkt, len, fc)<0)
	    return;
	break;
    case T_CTRL:
	if(decode_ctrl_frame(pkt, len, fc)<0)
	    return;
	break;
    default:
	cbs->Handle80211( *this, fc, MAC::null, MAC::null, MAC::null, MAC::null, pkt, len);
	cbs->Handle80211Unknown( *this, fc, pkt, len);
	return;
    }
}
