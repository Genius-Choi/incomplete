static void read_exp_features_complete(uint8_t status, uint16_t length,
					const void *param, void *user_data)
{
	struct btd_adapter *adapter = user_data;
	const struct mgmt_rp_read_exp_features_info *rp = param;
	size_t feature_count = 0;
	size_t i = 0;

	DBG("index %u status 0x%02x", adapter->dev_id, status);

	if (status != MGMT_STATUS_SUCCESS) {
		btd_error(adapter->dev_id,
				"Failed to read exp features info: %s (0x%02x)",
				mgmt_errstr(status), status);
		return;
	}

	if (length < sizeof(*rp)) {
		btd_error(adapter->dev_id, "Response too small");
		return;
	}

	feature_count = le16_to_cpu(rp->feature_count);

	if (length < sizeof(*rp) + (sizeof(*rp->features) * feature_count)) {
		btd_error(adapter->dev_id, "Response too small");
		return;
	}

	for (i = 0; i < feature_count; ++i) {
		size_t j;

		for (j = 0; j < ARRAY_SIZE(exp_table); j++) {
			const struct exp_feat *feat = &exp_table[j];

			if (memcmp(rp->features[i].uuid, feat->uuid,
					sizeof(rp->features[i].uuid)))
				continue;

			if (feat->func)
				feat->func(adapter, rp->features[i].flags);
		}
	}
}
