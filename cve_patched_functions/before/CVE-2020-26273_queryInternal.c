Status queryInternal(const std::string& query,
                     QueryDataTyped& results,
                     const SQLiteDBInstanceRef& instance) {
  sqlite3_stmt* prepared_statement{nullptr}; /* Statement to execute. */

  int rc = SQLITE_OK; /* Return Code */
  const char* leftover_sql = nullptr; /* Tail of unprocessed SQL */
  const char* sql = query.c_str(); /* SQL to be processed */

  /* The big while loop.  One iteration per statement */
  while ((sql[0] != '\0') && (SQLITE_OK == rc)) {
    const auto lock = instance->attachLock();

    // Trim leading whitespace
    while (isspace(sql[0])) {
      sql++;
    }
    rc = sqlite3_prepare_v2(
        instance->db(), sql, -1, &prepared_statement, &leftover_sql);
    if (rc != SQLITE_OK) {
      Status s = Status::failure(sqlite3_errmsg(instance->db()));
      sqlite3_finalize(prepared_statement);
      return s;
    }

    Status s = readRows(prepared_statement, results, instance);
    if (!s.ok()) {
      return s;
    }

    sql = leftover_sql;
  } /* end while */
  sqlite3_db_release_memory(instance->db());
  return Status::success();
}
