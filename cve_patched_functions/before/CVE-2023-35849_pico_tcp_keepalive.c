static void pico_tcp_keepalive(pico_time now, void *arg)
{
    struct pico_socket_tcp *t = (struct pico_socket_tcp *)arg;
    if (((t->sock.state & PICO_SOCKET_STATE_TCP) == PICO_SOCKET_STATE_TCP_ESTABLISHED)  && (t->ka_time > 0)) {
        if (t->ka_time < (now - t->ack_timestamp)) {
            if (t->ka_retries_count == 0) {
                /* First probe */
                tcp_send_probe(t);
                t->ka_retries_count++;
            }

            if (t->ka_retries_count > t->ka_probes) {
                if (t->sock.wakeup)
                {
                    pico_err = PICO_ERR_ECONNRESET;
                    t->sock.wakeup(PICO_SOCK_EV_ERR, &t->sock);
                }
            }

            if (((t->ka_retries_count * (pico_time)t->ka_intvl) + t->ka_time) < (now - t->ack_timestamp)) {
                /* Next probe */
                tcp_send_probe(t);
                t->ka_retries_count++;
            }
        } else {
            t->ka_retries_count = 0;
        }
    }

    t->keepalive_tmr = pico_timer_add(t->sock.stack, 1000, pico_tcp_keepalive, t);
    if (!t->keepalive_tmr) {
        tcp_dbg("TCP: Failed to start keepalive timer\n");
        if (t->sock.wakeup)
            t->sock.wakeup(PICO_SOCK_EV_ERR, &t->sock);
    }
}
