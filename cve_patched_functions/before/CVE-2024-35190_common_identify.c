static struct ast_sip_endpoint *common_identify(ao2_callback_fn *identify_match_cb, void *arg)
{
	RAII_VAR(struct ao2_container *, candidates, NULL, ao2_cleanup);
	struct ip_identify_match *match;
	struct ast_sip_endpoint *endpoint;

	/* If no possibilities exist return early to save some time */
	candidates = ast_sorcery_retrieve_by_fields(ast_sip_get_sorcery(), "identify",
		AST_RETRIEVE_FLAG_MULTIPLE | AST_RETRIEVE_FLAG_ALL, NULL);
	if (!candidates || !ao2_container_count(candidates)) {
		ast_debug(3, "No identify sections to match against\n");
		return NULL;
	}

	match = ao2_callback(candidates, 0, identify_match_cb, arg);
	if (!match) {
		return NULL;
	}

	endpoint = ast_sorcery_retrieve_by_id(ast_sip_get_sorcery(), "endpoint",
		match->endpoint_name);
	if (endpoint) {
		ast_debug(3, "Identify '%s' SIP message matched to endpoint %s\n",
			ast_sorcery_object_get_id(match), match->endpoint_name);
	} else {
		ast_log(LOG_WARNING, "Identify '%s' points to endpoint '%s' but endpoint could not be found\n",
			ast_sorcery_object_get_id(match), match->endpoint_name);
	}

	ao2_ref(match, -1);
	return endpoint;
}
