static void audio_level_handler(void *arg)
{
	struct ecall *ecall = arg;
	struct list levell = LIST_INIT;
	int err = 0;
	
	tmr_start(&ecall->audio.level.tmr, TIMEOUT_AUDIO_LEVEL,
		  audio_level_handler, ecall);

	if (!ecall->icall.audio_levelh)
		return;

#if 0
	(void)err;
#else
	err = IFLOW_CALLE(ecall->flow, get_audio_level, &levell);
	if (err) {
		warning("ecall(%p): could not get audio levels: %m\n", ecall, err);
		return;
	}
#endif

	//info("levels from flow: %H\n", audio_level_list_debug, &levell);
	
	/* Compare previous levels to these levels, if order has changed,
	 * trigger callback
	 */
#if 1
	ICALL_CALL_CB(ecall->icall, audio_levelh,
		      &ecall->icall, &levell, ecall->icall.arg);
	list_flush(&levell);
#else
	ecall->audio.level.cycle++;

	if (audio_level_update(ecall, &levell)) {
		ICALL_CALL_CB(ecall->icall, audio_levelh,
			      &ecall->icall, &ecall->audio.level.l, ecall->icall.arg);
	}
	else if (ecall->audio.level.cycle > AUDIO_LEVEL_UPDATE_CYCLE) {
		if (ecall->audio.level.l.head)
			list_flush(&ecall->audio.level.l);
		ecall->audio.level.l = levell;

		ICALL_CALL_CB(ecall->icall, audio_levelh,
			      &ecall->icall, &ecall->audio.level.l, ecall->icall.arg);
		ecall->audio.level.cycle = 0;
	}
	else {
		list_flush(&levell);
	}
#endif
}
