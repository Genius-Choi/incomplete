static uint16_t _send_nth_fragment(gnrc_netif_t *netif,
                                   gnrc_sixlowpan_frag_fb_t *fbuf,
                                   unsigned page,
                                   gnrc_pktsnip_t **tx_sync)
{
    gnrc_pktsnip_t *frag, *pkt = fbuf->pkt;
    sixlowpan_sfr_rfrag_t *hdr;
    uint8_t *data;
    uint16_t frag_size = (uint16_t)netif->sixlo.max_frag_size -
                         sizeof(sixlowpan_sfr_rfrag_t);
    uint16_t local_offset;

    assert((fbuf->sfr.cur_seq > 0) &&
           (fbuf->sfr.cur_seq <= SIXLOWPAN_SFR_SEQ_MAX));
    assert((fbuf->sfr.frags_sent == 0) || (fbuf->sfr.window.next != NULL));
    assert(fbuf->tag <= UINT8_MAX);

    DEBUG("6lo sfr: determined frag_size = %u\n", frag_size);
    frag = _build_frag_from_fbuf(pkt, fbuf,
                                 _min(frag_size,
                                      fbuf->datagram_size - fbuf->offset));
    if (frag == NULL) {
        DEBUG("6lo sfr: error allocating subsequent fragment\n");
        return 0;
    }
    hdr = frag->next->data;
    data = (uint8_t *)(hdr + 1);
    sixlowpan_sfr_rfrag_set_offset(hdr, fbuf->offset);
    pkt = pkt->next;    /* don't copy netif header */
    local_offset = _find_offset_and_copy_rest(data, &pkt, frag_size,
                                              fbuf->offset);
    /* copy remaining packet snips */
    local_offset = _copy_pkt_to_frag(data, pkt, frag_size, local_offset);
    if (IS_USED(MODULE_GNRC_TX_SYNC) && *tx_sync && (local_offset >= fbuf->datagram_size)) {
        gnrc_pkt_append(frag, *tx_sync);
        *tx_sync = NULL;
    }
    DEBUG("6lo sfr: send subsequent fragment (tag: %u, X: %i, seq: %u, "
          "frag_size: %u, offset: %u)\n",
          hdr->base.tag, sixlowpan_sfr_rfrag_ack_req(hdr),
          sixlowpan_sfr_rfrag_get_seq(hdr),
          sixlowpan_sfr_rfrag_get_frag_size(hdr),
          sixlowpan_sfr_rfrag_get_offset(hdr));
    if (!_send_fragment(frag, fbuf, page, fbuf->offset)) {
        local_offset = 0;
    }
    return local_offset;
}
