static std::list<std::string> matchWildcard(Computer * comp, const std::list<std::string>& options, std::list<std::string>::iterator pathc, const std::list<std::string>::iterator end) {
    if (pathc == end) return {};
    std::string pathc_regex = *pathc;
    for (const std::string& r : regex_escape) pathc_regex = replace_str(pathc_regex, r, "\\" + r);
    pathc_regex = replace_str(pathc_regex, "*", ".*");
    std::list<std::string> nextOptions;
    for (const std::string& opt : options) {
        std::vector<path_t> possible_paths = fixpath_multiple(comp, opt.c_str());
        if (possible_paths.empty()) continue;
        for (const path_t& path : possible_paths) {
            if (std::regex_search((*path.begin()).native(), pathregex("^\\d+:"))) {
                try {
                    const FileEntry &d = comp->virtualMounts[(unsigned)std::stoul((*path.begin()).native())]->path(path.lexically_relative(*path.begin()));
                    if (d.isDir) for (auto p : d.dir) if (std::regex_match(p.first, std::regex(pathc_regex))) nextOptions.push_back(opt + (opt == "" ? "" : "/") + p.first);
                } catch (...) {continue;}
            } else {
                std::error_code e;
                if (fs::is_directory(path, e)) {
                    for (const auto& dir : fs::directory_iterator(path, e)) {
                        if (dir.path().filename() == ".DS_Store" || dir.path().filename() == "desktop.ini") continue;
                        if (std::regex_match(dir.path().filename().u8string(), std::regex(pathc_regex))) nextOptions.push_back(opt + (opt.empty() ? "" : "/") + dir.path().filename().u8string());
                    }
                }
            }
        }
        for (const std::string& value : getMounts(comp, opt.c_str())) 
            if (*pathc == "*" || value == *pathc) nextOptions.push_back(opt + (opt.empty() ? "" : "/") + value);
    }
    if (++pathc == end) return nextOptions;
    else return matchWildcard(comp, nextOptions, pathc, end);
}
