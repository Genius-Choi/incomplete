static void fio_cluster_on_data(intptr_t uuid, fio_protocol_s *pr_) {
  cluster_pr_s *c = (cluster_pr_s *)pr_;
  ssize_t i =
      fio_read(uuid, c->buffer + c->length, CLUSTER_READ_BUFFER - c->length);
  if (i <= 0)
    return;
  c->length += i;
  i = 0;
  do {
    if (!c->exp_channel && !c->exp_msg) {
      if (c->length - i < 16)
        break;
      c->exp_channel = fio_str2u32(c->buffer + i) + 1;
      c->exp_msg = fio_str2u32(c->buffer + i + 4) + 1;
      c->type = fio_str2u32(c->buffer + i + 8);
      c->filter = (int32_t)fio_str2u32(c->buffer + i + 12);
      if (c->exp_channel) {
        if (c->exp_channel >= (1024 * 1024 * 16) + 1) {
          FIO_LOG_FATAL("(%d) cluster message name too long (16Mb limit): %u\n",
                        (int)getpid(), (unsigned int)c->exp_channel);
          exit(1);
          return;
        }
      }
      if (c->exp_msg) {
        if (c->exp_msg >= (1024 * 1024 * 64) + 1) {
          FIO_LOG_FATAL("(%d) cluster message data too long (64Mb limit): %u\n",
                        (int)getpid(), (unsigned int)c->exp_msg);
          exit(1);
          return;
        }
      }
      c->msg = fio_msg_internal_create(
          c->filter, c->type,
          (fio_str_info_s){.data = (char *)(c->msg + 1),
                           .len = c->exp_channel - 1},
          (fio_str_info_s){.data = ((char *)(c->msg + 1) + c->exp_channel + 1),
                           .len = c->exp_msg - 1},
          (int8_t)(c->type == FIO_CLUSTER_MSG_JSON ||
                   c->type == FIO_CLUSTER_MSG_ROOT_JSON),
          0);
      i += 16;
    }
    if (c->exp_channel) {
      if (c->exp_channel + i > c->length) {
        memcpy(c->msg->channel.data +
                   ((c->msg->channel.len + 1) - c->exp_channel),
               (char *)c->buffer + i, (size_t)(c->length - i));
        c->exp_channel -= (c->length - i);
        i = c->length;
        break;
      } else {
        memcpy(c->msg->channel.data +
                   ((c->msg->channel.len + 1) - c->exp_channel),
               (char *)c->buffer + i, (size_t)(c->exp_channel));
        i += c->exp_channel;
        c->exp_channel = 0;
      }
    }
    if (c->exp_msg) {
      if (c->exp_msg + i > c->length) {
        memcpy(c->msg->data.data + ((c->msg->data.len + 1) - c->exp_msg),
               (char *)c->buffer + i, (size_t)(c->length - i));
        c->exp_msg -= (c->length - i);
        i = c->length;
        break;
      } else {
        memcpy(c->msg->data.data + ((c->msg->data.len + 1) - c->exp_msg),
               (char *)c->buffer + i, (size_t)(c->exp_msg));
        i += c->exp_msg;
        c->exp_msg = 0;
      }
    }
    fio_postoffice_meta_update(c->msg);
    c->handler(c);
    fio_msg_internal_free(c->msg);
    c->msg = NULL;
  } while (c->length > i);
  c->length -= i;
  if (c->length && i) {
    memmove(c->buffer, c->buffer + i, c->length);
  }
  (void)pr_;
}
