static int on_config_one_ech(h2o_configurator_command_t *cmd, yoml_t *map, struct ech_opener_config_t *config)
{
    yoml_t **key_file, **config_id, **public_name, **cipher_suites, **max_name_length, **advertise;

    *config = (struct ech_opener_config_t){.cipher_suites = ptls_openssl_hpke_cipher_suites, .max_name_length = 64, .advertise = 1};

    if (h2o_configurator_parse_mapping(cmd, map, "key-file:s,config-id:s,public-name:s",
                                       "cipher-suite:a,max-name-length:s,advertise:s", &key_file, &config_id, &public_name,
                                       &cipher_suites, &max_name_length, &advertise) != 0)
        return -1;

    { /* Load private key. TODO use neverbleed instead of retaining the ECH private key inside h2o. We may not need or want
       * asynchronous handling though, because X25519 is lightweight. */
        FILE *fp;
        if ((fp = fopen((*key_file)->data.scalar, "rt")) == NULL) {
            h2o_configurator_errprintf(cmd, *key_file, "failed to open ECH private key file:%s:%s", (*key_file)->data.scalar,
                                       strerror(errno));
            return -1;
        }
        EVP_PKEY *pkey;
        if ((pkey = PEM_read_PrivateKey(fp, NULL, NULL, NULL)) == NULL) {
            h2o_configurator_errprintf(cmd, *key_file, "failed to load ECH private key from file:%s", (*key_file)->data.scalar);
            return -1;
        }
        if (ptls_openssl_create_key_exchange(&config->keyex, pkey) != 0) {
            h2o_configurator_errprintf(cmd, *key_file, "failed to setup ECH private key from file:%s", (*key_file)->data.scalar);
            return -1;
        }
        EVP_PKEY_free(pkey);
        fclose(fp);
    }

    /* determine kem */
    for (size_t i = 0; ptls_openssl_hpke_kems[i] != NULL; ++i) {
        if (ptls_openssl_hpke_kems[i]->keyex == config->keyex->algo) {
            config->kem = ptls_openssl_hpke_kems[i];
            break;
        }
    }
    if (config->kem == NULL) {
        h2o_configurator_errprintf(cmd, *key_file, "private key of type %s is not supported for ECH", config->keyex->algo->name);
        return -1;
    }

    /* replace ciphers to the provided list, if specified */
    if (cipher_suites != NULL) {
        config->cipher_suites = h2o_mem_alloc(sizeof(config->cipher_suites[0]) * ((*cipher_suites)->data.sequence.size + 1));
        for (size_t input_index = 0; input_index < (*cipher_suites)->data.sequence.size; ++input_index) {
            yoml_t *input = (*cipher_suites)->data.sequence.elements[input_index];
            if (input->type != YOML_TYPE_SCALAR) {
                h2o_configurator_errprintf(cmd, input, "elements of cipher-suites must be a string");
                return -1;
            }
            ptls_hpke_cipher_suite_t **cand;
            for (cand = ptls_openssl_hpke_cipher_suites; *cand != NULL; ++cand)
                if (strcasecmp(input->data.scalar, (*cand)->name) == 0)
                    break;
            if (*cand == NULL) {
                h2o_configurator_errprintf(cmd, input,
                                           "ECH cipher-suite not found; should be in specified in the form of <kdf>/<aead> using "
                                           "the names defined in IANA HPKE registry");
                return -1;
            }
            config->cipher_suites[input_index] = *cand;
        }
        config->cipher_suites[(*cipher_suites)->data.sequence.size] = NULL;
    }

    /* rest of the parameters */
    if (h2o_configurator_scanf(cmd, *config_id, "%" SCNu8, &config->config_id) != 0) {
        h2o_configurator_errprintf(cmd, *config_id, "config_id must be uint8");
        return -1;
    }
    if (max_name_length != NULL &&
        (h2o_configurator_scanf(cmd, *max_name_length, "%" SCNu8, &config->max_name_length) != 0 || config->max_name_length < 64)) {
        h2o_configurator_errprintf(cmd, *max_name_length, "max-name-length must be a number between 64 and 255");
        return -1;
    }
    if (advertise != NULL) {
        ssize_t v;
        if ((v = h2o_configurator_get_one_of(cmd, *advertise, "NO,YES")) == -1) {
            h2o_configurator_errprintf(cmd, *advertise, "advertise must be either YES or NO (default: YES)");
            return -1;
        }
        config->advertise = !!v;
    }

    { /* build ECHConfig */
        ptls_buffer_t buf;
        ptls_buffer_init(&buf, "", 0);
        int ret = ptls_ech_encode_config(&buf, config->config_id, config->kem, config->keyex->pubkey, config->cipher_suites,
                                         config->max_name_length, (*public_name)->data.scalar);
        if (ret != 0)
            h2o_fatal("failed to build ECHConfig:%d", ret);
        config->ech_config = ptls_iovec_init(buf.base, buf.off); /* steal ownership of malloc'ed memory */
    }

    return 0;
}
