void CLASS lossless_dng_load_raw()
{
  unsigned save, trow=0, tcol=0, jwide, jrow, jcol, row, col;
  struct jhead jh;
  ushort *rp;

  while (trow < raw_height) {
    save = ftell(ifp);
    if (tile_length < INT_MAX)
      fseek (ifp, get4(), SEEK_SET);
    if (!ljpeg_start (&jh, 0)) break;
    jwide = jh.wide;
    if (filters) jwide *= jh.clrs;
    jwide /= is_raw;
#ifdef LIBRAW_LIBRARY_BUILD
    if(!data_size)
        throw LIBRAW_EXCEPTION_IO_BADFILE;
    LibRaw_byte_buffer *buf = ifp->make_byte_buffer(data_size);
    LibRaw_bit_buffer bits;
#endif

#ifndef LIBRAW_LIBRARY_BUILD
    for (row=col=jrow=0; jrow < jh.high; jrow++) {
      rp = ljpeg_row (jrow, &jh);
      for (jcol=0; jcol < jwide; jcol++) {
	adobe_copy_pixel (trow+row, tcol+col, &rp);
	if (++col >= tile_width || col >= raw_width)
	  row += 1 + (col = 0);
      }
    }
#else
    if(raw_image)
      {
        for (row=col=jrow=0; jrow < jh.high; jrow++) {
#ifdef LIBRAW_LIBRARY_BUILD
          rp = ljpeg_row_new (jrow, &jh,bits,buf);
#else
          rp = ljpeg_row (jrow, &jh);
#endif
          for (jcol=0; jcol < jwide; jcol++) {
            adobe_copy_pixel_raw (trow+row, tcol+col, &rp);
            if (++col >= tile_width || col >= raw_width)
              row += 1 + (col = 0);
          }
        }
      }
    else
      {
        for (row=col=jrow=0; jrow < jh.high; jrow++) {
#ifdef LIBRAW_LIBRARY_BUILD
          rp = ljpeg_row_new (jrow, &jh,bits,buf);
#else
          rp = ljpeg_row (jrow, &jh);
#endif
          for (jcol=0; jcol < jwide; jcol++) {
            adobe_copy_pixel_color (trow+row, tcol+col, &rp);
            if (++col >= tile_width || col >= raw_width)
              row += 1 + (col = 0);
          }
        }
      }
#endif
    fseek (ifp, save+4, SEEK_SET);
    if ((tcol += tile_width) >= raw_width)
      trow += tile_length + (tcol = 0);
    ljpeg_end (&jh);
#ifdef LIBRAW_LIBRARY_BUILD
    delete buf;
#endif
  }
}
