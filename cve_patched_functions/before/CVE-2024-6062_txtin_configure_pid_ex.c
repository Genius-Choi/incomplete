static GF_Err txtin_configure_pid_ex(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove, u32 force_fmt)
{
	GF_Err e;
	u32 codec_id=0;
	const char *src = NULL;
	GF_TXTIn *ctx = gf_filter_get_udta(filter);
	const GF_PropertyValue *prop;

	if (is_remove) {
		ctx->ipid = NULL;
		return GF_OK;
	}

	if (force_fmt) {
		ctx->fmt = force_fmt;
		if (!ctx->opid)
			ctx->opid = gf_filter_pid_new(filter);
		if (!ctx->timescale) ctx->timescale = 1000;
		goto force_format;
	}

	ctx->pid_framed = GF_FALSE;
	ctx->single_text_chunk = GF_FALSE;

	if (! gf_filter_pid_check_caps(pid))
		return GF_NOT_SUPPORTED;

	prop = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);
	if (ctx->srt_to_tx3g) {
		ctx->pid_framed = GF_TRUE;
		prop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);
		ctx->timescale = prop ? prop->value.uint : 1000;
	}
	else if (ctx->vtt_to_tx3g) {
		ctx->pid_framed = GF_TRUE;
		prop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);
		ctx->timescale = prop ? prop->value.uint : 1000;
	}
	else if (prop && (
		(prop->value.uint==GF_CODECID_WEBVTT)
		|| (prop->value.uint==GF_CODECID_SUBS_SSA)
	)) {
		codec_id = prop->value.uint;
		ctx->pid_framed = GF_TRUE;
		prop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);
		ctx->timescale = prop ? prop->value.uint : 1000;
	} else if (prop && (
		(prop->value.uint==GF_CODECID_SIMPLE_TEXT)
		|| (prop->value.uint==GF_CODECID_SUBS_TEXT)
	)) {
		codec_id = prop->value.uint;
		ctx->pid_framed = GF_TRUE;
		prop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);
		ctx->timescale = prop ? prop->value.uint : 1000;
		//no timescale, this is a single chunk of text to transform into stxt/vtt/tx3g
		if (!prop) {
			ctx->single_text_chunk = GF_TRUE;
		}
		gf_filter_pid_set_framing_mode(pid, GF_TRUE);
	} else {
		//otherwise check we have a file path
		prop = gf_filter_pid_get_property(pid, GF_PROP_PID_FILEPATH);
		if (prop && prop->value.string) src = prop->value.string;

		//check if mime is a vtt, if so default to vtt output - for other inputs, we'll use tx3g as usual
		prop = gf_filter_pid_get_property(pid, GF_PROP_PID_MIME);
		if (prop) {
			if (strstr(prop->value.string, "/vtt")) {
				codec_id = GF_CODECID_WEBVTT;
			}
		}
	}

	if (!ctx->ipid) {
		GF_FilterEvent fevt;
		ctx->ipid = pid;

		if (src) {
			//we work with full file only, send a play event on source to indicate that
			GF_FEVT_INIT(fevt, GF_FEVT_PLAY, pid);
			fevt.play.start_range = 0;
			fevt.base.on_pid = ctx->ipid;
			fevt.play.full_file_only = src ? GF_TRUE : GF_FALSE;
			gf_filter_pid_send_event(ctx->ipid, &fevt);
			if (ctx->file_name) gf_free(ctx->file_name);
			ctx->file_name = src ? gf_strdup(src) : NULL;

			if (!src) gf_filter_pid_set_framing_mode(ctx->ipid, GF_TRUE);
		} else {
			//loading from input pid without any file object, disable duration probing
			ctx->index = 0;
		}
	} else {
		if (pid != ctx->ipid) {
			return GF_REQUIRES_NEW_INSTANCE;
		}
		if (src) {
			if (ctx->file_name && !strcmp(ctx->file_name, src)) return GF_OK;

			ttxtin_reset(ctx);
			ctx->is_setup = GF_FALSE;
			if (ctx->file_name) gf_free(ctx->file_name);
			ctx->file_name = gf_strdup(src);
		}
		ctx->is_loaded = GF_FALSE;
	}
	if (src) {
		//guess type
		e = gf_text_guess_format(ctx, ctx->file_name, &ctx->fmt);
		if (e) return e;
		if (!ctx->fmt) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTLoad] Unknown text format for %s\n", ctx->file_name));
			return GF_NOT_SUPPORTED;
		}
	} else {
		if (ctx->vtt_to_tx3g)
			ctx->fmt = GF_TXTIN_MODE_SRT;
		else if (ctx->srt_to_tx3g)
			ctx->fmt = GF_TXTIN_MODE_SRT;
		else if (codec_id == GF_CODECID_WEBVTT)
			ctx->fmt = GF_TXTIN_MODE_WEBVTT;
		else if (codec_id == GF_CODECID_SUBS_SSA)
			ctx->fmt = GF_TXTIN_MODE_SSA;
		else if (ctx->single_text_chunk)
			ctx->fmt = GF_TXTIN_MODE_SIMPLE;
		//if we receive simple text streams in framed mode (one packet==one sub), decide how to translate it
		else if (ctx->pid_framed && ((codec_id==GF_CODECID_SIMPLE_TEXT) || (codec_id==GF_CODECID_SUBS_TEXT))) {
			if (ctx->stxtmod == STXT_MODE_VTT) {
				ctx->fmt = GF_TXTIN_MODE_WEBVTT;
			} else if (ctx->stxtmod==STXT_MODE_TX3G) {
				ctx->fmt = GF_TXTIN_MODE_SRT;
			} else {
				ctx->fmt = GF_TXTIN_MODE_SIMPLE;
			}
		} else {
			//we don't know the format - we could probe from mime but let's wait for first packet
			ctx->fmt = GF_TXTIN_MODE_PROBE;
			return GF_OK;
		}

		if (!ctx->opid)
			ctx->opid = gf_filter_pid_new(filter);
		if (!ctx->timescale) ctx->timescale = 1000;
	}

force_format:

	if (ctx->fmt == GF_TXTIN_MODE_SRT) {
		if (ctx->stxtmod==STXT_MODE_VTT) ctx->fmt = GF_TXTIN_MODE_WEBVTT;
	}

	if (!src) {
		gf_filter_pid_copy_properties(ctx->opid, pid);
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );

		if (!ctx->single_text_chunk) {
			if (ctx->fmt == GF_TXTIN_MODE_WEBVTT) codec_id = GF_CODECID_WEBVTT;
			else if (ctx->fmt == GF_TXTIN_MODE_TTML) codec_id = GF_CODECID_SUBS_XML;
			//no change in codec id (either simple_text or text_sub)
			else if (ctx->fmt == GF_TXTIN_MODE_SIMPLE) {}
			else codec_id = GF_CODECID_TX3G;
		}
		//simple text as vtt
		else if (ctx->stxtmod==STXT_MODE_VTT)
			codec_id = GF_CODECID_WEBVTT;
		//simple text as tx3g
		else if (ctx->stxtmod==STXT_MODE_TX3G)
			codec_id = GF_CODECID_TX3G;
		//otherwise keep codec id from source

		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(codec_id) );
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, NULL);
	}

	Bool gen_ttxt_dsi = GF_FALSE;
	Bool gen_webvtt_dsi = GF_FALSE;
	ctx->full_file_only = GF_FALSE;
	switch (ctx->fmt) {
	case GF_TXTIN_MODE_SRT:
		ctx->text_process = txtin_process_srt;
		if (!ctx->is_setup && ctx->pid_framed) gen_ttxt_dsi = GF_TRUE;
		break;
#ifndef GPAC_DISABLE_VTT
	case GF_TXTIN_MODE_WEBVTT:
		ctx->text_process = txtin_process_webvtt;
		if (!ctx->is_setup && ctx->pid_framed) gen_webvtt_dsi = GF_TRUE;
		break;
#endif
	case GF_TXTIN_MODE_TTXT:
		ctx->text_process = txtin_process_ttxt;
		ctx->full_file_only = GF_TRUE;
		break;
	case GF_TXTIN_MODE_TEXML:
		ctx->text_process = txtin_process_texml;
		ctx->full_file_only = GF_TRUE;
		break;
	case GF_TXTIN_MODE_SUB:
		ctx->text_process = gf_text_process_sub;
		if (!ctx->is_setup && ctx->pid_framed) gen_ttxt_dsi = GF_TRUE;
		break;
	case GF_TXTIN_MODE_TTML:
		ctx->text_process = gf_text_process_ttml;
		ctx->full_file_only = GF_TRUE;
		break;
	case GF_TXTIN_MODE_SSA:
		ctx->text_process = gf_text_process_ssa;
		if (!ctx->is_setup && ctx->pid_framed) gen_ttxt_dsi = GF_TRUE;
		break;
#ifndef GPAC_DISABLE_SWF_IMPORT
	case GF_TXTIN_MODE_SWF_SVG:
		ctx->text_process = gf_text_process_swf;
		ctx->full_file_only = GF_TRUE;
		break;
#endif
	case GF_TXTIN_MODE_SIMPLE:
		ctx->text_process = txtin_process_simple;
		if (ctx->stxtmod==STXT_MODE_TX3G) gen_ttxt_dsi = 1;
		else if (ctx->stxtmod==STXT_MODE_VTT) gen_webvtt_dsi = 1;
		break;
	case GF_TXTIN_MODE_PROBE:
		break;
	default:
		return GF_BAD_PARAM;
	}

	if (gen_ttxt_dsi) {
		txtin_setup_srt(filter, ctx, GF_TRUE);
	}
	if (gen_webvtt_dsi) {
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA((u8 *) "WEBVTT", 7 ) );
	}

	//when translating from unframed srt/vtt to framed tx3g/vtt, the number of input samples will be at most doubled by inserting blank samples
	if (ctx->pid_framed && !ctx->no_empty) {
		const GF_PropertyValue *p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_NB_FRAMES);
		if (p)
			gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NB_FRAMES, &PROP_UINT(p->value.uint*2));
	}

	return GF_OK;
}
