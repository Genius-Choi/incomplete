int ds_pvar_algo(struct sip_msg *msg, ds_set_p set, ds_dest_p **sorted_set,
															int ds_use_default)
{
	pv_value_t val;
	int i, j, k, end_idx, cnt;
	ds_dest_p *sset;
	ds_pvar_param_p param;

	if (!set) {
		LM_ERR("invalid set\n");
		return -1;
	}
	sset = shm_realloc(*sorted_set, set->nr * sizeof(ds_dest_p));
	if (!sset) {
		LM_ERR("no more shm memory\n");
		return -1;
	}
	*sorted_set = sset;

	end_idx = set->nr - 1;
	if (ds_use_default) {
		sset[end_idx] = &set->dlist[end_idx];
		end_idx--;
	}

	for (i = 0, cnt = 0; i < set->nr - (ds_use_default?1:0); i++) {
		if ( !dst_is_active(set->dlist[i]) ) {
			/* move to the end of the list */
			sset[end_idx--] = &set->dlist[i];
			continue;
		}

		/* if pvar not set - try to evaluate it */
		if (set->dlist[i].param == NULL) {
			param = ds_get_pvar_param(set->id, set->dlist[i].uri);
			if (param == NULL) {
				LM_ERR("cannot parse pvar for uri %.*s\n",
					   set->dlist[i].uri.len, set->dlist[i].uri.s);
				continue;
			}
			set->dlist[i].param = (void *)param;
		} else {
			param = (ds_pvar_param_p)set->dlist[i].param;
		}
		if (pv_get_spec_value(msg, &param->pvar, &val) < 0) {
			LM_ERR("cannot get spec value for spec %.*s\n",
				   set->dlist[i].uri.len, set->dlist[i].uri.s);
			continue;
		}
		if (!(val.flags & PV_VAL_NULL)) {
			if (!(val.flags & PV_VAL_INT)) {
				/* last attempt to retrieve value */
				if (!str2sint(&val.rs, &param->value)) {
					LM_ERR("invalid pvar value type - not int\n");
					continue;
				}
			} else {
				param->value = val.ri;
			}
		} else {
			param->value = 0;
		}
		/* search the proper position */
		j = 0;
		for (; j < cnt && ((ds_pvar_param_p)sset[j]->param)->value <= param->value; j++);
		/* make space for the new entry */
		for (k = cnt; k > j; k--)
			sset[k] = sset[k - 1];
		sset[j] = &set->dlist[i];
		cnt++;
	}

	return cnt;
}
