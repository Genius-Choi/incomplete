static CURLcode sectransp_set_selected_ciphers(struct Curl_easy *data,
                                               SSLContextRef ssl_ctx,
                                               const char *ciphers)
{
  size_t ciphers_count = 0;
  const char *cipher_start = ciphers;
  OSStatus err = noErr;
  SSLCipherSuite selected_ciphers[NUM_OF_CIPHERS];

  if(!ciphers)
    return CURLE_OK;

  while(is_separator(*ciphers))     /* Skip initial separators. */
    ciphers++;
  if(!*ciphers)
    return CURLE_OK;

  cipher_start = ciphers;
  while(*cipher_start && ciphers_count < NUM_OF_CIPHERS) {
    bool cipher_found = FALSE;
    size_t cipher_len = 0;
    const char *cipher_end = NULL;
    bool tls_name = FALSE;

    /* Skip separators */
    while(is_separator(*cipher_start))
       cipher_start++;
    if(*cipher_start == '\0') {
      break;
    }
    /* Find last position of a cipher in the ciphers string */
    cipher_end = cipher_start;
    while (*cipher_end != '\0' && !is_separator(*cipher_end)) {
      ++cipher_end;
    }

    /* IANA cipher names start with the TLS_ or SSL_ prefix.
       If the 4th symbol of the cipher is '_' we look for a cipher in the
       table by its (TLS) name.
       Otherwise, we try to match cipher by an alias. */
    if(cipher_start[3] == '_') {
      tls_name = TRUE;
    }
    /* Iterate through the cipher table and look for the cipher, starting
       the cipher number 0x01 because the 0x00 is not the real cipher */
    cipher_len = cipher_end - cipher_start;
    for(size_t i = 1; i < NUM_OF_CIPHERS; ++i) {
      const char *table_cipher_name = NULL;
      if(tls_name) {
        table_cipher_name = ciphertable[i].name;
      }
      else if(ciphertable[i].alias_name != NULL) {
        table_cipher_name = ciphertable[i].alias_name;
      }
      else {
        continue;
      }
      /* Compare a part of the string between separators with a cipher name
         in the table and make sure we matched the whole cipher name */
      if(strncmp(cipher_start, table_cipher_name, cipher_len) == 0
          && table_cipher_name[cipher_len] == '\0') {
        selected_ciphers[ciphers_count] = ciphertable[i].num;
        ++ciphers_count;
        cipher_found = TRUE;
        break;
      }
    }
    if(!cipher_found) {
      /* It would be more human-readable if we print the wrong cipher name
         but we don't want to allocate any additional memory and copy the name
         into it, then add it into logs.
         Also, we do not modify an original cipher list string. We just point
         to positions where cipher starts and ends in the cipher list string.
         The message is a bit cryptic and longer than necessary but can be
         understood by humans. */
      failf(data, "SSL: cipher string \"%s\" contains unsupported cipher name"
            " starting position %d and ending position %d",
            ciphers,
            cipher_start - ciphers,
            cipher_end - ciphers);
      return CURLE_SSL_CIPHER;
    }
    if(*cipher_end) {
      cipher_start = cipher_end + 1;
    }
    else {
      break;
    }
  }
  /* All cipher suites in the list are found. Report to logs as-is */
  infof(data, "SSL: Setting cipher suites list \"%s\"\n", ciphers);

  err = SSLSetEnabledCiphers(ssl_ctx, selected_ciphers, ciphers_count);
  if(err != noErr) {
    failf(data, "SSL: SSLSetEnabledCiphers() failed: OSStatus %d", err);
    return CURLE_SSL_CIPHER;
  }
  return CURLE_OK;
}
