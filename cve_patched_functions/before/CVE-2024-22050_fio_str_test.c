FIO_FUNC inline void fio_str_test(void) {
#define ROUND_UP_CAPA_2WORDS(num)                                              \
  (((num + 1) & (sizeof(long double) - 1))                                     \
       ? ((num + 1) | (sizeof(long double) - 1))                               \
       : (num))
  fprintf(stderr, "=== Testing Core String features (fio_str_s functions)\n");
  fprintf(stderr, "* String container size: %zu\n", sizeof(fio_str_s));
  fprintf(stderr,
          "* Self-Contained String Capacity (FIO_STR_SMALL_CAPA): %zu\n",
          FIO_STR_SMALL_CAPA);
  fio_str_s str = {.small = 0}; /* test zeroed out memory */
  FIO_ASSERT(fio_str_capa(&str) == FIO_STR_SMALL_CAPA - 1,
             "Small String capacity reporting error!");
  FIO_ASSERT(fio_str_len(&str) == 0, "Small String length reporting error!");
  FIO_ASSERT(fio_str_data(&str) ==
                 (char *)((uintptr_t)(&str + 1) - FIO_STR_SMALL_CAPA),
             "Small String pointer reporting error (%zd offset)!",
             (ssize_t)(((char *)((uintptr_t)(&str + 1) - FIO_STR_SMALL_CAPA)) -
                       fio_str_data(&str)));
  fio_str_write(&str, "World", 4);
  FIO_ASSERT(str.small,
             "Small String writing error - not small on small write!");
  FIO_ASSERT(fio_str_capa(&str) == FIO_STR_SMALL_CAPA - 1,
             "Small String capacity reporting error after write!");
  FIO_ASSERT(fio_str_len(&str) == 4,
             "Small String length reporting error after write!");
  FIO_ASSERT(fio_str_data(&str) ==
                 (char *)((uintptr_t)(&str + 1) - FIO_STR_SMALL_CAPA),
             "Small String pointer reporting error after write!");
  FIO_ASSERT(strlen(fio_str_data(&str)) == 4,
             "Small String NUL missing after write (%zu)!",
             strlen(fio_str_data(&str)));
  FIO_ASSERT(!strcmp(fio_str_data(&str), "Worl"),
             "Small String write error (%s)!", fio_str_data(&str));
  FIO_ASSERT(fio_str_data(&str) == fio_str_info(&str).data,
             "Small String `fio_str_data` != `fio_str_info(s).data` (%p != %p)",
             (void *)fio_str_data(&str), (void *)fio_str_info(&str).data);

  fio_str_capa_assert(&str, sizeof(fio_str_s) - 1);
  FIO_ASSERT(!str.small,
             "Long String reporting as small after capacity update!");
  FIO_ASSERT(fio_str_capa(&str) >= sizeof(fio_str_s) - 1,
             "Long String capacity update error (%zu != %zu)!",
             fio_str_capa(&str), sizeof(fio_str_s));
  FIO_ASSERT(fio_str_data(&str) == fio_str_info(&str).data,
             "Long String `fio_str_data` !>= `fio_str_info(s).data` (%p != %p)",
             (void *)fio_str_data(&str), (void *)fio_str_info(&str).data);

  FIO_ASSERT(
      fio_str_len(&str) == 4,
      "Long String length changed during conversion from small string (%zu)!",
      fio_str_len(&str));
  FIO_ASSERT(fio_str_data(&str) == str.data,
             "Long String pointer reporting error after capacity update!");
  FIO_ASSERT(strlen(fio_str_data(&str)) == 4,
             "Long String NUL missing after capacity update (%zu)!",
             strlen(fio_str_data(&str)));
  FIO_ASSERT(!strcmp(fio_str_data(&str), "Worl"),
             "Long String value changed after capacity update (%s)!",
             fio_str_data(&str));

  fio_str_write(&str, "d!", 2);
  FIO_ASSERT(!strcmp(fio_str_data(&str), "World!"),
             "Long String `write` error (%s)!", fio_str_data(&str));

  fio_str_replace(&str, 0, 0, "Hello ", 6);
  FIO_ASSERT(!strcmp(fio_str_data(&str), "Hello World!"),
             "Long String `insert` error (%s)!", fio_str_data(&str));

  fio_str_resize(&str, 6);
  FIO_ASSERT(!strcmp(fio_str_data(&str), "Hello "),
             "Long String `resize` clipping error (%s)!", fio_str_data(&str));

  fio_str_replace(&str, 6, 0, "My World!", 9);
  FIO_ASSERT(!strcmp(fio_str_data(&str), "Hello My World!"),
             "Long String `replace` error when testing overflow (%s)!",
             fio_str_data(&str));

  str.capa = str.len;
  fio_str_replace(&str, -10, 2, "Big", 3);
  FIO_ASSERT(!strcmp(fio_str_data(&str), "Hello Big World!"),
             "Long String `replace` error when testing splicing (%s)!",
             fio_str_data(&str));

  FIO_ASSERT(
      fio_str_capa(&str) == ROUND_UP_CAPA_2WORDS(strlen("Hello Big World!")),
      "Long String `fio_str_replace` capacity update error (%zu != %zu)!",
      fio_str_capa(&str), ROUND_UP_CAPA_2WORDS(strlen("Hello Big World!")));

  if (str.len < FIO_STR_SMALL_CAPA) {
    fio_str_compact(&str);
    FIO_ASSERT(str.small, "Compacting didn't change String to small!");
    FIO_ASSERT(fio_str_len(&str) == strlen("Hello Big World!"),
               "Compacting altered String length! (%zu != %zu)!",
               fio_str_len(&str), strlen("Hello Big World!"));
    FIO_ASSERT(!strcmp(fio_str_data(&str), "Hello Big World!"),
               "Compact data error (%s)!", fio_str_data(&str));
    FIO_ASSERT(fio_str_capa(&str) == FIO_STR_SMALL_CAPA - 1,
               "Compacted String capacity reporting error!");
  } else {
    fprintf(stderr, "* skipped `compact` test!\n");
  }

  {
    fio_str_freeze(&str);
    fio_str_info_s old_state = fio_str_info(&str);
    fio_str_write(&str, "more data to be written here", 28);
    fio_str_replace(&str, 2, 1, "more data to be written here", 28);
    fio_str_info_s new_state = fio_str_info(&str);
    FIO_ASSERT(old_state.len == new_state.len, "Frozen String length changed!");
    FIO_ASSERT(old_state.data == new_state.data,
               "Frozen String pointer changed!");
    FIO_ASSERT(
        old_state.capa == new_state.capa,
        "Frozen String capacity changed (allowed, but shouldn't happen)!");
    str.frozen = 0;
  }
  fio_str_printf(&str, " %u", 42);
  FIO_ASSERT(!strcmp(fio_str_data(&str), "Hello Big World! 42"),
             "`fio_str_printf` data error (%s)!", fio_str_data(&str));

  {
    fio_str_s str2 = FIO_STR_INIT;
    fio_str_concat(&str2, &str);
    FIO_ASSERT(fio_str_iseq(&str, &str2),
               "`fio_str_concat` error, strings not equal (%s != %s)!",
               fio_str_data(&str), fio_str_data(&str2));
    fio_str_write(&str2, ":extra data", 11);
    FIO_ASSERT(
        !fio_str_iseq(&str, &str2),
        "`fio_str_write` error after copy, strings equal ((%zu)%s == (%zu)%s)!",
        fio_str_len(&str), fio_str_data(&str), fio_str_len(&str2),
        fio_str_data(&str2));

    fio_str_free(&str2);
  }

  fio_str_free(&str);

  fio_str_write_i(&str, -42);
  FIO_ASSERT(fio_str_len(&str) == 3 && !memcmp("-42", fio_str_data(&str), 3),
             "fio_str_write_i output error ((%zu) %s != -42)",
             fio_str_len(&str), fio_str_data(&str));
  fio_str_free(&str);

  {
    fprintf(stderr, "* testing `fio_str_readfile`, and reference counting.\n");
    fio_str_s *s = fio_str_new2();
    FIO_ASSERT(s && s->small,
               "`fio_str_new2` error, string not initialized (%p)!", (void *)s);
    fio_str_s *s2 = fio_str_dup(s);

    ++fio_str_test_dealloc_counter;

    FIO_ASSERT(s2 == s, "`fio_str_dup` error, should return self!");
    FIO_ASSERT(s->ref == 1,
               "`fio_str_dup` error, reference counter not incremented!");

    fprintf(stderr, "* reading a file.\n");
    fio_str_info_s state = fio_str_readfile(s, __FILE__, 0, 0);
    if (!s->small) /* attach deallocation test */
      s->dealloc = fio_str_test_dealloc;

    FIO_ASSERT(state.data,
               "`fio_str_readfile` error, no data was read for file %s!",
               __FILE__);

    FIO_ASSERT(!memcmp(state.data,
                       "/* "
                       "******************************************************"
                       "***********************",
                       80),
               "`fio_str_readfile` content error, header mismatch!\n %s",
               state.data);
    fprintf(stderr, "* testing UTF-8 validation and length.\n");
    FIO_ASSERT(
        fio_str_utf8_valid(s),
        "`fio_str_utf8_valid` error, code in this file should be valid!");
    FIO_ASSERT(fio_str_utf8_len(s) && (fio_str_utf8_len(s) <= fio_str_len(s)) &&
                   (fio_str_utf8_len(s) >= (fio_str_len(s)) >> 1),
               "`fio_str_utf8_len` error, invalid value (%zu / %zu!",
               fio_str_utf8_len(s), fio_str_len(s));

    fprintf(stderr, "* reviewing reference counting `fio_str_free2` (1/2).\n");
    fio_str_free2(s2);
    --fio_str_test_dealloc_counter;
    FIO_ASSERT(s->ref == 0,
               "`fio_str_free2` error, reference counter not subtracted!");
    FIO_ASSERT(s->small == 0, "`fio_str_free2` error, strring reinitialized!");
    FIO_ASSERT(
        fio_str_data(s) == state.data,
        "`fio_str_free2` error, data freed while references exist! (%p != %p)",
        (void *)fio_str_data(s), (void *)state.data);

    if (1) {
      /* String content == whole file (this file) */
      intptr_t pos = -11;
      size_t len = 20;
      fprintf(stderr, "* testing UTF-8 positioning.\n");

      FIO_ASSERT(
          fio_str_utf8_select(s, &pos, &len) == 0,
          "`fio_str_utf8_select` returned error for negative pos! (%zd, %zu)",
          (ssize_t)pos, len);
      FIO_ASSERT(
          pos == (intptr_t)state.len - 10, /* no UTF-8 bytes in this file */
          "`fio_str_utf8_select` error, negative position invalid! (%zd)",
          (ssize_t)pos);
      FIO_ASSERT(len == 10,
                 "`fio_str_utf8_select` error, trancated length invalid! (%zd)",
                 (ssize_t)len);
      pos = 10;
      len = 20;
      FIO_ASSERT(fio_str_utf8_select(s, &pos, &len) == 0,
                 "`fio_str_utf8_select` returned error! (%zd, %zu)",
                 (ssize_t)pos, len);
      FIO_ASSERT(pos == 10,
                 "`fio_str_utf8_select` error, position invalid! (%zd)",
                 (ssize_t)pos);
      FIO_ASSERT(len == 20,
                 "`fio_str_utf8_select` error, length invalid! (%zd)",
                 (ssize_t)len);
    }
    fprintf(stderr, "* reviewing reference counting `fio_str_free2` (2/2).\n");
    fio_str_free2(s);
    fprintf(stderr, "* finished reference counting test.\n");
  }
  fio_str_free(&str);
  if (1) {

    const char *utf8_sample = /* three hearts, small-big-small*/
        "\xf0\x9f\x92\x95\xe2\x9d\xa4\xef\xb8\x8f\xf0\x9f\x92\x95";
    fio_str_write(&str, utf8_sample, strlen(utf8_sample));
    intptr_t pos = -2;
    size_t len = 2;
    FIO_ASSERT(fio_str_utf8_select(&str, &pos, &len) == 0,
               "`fio_str_utf8_select` returned error for negative pos on "
               "UTF-8 data! (%zd, %zu)",
               (ssize_t)pos, len);
    FIO_ASSERT(pos == (intptr_t)fio_str_len(&str) - 4, /* 4 byte emoji */
               "`fio_str_utf8_select` error, negative position invalid on "
               "UTF-8 data! (%zd)",
               (ssize_t)pos);
    FIO_ASSERT(len == 4, /* last utf-8 char is 4 byte long */
               "`fio_str_utf8_select` error, trancated length invalid on "
               "UTF-8 data! (%zd)",
               (ssize_t)len);
    pos = 1;
    len = 20;
    FIO_ASSERT(fio_str_utf8_select(&str, &pos, &len) == 0,
               "`fio_str_utf8_select` returned error on UTF-8 data! (%zd, %zu)",
               (ssize_t)pos, len);
    FIO_ASSERT(
        pos == 4,
        "`fio_str_utf8_select` error, position invalid on UTF-8 data! (%zd)",
        (ssize_t)pos);
    FIO_ASSERT(
        len == 10,
        "`fio_str_utf8_select` error, length invalid on UTF-8 data! (%zd)",
        (ssize_t)len);
    pos = 1;
    len = 3;
    FIO_ASSERT(
        fio_str_utf8_select(&str, &pos, &len) == 0,
        "`fio_str_utf8_select` returned error on UTF-8 data (2)! (%zd, %zu)",
        (ssize_t)pos, len);
    FIO_ASSERT(
        len == 10, /* 3 UTF-8 chars: 4 byte + 4 byte + 2 byte codes == 10 */
        "`fio_str_utf8_select` error, length invalid on UTF-8 data! (%zd)",
        (ssize_t)len);
  }
  fio_str_free(&str);
  if (1) {
    str = FIO_STR_INIT_STATIC("Welcome");
    FIO_ASSERT(fio_str_capa(&str) == 0, "Static string capacity non-zero.");
    FIO_ASSERT(fio_str_len(&str) > 0,
               "Static string length should be automatically calculated.");
    FIO_ASSERT(str.dealloc == NULL,
               "Static string deallocation function should be NULL.");
    fio_str_free(&str);
    str = FIO_STR_INIT_STATIC("Welcome");
    fio_str_info_s state = fio_str_write(&str, " Home", 5);
    FIO_ASSERT(state.capa > 0, "Static string not converted to non-static.");
    FIO_ASSERT(str.dealloc, "Missing static string deallocation function"
                            " after `fio_str_write`.");

    fprintf(stderr, "* reviewing `fio_str_detach`.\n   (%zu): %s\n",
            fio_str_info(&str).len, fio_str_info(&str).data);
    char *cstr = fio_str_detach(&str);
    FIO_ASSERT(cstr, "`fio_str_detach` returned NULL");
    FIO_ASSERT(!memcmp(cstr, "Welcome Home\0", 13),
               "`fio_str_detach` string error: %s", cstr);
    fio_free(cstr);
    FIO_ASSERT(fio_str_len(&str) == 0, "`fio_str_detach` data wasn't cleared.");
    // fio_str_free(&str);
  }
  fprintf(stderr, "* passed.\n");
}
