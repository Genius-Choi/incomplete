FwdState::serverClosed()
{
    // XXX: This method logic attempts to tolerate Connection::close() called
    // for serverConn earlier, by one of our dispatch()ed jobs. If that happens,
    // serverConn will already be closed here or, worse, it will already be open
    // for the next forwarding attempt. The current code prevents us getting
    // stuck, but the long term solution is to stop sharing serverConn.
    debugs(17, 2, serverConn);
    if (Comm::IsConnOpen(serverConn)) {
        const auto uses = fd_table[serverConn->fd].pconn.uses;
        debugs(17, 3, "prior uses: " << uses);
        fwdPconnPool->noteUses(uses); // XXX: May not have come from fwdPconnPool
        serverConn->noteClosure();
    }
    serverConn = nullptr;
    closeHandler = nullptr;
    destinationReceipt = nullptr;

    // will already be false if this closure happened before/without dispatch()
    waitingForDispatched = false;

    retryOrBail();
}
