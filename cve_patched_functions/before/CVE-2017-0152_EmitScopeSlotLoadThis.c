void ByteCodeGenerator::EmitScopeSlotLoadThis(FuncInfo *funcInfo, Js::RegSlot regLoc, bool chkUndecl)
{
    FuncInfo* nonLambdaFunc = funcInfo;
    if (funcInfo->IsLambda())
    {
        nonLambdaFunc = FindEnclosingNonLambda();
    }

    if (nonLambdaFunc->IsClassConstructor() && !nonLambdaFunc->IsBaseClassConstructor())
    {
        // If we are in a derived class constructor and we have a scope slot for 'this',
        // we need to load 'this' from the scope slot. This is to support the case where
        // the call to initialize 'this' via super() is inside a lambda since the lambda
        // can't assign to the 'this' register of the parent constructor.
        if (nonLambdaFunc->thisScopeSlot != Js::Constants::NoRegister)
        {
            Js::PropertyId slot = nonLambdaFunc->thisScopeSlot;

            EmitInternalScopedSlotLoad(funcInfo, slot, regLoc, chkUndecl);
        }
        else if (funcInfo->thisPointerRegister != Js::Constants::NoRegister && chkUndecl)
        {
            this->m_writer.Reg1(Js::OpCode::ChkUndecl, funcInfo->thisPointerRegister);
        }
        else if (chkUndecl)
        {
            // If we don't have a scope slot for 'this' we know that super could not have
            // been called inside a lambda so we can check to see if we called
            // super and assigned to the this register already. If not, this should trigger
            // a ReferenceError.
            EmitUseBeforeDeclarationRuntimeError(this, Js::Constants::NoRegister);
        }
    }
    else if (this->flags & fscrEval && (funcInfo->IsGlobalFunction() || (funcInfo->IsLambda() && nonLambdaFunc->IsGlobalFunction()))
        && funcInfo->GetBodyScope()->GetIsObject())
    {
        Js::RegSlot scopeLocation;

        if (funcInfo->byteCodeFunction->GetIsStrictMode() && funcInfo->IsGlobalFunction())
        {
            scopeLocation = funcInfo->frameDisplayRegister;
        }
        else if (funcInfo->NeedEnvRegister())
        {
            scopeLocation = funcInfo->GetEnvRegister();
        }
        else
        {
            // If this eval doesn't have environment register or frame display register, we didn't capture anything from a class constructor
            return;
        }

        // CONSIDER [tawoll] - Should we add a ByteCodeGenerator flag (fscrEvalWithClassConstructorParent) and avoid doing this runtime check?
        Js::ByteCodeLabel skipLabel = this->Writer()->DefineLabel();
        this->Writer()->BrReg1(Js::OpCode::BrNotUndecl_A, skipLabel, funcInfo->thisPointerRegister);

        uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, Js::PropertyIds::_lexicalThisSlotSymbol, false, false);
        this->m_writer.ElementP(Js::OpCode::ScopedLdFld, funcInfo->thisPointerRegister, cacheId);
        if (chkUndecl)
        {
            this->m_writer.Reg1(Js::OpCode::ChkUndecl, funcInfo->thisPointerRegister);
        }

        this->Writer()->MarkLabel(skipLabel);
    }
}
