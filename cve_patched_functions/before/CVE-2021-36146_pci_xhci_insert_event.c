pci_xhci_insert_event(struct pci_xhci_vdev *xdev,
		      struct xhci_trb *evtrb,
		      int do_intr)
{
	struct pci_xhci_rtsregs *rts;
	struct xhci_erst *erst;
	struct xhci_trb *evts;
	uint64_t erdp;
	int erdp_idx;

	rts = &xdev->rtsregs;
	erdp = rts->intrreg.erdp & ~0xF;
	erst = &rts->erstba_p[rts->er_enq_seg];
	erdp_idx = (erdp - erst->qwRingSegBase) / sizeof(struct xhci_trb);

	UPRINTF(LDBG, "insert event 0[%lx] 2[%x] 3[%x]\r\n"
			"\terdp idx %d/seg %d, enq idx %d/seg %d, pcs %u\r\n"
			"\t(erdp=0x%lx, erst=0x%lx, tblsz=%u, do_intr %d)\r\n",
			evtrb->qwTrb0, evtrb->dwTrb2, evtrb->dwTrb3,
			erdp_idx, rts->er_deq_seg,
			rts->er_enq_idx, rts->er_enq_seg,
			rts->event_pcs, erdp,
			rts->erstba_p->qwRingSegBase,
			rts->erstba_p->dwRingSegSize, do_intr);

	evtrb->dwTrb3 &= ~XHCI_TRB_3_CYCLE_BIT;
	evtrb->dwTrb3 |= rts->event_pcs;

	evts = XHCI_GADDR(xdev, erst->qwRingSegBase);
	if (!evts) {
		UPRINTF(LFTL, "Invalid gpa 0x%lx in insert event!\r\n",
			erst->qwRingSegBase);
		return -EINVAL;
	}
	memcpy(&evts[rts->er_enq_idx], evtrb, sizeof(struct xhci_trb));

	if (rts->er_enq_idx == erst->dwRingSegSize - 1) {
		rts->er_enq_idx = 0;
		rts->er_enq_seg = (rts->er_enq_seg + 1) % rts->intrreg.erstsz;
	} else {
		rts->er_enq_idx = (rts->er_enq_idx + 1) % erst->dwRingSegSize;
	}

	if (rts->er_enq_idx == 0 && rts->er_enq_seg == 0)
		rts->event_pcs ^= 1;

	if (do_intr)
		pci_xhci_assert_interrupt(xdev);

	return 0;
}
