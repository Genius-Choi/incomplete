static void parse_repeat(sdp_parser_t *p, char *d, sdp_repeat_t **result)
{
  /*
   repeat-fields =       %x72 "=" repeat-interval 2*(SP typed-time)

   repeat-interval =     POS-DIGIT *DIGIT [fixed-len-time-unit]

   typed-time =          1*DIGIT [fixed-len-time-unit]

   fixed-len-time-unit = %x64 / %x68 / %x6d / %x73 ; "d" | "h" | "m" | "s"
   */

  unsigned long tt, *interval;
  size_t i;
  int n, N;
  char *s;
  sdp_repeat_t *r;
  int strict = STRICT(p);

  /** Count number of intervals */
  for (N = 0, s = d; *s; ) {
    if (!(is_posdigit(*s) || (!strict && (*s) == '0')))
      break;
    do { s++; } while (is_digit(*s));
    if (*s && strchr(strict ? "dhms" : "dhmsDHMS", *s))
      s++;
    N++;
    if (!(i = strict ? is_space(*s) : strspn(s, SPACE TAB)))
      break;
    s += i;
  }

  PARSE_CHECK_REST(p, s, "r");
  if (N < 2) {
    parsing_error(p, "invalid repeat");
    return;
  }
  if (!(r = su_salloc(p->pr_home, offsetof(sdp_repeat_t, r_offsets[N - 1])))) {
    parse_alloc_error(p, "sdp_repeat_t");
    return;
  }

  r->r_number_of_offsets = N - 2;
  r->r_offsets[N - 2] = 0;

  for (n = 0, interval = &r->r_interval; n < N; n++) {
    tt = strtoul(d, &d, 10);

    switch (*d) {
    case 'd': case 'D': tt *= 24;
    case 'h': case 'H': tt *= 60;
    case 'm': case 'M': tt *= 60;
    case 's': case 'S': d++;
      break;
    }

    interval[n] = tt;

    while (is_space(*d))
      d++;
  }

  *result = r;
}
