authentic_sdo_allocate_prvkey(struct sc_profile *profile, struct sc_card *card,
		struct sc_pkcs15_prkey_info *key_info, struct sc_authentic_sdo **out)
{
	struct sc_context *ctx = card->ctx;
	struct sc_authentic_sdo *sdo = NULL;
	struct sc_file *file = NULL;
	int rv;

	LOG_FUNC_CALLED(ctx);

	if (!out)
		LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);

	if ((key_info->modulus_length % 256) || key_info->modulus_length < 1024 || key_info->modulus_length > 2048)
		LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);

	rv = authentic_pkcs15_new_file(profile, card, SC_PKCS15_TYPE_PRKEY_RSA, key_info->key_reference, &file);
	LOG_TEST_RET(ctx, rv, "Cannot instantiate new PRKEY-RSA file");

	sdo = calloc(1, sizeof(struct sc_authentic_sdo));
	if (!sdo) {
		sc_file_free(file);
		LOG_TEST_RET(ctx, SC_ERROR_OUT_OF_MEMORY, "Cannot allocate 'sc_authentic_sdo'");
	}

	sdo->magic = AUTHENTIC_SDO_MAGIC;
	sdo->docp.id = key_info->key_reference &  ~AUTHENTIC_OBJECT_REF_FLAG_LOCAL;
	sdo->docp.mech = authentic_v3_rsa_mechs[(key_info->modulus_length - 1024) / 256];

	rv = authentic_docp_set_acls(card, file, authentic_v3_rsa_ac_ops,
			sizeof(authentic_v3_rsa_ac_ops)/sizeof(authentic_v3_rsa_ac_ops[0]), &sdo->docp);
	sc_file_free(file);
	if (rv != SC_SUCCESS) {
		free(sdo);
		sc_log(ctx, "Cannot set key ACLs from file");
		LOG_FUNC_RETURN(ctx, rv);
	}

	sc_log(ctx, "sdo(mech:%X,id:%X,acls:%s)", sdo->docp.mech, sdo->docp.id,
			sc_dump_hex(sdo->docp.acl_data, sdo->docp.acl_data_len));

	*out = sdo;
	LOG_FUNC_RETURN(ctx, SC_SUCCESS);
}
