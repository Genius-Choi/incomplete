constructUserInfo(unsigned char type, DUL_ASSOCIATESERVICEPARAMETERS * params,
      DUL_USERINFO * userInfo, unsigned long *rtnLen)
{
    // the order in which the user info sub-items are constructed in this
    // function is not significant. The final transmission order is determined
    // by streamUserInfo().

    unsigned long length;
    // needed to detect overflow of total user item lengths (max 65535 bytes).
    // in the end this is copied to userInfo->length
    unsigned long totalUserInfoLength = 0;

    userInfo->type = DUL_TYPEUSERINFO;
    userInfo->rsv1 = 0;
    userInfo->length = 0;
    *rtnLen = 4;

    // construct user info sub-item 51H: maximum length
    OFCondition cond = constructMaxLength(params->maxPDU, &userInfo->maxLength, &length);
    if (cond.bad()) return cond;
    totalUserInfoLength += length;
    *rtnLen += length;

    // construct user info sub-item 52H: implementation class UID
    if (type == DUL_TYPEASSOCIATERQ)
        cond = constructSubItem(params->callingImplementationClassUID,
                DUL_TYPEIMPLEMENTATIONCLASSUID, &userInfo->implementationClassUID, &length);
    else
        cond = constructSubItem(params->calledImplementationClassUID,
                DUL_TYPEIMPLEMENTATIONCLASSUID, &userInfo->implementationClassUID, &length);
    if (cond.bad()) return cond;
    totalUserInfoLength += length;
    *rtnLen += length;

    // user info sub-item 53H (async operations) is not yet implemented!

    // construct user info sub-item 55H: implementation version name
    if (type == DUL_TYPEASSOCIATERQ) {
        if (strlen(params->callingImplementationVersionName) != 0) {
            cond = constructSubItem(params->callingImplementationVersionName,
                DUL_TYPEIMPLEMENTATIONVERSIONNAME,
                &userInfo->implementationVersionName,
                &length);
            if (cond.bad()) return cond;
            totalUserInfoLength += length;
            *rtnLen += length;
        }
     } else {
        if (strlen(params->calledImplementationVersionName) != 0) {
            cond = constructSubItem(params->calledImplementationVersionName,
                                    DUL_TYPEIMPLEMENTATIONVERSIONNAME,
                                    &userInfo->implementationVersionName,
                                    &length);
            if (cond.bad()) return cond;
            totalUserInfoLength += length;
            *rtnLen += length;
        }
    }

    // construct one or more user info sub-items 54H: SCP/SCU role selection
    cond = constructSCUSCPRoles(type, params, &userInfo->SCUSCPRoleList, &length);
    if (cond.bad()) return cond;
    totalUserInfoLength += length;
    *rtnLen += length;

    // construct one or more user info sub-items 56H: extended negotiation
    cond = constructExtNeg(type, params, &userInfo->extNegList, &length);
    if (cond.bad()) return cond;
    totalUserInfoLength += length;
    *rtnLen += length;

    // construct user info sub-item 58H: user identification negotiation
    if (params->reqUserIdentNeg && (type == DUL_TYPEASSOCIATERQ))
    {
      cond = params->reqUserIdentNeg->streamedLength(length);
      if (cond.bad()) return cond;
      userInfo->usrIdent = new UserIdentityNegotiationSubItemRQ();
      *(OFstatic_cast(UserIdentityNegotiationSubItemRQ*,userInfo->usrIdent)) = *(OFstatic_cast(UserIdentityNegotiationSubItemRQ*, params->reqUserIdentNeg));
      totalUserInfoLength += length;
      *rtnLen += length;
    }
    else if (params->ackUserIdentNeg && (type == DUL_TYPEASSOCIATEAC))
    {
      cond = params->ackUserIdentNeg->streamedLength(length);
      if (cond.bad()) return cond;
      userInfo->usrIdent = new UserIdentityNegotiationSubItemAC();
      *(OFstatic_cast(UserIdentityNegotiationSubItemAC*,userInfo->usrIdent)) = *(OFstatic_cast(UserIdentityNegotiationSubItemAC*, params->ackUserIdentNeg));
      totalUserInfoLength += length;
      *rtnLen += length;
    }
    if (totalUserInfoLength > 65535)
    {
      char errbuf[500];
      sprintf(errbuf, "Total length of user items (%lu bytes) exceeds upper limit of 65535 bytes", totalUserInfoLength);
      return makeDcmnetCondition(ASCC_CODINGERROR, OF_error, errbuf);
    }
    else // now casting to unsigned short should be safe
      userInfo->length = OFstatic_cast(unsigned short, totalUserInfoLength);
    return EC_Normal;
}
