QPDF::recoverStreamLength(PointerHolder<InputSource> input,
			  int objid, int generation,
                          qpdf_offset_t stream_offset)
{
    PCRE endobj_re("^\\s*endobj\\b");

    // Try to reconstruct stream length by looking for
    // endstream(\r\n?|\n)endobj
    warn(QPDFExc(qpdf_e_damaged_pdf, input->getName(),
		 this->last_object_description, stream_offset,
		 "attempting to recover stream length"));

    input->seek(0, SEEK_END);
    qpdf_offset_t eof = input->tell();
    input->seek(stream_offset, SEEK_SET);
    qpdf_offset_t last_line_offset = 0;
    size_t length = 0;
    static int const line_end_length = 12; // room for endstream\r\n\0
    char last_line_end[line_end_length];
    while (input->tell() < eof)
    {
	std::string line = input->readLine(50);
        qpdf_offset_t line_offset = input->getLastOffset();
	if (endobj_re.match(line.c_str()))
        {
            qpdf_offset_t endstream_offset = 0;
            if (last_line_offset >= line_end_length)
            {
                qpdf_offset_t cur_offset = input->tell();
                // Read from the end of the last line, guaranteeing
                // null termination
                qpdf_offset_t search_offset =
                    line_offset - (line_end_length - 1);
                input->seek(search_offset, SEEK_SET);
                memset(last_line_end, '\0', line_end_length);
                input->read(last_line_end, line_end_length - 1);
                input->seek(cur_offset, SEEK_SET);
                // if endstream[\r\n] will fit in last_line_end, the
                // 'e' has to be in one of the first three spots.
                // Check explicitly rather than using strstr directly
                // in case there are nulls right before endstream.
                char* p = ((last_line_end[0] == 'e') ? last_line_end :
                           (last_line_end[1] == 'e') ? last_line_end + 1 :
                           (last_line_end[2] == 'e') ? last_line_end + 2 :
                           0);
                char* endstream_p = 0;
                if (p)
                {
                    char* p1 = strstr(p, "endstream\n");
                    char* p2 = strstr(p, "endstream\r");
                    endstream_p = (p1 ? p1 : p2);
                }
                if (endstream_p)
                {
                    endstream_offset =
                        search_offset + (endstream_p - last_line_end);
                }
            }
            if (endstream_offset > 0)
            {
                // Stream probably ends right before "endstream"
                length = endstream_offset - stream_offset;
                // Go back to where we would have been if we had just
                // read the endstream.
                input->seek(line_offset, SEEK_SET);
                break;
            }
	}
	last_line_offset = line_offset;
    }

    if (length)
    {
	int this_obj_offset = 0;
	QPDFObjGen this_obj(0, 0);

	// Make sure this is inside this object
	for (std::map<QPDFObjGen, QPDFXRefEntry>::iterator iter =
		 this->xref_table.begin();
	     iter != this->xref_table.end(); ++iter)
	{
	    QPDFObjGen const& og = (*iter).first;
	    QPDFXRefEntry const& entry = (*iter).second;
	    if (entry.getType() == 1)
	    {
		qpdf_offset_t obj_offset = entry.getOffset();
		if ((obj_offset > stream_offset) &&
		    ((this_obj_offset == 0) ||
		     (this_obj_offset > obj_offset)))
		{
		    this_obj_offset = obj_offset;
		    this_obj = og;
		}
	    }
	}
	if (this_obj_offset &&
	    (this_obj.getObj() == objid) &&
	    (this_obj.getGen() == generation))
	{
	    // Well, we found endstream\nendobj within the space
	    // allowed for this object, so we're probably in good
	    // shape.
	}
	else
	{
	    QTC::TC("qpdf", "QPDF found wrong endstream in recovery");
	}
    }

    if (length == 0)
    {
	throw QPDFExc(qpdf_e_damaged_pdf, input->getName(),
		      this->last_object_description, stream_offset,
		      "unable to recover stream data");
    }

    QTC::TC("qpdf", "QPDF recovered stream length");
    return length;
}
