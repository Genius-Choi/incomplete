void LinearAlgebraOp<InputScalar, OutputScalar>::ComputeTensorSlice(
    OpKernelContext* context, int64_t matrix_index, const TensorInputs& inputs,
    const TensorShapes& input_matrix_shapes, const TensorOutputs& outputs,
    const TensorShapes& output_matrix_shapes) {
  InputConstMatrixMaps matrix_inputs;
  for (size_t i = 0; i < inputs.size(); ++i) {
    // TODO(kalakris): Handle alignment if possible. Eigen::Map is
    // unaligned by default.
    matrix_inputs.emplace_back(
        inputs[i]->flat<InputScalar>().data() +
            matrix_index * input_matrix_shapes[i].num_elements(),
        input_matrix_shapes[i].dim_size(0), input_matrix_shapes[i].dim_size(1));
  }

  OutputMatrixMaps matrix_outputs;
  for (size_t i = 0; i < output_matrix_shapes.size(); ++i) {
    // The output matrix shape may not be a matrix.
    int num_output_rows = output_matrix_shapes[i].dims() >= 1
                              ? output_matrix_shapes[i].dim_size(0)
                              : 1;
    int num_output_cols = output_matrix_shapes[i].dims() == 2
                              ? output_matrix_shapes[i].dim_size(1)
                              : 1;
    matrix_outputs.emplace_back(
        outputs[i]->flat<OutputScalar>().data() +
            matrix_index * output_matrix_shapes[i].num_elements(),
        num_output_rows, num_output_cols);
  }
  ComputeMatrix(context, matrix_inputs, &matrix_outputs);
}
