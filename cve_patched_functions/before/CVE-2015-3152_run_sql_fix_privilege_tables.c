static int run_sql_fix_privilege_tables(void)
{
  int found_real_errors= 0;
  const char **query_ptr;
  DYNAMIC_STRING ds_script;
  DYNAMIC_STRING ds_result;
  DBUG_ENTER("run_sql_fix_privilege_tables");

  if (init_dynamic_string(&ds_script, "", 65536, 1024))
    die("Out of memory");

  if (init_dynamic_string(&ds_result, "", 512, 512))
    die("Out of memory");

  verbose("Running 'mysql_fix_privilege_tables'...");

  /*
    Individual queries can not be executed independently by invoking
    a forked mysql client, because the script uses session variables
    and prepared statements.
  */
  for ( query_ptr= &mysql_fix_privilege_tables[0];
        *query_ptr != NULL;
        query_ptr++
      )
  {
    dynstr_append(&ds_script, *query_ptr);
  }

  run_query(ds_script.str,
            &ds_result, /* Collect result */
            TRUE);
  {
    /*
      Scan each line of the result for real errors
      and ignore the expected one(s) like "Duplicate column name",
      "Unknown column" and "Duplicate key name" since they just
      indicate the system tables are already up to date
    */
    char *line= ds_result.str;
    do
    {
      if (!is_expected_error(line))
      {
        /* Something unexpected failed, dump error line to screen */
        found_real_errors++;
        print_line(line);
      }
      else
      {
        char *c;

        /*
          We process the output of the child process here.
          Basically, if a line contains a warning, we'll print it,
          otherwise, we won't.
          The first branch handles new-style tools that print
          their name, then the severity in brackets,
          the second branch handles old-style tools that just print
          a severity.
        */
        if ((c= strstr(line, ": ")) && (c < strchr(line, ' ')) &&
            (strncmp(c + 2, "[Warning] ", 10) == 0))
          print_line(line);
        else if ((strncmp(line, "WARNING", 7) == 0) ||
                 (strncmp(line, "Warning", 7) == 0))
          print_line(line);
      }
    } while ((line= get_line(line)) && *line);
  }

  dynstr_free(&ds_result);
  dynstr_free(&ds_script);
  DBUG_RETURN(found_real_errors);
}
