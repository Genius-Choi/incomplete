static void gf_filter_reg_build_graph_single(GF_FilterRegDesc *reg_desc, const GF_FilterRegister *freg, GF_FilterRegDesc *a_reg, Bool freg_has_output, u32 nb_dst_caps, GF_CapsBundleStore *capstore, GF_Filter *dst_filter)
{
	u32 nb_src_caps, k, l;
	u32 path_weight;

	//check which cap of this filter matches our destination
	nb_src_caps = gf_filter_caps_bundle_count(a_reg->freg->caps, a_reg->freg->nb_caps);
	for (k=0; k<nb_src_caps; k++) {
		for (l=0; l<nb_dst_caps; l++) {
			s32 bundle_idx;

			if (gf_filter_has_out_caps(a_reg->freg->caps, a_reg->freg->nb_caps)) {
				u32 loaded_filter_only_flags = 0;

				path_weight = gf_filter_caps_to_caps_match(a_reg->freg, k, (const GF_FilterRegister *) freg, dst_filter, &bundle_idx, l, &loaded_filter_only_flags, capstore);

				if (path_weight && (bundle_idx == l)) {
					GF_FilterRegEdge *edge;
					if (reg_desc->nb_edges==reg_desc->nb_alloc_edges) {
						reg_desc->nb_alloc_edges += 10;
						reg_desc->edges = gf_realloc(reg_desc->edges, sizeof(GF_FilterRegEdge) * reg_desc->nb_alloc_edges);
					}
					assert(path_weight<0xFF);
					assert(k<0xFFFF);
					assert(l<0xFFFF);
					edge = &reg_desc->edges[reg_desc->nb_edges];
					memset(edge, 0, sizeof(GF_FilterRegEdge));
					edge->src_reg = a_reg;
					edge->weight = (u8) path_weight;
					edge->src_cap_idx = (u16) k;
					edge->dst_cap_idx = (u16) l;

					//we inverted the caps, invert the flags
					if (loaded_filter_only_flags & EDGE_LOADED_SOURCE_ONLY)
						edge->loaded_filter_only |= EDGE_LOADED_DEST_ONLY;
					if (loaded_filter_only_flags & EDGE_LOADED_DEST_ONLY)
						edge->loaded_filter_only |= EDGE_LOADED_SOURCE_ONLY;
					edge->src_stream_type = gf_filter_reg_get_bundle_stream_type(edge->src_reg->freg, edge->src_cap_idx, GF_TRUE);
					reg_desc->nb_edges++;
				}
			}

			if ( freg_has_output ) {
				u32 loaded_filter_only_flags = 0;

				path_weight = gf_filter_caps_to_caps_match(freg, l, a_reg->freg, dst_filter, &bundle_idx, k, &loaded_filter_only_flags, capstore);

				if (path_weight && (bundle_idx == k)) {
					GF_FilterRegEdge *edge;
					if (a_reg->nb_edges==a_reg->nb_alloc_edges) {
						a_reg->nb_alloc_edges += 10;
						a_reg->edges = gf_realloc(a_reg->edges, sizeof(GF_FilterRegEdge) * a_reg->nb_alloc_edges);
					}
					edge = &a_reg->edges[a_reg->nb_edges];
					edge->src_reg = reg_desc;
					edge->weight = (u8) path_weight;
					edge->src_cap_idx = (u16) l;
					edge->dst_cap_idx = (u16) k;
					edge->priority = 0;
					edge->loaded_filter_only = loaded_filter_only_flags;
					edge->src_stream_type = gf_filter_reg_get_bundle_stream_type(edge->src_reg->freg, edge->src_cap_idx, GF_TRUE);
					a_reg->nb_edges++;
				}
			}
		}
	}
}
