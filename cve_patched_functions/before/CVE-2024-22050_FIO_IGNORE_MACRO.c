intptr_t http_connect FIO_IGNORE_MACRO(const char *url,
                                       const char *unix_address,
                                       struct http_settings_s arg_settings) {
  if (!arg_settings.on_response && !arg_settings.on_upgrade) {
    FIO_LOG_ERROR("http_connect requires either an on_response "
                  " or an on_upgrade callback.\n");
    errno = EINVAL;
    goto on_error;
  }
  size_t len = 0, h_len = 0;
  char *a = NULL, *p = NULL, *host = NULL;
  uint8_t is_websocket = 0;
  uint8_t is_secure = 0;
  FIOBJ path = FIOBJ_INVALID;
  if (!url && !unix_address) {
    FIO_LOG_ERROR("http_connect requires a valid address.");
    errno = EINVAL;
    goto on_error;
  }
  if (url) {
    fio_url_s u = fio_url_parse(url, strlen(url));
    if (u.scheme.data &&
        (u.scheme.len == 2 || (u.scheme.len == 3 && u.scheme.data[2] == 's')) &&
        u.scheme.data[0] == 'w' && u.scheme.data[1] == 's') {
      is_websocket = 1;
      is_secure = (u.scheme.len == 3);
    } else if (u.scheme.data &&
               (u.scheme.len == 4 ||
                (u.scheme.len == 5 && u.scheme.data[4] == 's')) &&
               u.scheme.data[0] == 'h' && u.scheme.data[1] == 't' &&
               u.scheme.data[2] == 't' && u.scheme.data[3] == 'p') {
      is_secure = (u.scheme.len == 5);
    }
    if (is_secure && !arg_settings.tls) {
      FIO_LOG_ERROR("Secure connections (%.*s) require a TLS object.",
                    (int)u.scheme.len, u.scheme.data);
      errno = EINVAL;
      goto on_error;
    }
    if (u.path.data) {
      path = fiobj_str_new(
          u.path.data, strlen(u.path.data)); /* copy query and target as well */
    }
    if (unix_address) {
      a = (char *)unix_address;
      h_len = len = strlen(a);
      host = a;
    } else {
      if (!u.host.data) {
        FIO_LOG_ERROR("http_connect requires a valid address.");
        errno = EINVAL;
        goto on_error;
      }
      /***** no more error handling, since memory is allocated *****/
      /* copy address */
      a = fio_malloc(u.host.len + 1);
      memcpy(a, u.host.data, u.host.len);
      a[u.host.len] = 0;
      len = u.host.len;
      /* copy port */
      if (u.port.data) {
        p = fio_malloc(u.port.len + 1);
        memcpy(p, u.port.data, u.port.len);
        p[u.port.len] = 0;
      } else if (is_secure) {
        p = fio_malloc(3 + 1);
        memcpy(p, "443", 3);
        p[3] = 0;
      } else {
        p = fio_malloc(2 + 1);
        memcpy(p, "80", 2);
        p[2] = 0;
      }
    }
    if (u.host.data) {
      host = u.host.data;
      h_len = u.host.len;
    }
  }

  /* set settings */
  if (!arg_settings.timeout)
    arg_settings.timeout = 30;
  http_settings_s *settings = http_settings_new(arg_settings);
  settings->is_client = 1;
  // if (settings->tls) {
  //   fio_tls_alpn_add(settings->tls, "http/1.1", http_on_open_client_http1,
  //                     NULL, NULL);
  // }

  if (!arg_settings.ws_timeout)
    settings->ws_timeout = 0; /* allow server to dictate timeout */
  if (!arg_settings.timeout)
    settings->timeout = 0; /* allow server to dictate timeout */
  http_s *h = fio_malloc(sizeof(*h));
  FIO_ASSERT(h, "HTTP Client handler allocation failed");
  http_s_new(h, 0, http1_vtable());
  h->udata = arg_settings.udata;
  h->status = 0;
  h->path = path;
  settings->udata = h;
  settings->tls = arg_settings.tls;
  if (host)
    http_set_header2(h, (fio_str_info_s){.data = (char *)"host", .len = 4},
                     (fio_str_info_s){.data = host, .len = h_len});
  intptr_t ret;
  if (is_websocket) {
    /* force HTTP/1.1 */
    ret = fio_connect(.address = a, .port = p, .on_fail = http_on_client_failed,
                      .on_connect = http_on_open_client, .udata = settings,
                      .tls = arg_settings.tls);
    (void)0;
  } else {
    /* Allow for any HTTP version */
    ret = fio_connect(.address = a, .port = p, .on_fail = http_on_client_failed,
                      .on_connect = http_on_open_client, .udata = settings,
                      .tls = arg_settings.tls);
    (void)0;
  }
  if (a != unix_address)
    fio_free(a);
  fio_free(p);
  return ret;
on_error:
  if (arg_settings.on_finish)
    arg_settings.on_finish(&arg_settings);
  return -1;
}
