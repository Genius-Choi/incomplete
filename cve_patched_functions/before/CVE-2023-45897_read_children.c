static int read_children(struct exfat_fsck *fsck, struct exfat_inode *dir)
{
	struct exfat *exfat = fsck->exfat;
	struct exfat_inode *node = NULL;
	struct exfat_dentry *dentry;
	struct exfat_de_iter *de_iter;
	int dentry_count;
	int ret;

	de_iter = &fsck->de_iter;
	ret = exfat_de_iter_init(de_iter, exfat, dir, fsck->buffer_desc);
	if (ret == EOF)
		return 0;
	else if (ret)
		return ret;

	de_iter->name_hash_bitmap = fsck->name_hash_bitmap;
	memset(fsck->name_hash_bitmap, 0,
			EXFAT_BITMAP_SIZE(EXFAT_MAX_HASH_COUNT));

	while (1) {
		ret = exfat_de_iter_get(de_iter, 0, &dentry);
		if (ret == EOF) {
			break;
		} else if (ret) {
			fsck_err(dir->parent, dir,
				"failed to get a dentry. %d\n", ret);
			goto err;
		}

		dentry_count = 1;

		switch (dentry->type) {
		case EXFAT_FILE:
			ret = read_file(de_iter, &node, &dentry_count);
			if (ret < 0) {
				exfat_stat.error_count++;
				break;
			} else if (ret) {
				exfat_stat.error_count++;
				exfat_stat.fixed_count++;
			}

			if (node) {
				if ((node->attr & ATTR_SUBDIR) && node->size) {
					node->parent = dir;
					list_add_tail(&node->sibling,
						      &dir->children);
					list_add_tail(&node->list,
						      &exfat->dir_list);
				} else {
					exfat_free_inode(node);
				}
			}
			break;
		case EXFAT_LAST:
			goto out;
		case EXFAT_VOLUME:
		case EXFAT_BITMAP:
		case EXFAT_UPCASE:
		case EXFAT_GUID:
			if (dir == exfat->root)
				break;
			/* fallthrough */
		default:
			if (IS_EXFAT_DELETED(dentry->type))
				break;
			if (repair_file_ask(de_iter, NULL, ER_DE_UNKNOWN,
					    "unknown entry type %#x at %07" PRIx64,
					    dentry->type,
					    exfat_de_iter_file_offset(de_iter))) {
				struct exfat_dentry *dentry;

				exfat_de_iter_get_dirty(de_iter, 0, &dentry);
				dentry->type &= EXFAT_DELETE;
			}
			break;
		}

		exfat_de_iter_advance(de_iter, dentry_count);
	}
out:
	exfat_de_iter_flush(de_iter);
	return 0;
err:
	exfat_free_children(dir, false);
	INIT_LIST_HEAD(&dir->children);
	exfat_de_iter_flush(de_iter);
	return ret;
}
