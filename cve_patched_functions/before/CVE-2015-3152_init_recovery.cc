int init_recovery(Master_info* mi, const char** errmsg)
{
  DBUG_ENTER("init_recovery");

  int error= 0;
  Relay_log_info *rli= mi->rli;
  char *group_master_log_name= NULL;

  if (rli->recovery_parallel_workers)
  {
    /*
      This is not idempotent and a crash after this function and before
      the recovery is actually done may lead the system to an inconsistent
      state.

      This may happen because the gap is not persitent stored anywhere
      and eventually old relay log files will be removed and further
      calculations on the gaps will be impossible.

      We need to improve this. /Alfranio.
    */
    error= mts_recovery_groups(rli);
    if (rli->mts_recovery_group_cnt)
    {
      error= 1;
      sql_print_error("--relay-log-recovery cannot be executed when the slave "
                        "was stopped with an error or killed in MTS mode; "
                        "consider using RESET SLAVE or restart the server "
                        "with --relay-log-recovery = 0 followed by "
                        "START SLAVE UNTIL SQL_AFTER_MTS_GAPS");
    }
  }

  group_master_log_name= const_cast<char *>(rli->get_group_master_log_name());
  if (!error && group_master_log_name[0])
  {
    mi->set_master_log_pos(max<ulonglong>(BIN_LOG_HEADER_SIZE,
                                               rli->get_group_master_log_pos()));
    mi->set_master_log_name(rli->get_group_master_log_name());

    sql_print_warning("Recovery from master pos %ld and file %s.",
                      (ulong) mi->get_master_log_pos(), mi->get_master_log_name());

    rli->set_group_relay_log_name(rli->relay_log.get_log_fname());
    rli->set_event_relay_log_name(rli->relay_log.get_log_fname());
    rli->set_group_relay_log_pos(BIN_LOG_HEADER_SIZE);
    rli->set_event_relay_log_pos(BIN_LOG_HEADER_SIZE);
  }

  /*
    Clear the retrieved GTID set so that events that are written partially
    will be fetched again.
    */
  global_sid_lock->wrlock();
  (const_cast<Gtid_set *>(rli->get_gtid_set()))->clear();
  global_sid_lock->unlock();
  DBUG_RETURN(error);
}
