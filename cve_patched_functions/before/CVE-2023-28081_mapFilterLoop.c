CallResult<HermesValue> mapFilterLoop(
    Runtime &runtime,
    Handle<JSTypedArrayBase> self,
    Handle<Callable> callbackfn,
    Handle<> thisArg,
    Handle<JSArray> values,
    JSTypedArrayBase::size_type insert,
    JSTypedArrayBase::size_type len) {
  MutableHandle<> storage(runtime);
  MutableHandle<> val{runtime};
  GCScopeMarkerRAII marker{runtime};
  for (JSTypedArrayBase::size_type i = 0; i < len; ++i) {
    if (!self->attached(runtime)) {
      // If the callback detached this TypedArray, raise a TypeError and don't
      // continue.
      return runtime.raiseTypeError("Detached the TypedArray in the callback");
    }
    val = JSObject::getOwnIndexed(createPseudoHandle(self.get()), runtime, i);
    auto callRes = Callable::executeCall3(
        callbackfn,
        runtime,
        thisArg,
        *val,
        HermesValue::encodeNumberValue(i),
        self.getHermesValue());
    if (callRes == ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
    if (MapOrFilter) {
      // Map adds the result of the callback onto the array.
      storage = std::move(*callRes);
      JSArray::setElementAt(values, runtime, insert++, storage);
    } else if (toBoolean(callRes->get())) {
      storage = *val;
      JSArray::setElementAt(values, runtime, insert++, storage);
    }
    marker.flush();
  }
  return HermesValue::encodeNumberValue(insert);
}
