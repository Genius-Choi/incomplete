static int process_socket(int fd) {
        _cleanup_close_ int input_fd = -EBADF;
        Context context = {};
        struct iovec_wrapper iovw = {};
        struct iovec iovec;
        int r;

        assert(fd >= 0);

        log_setup();

        log_debug("Processing coredump received on stdin...");

        for (;;) {
                CMSG_BUFFER_TYPE(CMSG_SPACE(sizeof(int))) control;
                struct msghdr mh = {
                        .msg_control = &control,
                        .msg_controllen = sizeof(control),
                        .msg_iovlen = 1,
                };
                ssize_t n;
                ssize_t l;

                l = next_datagram_size_fd(fd);
                if (l < 0) {
                        r = log_error_errno(l, "Failed to determine datagram size to read: %m");
                        goto finish;
                }

                iovec.iov_len = l;
                iovec.iov_base = malloc(l + 1);
                if (!iovec.iov_base) {
                        r = log_oom();
                        goto finish;
                }

                mh.msg_iov = &iovec;

                n = recvmsg_safe(fd, &mh, MSG_CMSG_CLOEXEC);
                if (n < 0)  {
                        free(iovec.iov_base);
                        r = log_error_errno(n, "Failed to receive datagram: %m");
                        goto finish;
                }

                /* The final zero-length datagram carries the file descriptor and tells us
                 * that we're done. */
                if (n == 0) {
                        struct cmsghdr *found;

                        free(iovec.iov_base);

                        found = cmsg_find(&mh, SOL_SOCKET, SCM_RIGHTS, CMSG_LEN(sizeof(int)));
                        if (!found) {
                                cmsg_close_all(&mh);
                                r = log_error_errno(SYNTHETIC_ERRNO(EBADMSG),
                                                    "Coredump file descriptor missing.");
                                goto finish;
                        }

                        assert(input_fd < 0);
                        input_fd = *(int*) CMSG_DATA(found);
                        break;
                } else
                        cmsg_close_all(&mh);

                /* Add trailing NUL byte, in case these are strings */
                ((char*) iovec.iov_base)[n] = 0;
                iovec.iov_len = (size_t) n;

                r = iovw_put(&iovw, iovec.iov_base, iovec.iov_len);
                if (r < 0)
                        goto finish;
        }

        /* Make sure we got all data we really need */
        assert(input_fd >= 0);

        r = save_context(&context, &iovw);
        if (r < 0)
                goto finish;

        /* Make sure we received at least all fields we need. */
        for (int i = 0; i < _META_MANDATORY_MAX; i++)
                if (!context.meta[i]) {
                        r = log_error_errno(SYNTHETIC_ERRNO(EINVAL),
                                            "A mandatory argument (%i) has not been sent, aborting.",
                                            i);
                        goto finish;
                }

        r = submit_coredump(&context, &iovw, input_fd);

finish:
        iovw_free_contents(&iovw, true);
        return r;
}
