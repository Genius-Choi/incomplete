OptValue<uint32_t> CodeBlock::getFunctionSourceID() const {
  // Note that for the case of lazy compilation, the function sources had been
  // reserved into the function source table of the root bytecode module.
  // For non-lazy module, the lazy root module is itself.
  llvh::ArrayRef<std::pair<uint32_t, uint32_t>> table =
      runtimeModule_->getLazyRootModule()
          ->getBytecode()
          ->getFunctionSourceTable();

  // Performs a binary search since the function source table is sorted by the
  // 1st value. We could further optimize the lookup by loading it as a map in
  // the RuntimeModule, but the table is expected to be small.
  auto it = std::lower_bound(
      table.begin(),
      table.end(),
      functionID_,
      [](std::pair<uint32_t, uint32_t> entry, uint32_t id) {
        return entry.first < id;
      });
  if (it == table.end() || it->first != functionID_) {
    return llvh::None;
  } else {
    return it->second;
  }
}
