static char *get_next_processed_event(GList **events_list)
{
    if (!events_list || !*events_list)
        return NULL;

    char *event_name = (char *)(*events_list)->data;
    const size_t event_len = strlen(event_name);

    /* pop the current event */
    *events_list = g_list_delete_link(*events_list, *events_list);

    if (event_name[event_len - 1] == '*')
    {
        log_info("Expanding event '%s'", event_name);

        struct dump_dir *dd = dd_opendir(g_dump_dir_name, DD_OPEN_READONLY);
        if (!dd)
            error_msg_and_die("Can't open directory '%s'", g_dump_dir_name);

        /* Erase '*' */
        event_name[event_len - 1] = '\0';

        /* get 'event1\nevent2\nevent3\n' or '' if no event is possible */
        char *expanded_events = list_possible_events(dd, g_dump_dir_name, event_name);

        dd_close(dd);
        free(event_name);

        GList *expanded_list = NULL;
        /* add expanded events from event having trailing '*' */
        char *next = event_name = expanded_events;
        while ((next = strchr(event_name, '\n')))
        {
            /* 'event1\0event2\nevent3\n' */
            next[0] = '\0';

            /* 'event1' */
            event_name = xstrdup(event_name);
            log_debug("Adding a new expanded event '%s' to the processed list", event_name);

            /* the last event is not added to the expanded list */
            ++next;
            if (next[0] == '\0')
                break;

            expanded_list = g_list_prepend(expanded_list, event_name);

            /* 'event2\nevent3\n' */
            event_name = next;
        }

        free(expanded_events);

        /* It's OK we can safely compare address even if them were previously freed */
        if (event_name != expanded_events)
            /* the last expanded event name is stored in event_name */
            *events_list = g_list_concat(expanded_list, *events_list);
        else
        {
            log_info("No event was expanded, will continue with the next one.");
            /* no expanded event try the next event */
            return get_next_processed_event(events_list);
        }
    }

    clear_warnings();
    const bool acceptable = check_minimal_bt_rating(event_name);
    show_warnings();

    if (!acceptable)
    {
        /* a node for this event was already removed */
        free(event_name);

        g_list_free_full(*events_list, free);
        *events_list = NULL;
        return NULL;
    }

    return event_name;
}
