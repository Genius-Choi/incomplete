void ds_flusher_routine(unsigned int ticks, void* param)
{
	db_key_t key_cmp[2];
	db_val_t val_cmp[2];
	db_key_t key_set;
	db_val_t val_set;
	ds_set_p list;
	int j;

	/* do not run this routine if not in running mode */
	if (ticks > 0 && sr_get_core_status() < STATE_RUNNING)
		return;

	ds_partition_t *partition;
	for (partition = partitions; partition; partition = partition->next){
		if (*partition->db_handle==NULL)
			continue;

		val_cmp[0].type = DB_INT;
		val_cmp[0].nul  = 0;
		val_cmp[1].type = DB_STR;
		val_cmp[1].nul  = 0;

		val_set.type = DB_INT;
		val_set.nul  = 0;

		/* access ds data under reader's lock */
		lock_start_read( partition->lock );

		/* update the gateways */
		if (partition->dbf.use_table(*partition->db_handle,
					&partition->table_name) < 0) {
			LM_ERR("cannot select table \"%.*s\"\n",
				partition->table_name.len, partition->table_name.s);
			lock_stop_read( partition->lock );
			continue;
		}
		key_cmp[0] = &ds_set_id_col;
		key_cmp[1] = &ds_dest_uri_col;
		key_set = &ds_dest_state_col;

		if (*partition->data) {
			/* Iterate over the groups and the entries of each group */
			for(list = (*partition->data)->sets; list!= NULL; list=list->next){
				for(j=0; j<list->nr; j++) {
					/* If the Flag of the entry is STATE_DIRTY -> flush do db*/
					if ( (list->dlist[j].flags&DS_STATE_DIRTY_DST)==0 )
						/* nothing to do for this destination */
						continue;

					/* populate the update */
					val_cmp[0].val.int_val = list->id;
					val_cmp[1].val.str_val = list->dlist[j].uri;
					val_set.val.int_val =
						(list->dlist[j].flags&DS_INACTIVE_DST) ? 1 :
							((list->dlist[j].flags&DS_PROBING_DST)?2:0);

					/* update the state of this destination */
					LM_DBG("updating the state of destination <%.*s> to %d\n",
						list->dlist[j].uri.len, list->dlist[j].uri.s,
							val_set.val.int_val);

					if (partition->dbf.update(*partition->db_handle,key_cmp,0,
					val_cmp,&key_set,&val_set,2,1)<0 ) {
						LM_ERR("DB update failed\n");
					} else {
						list->dlist[j].flags &= ~DS_STATE_DIRTY_DST;
					}
				}
			}
		}

		lock_stop_read( partition->lock );
	}

	return;
}
