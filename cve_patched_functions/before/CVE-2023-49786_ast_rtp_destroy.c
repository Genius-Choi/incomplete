static int ast_rtp_destroy(struct ast_rtp_instance *instance)
{
	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);

	if (rtp->bundled) {
		struct ast_rtp *bundled_rtp;

		/* We can't hold our instance lock while removing ourselves from the parent */
		ao2_unlock(instance);

		ao2_lock(rtp->bundled);
		bundled_rtp = ast_rtp_instance_get_data(rtp->bundled);
		AST_VECTOR_REMOVE_CMP_UNORDERED(&bundled_rtp->ssrc_mapping, instance, SSRC_MAPPING_ELEM_CMP, AST_VECTOR_ELEM_CLEANUP_NOOP);
		ao2_unlock(rtp->bundled);

		ao2_lock(instance);
		ao2_ref(rtp->bundled, -1);
	}

	rtp_deallocate_transport(instance, rtp);

	/* Destroy the smoother that was smoothing out audio if present */
	if (rtp->smoother) {
		ast_smoother_free(rtp->smoother);
	}

	/* Destroy RTCP if it was being used */
	if (rtp->rtcp) {
		/*
		 * It is not possible for there to be an active RTCP scheduler
		 * entry at this point since it holds a reference to the
		 * RTP instance while it's active.
		 */
		ast_free(rtp->rtcp->local_addr_str);
		ast_free(rtp->rtcp);
	}

	/* Destroy RED if it was being used */
	if (rtp->red) {
		ao2_unlock(instance);
		AST_SCHED_DEL(rtp->sched, rtp->red->schedid);
		ao2_lock(instance);
		ast_free(rtp->red);
		rtp->red = NULL;
	}

	/* Destroy the send buffer if it was being used */
	if (rtp->send_buffer) {
		ast_data_buffer_free(rtp->send_buffer);
	}

	/* Destroy the recv buffer if it was being used */
	if (rtp->recv_buffer) {
		ast_data_buffer_free(rtp->recv_buffer);
	}

	AST_VECTOR_FREE(&rtp->transport_wide_cc.packet_statistics);

	ao2_cleanup(rtp->lasttxformat);
	ao2_cleanup(rtp->lastrxformat);
	ao2_cleanup(rtp->f.subclass.format);
	AST_VECTOR_FREE(&rtp->ssrc_mapping);
	AST_VECTOR_FREE(&rtp->missing_seqno);

	/* Finally destroy ourselves */
	rtp->owner = NULL;
	ast_free(rtp);

	return 0;
}
