void CxImage::Bitfield2RGB(uint8_t *src, uint32_t redmask, uint32_t greenmask, uint32_t bluemask, uint8_t bpp)
{
	switch (bpp){
	case 16:
	{
		uint32_t ns[3]={0,0,0};
		// compute the number of shift for each mask
		for (int32_t i=0;i<16;i++){
			if ((redmask>>i)&0x01) ns[0]++;
			if ((greenmask>>i)&0x01) ns[1]++;
			if ((bluemask>>i)&0x01) ns[2]++;
		}
		ns[1]+=ns[0]; ns[2]+=ns[1];	ns[0]=8-ns[0]; ns[1]-=8; ns[2]-=8;
		// dword aligned width for 16 bit image
		int32_t effwidth2=(((head.biWidth + 1) / 2) * 4);
		uint16_t w;
		int32_t y2,y3,x2,x3;
		uint8_t *p=info.pImage;
		// scan the buffer in reverse direction to avoid reallocations
		for (int32_t y=head.biHeight-1; y>=0; y--){
			y2=effwidth2*y;
			y3=info.dwEffWidth*y;
			for (int32_t x=head.biWidth-1; x>=0; x--){
				x2 = 2*x+y2;
				x3 = 3*x+y3;
				w = (uint16_t)(src[x2]+256*src[1+x2]);
				p[  x3]=(uint8_t)((w & bluemask)<<ns[0]);
				p[1+x3]=(uint8_t)((w & greenmask)>>ns[1]);
				p[2+x3]=(uint8_t)((w & redmask)>>ns[2]);
			}
		}
		break;
	}
	case 32:
	{
		uint32_t ns[3]={0,0,0};
		// compute the number of shift for each mask
		for (int32_t i=8;i<32;i+=8){
			if (redmask>>i) ns[0]++;
			if (greenmask>>i) ns[1]++;
			if (bluemask>>i) ns[2]++;
		}
		// dword aligned width for 32 bit image
		int32_t effwidth4 = head.biWidth * 4;
		int32_t y4,y3,x4,x3;
		uint8_t *p=info.pImage;
		// scan the buffer in reverse direction to avoid reallocations
		for (int32_t y=head.biHeight-1; y>=0; y--){
			y4=effwidth4*y;
			y3=info.dwEffWidth*y;
			for (int32_t x=head.biWidth-1; x>=0; x--){
				x4 = 4*x+y4;
				x3 = 3*x+y3;
				p[  x3]=src[ns[2]+x4];
				p[1+x3]=src[ns[1]+x4];
				p[2+x3]=src[ns[0]+x4];
			}
		}
	}

	}
	return;
}
