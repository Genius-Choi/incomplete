static GF_Err dasher_setup_mpd(GF_DasherCtx *ctx)
{
	u32 i, count;
	GF_MPD_ProgramInfo *info;
	ctx->mpd = gf_mpd_new();
	ctx->mpd->index_mode = ctx->do_index;
	ctx->mpd->segment_duration = (u32) gf_timestamp_rescale(ctx->segdur.num, ctx->segdur.den, 1000);
	ctx->mpd->xml_namespace = "urn:mpeg:dash:schema:mpd:2011";
	ctx->mpd->base_URLs = gf_list_new();
	ctx->mpd->locations = gf_list_new();
	ctx->mpd->program_infos = gf_list_new();
	ctx->mpd->periods = gf_list_new();
	ctx->mpd->use_gpac_ext = ctx->gxns;
	//created by default because we store xmlns in it
	ctx->mpd->x_attributes = gf_list_new();
	if (ctx->buf<0) {
		GF_Fraction segdur = ctx->segdur;
		s32 buf = -ctx->buf;
		if (ctx->no_seg_dur && ctx->from_index) {
			GF_DashStream *ds = gf_list_get(ctx->current_period->streams, 0);
			if (ds && ds->dash_dur.num && ds->dash_dur.den)
				segdur = ds->dash_dur;
		}
		ctx->mpd->min_buffer_time = (u32) ( segdur.num * 10 * buf / segdur.den); //*1000 (ms) / 100 (percent)
	} else
		ctx->mpd->min_buffer_time = ctx->buf;

	GF_SAFEALLOC(info, GF_MPD_ProgramInfo);
	if (info) {
		gf_list_add(ctx->mpd->program_infos, info);
		if (ctx->title)
			info->title = gf_strdup(ctx->title);
		else {
			char tmp[256];
			const char *name = NULL;
			if (ctx->out_path) {
				const char *url = ctx->out_path;
				if (!strncmp(ctx->out_path, "gfio://", 7)) {
					url = gf_fileio_translate_url(ctx->out_path);
					if (!url) url = "";
				}
				name = strrchr(url, '/');
				if (!name) name = strrchr(url, '\\');
				if (!name) name = url;
				else name++;
			}
			snprintf(tmp, 255, "%s generated by GPAC", name ? name : "");
			tmp[255]=0;
			info->title = gf_strdup(tmp);
		}
		if (ctx->cprt) info->copyright = gf_strdup(ctx->cprt);
		if (ctx->info) info->more_info_url = gf_strdup(ctx->info);
		else info->more_info_url = gf_strdup("http://gpac.io");
		if (ctx->source) info->source = gf_strdup(ctx->source);
		if (ctx->lang) info->lang = gf_strdup(ctx->lang);
	}

	count = ctx->location.nb_items;
	for (i=0; i<count; i++) {
		char *l = ctx->location.vals[i];
		gf_list_add(ctx->mpd->locations, gf_strdup(l));
	}
	count = ctx->base.nb_items;
	for (i=0; i<count; i++) {
		GF_MPD_BaseURL *base;
		char *b = ctx->base.vals[i];
		GF_SAFEALLOC(base, GF_MPD_BaseURL);
		if (base) {
			base->URL = gf_strdup(b);
			gf_list_add(ctx->mpd->base_URLs, base);
		}
	}
	return dasher_update_mpd(ctx);
}
