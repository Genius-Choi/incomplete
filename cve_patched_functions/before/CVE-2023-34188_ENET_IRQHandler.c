void ENET_IRQHandler(void) {
  ENET->EIMR = 0;           // Mask interrupts.
  uint32_t eir = ENET->EIR; // Read EIR
  ENET->EIR = 0xffffffff;   // Clear interrupts

  if (eir & EIMR_RX_ERR) // Global mask used
  {
    if (rx_buffer_descriptor[s_rt1020_rxno].control & BIT(15)) {
      ENET->EIMR = EIMR_RX_ERR; // Enable interrupts
      return;  // Empty? -> exit.
    }
    // Read inframes
    else { // Frame received, loop
      for (uint32_t i = 0; i < 10; i++) {  // read as they arrive but not forever
        if (rx_buffer_descriptor[s_rt1020_rxno].control & BIT(15)) break;  // exit when done
        // Process if CRC OK and frame not truncated
        if (!(rx_buffer_descriptor[s_rt1020_rxno].control & (BIT(2) | BIT(0)))) {
          uint32_t len = (rx_buffer_descriptor[s_rt1020_rxno].length);
          mg_tcpip_qwrite(rx_buffer_descriptor[s_rt1020_rxno].buffer, len > 4 ? len - 4 : len, s_ifp);
        }
        rx_buffer_descriptor[s_rt1020_rxno].control |= BIT(15); // Inform DMA RX is empty
        if (++s_rt1020_rxno >= ENET_RXBD_NUM) s_rt1020_rxno = 0;
      }
    }
  }
  ENET->EIMR = EIMR_RX_ERR; // Enable interrupts
}
