    int DrachtioController::processMessageStatelessly( msg_t* msg, sip_t* sip ) {
        int rc = 0 ;
        if (m_pBlacklist) {
            string host;
            getSourceAddressForMsg(msg, host);
            if (m_pBlacklist->isBlackListed(host.c_str())) {
                return -1;
            }
        }
        DR_LOG(log_debug) << "processMessageStatelessly - incoming message with call-id " << sip->sip_call_id->i_id <<
            " does not match an existing call leg, processed in thread " << std::this_thread::get_id()  ;

        tport_t* tp_incoming = nta_incoming_transport(m_nta, NULL, msg );
        tport_t* tp = tport_parent( tp_incoming ) ;
        const tp_name_t* tpn = tport_name( tp );
        tport_unref( tp_incoming ) ;

        if( sip->sip_request ) {
            
            // sofia sanity check on message format
            if( sip_sanity_check(sip) < 0 ) {
                DR_LOG(log_error) << "DrachtioController::processMessageStatelessly: invalid incoming request message; discarding call-id " << sip->sip_call_id->i_id ;
                STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_RESPONSES_OUT, {{"method", sip->sip_request->rq_method_name},{"code", "400"}})
                nta_msg_treply( m_nta, msg, 400, NULL, TAG_END() ) ;
                return -1 ;
            }

            // spammer check
            string action, tcpAction ;
            DrachtioConfig::mapHeader2Values& mapSpammers =  m_Config->getSpammers( action, tcpAction );
            if( mapSpammers.size() > 0 ) {
                if( 0 == strcmp( tpn->tpn_proto, "tcp") || 0 == strcmp( tpn->tpn_proto, "ws") || 0 == strcmp( tpn->tpn_proto, "wss") ) {
                    if( tcpAction.length() > 0 ) {
                        action = tcpAction ;
                    }
                }

                try {
                    for( DrachtioConfig::mapHeader2Values::iterator it = mapSpammers.begin(); mapSpammers.end() != it; ++it ) {
                        string hdrName = it->first ;
                        vector<string> vecValue = it->second ;

                        // currently limited to looking at User-Agent, From, and To
                        if( 0 == hdrName.compare("user-agent") && sip->sip_user_agent && sip->sip_user_agent->g_string ) {
                            for( std::vector<string>::iterator it = vecValue.begin(); it != vecValue.end(); ++it ) {
                                if( NULL != strstr( sip->sip_user_agent->g_string, (*it).c_str() ) ) {
                                    throw runtime_error(sip->sip_user_agent->g_string) ;
                                }
                            }
                        }
                        if( 0 == hdrName.compare("to") && sip->sip_to && sip->sip_to->a_url->url_user ) {
                            for( std::vector<string>::iterator it = vecValue.begin(); it != vecValue.end(); ++it ) {
                                if( NULL != strstr( sip->sip_to->a_url->url_user, (*it).c_str() ) ) {
                                    throw runtime_error(sip->sip_to->a_url->url_user) ;
                                }
                            }
                        }
                        if( 0 == hdrName.compare("from") && sip->sip_from && sip->sip_from->a_url->url_user ) {
                            for( std::vector<string>::iterator it = vecValue.begin(); it != vecValue.end(); ++it ) {
                                if( NULL != strstr( sip->sip_from->a_url->url_user, (*it).c_str() ) ) {
                                    throw runtime_error(sip->sip_from->a_url->url_user) ;
                                }
                            }
                        }
                    }
                } catch( runtime_error& err ) {
                    nta_incoming_t* irq = nta_incoming_create( m_nta, NULL, msg, sip, NTATAG_TPORT(tp), TAG_END() ) ;
                    if (sip->sip_request->rq_method != sip_method_ack) {
                        const char* remote_host = nta_incoming_remote_host(irq);
                        const char *remote_port = nta_incoming_remote_port(irq);
                        const char* what = err.what();
                        if (remote_host && remote_port && what) {
                            DR_LOG(log_notice) << "DrachtioController::processMessageStatelessly: detected potential spammer from " <<
                                nta_incoming_remote_host(irq) << ":" << nta_incoming_remote_port(irq)  << 
                                " due to header value: " << err.what()  ;
                        }
                        STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_RESPONSES_OUT, {{"method", sip->sip_request->rq_method_name},{"code", "603"}})
                        nta_incoming_treply( irq, 603, "Decline", TAG_END() ) ;
                        nta_incoming_destroy(irq) ;   

                        /*
                        if( 0 == action.compare("reject") ) {
                            nta_msg_treply( m_nta, msg, 603, NULL, TAG_END() ) ;
                        }
                        */
                        return -1 ;
                    }
                }
            }

            if( sip->sip_route && sip->sip_to->a_tag != NULL && url_has_param(sip->sip_route->r_url, "lr") ) {

                //check if we are in the first Route header, and the request-uri is not us; if so proxy accordingly
                bool hostMatch = 
                  (0 == strcmp( tpn->tpn_host, sip->sip_route->r_url->url_host ) || 
                  (tpn->tpn_canon && 0 == strcmp( tpn->tpn_canon, sip->sip_route->r_url->url_host )));
                bool portMatch = 
                  (tpn->tpn_port && sip->sip_route->r_url->url_port && 0 == strcmp(tpn->tpn_port,sip->sip_route->r_url->url_port)) ||
                  (!tpn->tpn_port && !sip->sip_route->r_url->url_port) ||
                  (!tpn->tpn_port && 0 == strcmp(sip->sip_route->r_url->url_port, "5060")) ||
                  (!sip->sip_route->r_url->url_port && 0 == strcmp(tpn->tpn_port, "5060")) ;


                if( /*hostMatch && portMatch && */ SipTransport::isLocalAddress(sip->sip_route->r_url->url_host)) {
                    //request within an established dialog in which we are a stateful proxy
                    if( !m_pProxyController->processRequestWithRouteHeader( msg, sip ) ) {
                       nta_msg_discard( m_nta, msg ) ;                
                    }          
                    return 0 ;          
                }
                DR_LOG(log_warning) << "DrachtioController::processMessageStatelessly: discarding incoming message with Route header as we do not match the first route";
            }

            if( m_pProxyController->isProxyingRequest( msg, sip ) ) {
                //CANCEL or other request within a proxy transaction
                m_pProxyController->processRequestWithoutRouteHeader( msg, sip ) ;
            }
            else {
                switch (sip->sip_request->rq_method ) {
                    case sip_method_invite:
                    case sip_method_register:
                    case sip_method_message:
                    case sip_method_options:
                    case sip_method_info:
                    case sip_method_notify:
                    case sip_method_subscribe:
                    case sip_method_publish:
                    {
                        if( m_pPendingRequestController->isRetransmission( sip ) ||
                            m_pProxyController->isRetransmission( sip ) ) {
                        
                            DR_LOG(log_info) << "discarding retransmitted request: " << sip->sip_call_id->i_id  ;
                            int ret = sip_method_invite == sip->sip_request->rq_method ? 100 : -1 ;
                            nta_msg_discard(m_nta, msg) ;  
                            return ret ;
                        }

                        if( sip_method_invite == sip->sip_request->rq_method ) {
                            nta_msg_treply( m_nta, msg_ref_create( msg ), 100, NULL, TAG_END() ) ;  
                            if (m_bAlwaysSend180) nta_msg_treply( m_nta, msg_ref_create( msg ), 180, NULL, TAG_END() ) ;  
                        }
                        if (sip_method_options == sip->sip_request->rq_method && sip->sip_user_agent && sip->sip_user_agent->g_string) {
                            if (0 == m_strUserAgentAutoAnswerOptions.compare(sip->sip_user_agent->g_string)) {
                                nta_msg_treply( m_nta, msg, 200, NULL, TAG_END() ) ;
                                return -1 ;
                            }
                        }

                        string transactionId ;
                        int status = m_pPendingRequestController->processNewRequest( msg, sip, tp_incoming, transactionId ) ;

                        //write attempt record	
                        if( status >= 0 && sip->sip_request->rq_method == sip_method_invite ) {	
                            Cdr::postCdr( std::make_shared<CdrAttempt>( msg, "network" ) );	
                        }
                        
                        //reject message if necessary, write stop record
                        if( status > 0  ) {
                            bool isInvite = sip->sip_request->rq_method == sip_method_invite;
                            msg_t* reply = nta_msg_create(m_nta, 0) ;
                            msg_ref_create(reply) ;
                            nta_msg_mreply( m_nta, reply, sip_object(reply), status, NULL, msg, TAG_END() ) ;

                            if( isInvite ) {
                                Cdr::postCdr( std::make_shared<CdrStop>( reply, "application", Cdr::call_rejected ) );
                            }
                            msg_destroy(reply) ;
                           return 0;
                        }
                    }
                    break ;

                    case sip_method_prack:
                        assert(0) ;//should not get here
                    break ;

                    case sip_method_cancel:
                    {
                        std::shared_ptr<PendingRequest_t> p = m_pPendingRequestController->findInviteByCallId( sip->sip_call_id->i_id ) ;
                        if( p ) {
                            DR_LOG(log_info) << "received quick cancel for invite that is out to client for disposition: " << sip->sip_call_id->i_id  ;

                            string encodedMessage ;
                            EncodeStackMessage( sip, encodedMessage ) ;
                            SipMsgData_t meta( msg ) ;

                            client_ptr client = m_pClientController->findClientForNetTransaction(p->getTransactionId()); 
                            if(client) {
                                void (BaseClient::*fn)(const string&, const string&, const SipMsgData_t&) = &BaseClient::sendSipMessageToClient;
                                m_pClientController->getIOService().post( std::bind(fn, client, p->getTransactionId(), encodedMessage, meta)) ;
                            }

                            STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_RESPONSES_OUT, {{"method", sip->sip_request->rq_method_name},{"code", "200"}})
                            nta_msg_treply( m_nta, msg, 200, NULL, TAG_END() ) ;  
                            p->cancel() ;
                            STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_RESPONSES_OUT, {{"method", "INVITE"},{"code", "487"}})
                            nta_msg_treply( m_nta, msg_dup(p->getMsg()), 487, NULL, TAG_END() ) ;
                        }
                        else {
                            STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_RESPONSES_OUT, {{"method", sip->sip_request->rq_method_name},{"code", "481"}})
                            nta_msg_treply( m_nta, msg, 481, NULL, TAG_END() ) ;                              
                        }
                    }
                    break ;
                    
                    case sip_method_update:
                    case sip_method_bye:
                        STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_RESPONSES_OUT, {{"method", sip->sip_request->rq_method_name},{"code", "481"}})
                        nta_msg_treply( m_nta, msg, 481, NULL, TAG_END() ) ;   
                        break;                           


                    default:
                        nta_msg_discard( m_nta, msg ) ;
                    break ;
                }             
            }
        }
        else {
            if( !m_pProxyController->processResponse( msg, sip ) ) {
                if( sip->sip_via->v_next ) {
                    DR_LOG(log_error) << "processMessageStatelessly - forwarding response upstream" ;
                    nta_msg_tsend( m_nta, msg, NULL, TAG_END() ) ; 
                }
                else {
                    DR_LOG(log_error) << "processMessageStatelessly - unknown response (possibly late arriving?) - discarding" ;
                    nta_msg_discard( m_nta, msg ) ;                    
                }
            } 
        }
        return rc ;
    }
