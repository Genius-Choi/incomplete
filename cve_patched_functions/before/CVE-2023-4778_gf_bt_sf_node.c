GF_Node *gf_bt_sf_node(GF_BTParser *parser, char *node_name, GF_Node *parent, char *szDEFName)
{
	u32 tag, ID;
	Bool is_script, replace_prev, register_def;
	GF_Proto *proto;
	GF_Node *node, *newnode, *undef_node;
	GF_FieldInfo info;
	Bool init_node;
	char *name;
	char * str;

	init_node = 0;

	if (node_name) {
		str = node_name;
	} else {
		str = gf_bt_get_next(parser, 0);
	}
	name = NULL;
	if (!strcmp(str, "NULL")) return NULL;

	ID = 0;
	register_def = 0;
	replace_prev = 0;
	undef_node = NULL;
	if (!strcmp(str, "DEF")) {
		register_def = 1;
		str = gf_bt_get_next(parser, 0);
		name = gf_strdup(str);
		str = gf_bt_get_next(parser, 0);
	} else if (szDEFName) {
		name = gf_strdup(szDEFName);
		register_def = 1;
	}
	if (name) {
		undef_node = gf_sg_find_node_by_name(parser->load->scene_graph, name);
		if (undef_node) {
			gf_list_del_item(parser->peeked_nodes, undef_node);
			ID = gf_node_get_id(undef_node);
			/*if we see twice a DEF N1 then force creation of a new node*/
			if (gf_bt_has_been_def(parser, name)) {
				undef_node = NULL;
				ID = gf_bt_get_def_id(parser, name);
				gf_bt_report(parser, GF_OK, "Node %s has been DEFed several times, IDs may get corrupted", name);
			}
		} else {
			ID = gf_bt_get_def_id(parser, name);
		}
	}
	else if (!strcmp(str, "USE")) {
		str = gf_bt_get_next(parser, 0);
		node = gf_sg_find_node_by_name(parser->load->scene_graph, str);
		if (!node) {
			/*create a temp node (undefined)*/
			node = gf_node_new(parser->load->scene_graph, TAG_UndefinedNode);
			ID = gf_bt_get_def_id(parser, str);
			gf_node_set_id(node, ID, str);
			gf_node_register(node, NULL);
			gf_list_add(parser->undef_nodes, node);
		}
		gf_node_register(node, parent);
		return node;
	}
	proto = NULL;
	tag = gf_bt_get_node_tag(parser, str);
	if (!tag) {
		GF_SceneGraph *sg = parser->load->scene_graph;
		while (1) {
			proto = gf_sg_find_proto(sg, 0, str);
			if (proto) break;
			sg = sg->parent_scene;
			if (!sg) break;
		}
		if (!proto) {
			/*locate proto*/
			gf_bt_report(parser, GF_BAD_PARAM, "%s: not a valid/supported node", str);
			return NULL;
		}
		tag = TAG_ProtoNode;
	}
	if (undef_node && (undef_node->sgprivate->tag == tag)) {
		node = undef_node;
	} else {
		if (undef_node) replace_prev = 1;
		if (proto) {
			node = gf_sg_proto_create_instance(parser->load->scene_graph, proto);
		} else {
			node = gf_node_new(parser->load->scene_graph, tag);
		}
		if (!parser->parsing_proto) init_node = 1;
	}
	is_script = 0;
	if ((tag==TAG_MPEG4_Script)
#ifndef GPAC_DISABLE_X3D
	        || (tag==TAG_X3D_Script)
#endif
	   )
		is_script = 1;

	if (!node) {
		parser->last_error = GF_SG_UNKNOWN_NODE;
		return NULL;
	}
	if (register_def) gf_list_add(parser->def_nodes, node);

	gf_node_register(node, parent);

	/*VRML: "The transformation hierarchy shall be a directed acyclic graph; results are undefined if a node
	in the transformation hierarchy is its own ancestor"
	that's good, because the scene graph can't handle cyclic graphs (destroy will never be called).
	However we still have to register the node before parsing it, to update node registry and get correct IDs*/
	if (name) {
		if (!undef_node || replace_prev) {
			gf_node_set_id(node, ID, name);
		}
		gf_free(name);
		name = NULL;
	}
	if (!parser->parsing_proto) gf_bt_update_timenode(parser, node);

	if (gf_bt_check_code(parser, '{')) {

		while (1) {
			if (gf_bt_check_code(parser, '}'))
				break;

			str = gf_bt_get_next(parser, 0);
			if (!str) {
				gf_bt_report(parser, GF_BAD_PARAM, "Invalid node syntax");
				goto err;
			}
			/*VRML/X3D specific */
			if (parser->is_wrl) {
				/*we ignore bboxCenter and bboxSize*/
				if (!strcmp(str, "bboxCenter") || !strcmp(str, "bboxSize")) {
					Fixed f;
					gf_bt_parse_float(parser, "x", &f);
					gf_bt_parse_float(parser, "y", &f);
					gf_bt_parse_float(parser, "z", &f);
					continue;
				}
				/*some VRML files declare routes almost anywhere*/
				if (!strcmp(str, "ROUTE")) {
					gf_bt_parse_route(parser, 1, 0, NULL);
					continue;
				}
			}

			parser->last_error = gf_node_get_field_by_name(node, str, &info);

			/*check common VRML fields removed in MPEG4*/
			if (parser->last_error) {
				if (!parser->is_wrl) {
					/*we ignore 'solid' for MPEG4 box/cone/etc*/
					if (!strcmp(str, "solid")) {
						SFBool b;
						gf_bt_parse_bool(parser, "solid", &b);
						parser->last_error = GF_OK;
						continue;
					}
					/*we ignore 'description' for MPEG4 sensors*/
					else if (!strcmp(str, "description")) {
						char *tmpstr = gf_bt_get_string(parser, 0);
						gf_free(tmpstr);
						parser->last_error = GF_OK;
						continue;
					}
					/*remaps X3D to old VRML/MPEG4*/
					else if ((tag==TAG_MPEG4_LOD) && !strcmp(str, "children")) {
						str = "level";
						parser->last_error = gf_node_get_field_by_name(node, str, &info);
					}
					else if ((tag==TAG_MPEG4_Switch) && !strcmp(str, "children")) {
						str = "choice";
						parser->last_error = gf_node_get_field_by_name(node, str, &info);
					}
					else if (!strcmp(str, "enabled")) {
						SFBool b;
						gf_bt_parse_bool(parser, "collide", &b);
						parser->last_error = GF_OK;
						continue;
					}
				} else {
					/*remaps old VRML/MPEG4 to X3D if possible*/
#ifndef GPAC_DISABLE_X3D
					if ((tag==TAG_X3D_LOD) && !strcmp(str, "level")) {
						str = "children";
						parser->last_error = gf_node_get_field_by_name(node, str, &info);
					}
					else if ((tag==TAG_X3D_Switch) && !strcmp(str, "choice")) {
						str = "children";
						parser->last_error = gf_node_get_field_by_name(node, str, &info);
					}
					else
#endif
						if (!strcmp(str, "collide")) {
							SFBool b;
							gf_bt_parse_bool(parser, "enabled", &b);
							parser->last_error = GF_OK;
							continue;
						}
				}
			}

			if (is_script && parser->last_error) {
				u32 eType, fType;

				if (!strcmp(str, "eventIn") || !strcmp(str, "inputOnly")) eType = GF_SG_SCRIPT_TYPE_EVENT_IN;
				else if (!strcmp(str, "eventOut") || !strcmp(str, "outputOnly")) eType = GF_SG_SCRIPT_TYPE_EVENT_OUT;
				else if (!strcmp(str, "field") || !strcmp(str, "initializeOnly")) eType = GF_SG_SCRIPT_TYPE_FIELD;
				else {
					gf_bt_report(parser, GF_BAD_PARAM, "%s: Unknown script event type", str);
					goto err;
				}
				str = gf_bt_get_next(parser, 0);
				fType = gf_sg_field_type_by_name(str);
				if (fType==GF_SG_VRML_UNKNOWN) {
					gf_bt_report(parser, GF_BAD_PARAM, "%s: Unknown script field type", str);
					goto err;
				}
				parser->last_error = GF_OK;
				str = gf_bt_get_next(parser, 0);
				gf_sg_script_field_new(node, eType, fType, str);
				parser->last_error = gf_node_get_field_by_name(node, str, &info);

				if (parser->parsing_proto && gf_bt_set_field_is(parser, &info, node)) continue;
				if ((eType == GF_SG_SCRIPT_TYPE_EVENT_IN) || (eType == GF_SG_SCRIPT_TYPE_EVENT_OUT)) continue;
			}

			if (parser->last_error) {
				gf_bt_report(parser, parser->last_error, "%s: Unknown field", str);
				goto err;
			}

			if (proto) gf_sg_proto_mark_field_loaded(node, &info);
			if (parser->parsing_proto && gf_bt_set_field_is(parser, &info, node)) continue;

			switch (info.fieldType) {
			case GF_SG_VRML_SFNODE:
				/*if redefining node reset it - this happens with CreateVrmlFromString*/
				if (* ((GF_Node **)info.far_ptr) ) {
					gf_node_unregister(* ((GF_Node **)info.far_ptr), node);
					* ((GF_Node **)info.far_ptr) = NULL;
				}

				newnode = gf_bt_sf_node(parser, NULL, node, NULL);
				if (!newnode && parser->last_error) goto err;
				if (newnode) {
					if (!gf_bt_check_ndt(parser, &info, newnode, node)) goto err;

					* ((GF_Node **)info.far_ptr) = newnode;
				}
				break;
			case GF_SG_VRML_MFNODE:
			{
				GF_ChildNodeItem *last = NULL;
				Bool single_child = 0;
				if (!gf_bt_check_code(parser, '[')) {
					if (parser->is_wrl) single_child = 1;
					else break;
				}

				/*if redefining node reset it - this happens with CreateVrmlFromString*/
				if (undef_node==node) {
					gf_node_unregister_children(node, *(GF_ChildNodeItem **)info.far_ptr);
					*(GF_ChildNodeItem **)info.far_ptr = NULL;
				}

				while (single_child || !gf_bt_check_code(parser, ']')) {
					/*VRML seems to allow that*/
					gf_bt_check_code(parser, ',');
					newnode = gf_bt_sf_node(parser, NULL, node, NULL);
					if (!newnode && parser->last_error) goto err;
					if (newnode) {
						if (!gf_bt_check_ndt(parser, &info, newnode, node)) goto err;
						gf_node_list_add_child_last( (GF_ChildNodeItem **)info.far_ptr, newnode, &last);
					}
					if (single_child) break;
				}
			}
			break;
			default:
				if (gf_sg_vrml_is_sf_field(info.fieldType)) {
					gf_bt_sffield(parser, &info, node);
				} else {
					gf_bt_mffield(parser, &info, node);
				}
				if (parser->last_error) goto err;
				break;
			}
			/*VRML seems to allow that*/
			gf_bt_check_code(parser, ',');
		}
	}
	/*VRML seems to allow that*/
	gf_bt_check_code(parser, ',');

	/*we must init the node once ID is set in case we're creating rendering stacks*/
	if (init_node && (gf_node_get_tag(node)!=TAG_ProtoNode) ) gf_node_init(node);

	/*remove temp node*/
	if (replace_prev) {
		gf_node_replace(undef_node, node, 0);
		gf_node_unregister(undef_node, NULL);
		gf_list_del_item(parser->undef_nodes, undef_node);
	}

	if (!parser->parsing_proto && is_script && (parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) ) {
		if (parser->cur_com) {
			if (!parser->cur_com->scripts_to_load) parser->cur_com->scripts_to_load = gf_list_new();
			gf_list_add(parser->cur_com->scripts_to_load, node);
		} else {
			/*postpone script init since it may use routes/nodes not yet defined ...*/
			gf_list_add(parser->scripts, node);
		}
	}
	/*For Ivica: load proto as soon as found when in playback mode*/
	if ( (parser->load->flags & GF_SM_LOAD_FOR_PLAYBACK) && proto && !parser->parsing_proto) {
		parser->last_error = gf_sg_proto_load_code(node);
	}
	return node;

err:
	gf_node_unregister(node, parent);
	if (name) gf_free(name);
	return NULL;
}
