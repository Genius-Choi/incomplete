static int sec_firmware_check_copy_loadable(const void *sec_firmware_img,
					    u32 *loadable_l, u32 *loadable_h)
{
	phys_addr_t sec_firmware_loadable_addr = 0;
	int conf_node_off, ld_node_off, images;
	char *conf_node_name = NULL;
	const void *data;
	size_t size;
	ulong load;
	const char *name, *str, *type;
	int len;

	conf_node_name = SEC_FIRMWARE_FIT_CNF_NAME;

	conf_node_off = fit_conf_get_node(sec_firmware_img, conf_node_name);
	if (conf_node_off < 0) {
		printf("SEC Firmware: %s: no such config\n", conf_node_name);
		return -ENOENT;
	}

	/* find the node holding the images information */
	images = fdt_path_offset(sec_firmware_img, FIT_IMAGES_PATH);
	if (images < 0) {
		printf("%s: Cannot find /images node: %d\n", __func__, images);
		return -1;
	}

	type = FIT_LOADABLE_PROP;

	name = fdt_getprop(sec_firmware_img, conf_node_off, type, &len);
	if (!name) {
		/* Loadables not present */
		return 0;
	}

	printf("SEC Firmware: '%s' present in config\n", type);

	for (str = name; str && ((str - name) < len);
	     str = strchr(str, '\0') + 1) {
		printf("%s: '%s'\n", type, str);
		ld_node_off = fdt_subnode_offset(sec_firmware_img, images, str);
		if (ld_node_off < 0) {
			printf("cannot find image node '%s': %d\n", str,
			       ld_node_off);
			return -EINVAL;
		}

		/* Verify secure firmware image */
		if (!(fit_image_verify(sec_firmware_img, ld_node_off))) {
			printf("SEC Loadable: Bad loadable image (bad CRC)\n");
			return -EINVAL;
		}

		if (fit_image_get_data(sec_firmware_img, ld_node_off,
				       &data, &size)) {
			printf("SEC Loadable: Can't get subimage data/size");
			return -ENOENT;
		}

		/* Get load address, treated as load offset to secure memory */
		if (fit_image_get_load(sec_firmware_img, ld_node_off, &load)) {
			printf("SEC Loadable: Can't get subimage load");
			return -ENOENT;
		}

		/* Compute load address for loadable in secure memory */
		sec_firmware_loadable_addr = (sec_firmware_addr -
						gd->arch.tlb_size) + load;

		/* Copy loadable to secure memory and flush dcache */
		debug("%s copied to address 0x%p\n",
		      FIT_LOADABLE_PROP, (void *)sec_firmware_loadable_addr);
		memcpy((void *)sec_firmware_loadable_addr, data, size);
		flush_dcache_range(sec_firmware_loadable_addr,
				   sec_firmware_loadable_addr + size);

		/* Populate loadable address only for Trusted OS */
		if (!strcmp(str, "trustedOS@1")) {
			/*
			 * Populate address ptrs for loadable image with
			 * loadbale addr
			 */
			out_le32(loadable_l, (sec_firmware_loadable_addr &
					      WORD_MASK));
			out_le32(loadable_h, (sec_firmware_loadable_addr >>
					      WORD_SHIFT));
		}
	}

	return 0;
}
