bool ARMFrameLowering::assignCalleeSavedSpillSlots(
    MachineFunction &MF, const TargetRegisterInfo *TRI,
    std::vector<CalleeSavedInfo> &CSI) const {
  // For CMSE entry functions, handle floating-point context as if it was a
  // callee-saved register.
  if (STI.hasV8_1MMainlineOps() &&
      MF.getInfo<ARMFunctionInfo>()->isCmseNSEntryFunction()) {
    CSI.emplace_back(ARM::FPCXTNS);
    CSI.back().setRestored(false);
  }

  // For functions, which sign their return address, upon function entry, the
  // return address PAC is computed in R12. Treat R12 as a callee-saved register
  // in this case.
  const auto &AFI = *MF.getInfo<ARMFunctionInfo>();
  if (AFI.shouldSignReturnAddress()) {
    // The order of register must match the order we push them, because the
    // PEI assigns frame indices in that order. When compiling for return
    // address sign and authenication, we use split push, therefore the orders
    // we want are:
    // LR, R7, R6, R5, R4, <R12>, R11, R10,  R9,  R8, D15-D8
    CSI.insert(find_if(CSI,
                       [=](const auto &CS) {
                         Register Reg = CS.getReg();
                         return Reg == ARM::R10 || Reg == ARM::R11 ||
                                Reg == ARM::R8 || Reg == ARM::R9 ||
                                ARM::DPRRegClass.contains(Reg);
                       }),
               CalleeSavedInfo(ARM::R12));
  }

  return false;
}
