int IniParser::write_helper(IniSection&ini, ofstream&of, int depth)
{
    char * out_buffer;
    string indent;
    string indent2;
    int readby = ini.getReadBy ();
    if (!subindent.empty ())
    {
	for (int ii = 0; ii<depth - 1;ii++)
	    indent = indent + subindent;
	if (depth)
	    indent2 = indent + subindent;
    }

    if (ini.getComment ()[0])
        of << ini.getComment();
    if (readby>=0 && readby < (int)sections.size ())
	{
	    asprintf (&out_buffer, sections[readby].begin.out.c_str (), ini.getName());
	    of << indent << out_buffer << "\n";
	    free (out_buffer);
	}
    
    IniIterator
	ci = ini.getContainerBegin (),
	ce = ini.getContainerEnd ();

    for (;ci != ce; ++ci)
	{
	    if (ci->t () == SECTION)
		{
		    write_helper (ci->s (), of, depth + 1);
		    ci->s ().clean();
		}
	    else
		{
		    IniEntry&e = ci->e ();
		    if (e.getComment ()[0])
			of << e.getComment();
		    if (e.getReadBy()>=0 && e.getReadBy() < (int)params.size ()) {
			// bnc#492859, a fixed buffer is too small
			asprintf (&out_buffer, params[e.getReadBy ()].line.out.c_str (), e.getName(), e.getValue());
			of << indent2 << out_buffer << "\n";
			free(out_buffer);
		    }
		    e.clean();
		}
	}

    if (ini.getEndComment ()[0])
        of << indent << ini.getEndComment();
    if (readby>=0 && readby < (int) sections.size () && sections[readby].end_valid)
	{
	    asprintf (&out_buffer, sections[readby].end.out.c_str (), ini.getName());
	    of << indent << out_buffer << "\n";
	    free(out_buffer);
	}
    ini.clean();
    return 0;
}
