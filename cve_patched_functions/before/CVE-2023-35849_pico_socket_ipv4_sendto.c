int pico_socket_ipv4_sendto(struct pico_socket *s, void *buf, uint32_t len, void *dst)
{
    struct pico_frame *f;
    struct pico_socket_ipv4 *s4 = (struct pico_socket_ipv4 *)s;
    (void)dst;
    if (!s4->hdr_included && (s4->proto == PICO_PROTO_IPV4)) {
       /* Raw socket: no send allowed withouth IP_HDRINCL, or if protocol is IPPROTO_IP */
        pico_err = PICO_ERR_EINVAL;
        return -1;
    }

    if (len > pico_socket_get_mss(s)) {
        pico_err = PICO_ERR_EMSGSIZE;
        return -1;
    }

    if (!s4->hdr_included) {
        f = pico_proto_ipv4.alloc(s->stack, &pico_proto_ipv4, NULL, (uint16_t)(len));
        if (!f)
            return -1;
        memcpy(f->transport_hdr, (const uint8_t *)buf, len);
        f->transport_len = (uint16_t)len;
        f->sock = s;
        if (dst) {
            f->info = PICO_ZALLOC(sizeof(struct pico_remote_endpoint));
            if (f->info == NULL) {
                pico_frame_discard(f);
                pico_err = PICO_ERR_ENOMEM;
                return -1;
            }
            memcpy(f->info, dst, sizeof(struct pico_remote_endpoint));
        }
        if (pico_ipv4_frame_sock_push_ex(s->stack, &pico_proto_ipv4, f, s4->proto) > 0)
            return (int)len;
        else
            return -1;
    }

    /* Allocate packet and send */
    f = pico_proto_ethernet.alloc(s->stack, &pico_proto_ethernet, NULL, (uint16_t)(len));
    if (!f) {
        return -1;
    }
    memcpy(f->net_hdr, (const uint8_t *)buf, len);
    f->start = f->net_hdr;
    f->len = len;
    if (pico_socket_ipv4_process_out(s, f) > 0)
        return (int)len;
    else
        return -1;
}
