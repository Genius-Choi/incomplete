dissect_bgp_path_attr(proto_tree *subtree, tvbuff_t *tvb, guint16 path_attr_len, guint tvb_off, packet_info *pinfo)
{
    guint8        bgpa_flags;                 /* path attributes          */
    guint8        bgpa_type;
    gint          o;                          /* packet offset            */
    gint          q=0;                        /* tmp                      */
    gint          end=0;                      /* message end              */
    int           advance;                    /* tmp                      */
    proto_item    *ti;                        /* tree item                */
    proto_item    *ti_communities;            /* tree communities         */
    proto_item    *ti_community;              /* tree for each community  */
    proto_item    *ti_as;                     /* tree for each as         */
    proto_item    *attr_len_item;
    proto_item    *aigp_type_item;
    proto_tree    *subtree2;                  /* path attribute subtree   */
    proto_tree    *subtree3;                  /* subtree for attributes   */
    proto_tree    *subtree4;                  /* subtree for attributes   */
    proto_tree    *subtree5;                  /* subtree for attributes   */
    proto_tree    *subtree6;                  /* subtree for attributes   */
    proto_tree    *subtree7;                  /* subtree for attributes   */
    proto_tree    *subtree8;                  /* subtree for attributes   */
    proto_tree    *attr_set_subtree;          /* subtree for attr_set     */
    proto_tree    *as_path_segment_tree;      /* subtree for AS_PATH segments */
    gint          number_as_segment=0;        /* Number As segment        */
    proto_tree    *communities_tree;          /* subtree for COMMUNITIES  */
    proto_tree    *community_tree;            /* subtree for a community  */
    proto_tree    *cluster_list_tree;         /* subtree for CLUSTER_LIST */
    int           i=0, j, k;                  /* tmp                      */
    guint8        type=0;                     /* AS_PATH segment type     */
    guint8        length=0;                   /* AS_PATH segment length   */
    guint32       aggregator_as;
    guint16       ssa_type;                   /* SSA T + Type */
    guint16       ssa_len;                    /* SSA TLV Length */
    guint8        ssa_v3_len;                 /* SSA L2TPv3 Cookie Length */
    guint16       encaps_tunnel_type;         /* Encapsulation Tunnel Type */
    guint16       encaps_tunnel_len;          /* Encapsulation TLV Length */
    guint8        encaps_tunnel_subtype;      /* Encapsulation Tunnel Sub-TLV Type */
    guint16       encaps_tunnel_sublen;       /* Encapsulation TLV Sub-TLV Length */
    guint16       encaps_tunnel_sub_totallen; /* Encapsulation TLV Sub-TLV Length + Type + Length field */
    guint8        aigp_type;                  /* AIGP TLV type from AIGP attribute */
    guint8        prefix_sid_subtype;         /* BGP Prefix-SID TLV Type */
    guint16       prefix_sid_sublen;          /* BGP Prefix-SID TLV Length */
    gint          prefix_sid_sub_tlv_offset;  /* BGP Prefix-SID SRGB Length */
    gint          check_srgb;                 /* BGP Prefix-SID SRGB counter */
    guint16       secpathlen;                 /* BGPsec Secure Path length */
    guint16       sigblocklen;                /* BGPsec Signature Block length */
    guint8        secpathcount;               /* Number of Secure Path Segments */
    guint16       sig_len;                    /* Length of BGPsec Signature */
    guint32       segment_subtlv_type;        /* Segment List SubTLV Type */
    guint32       segment_subtlv_length;      /* Segment List SubTLV Length */
    guint8        srv6_service_subtlv_type;         /* SRv6 Service Sub-TLV type */
    guint16       srv6_service_subtlv_len;          /* SRv6 Service Sub-TLV length */
    guint8        srv6_service_data_subsubtlv_type; /* SRv6 Service Data Sub-Sub-TLV type */
    guint16       srv6_service_data_subsubtlv_len;  /* SRv6 Service Data Sub-Sub-TLV length */

    o = tvb_off;

    while (i < path_attr_len) {
        proto_item *ti_pa, *ti_flags;
        int     off;
        gint    alen, aoff, tlen, aoff_save;
        guint8  snpa;
        guint8  nexthop_len;
        guint8  asn_len = 0;
        guint32 af, saf, as_num;

        static int * const path_flags[] = {
            &hf_bgp_update_path_attribute_flags_optional,
            &hf_bgp_update_path_attribute_flags_transitive,
            &hf_bgp_update_path_attribute_flags_partial,
            &hf_bgp_update_path_attribute_flags_extended_length,
            &hf_bgp_update_path_attribute_flags_unused,
            NULL
        };

        bgpa_flags = tvb_get_guint8(tvb, o + i);
        bgpa_type = tvb_get_guint8(tvb, o + i+1);

        /* check for the Extended Length bit */
        if (bgpa_flags & BGP_ATTR_FLAG_EXTENDED_LENGTH) {
            alen = tvb_get_ntohs(tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE);
            aoff = BGP_SIZE_OF_PATH_ATTRIBUTE+2;
        } else {
            alen = tvb_get_guint8(tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE);
            aoff = BGP_SIZE_OF_PATH_ATTRIBUTE+1;
        }
        tlen = alen;

        ti_pa = proto_tree_add_item(subtree, hf_bgp_update_path_attribute, tvb, o + i, tlen + aoff, ENC_NA);
        proto_item_append_text(ti_pa, " - %s", val_to_str(bgpa_type, bgpattr_type, "Unknown (%u)"));

        subtree2 = proto_item_add_subtree(ti_pa, ett_bgp_attr);

        ti_flags = proto_tree_add_bitmask(subtree2, tvb, o + i, hf_bgp_update_path_attribute_flags, ett_bgp_attr_flags, path_flags, ENC_NA);

        if ((bgpa_flags & BGP_ATTR_FLAG_OPTIONAL) == 0)
            proto_item_append_text(ti_flags, "%s", ", Well-known");
        if ((bgpa_flags & BGP_ATTR_FLAG_TRANSITIVE) == 0)
            proto_item_append_text(ti_flags, "%s", ", Non-transitive");
        if ((bgpa_flags & BGP_ATTR_FLAG_PARTIAL) == 0)
            proto_item_append_text(ti_flags, "%s", ", Complete");

        proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_type_code, tvb, o + i + 1, 1, ENC_BIG_ENDIAN);

        attr_len_item = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_length, tvb, o + i + BGP_SIZE_OF_PATH_ATTRIBUTE,
                                            aoff - BGP_SIZE_OF_PATH_ATTRIBUTE, ENC_BIG_ENDIAN);
        if (aoff + tlen > path_attr_len - i) {
            proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,
                                         "Path attribute length is invalid: %u byte%s", tlen,
                                         plurality(tlen, "", "s"));
            return;
        }

        /* Path Attribute Type */
        switch (bgpa_type) {
            case BGPTYPE_ORIGIN:
                if (tlen != 1) {
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,
                                                 "Origin (invalid): %u byte%s", tlen,
                                                 plurality(tlen, "", "s"));
                } else {
                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_origin, tvb,
                                        o + i + aoff, 1, ENC_BIG_ENDIAN);
                    proto_item_append_text(ti_pa, ": %s", val_to_str_const(tvb_get_guint8(tvb, o + i + aoff), bgpattr_origin, "Unknown"));
                }
                break;
            case BGPTYPE_AS_PATH:
            case BGPTYPE_AS4_PATH:
                /* Apply heuristic to guess if we are facing 2 or 4 bytes ASN
                   (o + i + aoff) =
                   (o + current attribute + aoff bytes to first tuple)
                   heuristic also tell us how many AS segments we have */
                asn_len = heuristic_as2_or_4_from_as_path(tvb, o+i+aoff, o+i+aoff+tlen,
                                                          bgpa_type, &number_as_segment);
                if (asn_len == 255)
                    {
                        expert_add_info_format(pinfo, ti_pa, &ei_bgp_attr_as_path_as_len_err,
                                               "ASN length uncalculated by heuristic : %u", asn_len);
                        break;
                    }
                proto_item_append_text(ti_pa,": ");
                if(tlen == 0) {
                    proto_item_append_text(ti_pa,"empty");
                }
                q = o + i + aoff;
                for (k=0; k < number_as_segment; k++)
                {
                    type = tvb_get_guint8(tvb, q);
                    length = tvb_get_guint8(tvb, q+1);
                    ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_as_path_segment, tvb,
                                             q, length * asn_len + 2, ENC_NA);
                    proto_item_append_text(ti,": ");
                    as_path_segment_tree = proto_item_add_subtree(ti, ett_bgp_as_path_segment);
                    proto_tree_add_item(as_path_segment_tree, hf_bgp_update_path_attribute_as_path_segment_type, tvb,
                                        q, 1, ENC_BIG_ENDIAN);
                    proto_tree_add_item(as_path_segment_tree, hf_bgp_update_path_attribute_as_path_segment_length, tvb,
                                        q+1, 1, ENC_BIG_ENDIAN);
                    switch(type)
                    {
                        case AS_SET:
                            proto_item_append_text(ti_pa, "{");
                            proto_item_append_text(ti, "{");
                            break;
                        case AS_CONFED_SET:
                            proto_item_append_text(ti_pa, "[");
                            proto_item_append_text(ti, "[");
                            break;
                        case AS_CONFED_SEQUENCE:
                            proto_item_append_text(ti_pa, "(");
                            proto_item_append_text(ti, "(");
                            break;
                    }

                    q = q + 2;
                    for (j = 0; j < length; j++)
                    {
                        if(asn_len == 2) {
                            ti_as = proto_tree_add_item_ret_uint(as_path_segment_tree,
                                                hf_bgp_update_path_attribute_as_path_segment_as2,
                                                tvb, q, 2, ENC_BIG_ENDIAN, &as_num);
                            if (as_num == BGP_AS_TRANS) {
                                proto_item_append_text(ti_as, " (AS_TRANS)");
                            }
                            proto_item_append_text(ti_pa, "%u",
                                                   tvb_get_ntohs(tvb, q));
                            proto_item_append_text(ti, "%u",
                                                   tvb_get_ntohs(tvb, q));
                        }
                        else if (asn_len == 4) {
                            proto_tree_add_item(as_path_segment_tree,
                                                hf_bgp_update_path_attribute_as_path_segment_as4,
                                                tvb, q, 4, ENC_BIG_ENDIAN);
                            proto_item_append_text(ti_pa, "%u",
                                                   tvb_get_ntohl(tvb, q));
                            proto_item_append_text(ti, "%u",
                                                   tvb_get_ntohl(tvb, q));
                        }
                        if (j != length-1)
                        {
                            proto_item_append_text(ti_pa, "%s",
                                                   (type == AS_SET || type == AS_CONFED_SET) ?
                                                   ", " : " ");
                            proto_item_append_text(ti, "%s",
                                                   (type == AS_SET || type == AS_CONFED_SET) ?
                                                   ", " : " ");
                        }
                        q += asn_len;
                    }
                    switch(type)
                    {
                        case AS_SET:
                            proto_item_append_text(ti_pa, "} ");
                            proto_item_append_text(ti, "}");
                            break;
                        case AS_CONFED_SET:
                            proto_item_append_text(ti_pa, "] ");
                            proto_item_append_text(ti, "]");
                            break;
                        case AS_CONFED_SEQUENCE:
                            proto_item_append_text(ti_pa, ") ");
                            proto_item_append_text(ti, ")");
                            break;
                        default:
                            proto_item_append_text(ti_pa, " ");
                            break;
                    }
                }

                break;
            case BGPTYPE_NEXT_HOP:
                if (tlen != 4) {
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,
                                                 "Next hop (invalid): %u byte%s", tlen,
                                                 plurality(tlen, "", "s"));
                } else {
                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_next_hop, tvb,
                                        o + i + aoff, 4, ENC_BIG_ENDIAN);
                    proto_item_append_text(ti_pa, ": %s ", tvb_ip_to_str(pinfo->pool, tvb, o + i + aoff));
                }
                break;
            case BGPTYPE_MULTI_EXIT_DISC:
                if (tlen != 4) {
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,
                                                 "Multiple exit discriminator (invalid): %u byte%s",
                                                 tlen, plurality(tlen, "", "s"));
                } else {
                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_multi_exit_disc, tvb,
                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);
                    proto_item_append_text(ti_pa,": %u", tvb_get_ntohl(tvb, o + i + aoff));
                }
                break;
            case BGPTYPE_LOCAL_PREF:
                if (tlen != 4) {
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,
                                                 "Local preference (invalid): %u byte%s", tlen,
                                                 plurality(tlen, "", "s"));
                } else {
                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_local_pref, tvb,
                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);
                    proto_item_append_text(ti_pa, ": %u", tvb_get_ntohl(tvb, o + i + aoff));
                }
                break;
            case BGPTYPE_ATOMIC_AGGREGATE:
                if (tlen != 0) {
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,
                                                 "Atomic aggregate (invalid): %u byte%s", tlen,
                                                 plurality(tlen, "", "s"));
                }
                break;
            case BGPTYPE_AGGREGATOR:
                if (tlen != 6 && tlen != 8) {
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,
                                                 "Aggregator (invalid): %u byte%s", tlen,
                                                 plurality(tlen, "", "s"));
                    break;
                }
                /* FALL THROUGH */
            case BGPTYPE_AS4_AGGREGATOR:
                if (bgpa_type == BGPTYPE_AS4_AGGREGATOR && tlen != 8)
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,
                                                 "Aggregator (invalid): %u byte%s", tlen,
                                                 plurality(tlen, "", "s"));
                else {
                    asn_len = tlen - 4;
                    aggregator_as = (asn_len == 2) ?
                        tvb_get_ntohs(tvb, o + i + aoff) :
                        tvb_get_ntohl(tvb, o + i + aoff);
                    proto_tree_add_uint(subtree2, hf_bgp_update_path_attribute_aggregator_as, tvb,
                                        o + i + aoff, asn_len, aggregator_as);
                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_aggregator_origin, tvb,
                                        o + i + aoff + asn_len, 4, ENC_BIG_ENDIAN);

                    proto_item_append_text(ti_pa, ": AS: %u origin: %s", aggregator_as,
                                           tvb_ip_to_str(pinfo->pool, tvb, o + i + aoff + asn_len));
                }
                break;
            case BGPTYPE_COMMUNITIES:
                if (tlen % 4 != 0) {
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,
                                                 "Communities (invalid): %u byte%s", tlen,
                                                 plurality(tlen, "", "s"));
                    break;
                }

                proto_item_append_text(ti_pa, ": ");

                ti_communities = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_communities,
                                                     tvb, o + i + aoff, tlen, ENC_NA);

                communities_tree = proto_item_add_subtree(ti_communities,
                                                          ett_bgp_communities);
                proto_item_append_text(ti_communities, ": ");
                /* (o + i + aoff) =
                   (o + current attribute + aoff bytes to first tuple) */
                q = o + i + aoff;
                end = q + tlen;

                /* snarf each community */
                while (q < end) {
                    /* check for reserved values */
                    guint32 community = tvb_get_ntohl(tvb, q);
                    if ((community & 0xFFFF0000) == FOURHEX0 ||
                        (community & 0xFFFF0000) == FOURHEXF) {
                        proto_tree_add_item(communities_tree, hf_bgp_update_path_attribute_community_well_known,
                                            tvb, q, 4, ENC_BIG_ENDIAN);
                        proto_item_append_text(ti_pa, "%s ", val_to_str_const(community, community_vals, "Reserved"));
                        proto_item_append_text(ti_communities, "%s ", val_to_str_const(community, community_vals, "Reserved"));
                    }
                    else {
                        ti_community = proto_tree_add_item(communities_tree, hf_bgp_update_path_attribute_community, tvb,
                                                           q, 4, ENC_NA);
                        community_tree = proto_item_add_subtree(ti_community,
                                                                ett_bgp_community);
                        proto_tree_add_item(community_tree, hf_bgp_update_path_attribute_community_as,
                                            tvb, q, 2, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_update_path_attribute_community_value,
                                            tvb, q+2, 2, ENC_BIG_ENDIAN);
                        proto_item_append_text(ti_pa, "%u:%u ",tvb_get_ntohs(tvb, q),
                                               tvb_get_ntohs(tvb, q+2));
                        proto_item_append_text(ti_communities, "%u:%u ",tvb_get_ntohs(tvb, q),
                                               tvb_get_ntohs(tvb, q+2));
                        proto_item_append_text(ti_community, ": %u:%u ",tvb_get_ntohs(tvb, q),
                                               tvb_get_ntohs(tvb, q+2));
                    }

                    q += 4;
                }


                break;
            case BGPTYPE_ORIGINATOR_ID:
                if (tlen != 4) {
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,
                                                 "Originator identifier (invalid): %u byte%s", tlen,
                                                 plurality(tlen, "", "s"));
                } else {
                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_originator_id, tvb,
                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);
                    proto_item_append_text(ti_pa, ": %s ", tvb_ip_to_str(pinfo->pool, tvb, o + i + aoff));
                }
                break;
            case BGPTYPE_MP_REACH_NLRI:
                /* RFC 2283 says that a MP_[UN]REACH_NLRI path attribute can
                 * have more than one <AFI, SAFI, Next Hop, ..., NLRI> tuple.
                 * However, that doesn't work because the NLRI is also a
                 * variable number of <length, prefix> fields without a field
                 * for the overall length of the NLRI. Thus one would have to
                 * guess whether a particular byte were the length of the next
                 * prefix or a new AFI. So no one ever implemented that, and
                 * RFC 2858, obsoleting 2283, says you can't do that.
                 */
                proto_tree_add_item_ret_uint(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_address_family, tvb,
                                    o + i + aoff, 2, ENC_BIG_ENDIAN, &af);
                proto_tree_add_item_ret_uint(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_safi, tvb,
                                    o + i + aoff + 2, 1, ENC_BIG_ENDIAN, &saf);
                nexthop_len = tvb_get_guint8(tvb, o + i + aoff + 3);
                save_afi_safi_data(pinfo, (guint16)af, (guint8)saf);

                decode_mp_next_hop(tvb_new_subset_length(tvb, o + i + aoff + 3, nexthop_len + 1), subtree2, pinfo, af, saf, nexthop_len);

                aoff_save = aoff;
                tlen -= nexthop_len + 4;
                aoff += nexthop_len + 4;

                off = 0;
                snpa = tvb_get_guint8(tvb, o + i + aoff);
                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri_nbr_snpa, tvb,
                                         o + i + aoff, 1, ENC_BIG_ENDIAN);
                off++;
                if (snpa) {
                    subtree3 = proto_item_add_subtree(ti, ett_bgp_mp_snpa);
                    for (/*nothing*/; snpa > 0; snpa--) {
                        guint8 snpa_length = tvb_get_guint8(tvb, o + i + aoff + off);
                        proto_tree_add_item(subtree3, hf_bgp_update_path_attribute_mp_reach_nlri_snpa_length, tvb,
                                            o + i + aoff + off, 1, ENC_BIG_ENDIAN);
                        off++;
                        proto_tree_add_item(subtree3, hf_bgp_update_path_attribute_mp_reach_nlri_snpa, tvb,
                                            o + i + aoff + off, snpa_length, ENC_NA);
                        off += snpa_length;
                    }
                }
                tlen -= off;
                aoff += off;

                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_reach_nlri, tvb, o + i + aoff, tlen, ENC_NA);
                subtree3 = proto_item_add_subtree(ti, ett_bgp_mp_reach_nlri);

                if (tlen)  {
                    if (af != AFNUM_INET && af != AFNUM_INET6 && af != AFNUM_L2VPN && af != AFNUM_BGP_LS) {
                        proto_tree_add_expert(subtree3, pinfo, &ei_bgp_unknown_afi, tvb, o + i + aoff, tlen);
                    } else {
                        while (tlen > 0) {
                            advance = decode_prefix_MP(subtree3,
                                                       hf_bgp_nlri_path_id,
                                                       hf_bgp_mp_reach_nlri_ipv4_prefix,
                                                       hf_bgp_mp_reach_nlri_ipv6_prefix,
                                                       af, saf, tlen,
                                                       tvb, o + i + aoff, "MP Reach NLRI", pinfo);
                            if (advance < 0)
                                break;
                            tlen -= advance;
                            aoff += advance;
                        }
                    }
                }
                aoff = aoff_save;
                break;
            case BGPTYPE_MP_UNREACH_NLRI:
                af = tvb_get_ntohs(tvb, o + i + aoff);
                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_unreach_nlri_address_family, tvb,
                                    o + i + aoff, 2, ENC_BIG_ENDIAN);
                saf = tvb_get_guint8(tvb, o + i + aoff + 2) ;
                proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_unreach_nlri_safi, tvb,
                                    o + i + aoff+2, 1, ENC_BIG_ENDIAN);
                save_afi_safi_data(pinfo, (guint16)af, (guint8)saf);

                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_mp_unreach_nlri, tvb, o + i + aoff + 3, tlen - 3, ENC_NA);
                subtree3 = proto_item_add_subtree(ti, ett_bgp_mp_unreach_nlri);

                aoff_save = aoff;
                tlen -= 3;
                aoff += 3;
                if (tlen > 0) {

                    while (tlen > 0) {
                        advance = decode_prefix_MP(subtree3,
                                                   hf_bgp_nlri_path_id,
                                                   hf_bgp_mp_unreach_nlri_ipv4_prefix,
                                                   hf_bgp_mp_unreach_nlri_ipv6_prefix,
                                                   af, saf, tlen,
                                                   tvb, o + i + aoff, "MP Unreach NLRI", pinfo);
                        if (advance < 0)
                            break;
                        tlen -= advance;
                        aoff += advance;
                    }
                }
                aoff = aoff_save;
                break;
            case BGPTYPE_CLUSTER_LIST:
                if (tlen % 4 != 0) {
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,
                                                 "Cluster list (invalid): %u byte%s", tlen,
                                                 plurality(tlen, "", "s"));
                    break;
                }

                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_cluster_list,
                                         tvb, o + i + aoff, tlen, ENC_NA);
                cluster_list_tree = proto_item_add_subtree(ti,
                                                               ett_bgp_cluster_list);

                /* (o + i + aoff) =
                   (o + current attribute + aoff bytes to first tuple) */
                q = o + i + aoff;
                end = q + tlen;
                proto_item_append_text(ti, ":");
                proto_item_append_text(ti_pa, ":");
                /* snarf each cluster identifier */
                while (q < end) {
                    proto_tree_add_item(cluster_list_tree, hf_bgp_update_path_attribute_cluster_id,
                                        tvb, q - 3 + aoff, 4, ENC_NA);
                    proto_item_append_text(ti, " %s", tvb_ip_to_str(pinfo->pool, tvb, q-3+aoff));
                    proto_item_append_text(ti_pa, " %s", tvb_ip_to_str(pinfo->pool, tvb, q-3+aoff));
                    q += 4;
                }

                break;
            case BGPTYPE_EXTENDED_COMMUNITY:
                if (tlen %8 != 0) {
                    expert_add_info_format(pinfo, attr_len_item, &ei_bgp_ext_com_len_bad,
                                           "Community length %u wrong, must be modulo 8", tlen);
                } else {
                    dissect_bgp_update_ext_com(subtree2, tvb, tlen, o+i+aoff, pinfo);
                }
                break;
            case BGPTYPE_SAFI_SPECIFIC_ATTR:
                q = o + i + aoff;
                end = o + i + aoff + tlen ;

                while(q < end) {
                    ssa_type = tvb_get_ntohs(tvb, q) & BGP_SSA_TYPE;
                    ssa_len = tvb_get_ntohs(tvb, q + 2);

                    subtree3 = proto_tree_add_subtree_format(subtree2, tvb, q, MIN(ssa_len + 4, end - q),
                                                             ett_bgp_ssa, NULL, "%s Information",
                                                             val_to_str_const(ssa_type, bgp_ssa_type, "Unknown SSA"));

                    proto_tree_add_item(subtree3, hf_bgp_ssa_t, tvb,
                                        q, 1, ENC_BIG_ENDIAN);
                    proto_tree_add_item(subtree3, hf_bgp_ssa_type, tvb, q, 2, ENC_BIG_ENDIAN);

                    proto_tree_add_item(subtree3, hf_bgp_ssa_len, tvb, q + 2, 2, ENC_BIG_ENDIAN);

                    if ((ssa_len == 0) || (q + ssa_len > end)) {
                        proto_tree_add_expert_format(subtree3, pinfo, &ei_bgp_length_invalid, tvb, q + 2,
                                                     end - q - 2, "Invalid Length of %u", ssa_len);
                        break;
                    }

                    switch (ssa_type) {
                        case BGP_SSA_L2TPv3:
                            proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_pref, tvb,
                                                q + 4, 2, ENC_BIG_ENDIAN);

                            subtree4 = proto_tree_add_subtree(subtree3, tvb, q + 6, 1, ett_bgp_ssa_subtree, NULL, "Flags");
                            proto_tree_add_item(subtree4, hf_bgp_ssa_l2tpv3_s, tvb,
                                                q + 6, 1, ENC_BIG_ENDIAN);
                            proto_tree_add_item(subtree4, hf_bgp_ssa_l2tpv3_unused, tvb,
                                                q + 6, 1, ENC_BIG_ENDIAN);

                            ssa_v3_len = tvb_get_guint8(tvb, q + 7);
                            if (ssa_v3_len + 8 == ssa_len){
                                proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_cookie_len, tvb,
                                                    q + 7, 1, ENC_BIG_ENDIAN);
                            } else {
                                proto_tree_add_expert_format(subtree3, pinfo, &ei_bgp_length_invalid, tvb, q + 7, 1,
                                                             "Invalid Cookie Length of %u", ssa_v3_len);
                                q += ssa_len + 4; /* 4 from type and length */
                                break;
                            }
                            proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_session_id, tvb,
                                                q + 8, 4, ENC_BIG_ENDIAN);
                            if (ssa_v3_len)
                                proto_tree_add_item(subtree3, hf_bgp_ssa_l2tpv3_cookie, tvb,
                                                    q + 12, ssa_v3_len, ENC_NA);
                            q += ssa_len + 4; /* 4 from type and length */
                            break;
                        case BGP_SSA_mGRE:
                        case BGP_SSA_IPSec:
                        case BGP_SSA_MPLS:
                        default:
                            proto_tree_add_item(subtree3, hf_bgp_ssa_value, tvb,
                                                q + 4, ssa_len, ENC_NA);
                            q += ssa_len + 4; /* 4 from type and length */
                            break;
                        case BGP_SSA_L2TPv3_IN_IPSec:
                        case BGP_SSA_mGRE_IN_IPSec:
                            /* These contain BGP_SSA_IPSec and BGP_SSA_L2TPv3/BGP_SSA_mGRE */
                            q += 4; /* 4 from type and length */
                            break;
                    } /* switch (bgpa.bgpa_type) */
                }
                break;
            case BGPTYPE_TUNNEL_ENCAPS_ATTR:
                q = o + i + aoff;
                end = o + i + aoff + tlen;

                subtree3 = proto_tree_add_subtree(subtree2, tvb, q, tlen, ett_bgp_tunnel_tlv, NULL, "TLV Encodings");

                while (q < end) {
                    encaps_tunnel_type = tvb_get_ntohs(tvb, q);
                    encaps_tunnel_len = tvb_get_ntohs(tvb, q + 2);

                    subtree4 = proto_tree_add_subtree_format(subtree3, tvb, q, encaps_tunnel_len + 4,
                                         ett_bgp_tunnel_tlv_subtree, NULL, "%s (%u bytes)",
                                         val_to_str_const(encaps_tunnel_type, bgp_attr_tunnel_type, "Unknown"), encaps_tunnel_len + 4);

                    proto_tree_add_item(subtree4, hf_bgp_update_encaps_tunnel_tlv_type, tvb, q, 2, ENC_BIG_ENDIAN);
                    proto_tree_add_item(subtree4, hf_bgp_update_encaps_tunnel_tlv_len, tvb, q + 2, 2, ENC_BIG_ENDIAN);

                    subtree5 = proto_tree_add_subtree(subtree4, tvb, q + 4, encaps_tunnel_len, ett_bgp_tunnel_subtlv, NULL, "Sub-TLV Encodings");

                    q += 4;
                    j = q + encaps_tunnel_len;
                    while ( q < j ) {
                        encaps_tunnel_subtype = tvb_get_guint8(tvb, q);
                        if (encaps_tunnel_subtype < 128) {
                            encaps_tunnel_sublen = tvb_get_guint8(tvb, q + 1);
                            encaps_tunnel_sub_totallen = encaps_tunnel_sublen + 2;
                        } else {
                            encaps_tunnel_sublen = tvb_get_ntohs(tvb, q + 1);
                            encaps_tunnel_sub_totallen = encaps_tunnel_sublen + 3;
                        }
                        subtree6 = proto_tree_add_subtree_format(subtree5, tvb, q, encaps_tunnel_sub_totallen,
                                             ett_bgp_tunnel_tlv_subtree, NULL, "%s (%u bytes)",
                                             val_to_str_const(encaps_tunnel_subtype, subtlv_type, "Unknown"), encaps_tunnel_sub_totallen);
                        proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_type, tvb, q, 1, ENC_BIG_ENDIAN);
                        q += 1;
                        if (encaps_tunnel_subtype < 128) {
                            proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_len, tvb, q, 1, ENC_BIG_ENDIAN);
                            q += 1;
                        } else {
                            proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_len, tvb, q, 2, ENC_BIG_ENDIAN);
                            q += 2;
                        }

                        switch (encaps_tunnel_subtype) {
                            case TUNNEL_SUBTLV_ENCAPSULATION:
                                {
                                static int * const vxlan_flags[] = {
                                    &hf_bgp_update_encaps_tunnel_subtlv_vxlan_flags_valid_vnid,
                                    &hf_bgp_update_encaps_tunnel_subtlv_vxlan_flags_valid_mac,
                                    &hf_bgp_update_encaps_tunnel_subtlv_vxlan_flags_reserved,
                                    NULL
                                    };
                                static int * const vxlan_gpe_flags[] = {
                                    &hf_bgp_update_encaps_tunnel_subtlv_vxlan_gpe_flags_version,
                                    &hf_bgp_update_encaps_tunnel_subtlv_vxlan_gpe_flags_valid_vnid,
                                    &hf_bgp_update_encaps_tunnel_subtlv_vxlan_gpe_flags_reserved,
                                    NULL
                                    };
                                static int * const nvgre_flags[] = {
                                    &hf_bgp_update_encaps_tunnel_subtlv_nvgre_flags_valid_vnid,
                                    &hf_bgp_update_encaps_tunnel_subtlv_nvgre_flags_valid_mac,
                                    &hf_bgp_update_encaps_tunnel_subtlv_nvgre_flags_reserved,
                                    NULL
                                    };
                                if (encaps_tunnel_type == TUNNEL_TYPE_L2TP_OVER_IP) {
                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_session_id, tvb, q, 4, ENC_BIG_ENDIAN);
                                    q += 4;
                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_cookie, tvb, q, encaps_tunnel_sublen - 4, ENC_NA);
                                    q += (encaps_tunnel_sublen - 4);
                                } else if (encaps_tunnel_type == TUNNEL_TYPE_GRE || encaps_tunnel_type == TUNNEL_TYPE_MPLS_IN_GRE) {
                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_gre_key, tvb, q, 4, ENC_BIG_ENDIAN);
                                    q += 4;
                                } else if (encaps_tunnel_type == TUNNEL_TYPE_VXLAN) {
                                    proto_tree_add_bitmask(subtree6, tvb, q, hf_bgp_update_encaps_tunnel_subtlv_vxlan_flags,
                                            ett_bgp_vxlan, vxlan_flags, ENC_BIG_ENDIAN);
                                    q += 1;
                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_vxlan_vnid, tvb, q, 3, ENC_BIG_ENDIAN);
                                    q += 3;
                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_vxlan_mac, tvb, q, 6, ENC_NA);
                                    q += 6;
                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_vxlan_reserved, tvb, q, 2, ENC_BIG_ENDIAN);
                                    q += 2;
                                } else if (encaps_tunnel_type == TUNNEL_TYPE_VXLAN_GPE) {
                                    proto_tree_add_bitmask(subtree6, tvb, q, hf_bgp_update_encaps_tunnel_subtlv_vxlan_gpe_flags,
                                            ett_bgp_vxlan, vxlan_gpe_flags, ENC_BIG_ENDIAN);
                                    q += 1;
                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_vxlan_gpe_reserved, tvb, q, 2, ENC_BIG_ENDIAN);
                                    q += 2;
                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_vxlan_gpe_vnid, tvb, q, 3, ENC_BIG_ENDIAN);
                                    q += 3;
                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_vxlan_gpe_reserved, tvb, q, 1, ENC_BIG_ENDIAN);
                                    q += 1;
                                } else if (encaps_tunnel_type == TUNNEL_TYPE_NVGRE) {
                                    proto_tree_add_bitmask(subtree6, tvb, q, hf_bgp_update_encaps_tunnel_subtlv_nvgre_flags,
                                            ett_bgp_vxlan, nvgre_flags, ENC_BIG_ENDIAN);
                                    q += 1;
                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_nvgre_vnid, tvb, q, 3, ENC_BIG_ENDIAN);
                                    q += 3;
                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_nvgre_mac, tvb, q, 6, ENC_NA);
                                    q += 6;
                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_nvgre_reserved, tvb, q, 2, ENC_BIG_ENDIAN);
                                    q += 2;
                                }
                                }
                                break;
                            case TUNNEL_SUBTLV_PROTO_TYPE:
                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_gre_key, tvb, q, 2, ENC_BIG_ENDIAN);
                                q += 2;
                                break;
                            case TUNNEL_SUBTLV_COLOR:
                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_color_value, tvb, q, 4, ENC_BIG_ENDIAN);
                                q += 4;
                                break;
                            case TUNNEL_SUBTLV_LOAD_BALANCE:
                                if (encaps_tunnel_type == TUNNEL_TYPE_L2TP_OVER_IP || encaps_tunnel_type == TUNNEL_TYPE_GRE) {
                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_lb_block_length, tvb, q, 4, ENC_BIG_ENDIAN);
                                    q += 4;
                                }
                                break;
                            case TUNNEL_SUBTLV_PREFERENCE:
                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_pref_flags, tvb, q, 1, ENC_BIG_ENDIAN);
                                q += 1;
                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_pref_reserved, tvb, q, 1, ENC_BIG_ENDIAN);
                                q += 1;
                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_pref_preference, tvb, q, 4, ENC_NA);
                                q += 4;
                                break;
                            case TUNNEL_SUBTLV_BINDING_SID:
                                {
                                static int * const flags[] = {
                                    &hf_bgp_update_encaps_tunnel_subtlv_binding_sid_flags_specified,
                                    &hf_bgp_update_encaps_tunnel_subtlv_binding_sid_flags_invalid,
                                    &hf_bgp_update_encaps_tunnel_subtlv_binding_sid_flags_reserved,
                                    NULL
                                    };

                                proto_tree_add_bitmask(subtree6, tvb, q, hf_bgp_update_encaps_tunnel_subtlv_binding_sid_flags,
                                        ett_bgp_binding_sid, flags, ENC_BIG_ENDIAN);
                                q += 1;
                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_binding_sid_reserved,
                                        tvb, q, 1, ENC_BIG_ENDIAN);
                                q += 1;
                                if (encaps_tunnel_sublen > 2) {
                                    proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_binding_sid_sid, tvb, q,
                                            encaps_tunnel_sublen - 2, ENC_NA);
                                    q += (encaps_tunnel_sublen - 2);
                                }
                                }
                                break;
                            case TUNNEL_SUBTLV_ENLP:
                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_enlp_flags, tvb, q, 1, ENC_BIG_ENDIAN);
                                q += 1;
                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_enlp_reserved, tvb, q, 1, ENC_BIG_ENDIAN);
                                q += 1;
                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_enlp_enlp, tvb, q, 1, ENC_BIG_ENDIAN);
                                q += 1;
                                break;
                            case TUNNEL_SUBTLV_PRIORITY:
                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_priority_priority, tvb, q, 1, ENC_BIG_ENDIAN);
                                q += 1;
                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_priority_reserved, tvb, q, 1, ENC_BIG_ENDIAN);
                                q += 1;
                                break;
                            case TUNNEL_SUBTLV_SEGMENT_LIST:
                                {
                                static int * const flags[] = {
                                    &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_flags_verification,
                                    &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_flags_algorithm,
                                    &hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_flags_reserved,
                                    NULL
                                    };

                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_segment_list_reserved, tvb, q, 1, ENC_BIG_ENDIAN);
                                q += 1;
                                ti = proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv, tvb, q,
                                        encaps_tunnel_sublen - 1, ENC_NA);
                                encaps_tunnel_sublen -= 1;
                                subtree7 = proto_item_add_subtree(ti, ett_bgp_segment_list);
                                while (encaps_tunnel_sublen > 2) {
                                    segment_subtlv_type = tvb_get_guint8(tvb, q);
                                    segment_subtlv_length = tvb_get_guint8(tvb, q + 1);
                                    subtree8 = proto_tree_add_subtree_format(subtree7, tvb, q, segment_subtlv_length + 2,
                                            ett_bgp_segment_list, NULL, "SubTLV: %s", val_to_str_const(segment_subtlv_type,
                                            bgp_sr_policy_list_type, "Unknown"));
                                    proto_tree_add_item(subtree8, hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_type, tvb, q, 1, ENC_BIG_ENDIAN);
                                    q += 1;
                                    proto_tree_add_item(subtree8, hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_length, tvb, q, 1, ENC_BIG_ENDIAN);
                                    q += 1;
                                    if (segment_subtlv_length > 0) {
                                        switch(segment_subtlv_type) {
                                            /* TODO: Dissect further subTLVs data as defined in draft-ietf-idr-segment-routing-te-policy-08 section 2.4.3.2 */
                                            case TUNNEL_SUBTLV_SEGMENT_LIST_SUB_TYPE_A:
                                                proto_tree_add_bitmask(subtree8, tvb, q, hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_flags,
                                                        ett_bgp_segment_list, flags, ENC_BIG_ENDIAN);
                                                q += 1;
                                                proto_tree_add_item(subtree8, hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_reserved,
                                                        tvb, q, 1, ENC_NA);
                                                q += 1;
                                                proto_tree_add_item(subtree8, hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_mpls_label,
                                                        tvb, q, 3, ENC_BIG_ENDIAN);
                                                proto_tree_add_item(subtree8, hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_traffic_class,
                                                        tvb, q, 3, ENC_BIG_ENDIAN);
                                                proto_tree_add_item(subtree8, hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_bottom_stack,
                                                        tvb, q, 3, ENC_BIG_ENDIAN);
                                                q += 3;
                                                proto_tree_add_item(subtree8, hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_ttl,
                                                        tvb, q, 1, ENC_BIG_ENDIAN);
                                                q += 1;
                                                break;
                                            default:
                                                proto_tree_add_item(subtree8, hf_bgp_update_encaps_tunnel_subtlv_segment_list_subtlv_data,
                                                        tvb, q, segment_subtlv_length, ENC_NA);
                                                q += segment_subtlv_length;
                                                break;
                                        }
                                    }
                                    encaps_tunnel_sublen -= (segment_subtlv_length + 2);
                                }
                                }
                                break;
                            case TUNNEL_SUBTLV_POLICY_NAME:
                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_policy_name_reserved, tvb, q, 1, ENC_BIG_ENDIAN);
                                q += 1;
                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_policy_name_name, tvb, q,
                                        encaps_tunnel_sublen - 1, ENC_ASCII);
                                q += (encaps_tunnel_sublen - 1);
                                break;
                            default:
                                proto_tree_add_item(subtree6, hf_bgp_update_encaps_tunnel_subtlv_value, tvb, q, encaps_tunnel_sublen, ENC_NA);
                                q += encaps_tunnel_sublen;
                                break;
                        } /* switch (encaps_tunnel_subtype) */
                    }
                }
                break;
            case BGPTYPE_AIGP:
                q = o + i + aoff;
                ti = proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_aigp, tvb, q, tlen, ENC_NA);
                subtree3 = proto_item_add_subtree(ti, ett_bgp_aigp_attr);
                aigp_type_item =  proto_tree_add_item(subtree3, hf_bgp_aigp_type, tvb, q, 1, ENC_BIG_ENDIAN);
                aigp_type = tvb_get_guint8(tvb,q);
                switch (aigp_type) {
                    case AIGP_TLV_TYPE :
                        proto_tree_add_item(subtree3, hf_bgp_aigp_tlv_length, tvb, q+1, 2, ENC_BIG_ENDIAN);
                        proto_tree_add_item(subtree3, hf_bgp_aigp_accu_igp_metric, tvb, q+3, 8, ENC_BIG_ENDIAN);
                        proto_item_append_text(ti, ": %" PRIu64, tvb_get_ntoh64(tvb, q+3));
                        proto_item_append_text(ti_pa, ": %" PRIu64, tvb_get_ntoh64(tvb, q+3));
                        break;
                    default :
                        expert_add_info_format(pinfo, aigp_type_item, &ei_bgp_attr_aigp_type,
                                               "AIGP type %u unknown", aigp_type);
                }
                break;
            case BGPTYPE_LINK_STATE_ATTR:
            case BGPTYPE_LINK_STATE_OLD_ATTR:
                q = o + i + aoff;
                end = o + i + aoff + tlen;
                /* FF: BGPTYPE_LINK_STATE_ATTR body dissection is moved after the while.
                   Here we just save the TLV coordinates and the subtree. */
                save_link_state_attr_position(pinfo, q, end, tlen, subtree2);
                break;

            case BGPTYPE_LARGE_COMMUNITY:
                if(tlen == 0 || tlen % 12){
                    break;
                }
                q = o + i + aoff;
                end = q + tlen;
                wmem_strbuf_t *comm_strbuf;
                comm_strbuf = wmem_strbuf_create(pinfo->pool);
                while (q < end) {
                    guint32 ga, ldp1, ldp2;
                    ga = tvb_get_ntohl(tvb, q);
                    ldp1 = tvb_get_ntohl(tvb, q+4);
                    ldp2 = tvb_get_ntohl(tvb, q+8);
                    ti = proto_tree_add_string_format(subtree2, hf_bgp_large_communities, tvb, q, 12, NULL, "Large communities: %u:%u:%u", ga, ldp1, ldp2);
                    subtree3 = proto_item_add_subtree(ti, ett_bgp_large_communities);
                    proto_tree_add_item(subtree3, hf_bgp_large_communities_ga, tvb,
                                            q, 4, ENC_BIG_ENDIAN);
                    proto_tree_add_item(subtree3, hf_bgp_large_communities_ldp1, tvb,
                                            q + 4, 4, ENC_BIG_ENDIAN);
                    proto_tree_add_item(subtree3, hf_bgp_large_communities_ldp2, tvb,
                                            q + 8, 4, ENC_BIG_ENDIAN);
                    wmem_strbuf_append_printf(comm_strbuf, " %u:%u:%u", ga, ldp1, ldp2);
                    q += 12;
                }

                proto_item_append_text(ti_pa, ":%s", wmem_strbuf_get_str(comm_strbuf));

                break;
            case BGPTYPE_BGPSEC_PATH:
                q = o + i + aoff;
                end = q + tlen;
                secpathlen = tvb_get_ntohs(tvb, q); /* Secure Path Length */

                if (((secpathlen - 2) % SEC_PATH_SEG_SIZE) != 0) { /* SEC_PATH_SEG_SIZE = 6 */
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, alen,
                        "Invalid BGPsec Secure Path length: %u bytes", secpathlen);
                }

                subtree3 = proto_tree_add_subtree_format(subtree2, tvb, q, secpathlen,
                                                         ett_bgp_bgpsec_secure_path,
                                                         NULL,
                                                         "Secure Path (%d byte%s)",
                                                         secpathlen,
                                                         plurality(secpathlen, "", "s"));

                /* Secure Path Length */
                proto_tree_add_item(subtree3, hf_bgp_update_path_attribute_bgpsec_sp_len, tvb, q, 2, ENC_BIG_ENDIAN);
                q += 2;

                secpathcount = (secpathlen - 2) / SEC_PATH_SEG_SIZE; /* Amount of Secure Path Segments */
                j = 0;
                while (j < secpathcount) {
                    subtree4 = proto_tree_add_subtree_format(subtree3, tvb, q, SEC_PATH_SEG_SIZE,
                                                             ett_bgp_bgpsec_secure_path_segment,
                                                             NULL,
                                                             "Secure Path Segment (%d byte%s)",
                                                             SEC_PATH_SEG_SIZE,
                                                             plurality(SEC_PATH_SEG_SIZE, "", "s"));

                    /* pCount field */
                    proto_tree_add_item(subtree4, hf_bgp_update_path_attribute_bgpsec_sps_pcount, tvb,
                                        q, 1, ENC_BIG_ENDIAN);
                    q += 1;

                    /* Flags field */
                    proto_tree_add_item(subtree4, hf_bgp_update_path_attribute_bgpsec_sps_flags, tvb,
                                        q, 1, ENC_BIG_ENDIAN);
                    q += 1;

                    /* ASN field */
                    proto_tree_add_item(subtree4, hf_bgp_update_path_attribute_bgpsec_sps_as, tvb,
                                        q, 4, ENC_BIG_ENDIAN);
                    q += 4;
                    j++;
                }

                sigblocklen = tvb_get_ntohs(tvb, q); /* Signature Block Length */

                subtree3 = proto_tree_add_subtree_format(subtree2, tvb, q, sigblocklen,
                                                         ett_bgp_bgpsec_signature_block,
                                                         NULL,
                                                         "Signature Block (%d byte%s)",
                                                         sigblocklen,
                                                         plurality(sigblocklen, "", "s"));

                /* Signature Block Length */
                proto_tree_add_item(subtree3, hf_bgp_update_path_attribute_bgpsec_sb_len, tvb, q, 2, ENC_BIG_ENDIAN);
                q += 2;

                /* Algorithm Suite ID */
                proto_tree_add_item(subtree3, hf_bgp_update_path_attribute_bgpsec_algo_id, tvb, q, 1, ENC_BIG_ENDIAN);
                q += 1;

                while (q < end) {
                    sig_len = tvb_get_ntohs(tvb, q+20); /* Signature Length of current Segment */

                    subtree4 = proto_tree_add_subtree_format(subtree3, tvb, q, 22+sig_len,
                                                             ett_bgp_bgpsec_signature_segment,
                                                             NULL,
                                                             "Signature Segment (%d byte%s)",
                                                             22+sig_len,
                                                             plurality(22+sig_len, "", "s"));

                    /* Subject Key Identifier */
                    proto_tree_add_item(subtree4, hf_bgp_update_path_attribute_bgpsec_ski, tvb,
                                        q, 20, ENC_NA);
                    q += 20;

                    /* Signature Length */
                    proto_tree_add_item(subtree4, hf_bgp_update_path_attribute_bgpsec_sig_len, tvb,
                                        q, 2, ENC_BIG_ENDIAN);
                    q += 2;

                    /* Signature */
                    proto_tree_add_item(subtree4, hf_bgp_update_path_attribute_bgpsec_sig, tvb,
                                        q, sig_len, ENC_NA);
                    q += sig_len;
                }

                break;
            case BGPTYPE_BGP_PREFIX_SID:
                q = o + i + aoff;
                end = q + tlen;
                proto_item    *tlv_item, *stlv_item, *sstlv_item;
                proto_tree    *tlv_tree, *stlv_tree, *sstlv_tree;
                proto_item    *srgb_tlv_item;
                proto_tree    *srgb_tlv_tree;
                proto_item    *srv6_stlv_item;
                proto_tree    *srv6_stlv_tree;
                proto_item    *srv6_data_sstlv_item;
                proto_tree    *srv6_data_sstlv_tree;
                gint sub_pnt, sub_end;
                gint sub_sub_pnt, sub_sub_end;
                while (q < end) {
                    prefix_sid_subtype = tvb_get_guint8(tvb, q);
                    prefix_sid_sublen = tvb_get_ntohs(tvb, q + 1);
                    switch (prefix_sid_subtype) {
                        case BGP_PREFIX_SID_TLV_LABEL_INDEX:
                            tlv_item = proto_tree_add_item(subtree2, hf_bgp_prefix_sid_label_index, tvb, q , prefix_sid_sublen + 3, ENC_NA);
                            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_prefix_sid_label_index);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_type, tvb, q, 1, ENC_BIG_ENDIAN);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_length, tvb, q + 1, 2, ENC_BIG_ENDIAN);
                            if (prefix_sid_sublen != BGP_PREFIX_SID_TLV_LEN_LABEL_INDEX){
                                proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, alen,
                                    "Invalid BGP Prefix-SID Label Index length: %u bytes", prefix_sid_sublen);
                                q += 3 + prefix_sid_sublen;
                                break;
                            }
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_reserved, tvb, q + 3, 1, ENC_NA);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_label_index_flags, tvb, q + 4, 2, ENC_BIG_ENDIAN);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_label_index_value, tvb, q + 6, 4, ENC_BIG_ENDIAN);
                            proto_item_append_text(tlv_tree, ": %u ", tvb_get_ntohl(tvb, q + 6));
                            q += 10;
                            break;
                        case BGP_PREFIX_SID_TLV_ORIGINATOR_SRGB:
                            check_srgb = prefix_sid_sublen - 2;
                            prefix_sid_sub_tlv_offset = 0;
                            tlv_item = proto_tree_add_item(subtree2, hf_bgp_prefix_sid_originator_srgb, tvb, q , prefix_sid_sublen + 3, ENC_NA);
                            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_prefix_sid_originator_srgb);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_type, tvb, q, 1, ENC_BIG_ENDIAN);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_length, tvb, q + 1, 2, ENC_BIG_ENDIAN);
                            if(check_srgb % 3 || check_srgb % 2){
                                proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, alen,
                                    "Invalid BGP Prefix-SID SRGB Originator length: %u bytes", prefix_sid_sublen);
                                q += 3 + prefix_sid_sublen;
                                break;
                            }
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_originator_srgb_flags, tvb, q + 3, 2, ENC_BIG_ENDIAN);
                            q += 2;
                            tlv_item = proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_originator_srgb_blocks, tvb, q , prefix_sid_sublen - 2, ENC_NA);
                            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_prefix_sid_originator_srgb_blocks);
                            while (prefix_sid_sublen > prefix_sid_sub_tlv_offset + 2) {
                                srgb_tlv_item = proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_originator_srgb_block, tvb, q , prefix_sid_sublen - 2, ENC_NA);
                                srgb_tlv_tree = proto_item_add_subtree(srgb_tlv_item, ett_bgp_prefix_sid_originator_srgb_block);
                                prefix_sid_sub_tlv_offset += 3;
                                proto_tree_add_item(srgb_tlv_tree, hf_bgp_prefix_sid_originator_srgb_base, tvb, q + prefix_sid_sub_tlv_offset, 3, ENC_BIG_ENDIAN);
                                prefix_sid_sub_tlv_offset += 3;
                                proto_tree_add_item(srgb_tlv_tree, hf_bgp_prefix_sid_originator_srgb_range, tvb, q + prefix_sid_sub_tlv_offset, 3, ENC_BIG_ENDIAN);
                                proto_item_append_text(srgb_tlv_tree, "(%u:%u)", tvb_get_ntoh24(tvb, q + prefix_sid_sub_tlv_offset - 3),
                                    tvb_get_ntoh24(tvb, q + prefix_sid_sub_tlv_offset));
                            }
                            q += 3 + prefix_sid_sublen;
                            break;
                        case BGP_PREFIX_SID_TLV_SRV6_L3_SERVICE:
                            tlv_item = proto_tree_add_item(subtree2, hf_bgp_prefix_sid_srv6_l3vpn, tvb, q , prefix_sid_sublen + 3, ENC_NA);
                            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_prefix_sid_srv6_l3vpn);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_type, tvb, q, 1, ENC_BIG_ENDIAN);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_length, tvb, q + 1, 2, ENC_BIG_ENDIAN);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_reserved, tvb, q + 3, 1, ENC_NA);

                            srv6_stlv_item = proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sub_tlvs, tvb, q + 4, prefix_sid_sublen - 1, ENC_NA);
                            srv6_stlv_tree = proto_item_add_subtree(srv6_stlv_item, ett_bgp_prefix_sid_srv6_l3vpn_sub_tlvs);

                            sub_pnt = q + 4;
                            sub_end = q + 3 + prefix_sid_sublen;
                            while (sub_pnt < sub_end) {
                                srv6_service_subtlv_type = tvb_get_guint8(tvb, sub_pnt);
                                srv6_service_subtlv_len = tvb_get_ntohs(tvb, sub_pnt + 1);

                                switch (srv6_service_subtlv_type) {
                                    case SRV6_SERVICE_SRV6_SID_INFORMATION:
                                        stlv_item = proto_tree_add_item(srv6_stlv_tree,
                                                                        hf_bgp_prefix_sid_srv6_l3vpn_sub_tlv,
                                                                        tvb, sub_pnt , srv6_service_subtlv_len + 3, ENC_NA);
                                        proto_item_append_text(stlv_item, " - %s",
                                                               val_to_str(srv6_service_subtlv_type, srv6_service_sub_tlv_type, "Unknown (%u)"));
                                        stlv_tree = proto_item_add_subtree(stlv_item, ett_bgp_prefix_sid_srv6_l3vpn_sid_information);

                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sub_tlv_type, tvb, sub_pnt, 1, ENC_BIG_ENDIAN);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sub_tlv_length, tvb, sub_pnt + 1, 2, ENC_BIG_ENDIAN);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sub_tlv_reserved, tvb, sub_pnt + 3, 1, ENC_NA);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sid_value, tvb, sub_pnt + 4, 16, ENC_NA);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sid_flags, tvb, sub_pnt + 20, 1, ENC_NA);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_srv6_endpoint_behavior, tvb, sub_pnt + 21, 2, ENC_NA);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_reserved, tvb, sub_pnt + 23, 1, ENC_NA);

                                        srv6_data_sstlv_item = proto_tree_add_item(stlv_tree,
                                                                                   hf_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlvs,
                                                                                   tvb, sub_pnt + 24, srv6_service_subtlv_len - 21, ENC_NA);
                                        srv6_data_sstlv_tree = proto_item_add_subtree(srv6_data_sstlv_item, ett_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlvs);

                                        sub_sub_pnt = sub_pnt + 24;
                                        sub_sub_end = sub_pnt + 3 + srv6_service_subtlv_len;
                                        while (sub_sub_pnt < sub_sub_end) {
                                            srv6_service_data_subsubtlv_type = tvb_get_guint8(tvb, sub_sub_pnt);
                                            srv6_service_data_subsubtlv_len = tvb_get_ntohs(tvb, sub_sub_pnt + 1);

                                            switch (srv6_service_data_subsubtlv_type) {
                                                case SRV6_SERVICE_DATA_SRV6_SID_STRUCTURE:
                                                    sstlv_item = proto_tree_add_item(srv6_data_sstlv_tree,
                                                                                     hf_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlv,
                                                                                     tvb, sub_sub_pnt , srv6_service_data_subsubtlv_len + 3, ENC_NA);
                                                    proto_item_append_text(sstlv_item, " - %s",
                                                                           val_to_str(srv6_service_data_subsubtlv_type, srv6_service_data_sub_sub_tlv_type, "Unknown (%u)"));
                                                    sstlv_tree = proto_item_add_subtree(sstlv_item, ett_bgp_prefix_sid_srv6_l3vpn_sid_structure);

                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlv_type, tvb, sub_sub_pnt, 1, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlv_length, tvb, sub_sub_pnt + 1, 2, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sid_locator_block_len, tvb, sub_sub_pnt + 3, 1, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sid_locator_node_len, tvb, sub_sub_pnt + 4, 1, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sid_func_len, tvb, sub_sub_pnt + 5, 1, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sid_arg_len, tvb, sub_sub_pnt + 6, 1, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sid_trans_len, tvb, sub_sub_pnt + 7, 1, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sid_trans_offset, tvb, sub_sub_pnt + 8, 1, ENC_BIG_ENDIAN);
                                                    break;
                                                default:
                                                    sstlv_item = proto_tree_add_item(srv6_data_sstlv_tree,
                                                                                     hf_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlv,
                                                                                     tvb, sub_sub_pnt , srv6_service_data_subsubtlv_len + 3, ENC_NA);
                                                    proto_item_append_text(sstlv_item, " - %s",
                                                                           val_to_str(srv6_service_data_subsubtlv_type, srv6_service_data_sub_sub_tlv_type, "Unknown (%u)"));
                                                    sstlv_tree = proto_item_add_subtree(sstlv_item, ett_bgp_prefix_sid_srv6_l3vpn_sid_unknown);

                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlv_type, tvb, sub_sub_pnt, 1, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlv_length, tvb, sub_sub_pnt + 1, 2, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sub_sub_tlv_value, tvb, sub_sub_pnt + 3, srv6_service_data_subsubtlv_len, ENC_NA);
                                                    break;
                                            }
                                            sub_sub_pnt += 3 + srv6_service_data_subsubtlv_len;
                                        }
                                        break;
                                    default:
                                        stlv_item = proto_tree_add_item(srv6_stlv_tree,
                                                                        hf_bgp_prefix_sid_srv6_l3vpn_sub_tlv,
                                                                        tvb, sub_pnt , srv6_service_subtlv_len + 3, ENC_NA);
                                        proto_item_append_text(stlv_item, " - %s", val_to_str(srv6_service_subtlv_type, srv6_service_sub_tlv_type, "Unknown (%u)"));
                                        stlv_tree = proto_item_add_subtree(stlv_item, ett_bgp_prefix_sid_srv6_l3vpn_unknown);

                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sub_tlv_type, tvb, sub_pnt, 1, ENC_BIG_ENDIAN);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sub_tlv_length, tvb, sub_pnt + 1, 2, ENC_BIG_ENDIAN);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l3vpn_sub_tlv_value, tvb, sub_pnt + 3, srv6_service_subtlv_len, ENC_NA);
                                        break;
                                }
                                sub_pnt += 3 + srv6_service_subtlv_len;
                            }
                            q += (3 + prefix_sid_sublen);
                            break;
                        case BGP_PREFIX_SID_TLV_SRV6_L2_SERVICE:
                            tlv_item = proto_tree_add_item(subtree2, hf_bgp_prefix_sid_srv6_l2vpn, tvb, q , prefix_sid_sublen + 3, ENC_NA);
                            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_prefix_sid_srv6_l2vpn);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_type, tvb, q, 1, ENC_BIG_ENDIAN);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_length, tvb, q + 1, 2, ENC_BIG_ENDIAN);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_reserved, tvb, q + 3, 1, ENC_NA);

                            srv6_stlv_item = proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sub_tlvs, tvb, q + 4, prefix_sid_sublen - 1, ENC_NA);
                            srv6_stlv_tree = proto_item_add_subtree(srv6_stlv_item, ett_bgp_prefix_sid_srv6_l2vpn_sub_tlvs);

                            sub_pnt = q + 4;
                            sub_end = q + 3 + prefix_sid_sublen;
                            while (sub_pnt < sub_end) {
                                srv6_service_subtlv_type = tvb_get_guint8(tvb, sub_pnt);
                                srv6_service_subtlv_len = tvb_get_ntohs(tvb, sub_pnt + 1);

                                switch (srv6_service_subtlv_type) {
                                    case SRV6_SERVICE_SRV6_SID_INFORMATION:
                                        stlv_item = proto_tree_add_item(srv6_stlv_tree,
                                                                        hf_bgp_prefix_sid_srv6_l2vpn_sub_tlv,
                                                                        tvb, sub_pnt , srv6_service_subtlv_len + 3, ENC_NA);
                                        proto_item_append_text(stlv_item, " - %s",
                                                               val_to_str(srv6_service_subtlv_type, srv6_service_sub_tlv_type, "Unknown (%u)"));
                                        stlv_tree = proto_item_add_subtree(stlv_item, ett_bgp_prefix_sid_srv6_l2vpn_sid_information);

                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sub_tlv_type, tvb, sub_pnt, 1, ENC_BIG_ENDIAN);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sub_tlv_length, tvb, sub_pnt + 1, 2, ENC_BIG_ENDIAN);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sub_tlv_reserved, tvb, sub_pnt + 3, 1, ENC_NA);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sid_value, tvb, sub_pnt + 4, 16, ENC_NA);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sid_flags, tvb, sub_pnt + 20, 1, ENC_NA);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_srv6_endpoint_behavior, tvb, sub_pnt + 21, 2, ENC_NA);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_reserved, tvb, sub_pnt + 23, 1, ENC_NA);

                                        srv6_data_sstlv_item = proto_tree_add_item(stlv_tree,
                                                                                   hf_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlvs,
                                                                                   tvb, sub_pnt + 24, srv6_service_subtlv_len - 21, ENC_NA);
                                        srv6_data_sstlv_tree = proto_item_add_subtree(srv6_data_sstlv_item, ett_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlvs);

                                        sub_sub_pnt = sub_pnt + 24;
                                        sub_sub_end = sub_pnt + 3 + srv6_service_subtlv_len;
                                        while (sub_sub_pnt < sub_sub_end) {
                                            srv6_service_data_subsubtlv_type = tvb_get_guint8(tvb, sub_sub_pnt);
                                            srv6_service_data_subsubtlv_len = tvb_get_ntohs(tvb, sub_sub_pnt + 1);

                                            switch (srv6_service_data_subsubtlv_type) {
                                                case SRV6_SERVICE_DATA_SRV6_SID_STRUCTURE:
                                                    sstlv_item = proto_tree_add_item(srv6_data_sstlv_tree,
                                                                                     hf_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlv,
                                                                                     tvb, sub_sub_pnt , srv6_service_data_subsubtlv_len + 3, ENC_NA);
                                                    proto_item_append_text(sstlv_item, " - %s",
                                                                           val_to_str(srv6_service_data_subsubtlv_type, srv6_service_data_sub_sub_tlv_type, "Unknown (%u)"));
                                                    sstlv_tree = proto_item_add_subtree(sstlv_item, ett_bgp_prefix_sid_srv6_l2vpn_sid_structure);

                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlv_type, tvb, sub_sub_pnt, 1, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlv_length, tvb, sub_sub_pnt + 1, 2, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sid_locator_block_len, tvb, sub_sub_pnt + 3, 1, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sid_locator_node_len, tvb, sub_sub_pnt + 4, 1, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sid_func_len, tvb, sub_sub_pnt + 5, 1, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sid_arg_len, tvb, sub_sub_pnt + 6, 1, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sid_trans_len, tvb, sub_sub_pnt + 7, 1, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sid_trans_offset, tvb, sub_sub_pnt + 8, 1, ENC_BIG_ENDIAN);
                                                    break;
                                                default:
                                                    sstlv_item = proto_tree_add_item(srv6_data_sstlv_tree,
                                                                                     hf_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlv,
                                                                                     tvb, sub_sub_pnt , srv6_service_data_subsubtlv_len + 3, ENC_NA);
                                                    proto_item_append_text(sstlv_item, " - %s",
                                                                           val_to_str(srv6_service_data_subsubtlv_type, srv6_service_data_sub_sub_tlv_type, "Unknown (%u)"));
                                                    sstlv_tree = proto_item_add_subtree(sstlv_item, ett_bgp_prefix_sid_srv6_l2vpn_sid_unknown);

                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlv_type, tvb, sub_sub_pnt, 1, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlv_length, tvb, sub_sub_pnt + 1, 2, ENC_BIG_ENDIAN);
                                                    proto_tree_add_item(sstlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sub_sub_tlv_value, tvb, sub_sub_pnt + 3, srv6_service_data_subsubtlv_len, ENC_NA);
                                                    break;
                                            }
                                            sub_sub_pnt += 3 + srv6_service_data_subsubtlv_len;
                                        }
                                        break;
                                    default:
                                        stlv_item = proto_tree_add_item(srv6_stlv_tree,
                                                                        hf_bgp_prefix_sid_srv6_l2vpn_sub_tlv,
                                                                        tvb, sub_pnt , srv6_service_subtlv_len + 3, ENC_NA);
                                        proto_item_append_text(stlv_item, " - %s", val_to_str(srv6_service_subtlv_type, srv6_service_sub_tlv_type, "Unknown (%u)"));
                                        stlv_tree = proto_item_add_subtree(stlv_item, ett_bgp_prefix_sid_srv6_l2vpn_unknown);

                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sub_tlv_type, tvb, sub_pnt, 1, ENC_BIG_ENDIAN);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sub_tlv_length, tvb, sub_pnt + 1, 2, ENC_BIG_ENDIAN);
                                        proto_tree_add_item(stlv_tree, hf_bgp_prefix_sid_srv6_l2vpn_sub_tlv_value, tvb, sub_pnt + 3, srv6_service_subtlv_len, ENC_NA);
                                        break;
                                }
                                sub_pnt += 3 + srv6_service_subtlv_len;
                            }
                            q += (3 + prefix_sid_sublen);
                            break;
                        default:
                            tlv_item = proto_tree_add_item(subtree2, hf_bgp_prefix_sid_unknown, tvb, q, prefix_sid_sublen + 3, ENC_NA);
                            proto_item_append_text(tlv_item, " (%s)", val_to_str(prefix_sid_subtype, bgp_prefix_sid_type, "%u"));
                            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_prefix_sid_unknown);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_type, tvb, q, 1, ENC_BIG_ENDIAN);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_length, tvb, q + 1, 2, ENC_BIG_ENDIAN);
                            proto_tree_add_item(tlv_tree, hf_bgp_prefix_sid_value, tvb, q + 3, prefix_sid_sublen - 3, ENC_NA);
                            q += (3 + prefix_sid_sublen);
                            break;
                    }
                }
                break;
            case BGPTYPE_PMSI_TUNNEL_ATTR:
                dissect_bgp_update_pmsi_attr(pinfo, subtree2, tvb, tlen, o+i+aoff);
                break;

            case BGPTYPE_ATTR_SET:
                if (alen >= 4) {
                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_attrset_origin_as, tvb,
                                        o + i + aoff, 4, ENC_BIG_ENDIAN);
                    if (alen > 4) {
                        ti =  proto_tree_add_item(subtree2, hf_bgp_update_path_attributes, tvb, o+i+aoff+4, alen-4, ENC_NA);
                        attr_set_subtree = proto_item_add_subtree(ti, ett_bgp_attrs);
                        dissect_bgp_path_attr(attr_set_subtree, tvb, alen-4, o+i+aoff+4, pinfo);
                    }
                } else {
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, alen,
                                                 "Attribute set (invalid): %u byte%s",
                                                 alen, plurality(alen, "", "s"));
                }
                break;
            case BGPTYPE_OTC:
                if (tlen != 4) {
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,
                                                 "Only to Customer (invalid): %u byte%s", tlen,
                                                 plurality(tlen, "", "s"));
                } else {
                    proto_tree_add_item(subtree2, hf_bgp_update_path_attribute_otc, tvb,
                                        o + i + aoff, tlen, ENC_BIG_ENDIAN);
                    proto_item_append_text(ti_pa, ": %u", tvb_get_ntohl(tvb, o + i + aoff));
                }
                break;
            case BGPTYPE_D_PATH:
                if(tlen < 8){
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,
                                                 "D-PATH attribute has invalid length (invalid): %u byte%s", tlen,
                                                 plurality(tlen, "", "s"));
                    break;
                }
                q = o + i + aoff;
                end = q + tlen;
                wmem_strbuf_t *dpath_strbuf;
                dpath_strbuf = wmem_strbuf_create(pinfo->pool);
                guint8 dpath_len;
                dpath_len = tvb_get_guint8(tvb, q);
                proto_tree_add_item(subtree2, hf_bgp_d_path_length, tvb,
                                        q, 1, ENC_BIG_ENDIAN);
                q += 1;
                while (dpath_len > 0 && q < end) {
                    guint32 ad;
                    guint16 ld;
                    ad = tvb_get_ntohl(tvb, q);
                    ld = tvb_get_ntohs(tvb, q+4);
                    ti = proto_tree_add_string_format(subtree2, hf_bgp_update_path_attribute_d_path, tvb, q, 6, NULL, "Domain ID: %u:%u", ad, ld);
                    subtree3 = proto_item_add_subtree(ti, ett_bgp_dpath);
                    proto_tree_add_item(subtree3, hf_bgp_d_path_ga, tvb,
                                        q, 4, ENC_BIG_ENDIAN);
                    proto_tree_add_item(subtree3, hf_bgp_d_path_la, tvb,
                                        q + 4, 2, ENC_BIG_ENDIAN);
                    wmem_strbuf_append_printf(dpath_strbuf, " %u:%u", ad, ld);
                    q += 6;
                    dpath_len -= 1;
                }
                if (dpath_len != 0 || q >= end) {
                    proto_tree_add_expert_format(subtree2, pinfo, &ei_bgp_length_invalid, tvb, o + i + aoff, tlen,
                                                 "D-PATH list (invalid): %u byte%s", tlen,
                                                 plurality(tlen, "", "s"));
                    break;
                }
                proto_item_append_text(ti_pa, ":%s", wmem_strbuf_get_str(dpath_strbuf));

                proto_tree_add_item(subtree2, hf_bgp_d_path_isf_safi, tvb,
                                    q, 1, ENC_BIG_ENDIAN);
                break;
            default:
                proto_tree_add_item(subtree2, hf_bgp_update_path_attributes_unknown, tvb, o + i + aoff, tlen, ENC_NA);
                break;
        } /* switch (bgpa.bgpa_type) */ /* end of second switch */

        i += alen + aoff;
    }
    {
        /* FF: postponed BGPTYPE_LINK_STATE_ATTR dissection */
        link_state_data *data = load_link_state_data(pinfo);
        if (data && data->link_state_attr_present) {
            ti = proto_tree_add_item(data->subtree2, hf_bgp_update_path_attribute_link_state, tvb, data->ostart, data->tlen, ENC_NA);
            subtree3 = proto_item_add_subtree(ti, ett_bgp_link_state);
            while (data->ostart < data->oend) {
                advance = decode_link_state_attribute_tlv(subtree3, tvb, data->ostart, pinfo, data->protocol_id);
                if (advance < 0) {
                    break;
                }
                data->ostart += advance;
            }
        }
    }
}
