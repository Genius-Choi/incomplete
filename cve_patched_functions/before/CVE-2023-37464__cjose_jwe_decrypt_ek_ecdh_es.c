static bool _cjose_jwe_decrypt_ek_ecdh_es(_jwe_int_recipient_t *recipient, cjose_jwe_t *jwe, const cjose_jwk_t *jwk, cjose_err *err)
{
    cjose_jwk_t *epk_jwk = NULL;
    uint8_t *secret = NULL;
    size_t secret_len = 0;
    uint8_t *otherinfo = NULL;
    size_t otherinfo_len = 0;
    uint8_t *derived = NULL;
    bool result = false;

    memset(err, 0, sizeof(cjose_err));
    char *epk_json = cjose_header_get_raw(jwe->hdr, CJOSE_HDR_EPK, err);
    if (NULL != epk_json)
    {
        epk_jwk = cjose_jwk_import(epk_json, strlen(epk_json), err);
    }
    else if (CJOSE_ERR_NONE == err->code)
    {
        CJOSE_ERROR(err, CJOSE_ERR_INVALID_ARG);
        goto cjose_decrypt_ek_ecdh_es_finish;
    }

    if (NULL == epk_jwk)
    {
        // error details already set
        goto cjose_decrypt_ek_ecdh_es_finish;
    }

    // perform ECDH (private=jwk, public=epk_jwk)
    if (!cjose_jwk_derive_ecdh_bits(jwk, epk_jwk, &secret, &secret_len, err))
    {
        goto cjose_decrypt_ek_ecdh_es_finish;
    }

    // perform label, ConcatKDF
    // - assemble otherInfo from:
    //   * alg (== {enc})
    //   * apu (default = "")
    //   * apv (default = "")
    //   * keylen (determined from {enc})
    cjose_header_t *hdr = jwe->hdr;
    const char *algId = cjose_header_get(hdr, CJOSE_HDR_ENC, err);
    const size_t keylen = _keylen_from_enc(algId) / 8;

    if (!cjose_concatkdf_create_otherinfo(algId, keylen * 8, hdr, &otherinfo, &otherinfo_len, err))
    {
        goto cjose_decrypt_ek_ecdh_es_finish;
    }

    derived = cjose_concatkdf_derive(keylen, secret, secret_len, otherinfo, otherinfo_len, err);
    if (NULL == derived)
    {
        goto cjose_decrypt_ek_ecdh_es_finish;
    }

    jwe->cek = derived;
    jwe->cek_len = keylen;
    recipient->enc_key.raw = NULL;
    recipient->enc_key.raw_len = 0;
    result = true;

cjose_decrypt_ek_ecdh_es_finish:

    cjose_jwk_release(epk_jwk);
    cjose_get_dealloc()(epk_json);
    cjose_get_dealloc()(secret);
    cjose_get_dealloc()(otherinfo);

    return result;
}
