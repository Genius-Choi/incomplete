static void *pci_vtsock_tx_thread(void *vsc)
{
	struct pci_vtsock_softc *sc = vsc;
	struct vqueue_info *vq = &sc->vssc_vqs[VTSOCK_QUEUE_TX];
	fd_set rfd, wfd;
	LIST_HEAD(tx_queue, pci_vtsock_sock) queue;

	pthread_setname_np("vsock:tx");

	assert(sc);
	assert(sc->tx_wake_fd != -1);
	assert(sc->connect_fd != -1);

	while(1) {
		bool kick_rx_closing = false;
		int i, nrfd, maxfd, nr;
		int buffering = 0;
		struct pci_vtsock_sock *s;
		struct timeval *select_timeout = NULL, select_timeout_5s;

		LIST_INIT(&queue);

		FD_ZERO(&rfd);
		FD_ZERO(&wfd);

		FD_SET(sc->tx_wake_fd, &rfd);
		maxfd = sc->tx_wake_fd;

		FD_SET(sc->connect_fd, &rfd);
		maxfd = max_fd(sc->connect_fd, maxfd);
		nrfd = 2;

		for (i = 0; i < sc->nr_fwds; i++) {
			struct pci_vtsock_forward *fwd = &sc->fwds[i];
			assert(fwd->listen_fd != -1);
			FD_SET(fwd->listen_fd, &rfd);
			maxfd = max_fd(fwd->listen_fd, maxfd);
			nrfd++;
		}

		pthread_rwlock_rdlock(&sc->list_rwlock);
		LIST_FOREACH(s, &sc->inuse_list, list) {
			get_sock(s);

			switch (s->state) {
			case SOCK_CLOSING_TX: /* Closing comes through here */
				if (sock_is_buffering(s))
					break;

			        /* Close down */
				assert(s->local_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL ||
				       s->peer_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL);

				DPRINTF(("TX: Closing sock %p fd %d local %"PRIx32" peer %"PRIx32"\n",
					 (void *)s, s->fd,
					 s->local_shutdown,
					 s->peer_shutdown));
				PPRINTF(("TX: SOCK closed (%d) "PRIaddr" <=> "PRIaddr"\n",
					 s->fd,
					 FMTADDR(s->local_addr), FMTADDR(s->peer_addr)));

				s->state = SOCK_CLOSING_RX;

				kick_rx_closing = true;

				put_sock(s);
				continue;
			case SOCK_CONNECTED:
				break;
			case SOCK_FREE:
			case SOCK_CONNECTING:
			case SOCK_CLOSING_RX:
				put_sock(s);
				continue;
			}
			assert(s->fd >= 0);

			if (s->local_shutdown == VIRTIO_VSOCK_FLAG_SHUTDOWN_ALL) {
				time_t now = time(NULL);

				/* Has deadline for peer to return a RST expired? */
				if (now > s->rst_deadline) {
					send_response_sock(sc, VIRTIO_VSOCK_OP_RST, 0, s);
					close_sock(sc, s, "TX");
					put_sock(s);
					continue;
				} else if (select_timeout == NULL) {
					select_timeout_5s.tv_sec = 5;
					select_timeout_5s.tv_usec = 0;
					select_timeout = &select_timeout_5s;
				}
			}

			if (s->local_shutdown & VIRTIO_VSOCK_FLAG_SHUTDOWN_RX) {
				put_sock(s);
				continue;
			}

			if (sock_is_buffering(s)) {
				FD_SET(s->fd, &wfd);
				maxfd = max_fd(s->fd, maxfd);
				buffering++;
				nrfd++;
				LIST_INSERT_HEAD(&queue, s, tx_queue);
			}
			put_sock(s);
		}
		pthread_rwlock_unlock(&sc->list_rwlock);
		assert(maxfd < FD_SETSIZE);

		if (kick_rx_closing)
			kick_rx(sc, "tx closing");

		DPRINTF(("TX: *** selecting on %d fds (buffering: %d)\n",
			 nrfd, buffering));
		nr = xselect("TX", maxfd + 1, &rfd, &wfd, NULL, select_timeout);
		if (nr < 0) continue;
		DPRINTF(("TX:\nTX: *** %d/%d fds are readable/writeable\n", nr, nrfd));

		if (FD_ISSET(sc->tx_wake_fd, &rfd)) {
			/* Eat the notification(s) */
			char dummy[128];
			ssize_t rd_dummy = read(sc->tx_wake_fd, &dummy, sizeof(dummy));
			assert(rd_dummy >= 1);
			/* Restart select now that we have some descriptors */
			DPRINTF(("TX: thread got %zd kicks (have descs: %s)\n",
				 rd_dummy,
				 vq_has_descs(vq) ? "yes" : "no"));
		}

		if (FD_ISSET(sc->connect_fd, &rfd)) {
			DPRINTF(("TX: Handling connect fd\n"));
			handle_connect_fd(sc, sc->connect_fd, VMADDR_CID_ANY, 0);
		}

		for (i = 0; i < sc->nr_fwds; i++) {
			struct pci_vtsock_forward *fwd = &sc->fwds[i];
			if (FD_ISSET(fwd->listen_fd, &rfd)) {
				DPRINTF(("Attempt to connect to forwarded guest port %"PRId32"\n", fwd->port));
				handle_connect_fd(sc, fwd->listen_fd, sc->vssc_cfg.guest_cid, fwd->port);
			}
		}

		if (buffering) {
			LIST_FOREACH(s, &queue, tx_queue) {
				get_sock(s);
				if (s->state != SOCK_CONNECTED && s->state != SOCK_CLOSING_TX) {
					put_sock(s);
					continue;
				}
				if (FD_ISSET(s->fd, &wfd)) {
					buffer_drain(sc, s);
				}
				put_sock(s);
			}
		}

		while (vq_has_descs(vq))
			pci_vtsock_proc_tx(sc, vq);

		if (vq_ring_ready(vq))
			vq_endchains(vq, 1);

		if (sc->rx_kick_pending) {
			kick_rx(sc, "end of tx loop");
		}
		DPRINTF(("TX: All work complete\n"));
	}
}
