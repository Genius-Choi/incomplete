build_mcast_lookup_flows_for_lrouter(
        struct ovn_datapath *od, struct hmap *lflows,
        struct ds *match, struct ds *actions)
{
    if (od->nbr) {

        /* Drop IPv6 multicast traffic that shouldn't be forwarded,
         * i.e., router solicitation and router advertisement.
         */
        ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10550,
                      "nd_rs || nd_ra", debug_drop_action());
        if (!od->mcast_info.rtr.relay) {
            return;
        }

        struct ovn_igmp_group *igmp_group;

        LIST_FOR_EACH (igmp_group, list_node, &od->mcast_info.groups) {
            ds_clear(match);
            ds_clear(actions);
            if (IN6_IS_ADDR_V4MAPPED(&igmp_group->address)) {
                ds_put_format(match, "ip4 && ip4.dst == %s ",
                            igmp_group->mcgroup.name);
            } else {
                ds_put_format(match, "ip6 && ip6.dst == %s ",
                            igmp_group->mcgroup.name);
            }
            if (od->mcast_info.rtr.flood_static) {
                ds_put_cstr(actions,
                            "clone { "
                                "outport = \""MC_STATIC"\"; "
                                "ip.ttl--; "
                                "next; "
                            "};");
            }
            ds_put_format(actions, "outport = \"%s\"; ip.ttl--; next;",
                          igmp_group->mcgroup.name);
            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10500,
                          ds_cstr(match), ds_cstr(actions));
        }

        /* If needed, flood unregistered multicast on statically configured
         * ports. Otherwise drop any multicast traffic.
         */
        if (od->mcast_info.rtr.flood_static) {
            /* MLD and IGMP packets that need to be flooded statically
             * should be flooded without decrementing TTL (it's always
             * 1).  To prevent packets looping for ever (to some extent),
             * drop IGMP/MLD packets that are received from the router's
             * own mac addresses.
             */
            struct ovn_port *op;
            LIST_FOR_EACH (op, dp_node, &od->port_list) {
                ds_clear(match);
                ds_put_format(match, "eth.src == %s && igmp",
                              op->lrp_networks.ea_s);
                ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10550,
                              ds_cstr(match), debug_drop_action());

                ds_clear(match);
                ds_put_format(match, "eth.src == %s && (mldv1 || mldv2)",
                              op->lrp_networks.ea_s);
                ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10550,
                              ds_cstr(match), debug_drop_action());
            }

            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10460,
                          "igmp",
                          "clone { "
                                "outport = \""MC_STATIC"\"; "
                                "next; "
                          "};");
            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10460,
                          "mldv1 || mldv2",
                          "clone { "
                                "outport = \""MC_STATIC"\"; "
                                "next; "
                          "};");
            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10450,
                          "ip4.mcast || ip6.mcast",
                          "clone { "
                                "outport = \""MC_STATIC"\"; "
                                "ip.ttl--; "
                                "next; "
                          "};");
        } else {
            ovn_lflow_add(lflows, od, S_ROUTER_IN_IP_ROUTING, 10450,
                          "ip4.mcast || ip6.mcast", debug_drop_action());
        }
    }
}
