static void belle_sip_provider_dispatch_response(belle_sip_provider_t* p, belle_sip_response_t *msg){
	belle_sip_client_transaction_t *t;
	t=belle_sip_provider_find_matching_client_transaction(p,msg);

	/*good opportunity to cleanup auth context if answer = 401|407|403*/

	switch (belle_sip_response_get_status_code(msg)) {
	case 401:
	case 403:
	case 407: {
		if (t!=NULL){
			const char* nonce = NULL;
			belle_sip_message_t* req = BELLE_SIP_MESSAGE(belle_sip_transaction_get_request((belle_sip_transaction_t*)t));
			belle_sip_header_authorization_t* authorization=BELLE_SIP_HEADER_AUTHORIZATION(belle_sip_message_get_header_by_type(req, belle_sip_header_proxy_authorization_t));
			if (authorization==NULL) authorization=belle_sip_message_get_header_by_type(req, belle_sip_header_authorization_t);
			if (authorization!=NULL){
				nonce = belle_sip_header_authorization_get_nonce(authorization);
				if (nonce != NULL){
					belle_sip_list_t * auth_context_with_nonce = NULL;
					while ((auth_context_with_nonce = belle_sip_list_find_custom(p->auth_contexts, belle_sip_auth_context_find_by_nonce, nonce)) != NULL){
						belle_sip_authorization_destroy(auth_context_with_nonce->data);
						p->auth_contexts = belle_sip_list_delete_link(p->auth_contexts, auth_context_with_nonce);
					}
				}
			}
		}
		break;
	}
		default:
			if (t!=NULL){
				belle_sip_message_t* req = BELLE_SIP_MESSAGE(belle_sip_transaction_get_request((belle_sip_transaction_t*)t));
				belle_sip_header_authentication_info_t *authentication_info = belle_sip_message_get_header_by_type(msg,belle_sip_header_authentication_info_t);
				belle_sip_list_t *authorization_lst = NULL;
				belle_sip_header_call_id_t *call_id = belle_sip_message_get_header_by_type(msg,belle_sip_header_call_id_t);
				belle_sip_header_from_t *from = belle_sip_message_get_header_by_type(req,belle_sip_header_from_t);
				belle_sip_uri_t *from_uri=belle_sip_header_address_get_uri((belle_sip_header_address_t*)from);
				/*searching for authentication headers*/
				authorization_lst = belle_sip_list_copy(belle_sip_message_get_headers(BELLE_SIP_MESSAGE(req),BELLE_SIP_AUTHORIZATION));
				/*search for proxy authenticate*/
				authorization_lst=belle_sip_list_concat(authorization_lst,belle_sip_list_copy(belle_sip_message_get_headers(BELLE_SIP_MESSAGE(req),BELLE_SIP_PROXY_AUTHORIZATION)));
				/*update auth contexts with authenticate headers from response*/
				for (;authentication_info && authorization_lst!=NULL;authorization_lst=authorization_lst->next) {
					belle_sip_header_authorization_t *authorization=BELLE_SIP_HEADER_AUTHORIZATION(authorization_lst->data);
					belle_sip_header_www_authenticate_t *www_authenticate = belle_sip_auth_helper_create_www_authenticate(authorization);
					belle_sip_header_www_authenticate_set_nonce(www_authenticate, belle_sip_header_authentication_info_get_next_nonce(authentication_info));
					belle_sip_message( "Updating auth context for ream [%s] next nonce is going to be [%s]"
									  , belle_sip_header_www_authenticate_get_realm(www_authenticate)
									  , belle_sip_header_authentication_info_get_next_nonce(authentication_info));
					belle_sip_provider_update_or_create_auth_context(p
																	 , call_id
																	 , www_authenticate
																	 , from_uri
																	 ,belle_sip_header_www_authenticate_get_realm(www_authenticate));
					belle_sip_object_unref(www_authenticate);
				}
				if (authorization_lst)
					belle_sip_list_free(authorization_lst);
			}

	}
	if (t){ /*In some re-connection case, specially over udp, transaction may be found, but without associated channel*/
		if (t->base.channel == NULL) {
			belle_sip_channel_t *chan;
			belle_sip_message("Transaction [%p] does not have any channel associated, searching for a new one",t);
			chan=belle_sip_provider_get_channel(p,t->next_hop); /*might be faster to get channel directly from upper level*/
			if (chan){
				belle_sip_object_ref(chan);
				belle_sip_channel_add_listener(chan,BELLE_SIP_CHANNEL_LISTENER(t));
				t->base.channel=chan;
			}
		}
	}

	/*
	 * If a transaction is found and have a channel, pass it to the transaction and let it decide what to do.
	 * Else notifies directly.
	 */
	if (t && t->base.channel){
		/*since the add_response may indirectly terminate the transaction, we need to guarantee the transaction is not freed
		 * until full completion*/
		belle_sip_object_ref(t);
		belle_sip_client_transaction_add_response(t,msg);
		belle_sip_object_unref(t);
	}else{
		belle_sip_response_event_t event;
		event.source=(belle_sip_object_t*)p;
		event.client_transaction=NULL;
		event.dialog=NULL;
		event.response=msg;
		BELLE_SIP_PROVIDER_INVOKE_LISTENERS(p->listeners,process_response_event,&event);
	}
}
