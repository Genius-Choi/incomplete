int af_alg_accept(struct sock *sk, struct socket *newsock)
{
	struct alg_sock *ask = alg_sk(sk);
	const struct af_alg_type *type;
	struct sock *sk2;
	int err;

	lock_sock(sk);
	type = ask->type;

	err = -EINVAL;
	if (!type)
		goto unlock;

	sk2 = sk_alloc(sock_net(sk), PF_ALG, GFP_KERNEL, &alg_proto);
	err = -ENOMEM;
	if (!sk2)
		goto unlock;

	sock_init_data(newsock, sk2);
	sock_graft(sk2, newsock);
	security_sk_clone(sk, sk2);

	err = type->accept(ask->private, sk2);
	if (err) {
		sk_free(sk2);
		goto unlock;
	}

	sk2->sk_family = PF_ALG;

	sock_hold(sk);
	alg_sk(sk2)->parent = sk;
	alg_sk(sk2)->type = type;

	newsock->ops = type->ops;
	newsock->state = SS_CONNECTED;

	err = 0;

unlock:
	release_sock(sk);

	return err;
}
