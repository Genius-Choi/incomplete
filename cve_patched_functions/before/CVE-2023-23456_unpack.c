void PackTmt::unpack(OutputFile *fo) {
    Packer::handleStub(fi, fo, adam_offset);

    ibuf.alloc(ph.c_len);
    obuf.allocForDecompression(ph.u_len);

    fi->seek(adam_offset + ph.buf_offset + ph.getPackHeaderSize(), SEEK_SET);
    fi->readx(ibuf, ph.c_len);

    // decompress
    decompress(ibuf, obuf);

    // decode relocations
    const unsigned osize = ph.u_len - get_le32(obuf + ph.u_len - 4);
    SPAN_P_VAR(upx_byte, relocs, obuf + osize);
    const unsigned origstart = get_le32(obuf + ph.u_len - 8);

    // unfilter
    if (ph.filter) {
        Filter ft(ph.level);
        ft.init(ph.filter, 0);
        ft.cto = (unsigned char) ph.filter_cto;
        if (ph.version < 11)
            ft.cto = (unsigned char) (get_le32(obuf + ph.u_len - 12) >> 24);
        ft.unfilter(obuf, ptr_udiff_bytes(relocs, obuf));
    }

    // decode relocations
    MemBuffer mb_wrkmem;
    const unsigned relocn = unoptimizeReloc32(relocs, obuf, mb_wrkmem, true);
    SPAN_S_VAR(upx_byte, wrkmem, mb_wrkmem);
    for (unsigned ic = 0; ic < relocn; ic++)
        set_le32(wrkmem + ic * 4, get_le32(wrkmem + ic * 4) + 4);

    memcpy(&oh, &ih, sizeof(oh));
    oh.imagesize = osize;
    oh.entry = origstart;
    oh.relocsize = relocn * 4;

    const unsigned overlay = file_size - adam_offset - ih.imagesize - ih.relocsize - sizeof(ih);
    checkOverlay(overlay);

    // write decompressed file
    if (fo) {
        fo->write(&oh, sizeof(oh));
        fo->write(obuf, osize);
        fo->write(raw_bytes(wrkmem, relocn * 4), relocn * 4);
    }

    // copy the overlay
    copyOverlay(fo, overlay, obuf);
}
