ldbm_config_import_cachesize_set(void *arg,
                                 void *value,
                                 char *errorbuf,
                                 int phase __attribute__((unused)),
                                 int apply)
{
    struct ldbminfo *li = (struct ldbminfo *)arg;
    uint64_t val = (uint64_t)((uintptr_t)value);
    uint64_t delta;
    /* There is an error here. We check the new val against our current mem-alloc
     * Issue is that we already are using system pages, so while our value *might*
     * be valid, we may reject it here due to the current procs page usage.
     *
     * So how do we solve this? If we are setting a SMALLER value than we
     * currently have ALLOW it, because we already passed the cache sanity.
     * If we are setting a LARGER value, we check the delta of the two, and make
     * sure that it is sane.
     */
    if (val > li->li_import_cachesize) {
        delta = val - li->li_import_cachesize;

        util_cachesize_result sane;
        slapi_pal_meminfo *mi = spal_meminfo_get();
        sane = util_is_cachesize_sane(mi, &delta);
        spal_meminfo_destroy(mi);

        if (sane != UTIL_CACHESIZE_VALID) {
            slapi_create_errormsg(errorbuf, SLAPI_DSE_RETURNTEXT_SIZE, "Error: import cachesize value is too large.");
            slapi_log_err(SLAPI_LOG_ERR, "ldbm_config_import_cachesize_set",
                          "Import cachesize value is too large.\n");
            return LDAP_UNWILLING_TO_PERFORM;
        }
    }
    if (apply) {
        li->li_import_cachesize = val;
    }
    return LDAP_SUCCESS;
}
