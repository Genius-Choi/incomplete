bool HTTPServer::writeClient(Client* cl, int avail_bytes) {
	if (cl == NULL)
		return false;

	int actual_sent = 0; // Actual number of bytes sent as returned by send()
	int attempt_sent = 0; // Bytes that we're attempting to send now
	int remaining = 0; // Size of data left to send for the item
	bool disconnect = false;
	byte* pData = NULL;

	// The amount of available bytes to write, reported by the OS, cant really be trusted...
	if (avail_bytes > 1400) {
		// If the available amount of data is greater than the Ethernet MTU, cap it
		avail_bytes = 1400;
	} else if (avail_bytes == 0) {
		// Sometimes OS reports 0 when its possible to send data - attempt to trickle data
		// OS will eventually increase avail_bytes
		avail_bytes = 64;
	}

	SendQueueItem* item = cl->nextInSendQueue();
	if (item == NULL)
		return false;

	pData = item->getData();
	remaining = item->getSize() - item->getOffset();
	disconnect = item->getDisconnect();

	if (avail_bytes >= remaining) {
		// Send buffer is bigger than we need, rest of item can be sent
		attempt_sent = remaining;
	} else {
		// Send buffer is smaller than we need, send the amount thats available
		attempt_sent = avail_bytes;
	}

	// Send the data and increment the offset by the actual amount sent
	actual_sent = send(cl->getSocket(), pData + (item->getOffset()), attempt_sent, 0);
	if (actual_sent >= 0)
		item->setOffset(item->getOffset() + actual_sent);
	else
		disconnect = true;

	//std::cout << "[" << cl->getClientIP() << "] was sent " << actual_sent << " bytes " << std::endl;

	// SendQueueItem isnt needed anymore. Dequeue and delete
	if (item->getOffset() >= item->getSize())
		cl->dequeueFromSendQueue();

	if (disconnect) {
		disconnectClient(cl);
		return false;
	}

	return true;
}
