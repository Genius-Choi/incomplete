ovn_lb_svc_create(struct ovsdb_idl_txn *ovnsb_txn, struct ovn_northd_lb *lb,
                  struct hmap *monitor_map, struct hmap *ports)
{
    if (lb->template) {
        return;
    }

    for (size_t i = 0; i < lb->n_vips; i++) {
        struct ovn_lb_vip *lb_vip = &lb->vips[i];
        struct ovn_northd_lb_vip *lb_vip_nb = &lb->vips_nb[i];

        for (size_t j = 0; j < lb_vip->n_backends; j++) {
            struct ovn_lb_backend *backend = &lb_vip->backends[j];
            struct ovn_northd_lb_backend *backend_nb =
                &lb_vip_nb->backends_nb[j];

            struct ovn_port *op = NULL;
            char *svc_mon_src_ip = NULL;

            struct ds key = DS_EMPTY_INITIALIZER;
            ds_put_format(&key,
                          IN6_IS_ADDR_V4MAPPED(&lb_vip->vip)
                          ? "%s" : "[%s]", backend->ip_str);

            const char *s = smap_get(&lb->nlb->ip_port_mappings,
                                     ds_cstr(&key));
            if (s) {
                char *port_name = xstrdup(s);
                char *p = strstr(port_name, ":");
                if (p) {
                    *p = 0;
                    p++;
                    op = ovn_port_find(ports, port_name);
                    struct sockaddr_storage svc_mon_src_addr;
                    if (!inet_parse_address(p, &svc_mon_src_addr)) {
                        static struct vlog_rate_limit rl =
                            VLOG_RATE_LIMIT_INIT(5, 1);
                        VLOG_WARN_RL(&rl, "Invalid svc mon src IP %s", p);
                    } else {
                        struct ds src_ip_s = DS_EMPTY_INITIALIZER;
                        ss_format_address_nobracks(&svc_mon_src_addr,
                                                   &src_ip_s);
                        svc_mon_src_ip = ds_steal_cstr(&src_ip_s);
                    }
                }
                free(port_name);
            }
            ds_destroy(&key);

            backend_nb->op = op;
            backend_nb->svc_mon_src_ip = svc_mon_src_ip;

            if (!lb_vip_nb->lb_health_check || !op || !svc_mon_src_ip ||
                !lsp_is_enabled(op->nbsp)) {
                continue;
            }

            const char *protocol = lb->nlb->protocol;
            if (!protocol || !protocol[0]) {
                protocol = "tcp";
            }
            backend_nb->health_check = true;
            struct service_monitor_info *mon_info =
                create_or_get_service_mon(ovnsb_txn, monitor_map,
                                          backend->ip_str,
                                          backend_nb->op->nbsp->name,
                                          backend->port,
                                          protocol);
            ovs_assert(mon_info);
            sbrec_service_monitor_set_options(
                mon_info->sbrec_mon, &lb_vip_nb->lb_health_check->options);
            struct eth_addr ea;
            if (!mon_info->sbrec_mon->src_mac ||
                !eth_addr_from_string(mon_info->sbrec_mon->src_mac, &ea) ||
                !eth_addr_equals(ea, svc_monitor_mac_ea)) {
                sbrec_service_monitor_set_src_mac(mon_info->sbrec_mon,
                                                  svc_monitor_mac);
            }

            if (!mon_info->sbrec_mon->src_ip ||
                strcmp(mon_info->sbrec_mon->src_ip,
                       backend_nb->svc_mon_src_ip)) {
                sbrec_service_monitor_set_src_ip(
                    mon_info->sbrec_mon,
                    backend_nb->svc_mon_src_ip);
            }

            if ((!op->sb->n_up || !op->sb->up[0])
                && mon_info->sbrec_mon->status
                && !strcmp(mon_info->sbrec_mon->status, "online")) {
                sbrec_service_monitor_set_status(mon_info->sbrec_mon,
                                                 "offline");
            }

            backend_nb->sbrec_monitor = mon_info->sbrec_mon;
            mon_info->required = true;
        }
    }
}
