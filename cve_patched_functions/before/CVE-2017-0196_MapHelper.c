    Var JavascriptArray::MapHelper(JavascriptArray* pArr, Js::TypedArrayBase* typedArrayBase, RecyclableObject* obj, T length, Arguments& args, ScriptContext* scriptContext)
    {
        RecyclableObject* newObj = nullptr;
        JavascriptArray* newArr = nullptr;
        bool isTypedArrayEntryPoint = typedArrayBase != nullptr;
        bool isBuiltinArrayCtor = true;

        if (args.Info.Count < 2 || !JavascriptConversion::IsCallable(args[1]))
        {
            if (isTypedArrayEntryPoint)
            {
                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u("[TypedArray].prototype.map"));
            }
            else
            {
                JavascriptError::ThrowTypeError(scriptContext, JSERR_FunctionArgument_NeedFunction, _u("Array.prototype.map"));
            }
        }

        RecyclableObject* callBackFn = RecyclableObject::FromVar(args[1]);
        Var thisArg;

        if (args.Info.Count > 2)
        {
            thisArg = args[2];
        }
        else
        {
            thisArg = scriptContext->GetLibrary()->GetUndefined();
        }

        // If we came from Array.prototype.map and source object is not a JavascriptArray, source could be a TypedArray
        if (!isTypedArrayEntryPoint && pArr == nullptr && TypedArrayBase::Is(obj))
        {
            typedArrayBase = TypedArrayBase::FromVar(obj);
        }

        // If the entry point is %TypedArray%.prototype.map or the source object is an Array exotic object we should try to load the constructor property
        // and use it to construct the return object.
        if (isTypedArrayEntryPoint)
        {
            Var constructor = JavascriptOperators::SpeciesConstructor(
                typedArrayBase, TypedArrayBase::GetDefaultConstructor(args[0], scriptContext), scriptContext);
            isBuiltinArrayCtor = (constructor == scriptContext->GetLibrary()->GetArrayConstructor());

            if (JavascriptOperators::IsConstructor(constructor))
            {
                Js::Var constructorArgs[] = { constructor, JavascriptNumber::ToVar(length, scriptContext) };
                Js::CallInfo constructorCallInfo(Js::CallFlags_New, _countof(constructorArgs));
                newObj = RecyclableObject::FromVar(TypedArrayBase::TypedArrayCreate(constructor, &Js::Arguments(constructorCallInfo, constructorArgs), (uint32)length, scriptContext));
            }
            else if (isTypedArrayEntryPoint)
            {
                // We only need to throw a TypeError when the constructor property is not an actual constructor if %TypedArray%.prototype.map was called
                JavascriptError::ThrowTypeError(scriptContext, JSERR_NotAConstructor, _u("[TypedArray].prototype.map"));
            }
        }
        // skip the typed array and "pure" array case, we still need to handle special arrays like es5array, remote array, and proxy of array.
        else if (pArr == nullptr || scriptContext->GetConfig()->IsES6SpeciesEnabled())
        {
            newObj = ArraySpeciesCreate(obj, length, scriptContext, nullptr, nullptr, &isBuiltinArrayCtor);
        }

        if (newObj == nullptr)
        {
            if (length > UINT_MAX)
            {
                JavascriptError::ThrowRangeError(scriptContext, JSERR_ArrayLengthConstructIncorrect);
            }
            newArr = scriptContext->GetLibrary()->CreateArray(static_cast<uint32>(length));
            newArr->EnsureHead<Var>();
            newObj = newArr;
        }
        else
        {
            // If the new object we created is an array, remember that as it will save us time setting properties in the object below
            if (JavascriptArray::Is(newObj))
            {
#if ENABLE_COPYONACCESS_ARRAY
                JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(newObj);
#endif
                newArr = JavascriptArray::FromVar(newObj);
            }
        }

        Var element = nullptr;
        Var mappedValue = nullptr;
        // The correct flag value is CallFlags_Value but we pass CallFlags_None in compat modes
        CallFlags callBackFnflags = CallFlags_Value;
        CallInfo callBackFnInfo = CallInfo(callBackFnflags, 4);

        // We at least have to have newObj as a valid object
        Assert(newObj);

        if (pArr != nullptr)
        {
            // If source is a JavascriptArray, newObj may or may not be an array based on what was in source's constructor property

            for (uint32 k = 0; k < length; k++)
            {
                if (!pArr->DirectGetItemAtFull(k, &element))
                {
                    continue;
                }

                mappedValue = CALL_FUNCTION(callBackFn, callBackFnInfo, thisArg,
                    element,
                    JavascriptNumber::ToVar(k, scriptContext),
                    pArr);

                // If newArr is a valid pointer, then we constructed an array to return. Otherwise we need to do generic object operations
                if (newArr && isBuiltinArrayCtor)
                {
                    newArr->DirectSetItemAt(k, mappedValue);
                }
                else
                {
                    ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, mappedValue), scriptContext, k);
                }
            }
        }
        else if (typedArrayBase != nullptr)
        {
            // Source is a TypedArray, we may have tried to call a constructor, but newObj may not be a TypedArray (or an array either)
            TypedArrayBase* newTypedArray = nullptr;

            if (TypedArrayBase::Is(newObj))
            {
                newTypedArray = TypedArrayBase::FromVar(newObj);
            }

            for (uint32 k = 0; k < length; k++)
            {
                // We can't rely on the length value being equal to typedArrayBase->GetLength() because user code may lie and
                // attach any length property to a TypedArray instance and pass it as this parameter when .calling
                // Array.prototype.map.
                if (!typedArrayBase->HasItem(k))
                {
                    // We know that if HasItem returns false, all the future calls to HasItem will return false as well since
                    // we visit the items in order. We could return early here except that we have to continue calling HasItem
                    // on all the subsequent items according to the spec.
                    continue;
                }

                element = typedArrayBase->DirectGetItem(k);
                mappedValue = CALL_FUNCTION(callBackFn, callBackFnInfo, thisArg,
                    element,
                    JavascriptNumber::ToVar(k, scriptContext),
                    obj);

                // If newObj is a TypedArray, set the mappedValue directly, otherwise see if it's an array and finally fall back to
                // the normal Set path.
                if (newTypedArray)
                {
                    newTypedArray->DirectSetItem(k, mappedValue);
                }
                else if (newArr)
                {
                    newArr->DirectSetItemAt(k, mappedValue);
                }
                else
                {
                    JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, mappedValue);
                }
            }
        }
        else
        {
            for (uint32 k = 0; k < length; k++)
            {
                if (JavascriptOperators::HasItem(obj, k))
                {
                    element = JavascriptOperators::GetItem(obj, k, scriptContext);
                    mappedValue = CALL_FUNCTION(callBackFn, callBackFnInfo, thisArg,
                        element,
                        JavascriptNumber::ToVar(k, scriptContext),
                        obj);

                    if (newArr && isBuiltinArrayCtor)
                    {
                        newArr->SetItem(k, mappedValue, PropertyOperation_None);
                    }
                    else
                    {
                        ThrowErrorOnFailure(JavascriptArray::SetArrayLikeObjects(RecyclableObject::FromVar(newObj), k, mappedValue), scriptContext, k);
                    }
                }
            }
        }

#ifdef VALIDATE_ARRAY
        if (JavascriptArray::Is(newObj))
        {
            newArr->ValidateArray();
        }
#endif

        return newObj;
    }
