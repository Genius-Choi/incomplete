ssize_t tport_recv_iovec(tport_t const *self,
			 msg_t **in_out_msg,
			 msg_iovec_t iovec[msg_n_fragments],
			 size_t N,
			 int exact)
{
  msg_t *msg = *in_out_msg;
  ssize_t i, veclen;
  int fresh;

  if (N == 0)
    return 0;

  fresh = !msg;

  /*
   * Allocate a new message if needed
   */
  if (!msg) {
    if (!(*in_out_msg = msg = tport_msg_alloc(self, N))) {
      SU_DEBUG_7(("%s(%p): cannot allocate msg for "MOD_ZU" bytes "
		  "from (%s/%s:%s)\n",
		  __func__, (void *)self, N,
		  self->tp_protoname, self->tp_host, self->tp_port));
      return -1;
    }
  }

  /*
   * Get enough buffer space for the incoming data
   */
  veclen = msg_recv_iovec(msg, iovec, msg_n_fragments, N, exact);
  if (veclen < 0) {
    int err = su_errno();
    if (fresh && err == ENOBUFS && msg_get_flags(msg, MSG_FLG_TOOLARGE))
      veclen = msg_recv_iovec(msg, iovec, msg_n_fragments, 4096, 1);
  }
  if (veclen < 0) {
    int err = su_errno();
    SU_DEBUG_7(("%s(%p): cannot get msg %p buffer for "MOD_ZU" bytes "
		"from (%s/%s:%s): %s\n",
		__func__, (void *)self, (void *)msg, N,
		self->tp_protoname, self->tp_host, self->tp_port,
		su_strerror(err)));
    su_seterrno(err);
    return veclen;
  }

  assert(veclen <= msg_n_fragments);

  SU_DEBUG_7(("%s(%p) msg %p from (%s/%s:%s) has "MOD_ZU" bytes, "
	      "veclen = "MOD_ZD"\n",
              __func__, (void *)self,
	      (void *)msg, self->tp_protoname, self->tp_host, self->tp_port,
	      N, veclen));

  for (i = 0; veclen > 1 && i < veclen; i++) {
    SU_DEBUG_7(("\tiovec[%lu] = %lu bytes\n", (LU)i, (LU)iovec[i].mv_len));
  }

  return veclen;
}
