int popen_impl(const char* cmd, const char* mode, pid_t* out_pid) {
  int p[2];
  auto const read = *mode == 'r';
  if (!read && *mode != 'w') return -1;

  if (pipe2(p, O_CLOEXEC) < 0) {
    return -1;
  }

  auto pid = fork();
  if (pid < 0) {
    close(p[0]);
    close(p[1]);
    return -1;
  }
  int child_pipe = read ? 1 : 0;
  if (pid == 0) {
    // child
    mprotect_1g_pages(PROT_READ);
    // If anything goes wrong, let the OOM killer kill this child process.
    Process::OOMScoreAdj(1000);
    // replace stdin or stdout with the appropriate end
    // of the pipe
    if (p[child_pipe] == child_pipe) {
      // pretty unlikely, but if it was we must clear CLOEXEC,
      // and the only way to do that is to dup it to a new fd,
      // and then dup2 it back
      p[child_pipe] = fcntl(child_pipe, F_DUPFD_CLOEXEC, 3);
    }
    dup2(p[child_pipe], child_pipe);
    // no need to close p[child_pipe] because of O_CLOEXEC

    signal(SIGINT, SIG_DFL);
    sigset_t eset;
    sigemptyset(&eset);
    sigprocmask(SIG_SETMASK, &eset, nullptr);
    execl("/bin/sh", "sh", "-c", cmd, nullptr);
    Logger::Warning("Failed to exec: `%s'", cmd);
    _Exit(1);
  }
  // parent

  // close the pipe we're not using
  close(p[child_pipe]);
  *out_pid = pid;
  return p[1-child_pipe];
}
