static int resize_key_frame(VP8_COMP *cpi) {
#if CONFIG_SPATIAL_RESAMPLING
  VP8_COMMON *cm = &cpi->common;

  /* Do we need to apply resampling for one pass cbr.
   * In one pass this is more limited than in two pass cbr.
   * The test and any change is only made once per key frame sequence.
   */
  if (cpi->oxcf.allow_spatial_resampling &&
      (cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER)) {
    int hr, hs, vr, vs;
    int new_width, new_height;

    /* If we are below the resample DOWN watermark then scale down a
     * notch.
     */
    if (cpi->buffer_level < (cpi->oxcf.resample_down_water_mark *
                             cpi->oxcf.optimal_buffer_level / 100)) {
      cm->horiz_scale =
          (cm->horiz_scale < VP8E_ONETWO) ? cm->horiz_scale + 1 : VP8E_ONETWO;
      cm->vert_scale =
          (cm->vert_scale < VP8E_ONETWO) ? cm->vert_scale + 1 : VP8E_ONETWO;
    }
    /* Should we now start scaling back up */
    else if (cpi->buffer_level > (cpi->oxcf.resample_up_water_mark *
                                  cpi->oxcf.optimal_buffer_level / 100)) {
      cm->horiz_scale =
          (cm->horiz_scale > VP8E_NORMAL) ? cm->horiz_scale - 1 : VP8E_NORMAL;
      cm->vert_scale =
          (cm->vert_scale > VP8E_NORMAL) ? cm->vert_scale - 1 : VP8E_NORMAL;
    }

    /* Get the new height and width */
    Scale2Ratio(cm->horiz_scale, &hr, &hs);
    Scale2Ratio(cm->vert_scale, &vr, &vs);
    new_width = ((hs - 1) + (cpi->oxcf.Width * hr)) / hs;
    new_height = ((vs - 1) + (cpi->oxcf.Height * vr)) / vs;

    /* If the image size has changed we need to reallocate the buffers
     * and resample the source image
     */
    if ((cm->Width != new_width) || (cm->Height != new_height)) {
      cm->Width = new_width;
      cm->Height = new_height;
      vp8_alloc_compressor_data(cpi);
      scale_and_extend_source(cpi->un_scaled_source, cpi);
      return 1;
    }
  }

#endif
  return 0;
}
