static int symbol(void) {
	int r, code = RLC_ERR;
	bn_t a, b, c, p, q;

	bn_null(a);
	bn_null(b);
	bn_null(c);
	bn_null(p);
	bn_null(q);

	RLC_TRY {
		bn_new(a);
		bn_new(b);
		bn_new(c);
		bn_new(p);
		bn_new(q);

		do {
			bn_gen_prime(p, RLC_BN_BITS);
			bn_gen_prime(q, RLC_BN_BITS);
		} while (bn_is_even(p) || bn_is_even(q));

		TEST_CASE("legendre symbol is correct") {
			TEST_ASSERT(bn_smb_leg(p, p) == 0, end);
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_sqr(a, a);
			bn_mod(a, a, p);
			TEST_ASSERT(bn_smb_leg(a, p) == 1, end);
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			r = bn_smb_leg(a, p);
			TEST_ASSERT(r == 1 || r == -1, end);
		} TEST_END;

		TEST_CASE("legendre symbol is a homomorphism") {
			bn_rand(a, RLC_POS, RLC_BN_BITS / 2);
			bn_rand(b, RLC_POS, RLC_BN_BITS / 2);
			bn_mul(c, a, b);
			r = bn_smb_leg(a, p) * bn_smb_leg(b, p);
			TEST_ASSERT(r == bn_smb_leg(c, p), end);
		} TEST_END;

		TEST_ONCE("legendre symbol satisfies quadratic reciprocity") {
			/* Check the first supplement: (-1|p) = (-1)^(p-1)/2. */
			bn_set_dig(a, 1);
			bn_neg(a, a);
			r = bn_smb_leg(a, p);
			bn_set_dig(b, (r < 0 ? -r : r));
			if (r < 0) {
				bn_neg(b, b);
			}
			bn_sub_dig(c, p, 1);
			bn_rsh(c, c, 1);
			if (bn_is_even(c)) {
				bn_neg(a, a);
			}
			TEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);
			/* Check second supplement: (2|p) = (-1)^(p^2-1)/8. */
			bn_set_dig(a, 2);
			r = bn_smb_leg(a, p);
			bn_set_dig(b, (r < 0 ? -r : r));
			if (r < 0) {
				bn_neg(b, b);
			}
			bn_sqr(c, p);
			bn_sub_dig(c, c, 1);
			bn_rsh(c, c, 3);
			bn_set_dig(a, 1);
			if (!bn_is_even(c)) {
				bn_neg(a, a);
			}
			TEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);
			/* Check quadratic reciprocity law. */
			r = bn_smb_leg(q, p);
			bn_set_dig(a, (r < 0 ? -r : r));
			if (r < 0) {
				bn_neg(a, a);
			}
			r = bn_smb_leg(p, q);
			bn_set_dig(b, (r < 0 ? -r : r));
			if (r < 0) {
				bn_neg(b, b);
			}
			bn_sub_dig(c, p, 1);
			bn_rsh(c, c, 1);
			if (!bn_is_even(c)) {
				bn_sub_dig(c, q, 1);
				bn_rsh(c, c, 1);
				if (!bn_is_even(c)) {
					bn_neg(b, b);
				}
			}
			TEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);
		} TEST_END;

		TEST_CASE("jacobi symbol is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			TEST_ASSERT(bn_smb_leg(a, p) == bn_smb_jac(a, p), end);
		} TEST_END;

		TEST_CASE("jacobi symbol is a homomorphism") {
			bn_rand(a, RLC_POS, RLC_BN_BITS / 2);
			bn_rand(b, RLC_POS, RLC_BN_BITS / 2);
			bn_rand(p, RLC_POS, RLC_BN_BITS / 2);
			if (bn_is_even(p)) {
				bn_add_dig(p, p, 1);
			}
			bn_mul(c, a, b);
			r = bn_smb_jac(a, p) * bn_smb_jac(b, p);
			TEST_ASSERT(r == bn_smb_jac(c, p), end);
		} TEST_END;

		TEST_CASE("jacobi symbol is consistent with gcd") {
			bn_rand(a, RLC_POS, RLC_BN_BITS / 2);
			bn_rand(p, RLC_POS, RLC_BN_BITS / 2);
			if (bn_is_even(p)) {
				bn_add_dig(p, p, 1);
			}
			r = bn_smb_jac(a, p);
			bn_set_dig(c, (r < 0 ? -r : r));
			if (r < 0) {
				bn_neg(c, c);
			}
			bn_gcd(b, a, p);
			if (bn_cmp_dig(b, 1) != RLC_EQ) {
				TEST_ASSERT(r == 0, end);
			} else {
				TEST_ASSERT(r == 1 || r == -1, end);
			}
		} TEST_END;

		TEST_CASE("jacobi symbol satisfies quadratic reciprocity") {
			bn_rand(p, RLC_POS, RLC_BN_BITS / 2);
			if (bn_is_even(p)) {
				bn_add_dig(p, p, 1);
			}
			bn_rand(q, RLC_POS, RLC_BN_BITS / 2);
			if (bn_is_even(q)) {
				bn_add_dig(q, q, 1);
			}
			/* Check the first supplement: (-1|n) = (-1)^(n-1)/2. */
			bn_set_dig(a, 1);
			bn_neg(a, a);
			r = bn_smb_jac(a, p);
			bn_set_dig(b, (r < 0 ? -r : r));
			if (r < 0) {
				bn_neg(b, b);
			}
			bn_sub_dig(c, p, 1);
			bn_rsh(c, c, 1);
			if (bn_is_even(c)) {
				bn_neg(a, a);
			}
			TEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);
			/* Check second supplement: (2|p) = (-1)^(p^2-1)/8. */
			bn_set_dig(a, 2);
			r = bn_smb_jac(a, p);
			bn_set_dig(b, (r < 0 ? -r : r));
			if (r < 0) {
				bn_neg(b, b);
			}
			bn_sqr(c, p);
			bn_sub_dig(c, c, 1);
			bn_rsh(c, c, 3);
			bn_set_dig(a, 1);
			if (!bn_is_even(c)) {
				bn_neg(a, a);
			}
			TEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);
			/* Check quadratic reciprocity law. */
			r = bn_smb_jac(p, q);
			bn_set_dig(a, (r < 0 ? -r : r));
			if (r < 0) {
				bn_neg(a, a);
			}
			r = bn_smb_jac(q, p);
			bn_set_dig(b, (r < 0 ? -r : r));
			if (r < 0) {
				bn_neg(b, b);
			}
			bn_sub_dig(c, p, 1);
			bn_rsh(c, c, 1);
			if (!bn_is_even(c)) {
				bn_sub_dig(c, q, 1);
				bn_rsh(c, c, 1);
				if (!bn_is_even(c)) {
					bn_neg(b, b);
				}
			}
			TEST_ASSERT(bn_cmp(a, b) == RLC_EQ, end);
		} TEST_END;
	}
	RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;
  end:
	bn_free(a);
	bn_free(b);
	bn_free(c);
	bn_free(p);
	bn_free(q);
	return code;
}
