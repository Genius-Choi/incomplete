m_free(struct mbuf *m)
{
	struct mbuf *n;
	struct counters_ref cr;
	uint64_t *counters;
	int s;

	if (m == NULL)
		return (NULL);

	s = splnet();
	counters = counters_enter(&cr, mbstat);
	counters[m->m_type]--;
	counters_leave(&cr, mbstat);
	splx(s);

	n = m->m_next;
	if (m->m_flags & M_ZEROIZE) {
		m_zero(m);
		/* propagate M_ZEROIZE to the next mbuf in the chain */
		if (n)
			n->m_flags |= M_ZEROIZE;
	}
	if (m->m_flags & M_PKTHDR) {
		m_tag_delete_chain(m);
#if NPF > 0
		pf_mbuf_unlink_state_key(m);
		pf_mbuf_unlink_inpcb(m);
#endif	/* NPF > 0 */
	}
	if (m->m_flags & M_EXT)
		m_extfree(m);

	pool_put(&mbpool, m);

	return (n);
}
