pci_xhci_init(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	struct pci_xhci_vdev *xdev;
	struct pci_xhci_excap *excap;
	int	error;

	if (xhci_in_use) {
		UPRINTF(LWRN, "controller already defined\r\n");
		return -1;
	}

	xdev = calloc(1, sizeof(struct pci_xhci_vdev));
	if (!xdev) {
		UPRINTF(LWRN, "%s:%d fail to allocate memory\n",
			__func__, __LINE__);
		return -1;
	}

	dev->arg = xdev;
	xdev->dev = dev;

	xdev->usb2_port_start = (XHCI_MAX_DEVS/2) + 1;
	xdev->usb3_port_start = 1;

	xdev->vid = PCI_ACRN_XHCI_VID;
	xdev->pid = PCI_ACRN_XHCI_PID;
	xdev->excapoff = ACRN_XHCI_EXCAP1;
	xdev->excap_ptr = NULL;

	xdev->rtsregs.mfindex = 0;
	clock_gettime(CLOCK_MONOTONIC, &xdev->init_time);

	/* discover devices */
	error = pci_xhci_parse_opts(xdev, opts);
	if (error < 0)
		goto done;
	else
		error = 0;

	if (usb_dev_sys_init(pci_xhci_native_usb_dev_conn_cb,
				pci_xhci_native_usb_dev_disconn_cb,
				pci_xhci_usb_dev_notify_cb,
				pci_xhci_usb_dev_intr_cb,
				pci_xhci_usb_dev_lock_ep_cb,
				pci_xhci_usb_dev_unlock_ep_cb,
				xdev, usb_get_log_level()) < 0) {
		error = -3;
		goto done;
	}

	xdev->caplength = XHCI_SET_CAPLEN(XHCI_CAPLEN) |
			 XHCI_SET_HCIVERSION(0x0100);
	xdev->hcsparams1 = XHCI_SET_HCSP1_MAXPORTS(XHCI_MAX_DEVS) |
			 XHCI_SET_HCSP1_MAXINTR(1) |	/* interrupters */
			 XHCI_SET_HCSP1_MAXSLOTS(XHCI_MAX_SLOTS);
	xdev->hcsparams2 = XHCI_SET_HCSP2_ERSTMAX(XHCI_ERST_MAX) |
			 XHCI_SET_HCSP2_IST(0x04);
	xdev->hcsparams3 = 0;				/* no latency */
	xdev->hccparams1 = XHCI_SET_HCCP1_NSS(1) |	/* no 2nd-streams */
			 XHCI_SET_HCCP1_SPC(1) |	/* short packet */
			 XHCI_SET_HCCP1_MAXPSA(XHCI_STREAMS_MAX);
	xdev->hccparams2 = XHCI_SET_HCCP2_LEC(1) |
			 XHCI_SET_HCCP2_U3C(1);
	xdev->dboff = XHCI_SET_DOORBELL(XHCI_CAPLEN + XHCI_PORTREGS_START +
			 XHCI_MAX_DEVS * sizeof(struct pci_xhci_portregs));

	/* dboff must be 32-bit aligned */
	if (xdev->dboff & 0x3)
		xdev->dboff = (xdev->dboff + 0x3) & ~0x3;

	/* rtsoff must be 32-bytes aligned */
	xdev->rtsoff = XHCI_SET_RTSOFFSET(xdev->dboff +
		(XHCI_MAX_SLOTS+1) * 32);
	if (xdev->rtsoff & 0x1F)
		xdev->rtsoff = (xdev->rtsoff + 0x1F) & ~0x1F;
	xdev->rtsend = xdev->rtsoff + XHCI_RT_IR_BASE + sizeof(xdev->rtsregs);

	UPRINTF(LDBG, "dboff: 0x%x, rtsoff: 0x%x\r\n", xdev->dboff,
		 xdev->rtsoff);

	xdev->opregs.usbsts = XHCI_STS_HCH;
	xdev->opregs.pgsz = XHCI_PAGESIZE_4K;

	pci_xhci_reset(xdev);

	excap = xdev->excap_ptr;
	if (excap == NULL) {
		xdev->regsend = xdev->rtsend;
		xdev->excapoff = ACRN_XHCI_EXCAP1;
	} else {
		xdev->excapoff = excap->start;
		while (excap && excap->start != EXCAP_GROUP_END) {
			xdev->regsend = excap->end;
			excap++;
		}
	}

	/*
	 * Set extended capabilities pointer to be after regsend;
	 * value of excap field is 32-bit offset.
	 */
	xdev->hccparams1 |=
		XHCI_SET_HCCP1_XECP(XHCI_XECP_OFF_SHIFT(xdev->excapoff));

	pci_set_cfgdata16(dev, PCIR_DEVICE, xdev->pid);
	pci_set_cfgdata16(dev, PCIR_VENDOR, xdev->vid);
	pci_set_cfgdata8(dev, PCIR_CLASS, PCIC_SERIALBUS);
	pci_set_cfgdata8(dev, PCIR_SUBCLASS, PCIS_SERIALBUS_USB);
	pci_set_cfgdata8(dev, PCIR_PROGIF, PCIP_SERIALBUS_USB_XHCI);
	pci_set_cfgdata8(dev, PCI_USBREV, PCI_USB_REV_3_0);

	pci_emul_add_msicap(dev, 1);

	/* regsend registers */
	pci_emul_alloc_bar(dev, 0, PCIBAR_MEM32, xdev->regsend);
	UPRINTF(LDBG, "pci_emu_alloc: %d\r\n", xdev->regsend);

	pci_lintr_request(dev);

	pthread_mutex_init(&xdev->mtx, NULL);

	/* create vbdp_thread */
	xdev->vbdp_polling = true;
	sem_init(&xdev->vbdp_sem, 0, 0);
	error = pthread_create(&xdev->vbdp_thread, NULL, xhci_vbdp_thread,
			xdev);
	if (error)
		goto done;

	xhci_in_use = 1;
done:
	if (error) {
		UPRINTF(LFTL, "%s fail, error=%d\n", __func__, error);
		if (xdev) {
			if (xdev->devices) {
				free(xdev->devices);
				xdev->devices = NULL;
			}
			if (xdev->slots) {
				free(xdev->slots);
				xdev->slots = NULL;
			}
			if (xdev->portregs) {
				free(xdev->portregs);
				xdev->portregs = NULL;
			}
			free(xdev);
		}
	}

	return error;
}
