static void __io_queue_sqe(struct io_kiocb *req, struct io_comp_state *cs)
{
	struct io_kiocb *linked_timeout;
	struct io_kiocb *nxt;
	const struct cred *old_creds = NULL;
	int ret;

again:
	linked_timeout = io_prep_linked_timeout(req);

	if ((req->flags & REQ_F_WORK_INITIALIZED) && req->work.identity->creds &&
	    req->work.identity->creds != current_cred()) {
		if (old_creds)
			revert_creds(old_creds);
		if (old_creds == req->work.identity->creds)
			old_creds = NULL; /* restored original creds */
		else
			old_creds = override_creds(req->work.identity->creds);
		req->work.flags |= IO_WQ_WORK_CREDS;
	}

	ret = io_issue_sqe(req, true, cs);

	/*
	 * We async punt it if the file wasn't marked NOWAIT, or if the file
	 * doesn't support non-blocking read/write attempts
	 */
	if (ret == -EAGAIN && !(req->flags & REQ_F_NOWAIT)) {
		if (!io_arm_poll_handler(req)) {
punt:
			/*
			 * Queued up for async execution, worker will release
			 * submit reference when the iocb is actually submitted.
			 */
			io_queue_async_work(req);
		}

		if (linked_timeout)
			io_queue_linked_timeout(linked_timeout);
		goto exit;
	}

	if (unlikely(ret)) {
		/* un-prep timeout, so it'll be killed as any other linked */
		req->flags &= ~REQ_F_LINK_TIMEOUT;
		req_set_fail_links(req);
		io_put_req(req);
		io_req_complete(req, ret);
		goto exit;
	}

	/* drop submission reference */
	nxt = io_put_req_find_next(req);
	if (linked_timeout)
		io_queue_linked_timeout(linked_timeout);

	if (nxt) {
		req = nxt;

		if (req->flags & REQ_F_FORCE_ASYNC)
			goto punt;
		goto again;
	}
exit:
	if (old_creds)
		revert_creds(old_creds);
}
