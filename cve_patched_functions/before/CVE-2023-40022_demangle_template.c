demangle_template(work, mangled, tname, trawname, is_type, remember)
struct work_stuff *work;
const char **mangled;
string *tname;
string *trawname;
int is_type;
int remember;
{
	int i = 0;
	int r = 0;
	int need_comma = 0;
	int success = 0;
	int is_java_array = 0;
	string temp = { 0 };
	int bindex = 0;

	(*mangled)++;
	if (is_type) {
		if (remember)
			bindex = register_Btype(work);
		/* get template name */
		if (**mangled == 'z') {
			int idx;
			(*mangled)++;
			(*mangled)++;

			idx = consume_count_with_underscores(mangled);
			if (idx == -1 || (work->tmpl_argvec && idx >= work->ntmpl_args) || consume_count_with_underscores(mangled) == -1)
				return (0);

			if (work->tmpl_argvec) {
				string_append(tname, work->tmpl_argvec[idx]);
				if (trawname)
					string_append(trawname, work->tmpl_argvec[idx]);
			} else {
				char buf[10];
				sprintf(buf, "T%d", idx);
				string_append(tname, buf);
				if (trawname)
					string_append(trawname, buf);
			}
		} else {
			if ((r = consume_count(mangled)) <= 0 || (int)strlen(*mangled) < r) {
				return (0);
			}
			is_java_array = (work->options & DMGL_JAVA) && strncmp(*mangled, "JArray1Z", 8) == 0;
			if (!is_java_array) {
				string_appendn(tname, *mangled, r);
			}
			if (trawname)
				string_appendn(trawname, *mangled, r);
			*mangled += r;
		}
	}
	if (!is_java_array)
		string_append(tname, "<");
	/* get size of template parameter list */
	if (!get_count(mangled, &r)) {
		return (0);
	}
	if (!is_type) {
		/* Create an array for saving the template argument values. */
		work->tmpl_argvec = (char **)malloc(r * sizeof(char *));
		work->ntmpl_args = r;
		for (i = 0; i < r; i++)
			work->tmpl_argvec[i] = 0;
	}
	for (i = 0; i < r; i++) {
		if (need_comma) {
			string_append(tname, ", ");
		}
		/* Z for type parameters */
		if (**mangled == 'Z') {
			(*mangled)++;
			/* temp is initialized in do_type */
			success = do_type(work, mangled, &temp);
			if (success) {
				string_appends(tname, &temp);

				if (!is_type) {
					/* Save the template argument. */
					int len = temp.p - temp.b;
					work->tmpl_argvec[i] = malloc(len + 1);
					memcpy(work->tmpl_argvec[i], temp.b, len);
					work->tmpl_argvec[i][len] = '\0';
				}
			}
			string_delete(&temp);
			if (!success) {
				break;
			}
		}
		/* z for template parameters */
		else if (**mangled == 'z') {
			int r2;
			(*mangled)++;
			success = demangle_template_template_parm(work, mangled, tname);

			if (success && (r2 = consume_count(mangled)) > 0 && (int)strlen(*mangled) >= r2) {
				string_append(tname, " ");
				string_appendn(tname, *mangled, r2);
				if (!is_type) {
					/* Save the template argument. */
					int len = r2;
					work->tmpl_argvec[i] = malloc(len + 1);
					memcpy(work->tmpl_argvec[i], *mangled, len);
					work->tmpl_argvec[i][len] = '\0';
				}
				*mangled += r2;
			}
			if (!success) {
				break;
			}
		} else {
			string param;
			string *s;

			/* otherwise, value parameter */

			/* temp is initialized in do_type */
			success = do_type(work, mangled, &temp);
			string_delete(&temp);
			if (!success)
				break;

			if (!is_type) {
				s = &param;
				string_init(s);
			} else
				s = tname;

			success = demangle_template_value_parm(work, mangled, s,
				(type_kind_t)success);

			if (!success) {
				if (!is_type)
					string_delete(s);
				success = 0;
				break;
			}

			if (!is_type) {
				int len = s->p - s->b;
				work->tmpl_argvec[i] = malloc(len + 1);
				memcpy(work->tmpl_argvec[i], s->b, len);
				work->tmpl_argvec[i][len] = '\0';

				string_appends(tname, s);
				string_delete(s);
			}
		}
		need_comma = 1;
	}
	if (is_java_array) {
		string_append(tname, "[]");
	} else {
		if (tname->p[-1] == '>')
			string_append(tname, " ");
		string_append(tname, ">");
	}

	if (is_type && remember)
		remember_Btype(work, tname->b, LEN_STRING(tname), bindex);

	return (success);
}
