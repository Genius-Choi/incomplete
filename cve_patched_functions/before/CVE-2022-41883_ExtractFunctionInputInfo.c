Status ExtractFunctionInputInfo(
    EagerOperation* op, const KernelDef* kernel_def,
    std::vector<Device*>& input_device_ptrs,
    absl::flat_hash_map<string, const std::vector<string>*>& composite_devices,
    std::unordered_map<int, DtypeAndPartialTensorShape>&
        input_resource_variable_dtypes_and_shapes) {
  profiler::TraceMe activity("EagerCopyToDevice",
                             profiler::TraceMeLevel::kInfo);
  EagerContext& ctx = op->EagerContext();
  input_device_ptrs.reserve(op->Inputs().size());
  const absl::InlinedVector<TensorHandle*, 4>* inputs;
  TF_RETURN_IF_ERROR(op->TensorHandleInputs(&inputs));
  Device* op_device = nullptr;
  const NodeDef* node_def = nullptr;
  if (!op->is_function()) {
    op_device = absl::get<Device*>(op->Device());
    node_def = &op->MutableAttrs()->BuildNodeDef();
  }
  for (int i = 0, end = inputs->size(); i < end; ++i) {
    TensorHandle* input = (*inputs)[i];

    Device* input_device;
    bool is_host_memory_arg =
        IsHostMemoryArg(*op, node_def, op_device, kernel_def, i);
    TF_RETURN_IF_ERROR(
        GetDeviceForInput(*op, ctx, is_host_memory_arg, input, &input_device));
    VLOG(1) << op->Name() << ":input:" << i << " " << input_device->name();
    input_device_ptrs.push_back(input_device);
    CompositeDevice* composite_device = nullptr;
    if (ctx.FindCompositeDeviceFromName(input_device->name(), &composite_device)
            .ok()) {
      composite_devices[input_device->name()] =
          composite_device->underlying_devices();
    }
    if (input->dtype == DT_RESOURCE) {
      // We only care about data type and shape for resource variable inputs.
      // But we have no way to tell if input is resource variable (other than
      // looking it up in ResourceMgr, which is slow). So we just get
      // resource_dtypes_and_shapes for all DT_RESOURCE inputs. If
      // resource_dtypes_and_shapes is not empty, take the first element.
      std::vector<DtypeAndPartialTensorShape> resource_dtypes_and_shapes;
      TF_RETURN_IF_ERROR(
          input->GetResourceHandleDtypesAndShapes(&resource_dtypes_and_shapes));
      if (!resource_dtypes_and_shapes.empty()) {
        const DtypeAndPartialTensorShape& dtype_and_shape =
            resource_dtypes_and_shapes.at(0);
        input_resource_variable_dtypes_and_shapes[i] = dtype_and_shape;
      }
    }
  }
  return OkStatus();
}
