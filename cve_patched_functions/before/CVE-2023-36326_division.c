static int division(void) {
	int code = RLC_ERR;
	bn_t a, b, c, d, e;

	bn_null(a);
	bn_null(b);
	bn_null(c);
	bn_null(d);
	bn_null(e);

	RLC_TRY {
		bn_new(a);
		bn_new(b);
		bn_new(c);
		bn_new(d);
		bn_new(e);

		TEST_CASE("trivial division is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS / 2);
			bn_rand(b, RLC_POS, RLC_BN_BITS);
			bn_div(e, a, b);
			bn_div_rem(c, d, a, b);
			TEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);
			bn_mul(e, c, b);
			bn_add(e, e, d);
			TEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);
			TEST_ASSERT(bn_sign(a) == bn_sign(c), end);
			TEST_ASSERT(bn_sign(d) == RLC_POS, end);
		} TEST_END;

		TEST_CASE("trivial negative division is correct") {
			bn_rand(a, RLC_NEG, RLC_BN_BITS / 2);
			bn_rand(b, RLC_POS, RLC_BN_BITS);
			bn_div(e, a, b);
			bn_div_rem(c, d, a, b);
			TEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);
			bn_mul(e, c, b);
			bn_add(e, e, d);
			TEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);
			TEST_ASSERT(bn_sign(a) == bn_sign(c), end);
			TEST_ASSERT(bn_sign(d) == bn_sign(b), end);
		} TEST_END;

		TEST_CASE("trivial division by negative is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS / 2);
			bn_rand(b, RLC_NEG, RLC_BN_BITS);
			bn_div(e, a, b);
			bn_div_rem(c, d, a, b);
			TEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);
			bn_mul(e, c, b);
			bn_add(e, e, d);
			TEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);
			TEST_ASSERT(bn_sign(a) != bn_sign(c), end);
			TEST_ASSERT(bn_sign(d) == bn_sign(b), end);
		} TEST_END;

		TEST_CASE("negative trivial division by negative is correct") {
			bn_rand(a, RLC_NEG, RLC_BN_BITS / 2);
			bn_rand(b, RLC_NEG, RLC_BN_BITS);
			bn_div(e, a, b);
			bn_div_rem(c, d, a, b);
			TEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);
			bn_mul(e, c, b);
			bn_add(e, e, d);
			TEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);
			TEST_ASSERT(bn_sign(a) != bn_sign(c), end);
			TEST_ASSERT(bn_sign(d) == bn_sign(b), end);
		} TEST_END;

		TEST_CASE("division is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_rand(b, RLC_POS, RLC_BN_BITS / 2);
			bn_div(e, a, b);
			bn_div_rem(c, d, a, b);
			TEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);
			bn_mul(e, c, b);
			bn_add(e, e, d);
			TEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);
			TEST_ASSERT(bn_sign(a) == bn_sign(c), end);
			TEST_ASSERT(bn_sign(d) == bn_sign(d), end);
		} TEST_END;

		TEST_CASE("negative division is correct") {
			bn_rand(a, RLC_NEG, RLC_BN_BITS);
			bn_rand(b, RLC_POS, RLC_BN_BITS / 2);
			bn_div(e, a, b);
			bn_div_rem(c, d, a, b);
			TEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);
			bn_mul(e, c, b);
			bn_add(e, e, d);
			TEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);
			TEST_ASSERT(bn_sign(a) == bn_sign(c), end);
			TEST_ASSERT(bn_sign(d) == RLC_POS, end);
		} TEST_END;

		TEST_CASE("division by negative is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_rand(b, RLC_NEG, RLC_BN_BITS / 2);
			bn_div(e, a, b);
			bn_div_rem(c, d, a, b);
			TEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);
			bn_mul(e, c, b);
			bn_add(e, e, d);
			TEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);
			TEST_ASSERT(bn_sign(a) != bn_sign(c), end);
			TEST_ASSERT(bn_sign(d) == bn_sign(b), end);
		} TEST_END;

		TEST_CASE("negative division by negative is correct") {
			bn_rand(a, RLC_NEG, RLC_BN_BITS);
			bn_rand(b, RLC_NEG, RLC_BN_BITS / 2);
			bn_div(e, a, b);
			bn_div_rem(c, d, a, b);
			TEST_ASSERT(bn_cmp(e, c) == RLC_EQ, end);
			bn_mul(e, c, b);
			bn_add(e, e, d);
			TEST_ASSERT(bn_cmp(a, e) == RLC_EQ, end);
			TEST_ASSERT(bn_sign(a) != bn_sign(c), end);
			TEST_ASSERT(bn_sign(d) == bn_sign(b), end);
		} TEST_END;
	}
	RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;
  end:
	bn_free(a);
	bn_free(b);
	bn_free(c);
	bn_free(d);
	bn_free(e);
	return code;
}
