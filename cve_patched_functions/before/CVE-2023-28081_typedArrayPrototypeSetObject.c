CallResult<HermesValue> typedArrayPrototypeSetObject(
    Runtime &runtime,
    Handle<JSTypedArrayBase> self,
    Handle<> obj,
    double offset) {
  double targetLength = self->getLength();
  auto objRes = toObject(runtime, obj);
  if (objRes == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto src = runtime.makeHandle<JSObject>(objRes.getValue());
  auto propRes = JSObject::getNamed_RJS(
      src, runtime, Predefined::getSymbolID(Predefined::length));
  if (propRes == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto intRes = toLength(runtime, runtime.makeHandle(std::move(*propRes)));
  if (intRes == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  uint64_t srcLength = intRes->getNumberAs<uint64_t>();
  if (srcLength + offset > targetLength) {
    return runtime.raiseRangeError(
        "The sum of the length of the given object "
        "and the offset cannot be greater than the length "
        "of this TypedArray");
  }
  // Read everything from the other array and write it into self starting from
  // offset.
  GCScope scope(runtime);
  MutableHandle<> k(runtime, HermesValue::encodeNumberValue(0));
  auto marker = scope.createMarker();
  for (; k->getNumberAs<uint64_t>() < srcLength;
       k = HermesValue::encodeNumberValue(k->getNumberAs<uint64_t>() + 1)) {
    if ((propRes = JSObject::getComputed_RJS(src, runtime, k)) ==
        ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
    auto kValue = runtime.makeHandle(std::move(*propRes));
    if (JSObject::setOwnIndexed(self, runtime, offset++, kValue) ==
        ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
    scope.flushToMarker(marker);
  }
  return HermesValue::encodeUndefinedValue();
}
