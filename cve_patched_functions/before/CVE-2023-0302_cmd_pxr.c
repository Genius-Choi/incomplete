static void cmd_pxr(RCore *core, int len, int mode, int wordsize, const char *arg) {
	PJ *pj = NULL;
	RTable *t = NULL;
	if (mode == ',') {
		t = r_table_new ("pxr");
		RTableColumnType *n = r_table_type ("number");
		RTableColumnType *s = r_table_type ("string");
		r_table_add_column (t, n, "addr", 0);
		r_table_add_column (t, n, "value", 0);
		r_table_add_column (t, s, "refs", 0);
	}
	if (mode == 'j') {
		pj = pj_new ();
		if (!pj) {
			return;
		}
	}
	ut64 o_offset = core->offset;
	if (mode == 'j' || mode == ',' || mode == '*' || mode == 'q') {
		size_t i;
		const bool be = R_ARCH_CONFIG_IS_BIG_ENDIAN (core->anal->config);
		if (pj) {
			pj_a (pj);
		}
		const ut8 *buf = core->block;

		bool withref = false;
		int end = R_MIN (core->blocksize, len);
		ut64 at = o_offset;
		for (i = 0; i + wordsize < end; i += wordsize) {
			ut64 addr = o_offset + i;
			ut64 val = read_value (buf + i, wordsize, be);
			if (pj) {
				pj_o (pj);
				pj_kn (pj, "addr", addr);
				pj_kn (pj, "value", val);
			}

			// XXX: this only works in little endian
			withref = false;
			char *refs = NULL;
			core->offset = at + i;
			if (core->print->hasrefs) {
				char *rstr = core->print->hasrefs (core->print->user, val, true);
				if (R_STR_ISNOTEMPTY (rstr)) {
					r_str_trim (rstr);
					if (pj) {
						char *ns = r_str_escape (rstr);
						pj_ks (pj, "refstr", r_str_trim_head_ro (ns));
						pj_k (pj, "ref");
						const int hex_depth = r_config_get_i (core->config, "hex.depth");
						free (r_core_anal_hasrefs_to_depth (core, val, pj, hex_depth));
						pj_end (pj);
						free (ns);
					}
					withref = true;
				}
				refs = rstr;
			}
			if (mode == '*' && R_STR_ISNOTEMPTY (refs)) {
				// Show only the mapped ones?
				r_cons_printf ("f pxr.%"PFMT64x"=0x%"PFMT64x"\n", val, addr);
			} else if (mode == 'q' && R_STR_ISNOTEMPTY (refs)) {
				r_cons_printf ("%s\n", refs);
			}
			if (t) {
				r_table_add_rowf (t, "xxs", addr, val, refs);
			}
			R_FREE (refs);
			if (!withref && pj) {
				pj_end (pj);
			}
		}
		core->offset = at;
		if (t) {
			r_table_query (t, arg? arg + 1: NULL);
			char *s = r_table_tostring (t);
			r_cons_println (s);
			free (s);
			r_table_free (t);
		}
		if (pj) {
			pj_end (pj);
			r_cons_println (pj_string (pj));
			pj_free (pj);
		}
	} else {
		const int ocols = core->print->cols;
		int bitsize = core->rasm->config->bits;
		/* Thumb is 16bit arm but handles 32bit data */
		if (bitsize == 16) {
			bitsize = 32;
		}
		core->print->cols = 1;
		core->print->flags |= R_PRINT_FLAGS_REFS;
		r_cons_break_push (NULL, NULL);
		r_print_hexdump (core->print, core->offset,
				core->block, R_MIN (len, core->blocksize),
				wordsize * 8, bitsize / 8, 1);
		r_cons_break_pop ();
		core->print->flags &= ~R_PRINT_FLAGS_REFS;
		core->print->cols = ocols;
	}
	core->offset = o_offset;
}
