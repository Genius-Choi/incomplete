unsigned hostport2addrlist(SOCKADDR_LIST *addr_list,
        char *host_name, char *port_name) {
    struct addrinfo hints, *res, *cur;
    int err, retry=0;
    unsigned num;

    memset(&hints, 0, sizeof hints);
#if defined(USE_IPv6) || defined(USE_WIN32)
    hints.ai_family=AF_UNSPEC;
#else
    hints.ai_family=AF_INET;
#endif
    hints.ai_socktype=SOCK_STREAM;
    hints.ai_protocol=IPPROTO_TCP;
    hints.ai_flags=0;
    if(addr_list->passive)
        hints.ai_flags|=AI_PASSIVE;
#ifdef AI_ADDRCONFIG
    hints.ai_flags|=AI_ADDRCONFIG;
#endif
    for(;;) {
        res=NULL;
        err=getaddrinfo(host_name, port_name, &hints, &res);
        if(!err) /* success */
            break;
        if(err==EAI_SERVICE) {
            s_log(LOG_ERR, "Unknown TCP service \"%s\"", port_name);
            return 0; /* error */
        }
        if(err==EAI_AGAIN && ++retry<=3) {
            s_log(LOG_DEBUG, "getaddrinfo: EAI_AGAIN received: retrying");
            s_poll_sleep(1, 0);
            continue;
        }
#ifdef AI_ADDRCONFIG
        if(hints.ai_flags&AI_ADDRCONFIG) {
            hints.ai_flags&=~AI_ADDRCONFIG;
            continue; /* retry for unconfigured network interfaces */
        }
#endif
        s_log(LOG_ERR, "Error resolving \"%s\": %s",
            host_name ? host_name :
                (addr_list->passive ? DEFAULT_ANY : DEFAULT_LOOPBACK),
            s_gai_strerror(err));
        return 0; /* error */
    }

    /* find the number of newly resolved addresses */
    num=0;
    for(cur=res; cur; cur=cur->ai_next) {
        if(cur->ai_addrlen>(int)sizeof(SOCKADDR_UNION)) {
            s_log(LOG_ERR, "INTERNAL ERROR: ai_addrlen value too big");
            freeaddrinfo(res);
            return 0; /* no results */
        }
        ++num;
    }

    /* append the newly resolved addresses to addr_list->addr */
    addr_list->addr=str_realloc_detached(addr_list->addr,
        (addr_list->num+num)*sizeof(SOCKADDR_UNION));
    for(cur=res; cur; cur=cur->ai_next)
        memcpy(&addr_list->addr[(addr_list->num)++], cur->ai_addr,
            (size_t)cur->ai_addrlen);

    freeaddrinfo(res);
    return num; /* ok - return the number of new addresses */
}
