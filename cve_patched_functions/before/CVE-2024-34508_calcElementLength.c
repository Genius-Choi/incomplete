Uint32 DcmElement::calcElementLength(const E_TransferSyntax xfer,
                                     const E_EncodingType enctype)
{
    DcmXfer xferSyn(xfer);
    DcmEVR vr = getVR();

    /* These VRs don't use extended length encoding, but when writing, they are
     * converted to EVR_UN, which DOES use extended length encoding.
     * (EVR_na should never happen here, it's just handled for completeness)
     */
    if (vr == EVR_UNKNOWN2B || vr == EVR_na)
        vr = EVR_UN;

    /* compute length of element value */
    const Uint32 elemLength = getLength(xfer, enctype);

    /* Create an object that represents this object's "valid" data type */
    DcmVR myvalidvr(vr);

    if ((elemLength) > 0xffff && (! myvalidvr.usesExtendedLengthEncoding()) && xferSyn.isExplicitVR())
    {
      /* special case: we are writing in explicit VR, the VR of this
       * element uses a 2-byte length encoding, but the element length is
       * too large for a 2-byte length field. We need to write this element
       * as VR=UN (or VR=OB) and adjust the length calculation accordingly.
       * Since UN and OB always have the same header length, we can simply
       * assume that we are using UN.
       */
       vr = EVR_UN;
    }

    /* now compute length of header */
    const Uint32 headerLength = xferSyn.sizeofTagHeader(vr);

    if (OFStandard::check32BitAddOverflow(headerLength, elemLength))
      return DCM_UndefinedLength;
    else
      return headerLength + elemLength;
}
