scp_v1s_mng_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s)
{
    struct SCP_SESSION *session;
    tui32 ipaddr;
    tui16 cmd;
    tui8 sz;
    char buf[257];

    /* reading command */
    in_uint16_be(c->in_s, cmd);

    if (cmd != 1) /* manager login */
    {
        return SCP_SERVER_STATE_SEQUENCE_ERR;
    }

    session = scp_session_create();

    if (0 == session)
    {
        return SCP_SERVER_STATE_INTERNAL_ERR;
    }

    scp_session_set_version(session, 1);
    scp_session_set_type(session, SCP_SESSION_TYPE_MANAGE);

    /* reading username */
    in_uint8(c->in_s, sz);
    buf[sz] = '\0';
    in_uint8a(c->in_s, buf, sz);

    if (0 != scp_session_set_username(session, buf))
    {
        scp_session_destroy(session);
        return SCP_SERVER_STATE_INTERNAL_ERR;
    }

    /* reading password */
    in_uint8(c->in_s, sz);
    buf[sz] = '\0';
    in_uint8a(c->in_s, buf, sz);

    if (0 != scp_session_set_password(session, buf))
    {
        scp_session_destroy(session);
        return SCP_SERVER_STATE_INTERNAL_ERR;
    }

    /* reading remote address */
    in_uint8(c->in_s, sz);

    if (sz == SCP_ADDRESS_TYPE_IPV4)
    {
        in_uint32_be(c->in_s, ipaddr);
        scp_session_set_addr(session, sz, &ipaddr);
    }
    else if (sz == SCP_ADDRESS_TYPE_IPV6)
    {
        in_uint8a(c->in_s, buf, 16);
        scp_session_set_addr(session, sz, buf);
    }

    /* reading hostname */
    in_uint8(c->in_s, sz);
    buf[sz] = '\0';
    in_uint8a(c->in_s, buf, sz);

    if (0 != scp_session_set_hostname(session, buf))
    {
        scp_session_destroy(session);
        return SCP_SERVER_STATE_INTERNAL_ERR;
    }

    /* returning the struct */
    (*s) = session;

    return SCP_SERVER_STATE_START_MANAGE;
}
