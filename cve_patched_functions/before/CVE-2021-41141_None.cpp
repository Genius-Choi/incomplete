static pj_status_t and_media_codec_open(pjmedia_codec *codec,
					pjmedia_codec_param *attr)
{
    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;
    struct and_media_codec *and_media_data =
					&and_media_codec[codec_data->codec_idx];
    pj_status_t status;

    PJ_ASSERT_RETURN(codec && attr, PJ_EINVAL);
    PJ_ASSERT_RETURN(codec_data != NULL, PJ_EINVALIDOP);

    PJ_LOG(5,(THIS_FILE, "Opening codec.."));

    codec_data->vad_enabled = (attr->setting.vad != 0);
    codec_data->plc_enabled = (attr->setting.plc != 0);
    and_media_data->clock_rate = attr->info.clock_rate;

#if PJMEDIA_HAS_AND_MEDIA_AMRNB
    if (and_media_data->codec_id == AND_AUD_CODEC_AMRNB ||
	and_media_data->codec_id == AND_AUD_CODEC_AMRWB)
    {
	amr_settings_t *s;
	pj_uint8_t octet_align = 0;
	pj_int8_t enc_mode;
	unsigned i;

	enc_mode = pjmedia_codec_amr_get_mode(attr->info.avg_bps);

	pj_assert(enc_mode >= 0 && enc_mode <= 8);

	/* Check AMR specific attributes */
	for (i = 0; i < attr->setting.dec_fmtp.cnt; ++i) {
	    /* octet-align, one of the parameters that must have same value
	     * in offer & answer (RFC 4867 Section 8.3.1). Just check fmtp
	     * in the decoder side, since it's value is guaranteed to fulfil
	     * above requirement (by SDP negotiator).
	     */
	    const pj_str_t STR_FMTP_OCTET_ALIGN = {(char *)"octet-align", 11};

	    if (pj_stricmp(&attr->setting.dec_fmtp.param[i].name,
			   &STR_FMTP_OCTET_ALIGN) == 0)
	    {
		octet_align=(pj_uint8_t)
			    pj_strtoul(&attr->setting.dec_fmtp.param[i].val);
		break;
	    }
	}
	for (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {
	    /* mode-set, encoding mode is chosen based on local default mode
	     * setting:
	     * - if local default mode is included in the mode-set, use it
	     * - otherwise, find the closest mode to local default mode;
	     *   if there are two closest modes, prefer to use the higher
	     *   one, e.g: local default mode is 4, the mode-set param
	     *   contains '2,3,5,6', then 5 will be chosen.
	     */
	    const pj_str_t STR_FMTP_MODE_SET = {(char *)"mode-set", 8};

	    if (pj_stricmp(&attr->setting.enc_fmtp.param[i].name,
			   &STR_FMTP_MODE_SET) == 0)
	    {
		const char *p;
		pj_size_t l;
		pj_int8_t diff = 99;

		p = pj_strbuf(&attr->setting.enc_fmtp.param[i].val);
		l = pj_strlen(&attr->setting.enc_fmtp.param[i].val);

		while (l--) {
		    if ((and_media_data->codec_id == AND_AUD_CODEC_AMRNB &&
			 *p>='0' && *p<='7') ||
		        (and_media_data->codec_id == AND_AUD_CODEC_AMRWB &&
		         *p>='0' && *p<='8'))
		    {
			pj_int8_t tmp = (pj_int8_t)(*p - '0' - enc_mode);

			if (PJ_ABS(diff) > PJ_ABS(tmp) ||
			    (PJ_ABS(diff) == PJ_ABS(tmp) && tmp > diff))
			{
			    diff = tmp;
			    if (diff == 0) break;
			}
		    }
		    ++p;
		}
		if (diff == 99)
		    goto on_error;

		enc_mode = (pj_int8_t)(enc_mode + diff);

		break;
	    }
	}
	/* Initialize AMR specific settings */
	s = PJ_POOL_ZALLOC_T(codec_data->pool, amr_settings_t);
	codec_data->codec_setting = s;

	s->enc_setting.amr_nb = (pj_uint8_t)
			      (and_media_data->codec_id == AND_AUD_CODEC_AMRNB);
	s->enc_setting.octet_aligned = octet_align;
	s->enc_setting.reorder = 0;
	s->enc_setting.cmr = 15;
	s->dec_setting.amr_nb = (pj_uint8_t)
			      (and_media_data->codec_id == AND_AUD_CODEC_AMRNB);
	s->dec_setting.octet_aligned = octet_align;
	s->dec_setting.reorder = 0;
	/* Apply encoder mode/bitrate */
	s->enc_mode = enc_mode;

	PJ_LOG(4, (THIS_FILE, "Encoder setting octet_aligned=%d reorder=%d"
		   " cmr=%d enc_mode=%d",
		   s->enc_setting.octet_aligned, s->enc_setting.reorder,
		   s->enc_setting.cmr, enc_mode));
	PJ_LOG(4, (THIS_FILE, "Decoder setting octet_aligned=%d reorder=%d",
		   s->dec_setting.octet_aligned, s->dec_setting.reorder));
    }
#endif
    status = configure_codec(codec_data, PJ_TRUE);
    if (status != PJ_SUCCESS) {
        goto on_error;
    }
    status = configure_codec(codec_data, PJ_FALSE);
    if (status != PJ_SUCCESS) {
	goto on_error;
    }

    return PJ_SUCCESS;

on_error:
    return PJMEDIA_CODEC_EFAILED;
}
