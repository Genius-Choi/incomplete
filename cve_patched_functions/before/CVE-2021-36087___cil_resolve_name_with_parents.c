static int __cil_resolve_name_with_parents(struct cil_tree_node *node, char *name, enum cil_sym_index sym_index, struct cil_symtab_datum **datum)
{
	int rc = SEPOL_ERR;
	symtab_t *symtab = NULL;

	while (node != NULL && rc != SEPOL_OK) {
		switch (node->flavor) {
		case CIL_ROOT:
			goto exit;
			break;
		case CIL_BLOCK:
			symtab = &((struct cil_block*)node->data)->symtab[sym_index];
			rc = cil_symtab_get_datum(symtab, name, datum);
			break;
		case CIL_BLOCKINHERIT: {
			struct cil_blockinherit *inherit = node->data;
			rc = __cil_resolve_name_with_parents(node->parent, name, sym_index, datum);
			if (rc != SEPOL_OK) {
				/* Continue search in original block's parent */
				rc = __cil_resolve_name_with_parents(NODE(inherit->block), name, sym_index, datum);
				goto exit;
			}
		}
			break;
		case CIL_MACRO: {
			struct cil_macro *macro = node->data;
			symtab = &macro->symtab[sym_index];
			rc = cil_symtab_get_datum(symtab, name, datum);
		}
			break;
		case CIL_CALL: {
			struct cil_call *call = node->data;
			rc = cil_resolve_name_call_args(call, name, sym_index, datum);
			if (rc != SEPOL_OK) {
				/* Continue search in macro's parent */
				rc = __cil_resolve_name_with_parents(NODE(call->macro)->parent, name, sym_index, datum);
			}
		}
			break;
		case CIL_IN:
			/* In block symtabs only exist before resolving the AST */
		case CIL_CONDBLOCK:
			/* Cond block symtabs only exist before resolving the AST */
		default:
			break;
		}

		node = node->parent;
	}

exit:
	return rc;
}
