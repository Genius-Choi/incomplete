static void bgp_dynamic_capability_software_version(uint8_t *pnt, int action,
						    struct capability_header *hdr,
						    struct peer *peer)
{
	uint8_t *data = pnt + 3;
	uint8_t *end = data + hdr->length;
	uint8_t len = *data;
	char soft_version[BGP_MAX_SOFT_VERSION + 1] = {};

	if (action == CAPABILITY_ACTION_SET) {
		if (data + len > end) {
			zlog_err("%pBP: Received invalid Software Version capability length %d",
				 peer, len);
			return;
		}
		data++;

		if (len > BGP_MAX_SOFT_VERSION)
			len = BGP_MAX_SOFT_VERSION;

		memcpy(&soft_version, data, len);
		soft_version[len] = '\0';

		XFREE(MTYPE_BGP_SOFT_VERSION, peer->soft_version);
		peer->soft_version = XSTRDUP(MTYPE_BGP_SOFT_VERSION,
					     soft_version);

		SET_FLAG(peer->cap, PEER_CAP_SOFT_VERSION_RCV);
	} else {
		UNSET_FLAG(peer->cap, PEER_CAP_SOFT_VERSION_RCV);
		XFREE(MTYPE_BGP_SOFT_VERSION, peer->soft_version);
	}
}
