static const char *mp3_dmx_probe_data(const u8 *data, u32 size, GF_FilterProbeScore *score)
{
	u32 nb_frames=0;
	u32 pos=0;
	u32 prev_pos=0;
	s32 prev_sr_idx=-1;
	s32 prev_ch=-1;
	s32 prev_layer=-1;
	s32 init_pos = -1;
	Bool has_id3 = GF_FALSE;

	/* Check for ID3 */
	if (size>= 10) {
		if (data[0] == 'I' && data[1] == 'D' && data[2] == '3') {
			u32 tag_size = ((data[9] & 0x7f) + ((data[8] & 0x7f) << 7) + ((data[7] & 0x7f) << 14) + ((data[6] & 0x7f) << 21));

			if (tag_size+10>size) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, ("ID3 tag detected size %d but probe data only %d bytes, will rely on file extension (try increasing probe size using --block_size)\n", tag_size+10, size));
				*score = GF_FPROBE_EXT_MATCH;
				return "mp3|mp2|mp1";
			}
			data += tag_size+10;
			size -= tag_size+10;
			has_id3 = GF_TRUE;
		}
	}

	while (1) {
		u32 hdr = gf_mp3_get_next_header_mem(data, size, &pos);
		if (!hdr) break;

		if (init_pos<0) init_pos = pos;

		if (gf_mp3_version(hdr) > 3)
			break;
		//check sample rate
		u8 val = (hdr >> 10) & 0x3;
		if (val>2)
			break;
		u32 fsize = gf_mp3_frame_size(hdr);
		if (prev_pos && pos) {
			nb_frames=0;
			break;
		}

		if (prev_sr_idx>=0) {
			if ((u8) prev_sr_idx != val) {
				nb_frames=0;
				break;
			}
		}
		prev_sr_idx = val;

		val = gf_mp3_num_channels(hdr);
		if (prev_ch>=0) {
			if ((u8) prev_ch != val) {
				nb_frames=0;
				break;
			}
		}
		prev_ch = val;

		val = gf_mp3_layer(hdr);
		if (prev_layer>=0) {
			if ((u8) prev_layer != val) {
				nb_frames=0;
				break;
			}
		}
		prev_layer = val;

		if (fsize + pos > size) {
			nb_frames++;
			break;
		}

		prev_pos = pos;
		nb_frames++;
		if (nb_frames>4) break;
		if (size < fsize + pos) break;
		size -= fsize + pos;
		data += fsize + pos;
	}

	if (nb_frames>=2) {
		*score = (init_pos==0) ? GF_FPROBE_SUPPORTED : GF_FPROBE_MAYBE_NOT_SUPPORTED;
		return "audio/mp3";
	}
	if (nb_frames && has_id3) {
		*score = GF_FPROBE_MAYBE_SUPPORTED;
		return "audio/mp3";
	}
	return NULL;
}
