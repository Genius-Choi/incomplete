process_display_control_monitor_layout_data(struct xrdp_wm *wm)
{
    int error = 0;
    struct xrdp_mm *mm;
    struct xrdp_mod *module;
    struct xrdp_rdp *rdp;
    struct xrdp_sec *sec;
    struct xrdp_channel *chan;
    int in_progress;

    LOG_DEVEL(LOG_LEVEL_TRACE, "process_display_control_monitor_layout_data:");

    if (wm == NULL)
    {
        return 1;
    }
    mm = wm->mm;
    if (mm == NULL)
    {
        return 1;
    }
    module = mm->mod;
    if (module == NULL)
    {
        return 1;
    }

    if (!xrdp_wm_can_resize(wm))
    {
        return 0;
    }

    struct display_control_monitor_layout_data *description
            = mm->resize_data;
    const unsigned int desc_width = description->description.session_width;
    const unsigned int desc_height = description->description.session_height;

    switch (description->state)
    {
        case WMRZ_ENCODER_DELETE:
            // Stop any output from the module
            rdp = (struct xrdp_rdp *) (wm->session->rdp);
            xrdp_rdp_suppress_output(rdp,
                                     1, XSO_REASON_DYNAMIC_RESIZE,
                                     0, 0, 0, 0);
            // Disable the encoder until the resize is complete.
            if (mm->encoder != NULL)
            {
                xrdp_encoder_delete(mm->encoder);
                mm->encoder = NULL;
            }
            if (mm->resize_data->using_egfx == 0)
            {
                advance_resize_state_machine(mm, WMRZ_SERVER_MONITOR_RESIZE);
            }
            else
            {
                advance_resize_state_machine(mm, WMRZ_EGFX_DELETE_SURFACE);
            }
            break;
        case WMRZ_EGFX_DELETE_SURFACE:
            if (error == 0 && module != 0)
            {
                xrdp_egfx_shutdown_delete_surface(mm->egfx);
            }
            advance_resize_state_machine(mm, WMRZ_EGFX_CONN_CLOSE);
            break;
        case WMRZ_EGFX_CONN_CLOSE:
            if (error == 0 && module != 0)
            {
                xrdp_egfx_shutdown_close_connection(wm->mm->egfx);
                mm->egfx_up = 0;
            }
            advance_resize_state_machine(mm, WMRZ_EGFX_CONN_CLOSING);
            break;
        // Also processed in xrdp_egfx_close_response
        case WMRZ_EGFX_CONN_CLOSING:
            rdp = (struct xrdp_rdp *) (wm->session->rdp);
            sec = rdp->sec_layer;
            chan = sec->chan_layer;

            // Continue to check to see if the connection is closed. If it
            // ever is, advance the state machine!
            if (chan->drdynvcs[mm->egfx->channel_id].status
                    == XRDP_DRDYNVC_STATUS_CLOSED
                    || (g_time3() - description->last_state_update_timestamp) > 100)
            {
                advance_resize_state_machine(mm, WMRZ_EGFX_CONN_CLOSED);
                break;
            }
            g_set_wait_obj(mm->resize_ready);
            break;
        case WMRZ_EGFX_CONN_CLOSED:
            advance_resize_state_machine(mm, WRMZ_EGFX_DELETE);
            break;
        case WRMZ_EGFX_DELETE:
            if (error == 0 && module != 0)
            {
                xrdp_egfx_shutdown_delete(wm->mm->egfx);
                mm->egfx = NULL;
            }
            advance_resize_state_machine(mm, WMRZ_SERVER_MONITOR_RESIZE);
            break;
        case WMRZ_SERVER_MONITOR_RESIZE:
            error = module->mod_server_monitor_resize(
                        module, desc_width, desc_height,
                        description->description.monitorCount,
                        description->description.minfo,
                        &in_progress);
            if (error != 0)
            {
                LOG_DEVEL(LOG_LEVEL_INFO,
                          "process_display_control_monitor_layout_data:"
                          " mod_server_monitor_resize failed %d", error);
                return advance_error(error, mm);
            }
            else if (in_progress)
            {
                // Call is proceeding asynchronously
                advance_resize_state_machine(
                    mm, WMRZ_SERVER_MONITOR_MESSAGE_PROCESSING);
            }
            else
            {
                // Call is done
                advance_resize_state_machine(
                    mm, WMRZ_SERVER_MONITOR_MESSAGE_PROCESSED);
            }
            break;
        // Not processed here. Processed in client_monitor_resize
        // case WMRZ_SERVER_MONITOR_MESSAGE_PROCESSING:
        case WMRZ_SERVER_MONITOR_MESSAGE_PROCESSED:
            advance_resize_state_machine(mm, WMRZ_XRDP_CORE_RESET);
            break;
        case WMRZ_XRDP_CORE_RESET:
            sync_dynamic_monitor_data(wm, &(description->description));
            error = libxrdp_reset(wm->session);
            if (error != 0)
            {
                LOG_DEVEL(LOG_LEVEL_INFO,
                          "process_display_control_monitor_layout_data:"
                          " libxrdp_reset failed %d", error);
                return advance_error(error, mm);
            }
            /* reset cache */
            error = xrdp_cache_reset(wm->cache, wm->client_info);
            if (error != 0)
            {
                LOG_DEVEL(LOG_LEVEL_INFO,
                          "process_display_control_monitor_layout_data:"
                          " xrdp_cache_reset failed %d", error);
                return advance_error(error, mm);
            }
            advance_resize_state_machine(mm, WMRZ_XRDP_CORE_RESET_PROCESSING);
            break;

        // Not processed here. Processed in xrdp_mm_up_and_running()
        // case WMRZ_XRDP_CORE_RESET_PROCESSING:
        case WMRZ_XRDP_CORE_RESET_PROCESSED:
            /* load some stuff */
            error = xrdp_wm_load_static_colors_plus(wm, 0);
            if (error != 0)
            {
                LOG_DEVEL(LOG_LEVEL_INFO,
                          "process_display_control_monitor_layout_data:"
                          " xrdp_wm_load_static_colors_plus failed %d", error);
                return advance_error(error, mm);
            }

            error = xrdp_wm_load_static_pointers(wm);
            if (error != 0)
            {
                LOG_DEVEL(LOG_LEVEL_INFO,
                          "process_display_control_monitor_layout_data:"
                          " xrdp_wm_load_static_pointers failed %d", error);
                return advance_error(error, mm);
            }
            /* resize the main window */
            error = xrdp_bitmap_resize(
                        wm->screen, desc_width, desc_height);
            if (error != 0)
            {
                LOG_DEVEL(LOG_LEVEL_INFO,
                          "process_display_control_monitor_layout_data:"
                          " xrdp_bitmap_resize failed %d", error);
                return advance_error(error, mm);
            }
            advance_resize_state_machine(mm, WMRZ_EGFX_INITIALIZE);
            break;
        case WMRZ_EGFX_INITIALIZE:
            if (mm->resize_data->using_egfx)
            {
                egfx_initialize(mm);
                advance_resize_state_machine(mm, WMRZ_EGFX_INITALIZING);
            }
            else
            {
                advance_resize_state_machine(mm, WMRZ_EGFX_INITIALIZED);
            }
            break;
        // Not processed here. Processed in xrdp_mm_egfx_caps_advertise
        // case WMRZ_EGFX_INITALIZING:
        case WMRZ_EGFX_INITIALIZED:
            advance_resize_state_machine(mm, WMRZ_ENCODER_CREATE);
            break;
        case WMRZ_ENCODER_CREATE:
            if (mm->encoder == NULL)
            {
                mm->encoder = xrdp_encoder_create(mm);
            }
            advance_resize_state_machine(mm, WMRZ_SERVER_INVALIDATE);
            break;
        case WMRZ_SERVER_INVALIDATE:
            if (module != 0)
            {
                // Ack all frames to speed up resize.
                module->mod_frame_ack(module, 0, INT_MAX);
            }
            // Restart module output after invalidating
            // the screen. This causes an automatic redraw.
            xrdp_bitmap_invalidate(wm->screen, 0);
            rdp = (struct xrdp_rdp *) (wm->session->rdp);
            xrdp_rdp_suppress_output(rdp,
                                     0, XSO_REASON_DYNAMIC_RESIZE,
                                     0, 0, desc_width, desc_height);
            advance_resize_state_machine(mm, WMRZ_COMPLETE);
            break;
        default:
            break;
    }
    return 0;
}
