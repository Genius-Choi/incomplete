static ssize_t _nhc_ipv6_ext_encode_snip(gnrc_pktsnip_t *pkt, uint8_t *nhc_data,
                                         uint8_t *nh)
{
    gnrc_pktsnip_t *hdr = pkt->next->next;
    ipv6_ext_t *ext = hdr->data;
    ssize_t nhc_len;
    uint16_t ext_len = ((ext->len * IPV6_EXT_LEN_UNIT) + IPV6_EXT_LEN_UNIT);
    uint8_t new_nh = *nh;

    assert((hdr->size >= sizeof(ipv6_ext_t)) && (hdr->size >= ext_len));
    /* _iphc_nhc_ipv6_ext_encode() manipulates nh, so use `new_nh` as temporary
     * carrier in case of later errors */
    nhc_len = _iphc_nhc_ipv6_ext_encode(nhc_data, hdr, ext_len, &new_nh);
    if (nhc_len == 0) {
        /* extension header is not compressible, so don't compress it and
         * just copy it after the preceding compression headers */
        return nhc_len;
    }
    /* remove IPv6 extension header */
    if (!_remove_header(pkt, hdr, ext_len)) {
        return -1;
    }
    *nh = new_nh;
    return nhc_len;
}
