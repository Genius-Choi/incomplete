static u64 estimate_next_moof_earliest_presentation_time(u64 ref_track_decode_time, s32 ts_shift, u32 refTrackID, GF_ISOFile *movie)
{
	u32 i, j, nb_aus, nb_ctso, nb_moof;
	u64 duration;
	GF_TrunEntry *ent;
	GF_TrackFragmentBox *traf=NULL;
	GF_TrackFragmentRunBox *trun;
	u32 timescale;
	u64 min_next_cts = -1;

	GF_MovieFragmentBox *moof = gf_list_get(movie->moof_list, 0);

	for (i=0; i<gf_list_count(moof->TrackList); i++) {
		traf = (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, i);
		if (traf->tfhd->trackID==refTrackID) break;
		traf = NULL;
	}
	//no ref track, nothing to estimate
	if (!traf) return -1;
	timescale = traf->trex->track->Media->mediaHeader->timeScale;

	nb_aus = 0;
	duration = 0;
	nb_ctso = 0;
	nb_moof = 0;

	while ((moof = (GF_MovieFragmentBox*)gf_list_enum(movie->moof_list, &nb_moof))) {

		for (i=0; i<gf_list_count(moof->TrackList); i++) {
			traf = (GF_TrackFragmentBox*)gf_list_get(moof->TrackList, i);
			if (traf->tfhd->trackID==refTrackID) break;
			traf = NULL;
		}
		if (!traf) continue;

		i=0;
		while ((trun = (GF_TrackFragmentRunBox*)gf_list_enum(traf->TrackRuns, &i))) {
			for (j=0; j<trun->nb_samples; j++) {
				ent = &trun->samples[j];
				if (nb_aus + 1 + movie->sidx_pts_store_count > movie->sidx_pts_store_alloc) {
					movie->sidx_pts_store_alloc = movie->sidx_pts_store_count+nb_aus+1;
					movie->sidx_pts_store = gf_realloc(movie->sidx_pts_store, sizeof(u64) * movie->sidx_pts_store_alloc);
					movie->sidx_pts_next_store = gf_realloc(movie->sidx_pts_next_store, sizeof(u64) * movie->sidx_pts_store_alloc);
				}
				//get PTS for this AU, push to regular list
				movie->sidx_pts_store[movie->sidx_pts_store_count + nb_aus] = get_presentation_time( ref_track_decode_time + duration + ent->CTS_Offset, ts_shift);
				//get PTS for this AU shifted by its presentation duration, push to shifted list
				movie->sidx_pts_next_store[movie->sidx_pts_store_count + nb_aus] = get_presentation_time( ref_track_decode_time + duration + ent->CTS_Offset + ent->Duration, ts_shift);
				duration += ent->Duration;
				if (ent->CTS_Offset)
					nb_ctso++;

				nb_aus++;
			}
		}
	}

	movie->sidx_pts_store_count += nb_aus;

	//no AUs, nothing to estimate
	if (!nb_aus) {
		movie->sidx_pts_store_count = 0;
		return -1;
	}
	//no cts offset, assume earliest PTS in next segment is last PTS in this segment + duration
	if (!nb_ctso) {
		min_next_cts = movie->sidx_pts_next_store[movie->sidx_pts_store_count - 1];
		movie->sidx_pts_store_count = 0;
		return min_next_cts;
	}

	//look for all shifted PTS of this segment in the regular list. If found in the shifted list, the AU is in this segment
	//remove from both list
	for (i=0; i<movie->sidx_pts_store_count; i++) {
		for (j=i; j<movie->sidx_pts_store_count; j++) {
			/*

 			if (movie->sidx_pts_next_store[i] == movie->sidx_pts_store[j]) {
 			
			take care of misaligned timescale eg 24fps but 10000 timescale), we may not find exactly
			the same sample - if diff below N ms consider it a match
			not doing so would accumulate PTSs in the list, slowing down the muxing

			using N=1ms strict would not be enough to take into account sources with approximate timing - cf issue #2436
			we use N=2ms max to handle sources with high jitter in cts
			*/
			s64 diff = movie->sidx_pts_next_store[i];
			diff -= (s64) movie->sidx_pts_store[j];
			if (diff && (timescale>1000)) {
				if (ABS(diff) * 1000 < 2 * timescale)
					diff = 0;
			}
			if (diff==0) {
				if (movie->sidx_pts_store_count >= i + 1)
					memmove(&movie->sidx_pts_next_store[i], &movie->sidx_pts_next_store[i+1], sizeof(u64) * (movie->sidx_pts_store_count - i - 1) );
				if (movie->sidx_pts_store_count >= j + 1)
					memmove(&movie->sidx_pts_store[j], &movie->sidx_pts_store[j+1], sizeof(u64) * (movie->sidx_pts_store_count - j - 1) );
				movie->sidx_pts_store_count--;
				i--;
				break;
			}
		}
	}
	//the shifted list contain all AUs not yet in this segment, keep the smallest to compute the earliest PTS in next seg
	//note that we assume the durations were correctly set
	for (i=0; i<movie->sidx_pts_store_count; i++) {
		if (min_next_cts > movie->sidx_pts_next_store[i])
			min_next_cts = movie->sidx_pts_next_store[i];
	}
	return min_next_cts;
}
