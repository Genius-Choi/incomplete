compute_ticket_times(kdc_realm_t *realm, struct tgs_req_info *t,
                     krb5_timestamp kdc_time, krb5_flags *tktflags,
                     krb5_ticket_times *times)
{
    krb5_timestamp hstarttime;
    krb5_deltat hlife;
    krb5_ticket_times *htimes = &t->header_tkt->enc_part2->times;

    if (t->req->kdc_options & KDC_OPT_VALIDATE) {
        /* Validation requests preserve the header ticket times. */
        *times = *htimes;
        return;
    }

    /* Preserve the authtime from the subject ticket. */
    times->authtime = t->authtime;

    times->starttime = (t->req->kdc_options & KDC_OPT_POSTDATED) ?
        t->req->from : kdc_time;

    if (t->req->kdc_options & KDC_OPT_RENEW) {
        /* Give the new ticket the same lifetime as the header ticket, but no
         * later than the renewable end time. */
        hstarttime = htimes->starttime ? htimes->starttime : htimes->authtime;
        hlife = ts_delta(htimes->endtime, hstarttime);
        times->endtime = ts_min(htimes->renew_till,
                                ts_incr(times->starttime, hlife));
    } else {
        kdc_get_ticket_endtime(realm, times->starttime, htimes->endtime,
                               t->req->till, t->client, t->server,
                               &times->endtime);
    }

    kdc_get_ticket_renewtime(realm, t->req, t->header_tkt->enc_part2,
                             t->client, t->server, tktflags, times);

    /* starttime is optional, and treated as authtime if not present.
     * so we can omit it if it matches. */
    if (times->starttime == times->authtime)
        times->starttime = 0;
}
