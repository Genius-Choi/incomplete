static void _sched_next_frame(gnrc_sixlowpan_frag_fb_t *fbuf)
{
    if (!gnrc_sixlowpan_frag_sfr_congure_snd_has_inter_frame_gap()) {
        return;
    }
    int state = irq_disable();  /* make timer check atomic */
    bool already_set = xtimer_is_set(&_if_gap_timer);

    irq_restore(state);
    if (already_set) {
        DEBUG("6lo sfr: inter-frame timer was already set\n");
        return;
    }
    uint32_t last_sent_since = (_last_frame_sent - xtimer_now_usec());
    uint32_t if_gap = gnrc_sixlowpan_frag_sfr_congure_snd_inter_frame_gap(fbuf);

    if (last_sent_since <= if_gap) {
        uint32_t offset = if_gap - last_sent_since;
        DEBUG("6lo sfr: arming inter-frame timer in %" PRIu32 " us\n",
              last_sent_since);
        _if_gap_msg.content.ptr = fbuf;
        xtimer_set_msg(&_if_gap_timer, offset, &_if_gap_msg, _getpid());
    }
    else {
        DEBUG("6lo sfr: send frame immediately\n");
        /* there is no risk of infinite recursion due to the call of `_sched_next_frame` since
         * we only get here when (_last_frame_sent - now) > if_gap.
         * Since gnrc_sixlowpan_frag_sfr_inter_frame_gap updates _last_frame_sent when the list is
         * empty and only calls _sched_next_frame() when the list is still not empty after that this
         * can not be the case if we came from there (except for misconfigured if_gap). */
        gnrc_sixlowpan_frag_sfr_inter_frame_gap(fbuf);
    }
}
