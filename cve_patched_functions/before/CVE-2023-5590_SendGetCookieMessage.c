std::wstring CookieManager::SendGetCookieMessage(const std::wstring& url, 
                                                 const unsigned int message,
                                                 HookProcessor* hook) {
  LOG(TRACE) << "Entering CookieManager::SendGetCookieMessage";
  hook->PushData(url);

  // Since the named pipe server has to wait for the named pipe client
  // injected into the browser to connect to it before reading the data,
  // and since SendMessage is synchronous, we need to send the message
  // from a different thread to avoid a deadlock.
  CookieSendMessageInfo info;
  info.window_handle = this->window_handle_;
  info.message = message;
  unsigned int thread_id = 0;
  HANDLE thread_handle = reinterpret_cast<HANDLE>(_beginthreadex(NULL,
                                                  0,
                                                  &CookieManager::ThreadProc,
                                                  reinterpret_cast<void*>(&info),
                                                  0,
                                                  &thread_id));
  if (thread_handle != NULL) {
    ::CloseHandle(thread_handle);
  } else {
    LOGERR(DEBUG) << "Unable to create thread";
  }
  std::vector<char> buffer(0);
  int bytes = hook->PullData(&buffer);
  std::wstring cookies = reinterpret_cast<const wchar_t*>(&buffer[0]);
  return cookies;
}
