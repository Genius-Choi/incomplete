static int dpio_init(void)
{
	struct qbman_swp_desc p_des;
	struct dpio_attr attr;
	struct dpio_cfg dpio_cfg;
	int err = 0;
	uint16_t major_ver, minor_ver;

	dflt_dpio = (struct fsl_dpio_obj *)calloc(
					sizeof(struct fsl_dpio_obj), 1);
	if (!dflt_dpio) {
		printf("No memory: calloc() failed\n");
		err = -ENOMEM;
		goto err_calloc;
	}
	dpio_cfg.channel_mode = DPIO_LOCAL_CHANNEL;
	dpio_cfg.num_priorities = 8;

	err = dpio_create(dflt_mc_io,
			  dflt_dprc_handle,
			  MC_CMD_NO_FLAGS,
			  &dpio_cfg,
			  &dflt_dpio->dpio_id);
	if (err < 0) {
		printf("dpio_create() failed: %d\n", err);
		err = -ENODEV;
		goto err_create;
	}

	err = dpio_get_api_version(dflt_mc_io, 0,
				   &major_ver,
				   &minor_ver);
	if (err < 0) {
		printf("dpio_get_api_version() failed: %d\n", err);
		goto err_get_api_ver;
	}

	if (major_ver < DPIO_VER_MAJOR || (major_ver == DPIO_VER_MAJOR &&
					   minor_ver < DPIO_VER_MINOR)) {
		printf("DPRC version mismatch found %u.%u,",
		       major_ver,
		       minor_ver);
	}

	err = dpio_open(dflt_mc_io,
			MC_CMD_NO_FLAGS,
			dflt_dpio->dpio_id,
			&dflt_dpio->dpio_handle);
	if (err) {
		printf("dpio_open() failed\n");
		goto err_open;
	}

	memset(&attr, 0, sizeof(struct dpio_attr));
	err = dpio_get_attributes(dflt_mc_io, MC_CMD_NO_FLAGS,
				  dflt_dpio->dpio_handle, &attr);
	if (err < 0) {
		printf("dpio_get_attributes() failed: %d\n", err);
		goto err_get_attr;
	}

	if (dflt_dpio->dpio_id != attr.id) {
		printf("dnpi object id and attribute id are not same\n");
		goto err_attr_not_same;
	}

#ifdef DEBUG
	printf("Init: DPIO id=0x%d\n", dflt_dpio->dpio_id);
#endif
	err = dpio_enable(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpio->dpio_handle);
	if (err < 0) {
		printf("dpio_enable() failed %d\n", err);
		goto err_get_enable;
	}
	debug("ce_offset=0x%llx, ci_offset=0x%llx, portalid=%d, prios=%d\n",
	      attr.qbman_portal_ce_offset,
	      attr.qbman_portal_ci_offset,
	      attr.qbman_portal_id,
	      attr.num_priorities);

	p_des.cena_bar = (void *)(SOC_QBMAN_PORTALS_BASE_ADDR
					+ attr.qbman_portal_ce_offset);
	p_des.cinh_bar = (void *)(SOC_QBMAN_PORTALS_BASE_ADDR
					+ attr.qbman_portal_ci_offset);

	dflt_dpio->sw_portal = qbman_swp_init(&p_des);
	if (dflt_dpio->sw_portal == NULL) {
		printf("qbman_swp_init() failed\n");
		goto err_get_swp_init;
	}
	return 0;

err_get_swp_init:
	dpio_disable(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpio->dpio_handle);
err_get_enable:
err_get_attr:
err_attr_not_same:
	dpio_close(dflt_mc_io, MC_CMD_NO_FLAGS, dflt_dpio->dpio_handle);
err_open:
err_get_api_ver:
	dpio_destroy(dflt_mc_io,
		     dflt_dprc_handle,
		     MC_CMD_NO_FLAGS,
		     dflt_dpio->dpio_id);
err_create:
	free(dflt_dpio);
err_calloc:
	return err;
}
