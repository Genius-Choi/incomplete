static int lan78xx_probe(struct usb_interface *intf,
			 const struct usb_device_id *id)
{
	struct usb_host_endpoint *ep_blkin, *ep_blkout, *ep_intr;
	struct lan78xx_net *dev;
	struct net_device *netdev;
	struct usb_device *udev;
	int ret;
	unsigned int maxp;
	unsigned int period;
	u8 *buf = NULL;

	udev = interface_to_usbdev(intf);
	udev = usb_get_dev(udev);

	netdev = alloc_etherdev(sizeof(struct lan78xx_net));
	if (!netdev) {
		dev_err(&intf->dev, "Error: OOM\n");
		ret = -ENOMEM;
		goto out1;
	}

	/* netdev_printk() needs this */
	SET_NETDEV_DEV(netdev, &intf->dev);

	dev = netdev_priv(netdev);
	dev->udev = udev;
	dev->intf = intf;
	dev->net = netdev;
	dev->msg_enable = netif_msg_init(msg_level, NETIF_MSG_DRV
					| NETIF_MSG_PROBE | NETIF_MSG_LINK);

	skb_queue_head_init(&dev->rxq);
	skb_queue_head_init(&dev->txq);
	skb_queue_head_init(&dev->rxq_done);
	skb_queue_head_init(&dev->txq_pend);
	skb_queue_head_init(&dev->rxq_overflow);
	mutex_init(&dev->phy_mutex);
	mutex_init(&dev->dev_mutex);

	ret = lan78xx_urb_config_init(dev);
	if (ret < 0)
		goto out2;

	ret = lan78xx_alloc_tx_resources(dev);
	if (ret < 0)
		goto out2;

	ret = lan78xx_alloc_rx_resources(dev);
	if (ret < 0)
		goto out3;

	/* MTU range: 68 - 9000 */
	netdev->max_mtu = MAX_SINGLE_PACKET_SIZE;

	netif_set_tso_max_size(netdev, LAN78XX_TSO_SIZE(dev));

	netif_napi_add(netdev, &dev->napi, lan78xx_poll);

	INIT_DELAYED_WORK(&dev->wq, lan78xx_delayedwork);
	init_usb_anchor(&dev->deferred);

	netdev->netdev_ops = &lan78xx_netdev_ops;
	netdev->watchdog_timeo = TX_TIMEOUT_JIFFIES;
	netdev->ethtool_ops = &lan78xx_ethtool_ops;

	dev->delta = 1;
	timer_setup(&dev->stat_monitor, lan78xx_stat_monitor, 0);

	mutex_init(&dev->stats.access_lock);

	if (intf->cur_altsetting->desc.bNumEndpoints < 3) {
		ret = -ENODEV;
		goto out4;
	}

	dev->pipe_in = usb_rcvbulkpipe(udev, BULK_IN_PIPE);
	ep_blkin = usb_pipe_endpoint(udev, dev->pipe_in);
	if (!ep_blkin || !usb_endpoint_is_bulk_in(&ep_blkin->desc)) {
		ret = -ENODEV;
		goto out4;
	}

	dev->pipe_out = usb_sndbulkpipe(udev, BULK_OUT_PIPE);
	ep_blkout = usb_pipe_endpoint(udev, dev->pipe_out);
	if (!ep_blkout || !usb_endpoint_is_bulk_out(&ep_blkout->desc)) {
		ret = -ENODEV;
		goto out4;
	}

	ep_intr = &intf->cur_altsetting->endpoint[2];
	if (!usb_endpoint_is_int_in(&ep_intr->desc)) {
		ret = -ENODEV;
		goto out4;
	}

	dev->pipe_intr = usb_rcvintpipe(dev->udev,
					usb_endpoint_num(&ep_intr->desc));

	ret = lan78xx_bind(dev, intf);
	if (ret < 0)
		goto out4;

	period = ep_intr->desc.bInterval;
	maxp = usb_maxpacket(dev->udev, dev->pipe_intr);
	buf = kmalloc(maxp, GFP_KERNEL);
	if (!buf) {
		ret = -ENOMEM;
		goto out5;
	}

	dev->urb_intr = usb_alloc_urb(0, GFP_KERNEL);
	if (!dev->urb_intr) {
		ret = -ENOMEM;
		goto out6;
	} else {
		usb_fill_int_urb(dev->urb_intr, dev->udev,
				 dev->pipe_intr, buf, maxp,
				 intr_complete, dev, period);
		dev->urb_intr->transfer_flags |= URB_FREE_BUFFER;
	}

	dev->maxpacket = usb_maxpacket(dev->udev, dev->pipe_out);

	/* Reject broken descriptors. */
	if (dev->maxpacket == 0) {
		ret = -ENODEV;
		goto out6;
	}

	/* driver requires remote-wakeup capability during autosuspend. */
	intf->needs_remote_wakeup = 1;

	ret = lan78xx_phy_init(dev);
	if (ret < 0)
		goto out7;

	ret = register_netdev(netdev);
	if (ret != 0) {
		netif_err(dev, probe, netdev, "couldn't register the device\n");
		goto out8;
	}

	usb_set_intfdata(intf, dev);

	ret = device_set_wakeup_enable(&udev->dev, true);

	 /* Default delay of 2sec has more overhead than advantage.
	  * Set to 10sec as default.
	  */
	pm_runtime_set_autosuspend_delay(&udev->dev,
					 DEFAULT_AUTOSUSPEND_DELAY);

	return 0;

out8:
	phy_disconnect(netdev->phydev);
out7:
	usb_free_urb(dev->urb_intr);
out6:
	kfree(buf);
out5:
	lan78xx_unbind(dev, intf);
out4:
	netif_napi_del(&dev->napi);
	lan78xx_free_rx_resources(dev);
out3:
	lan78xx_free_tx_resources(dev);
out2:
	free_netdev(netdev);
out1:
	usb_put_dev(udev);

	return ret;
}
