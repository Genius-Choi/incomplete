static int pico_socket_ipv4_process_out(struct pico_socket *s, struct pico_frame *f)
{
    struct pico_socket_ipv4 *s4 = (struct pico_socket_ipv4 *)s;
    int ret;
    uint32_t plen = f->len;
    if (s->dev && ((s->state & PICO_SOCKET_STATE_BOUND) != 0)) {
        f->dev = s->dev;
        ret = pico_datalink_send(f); /* implies discard */
        if (ret > 0)
            return (int)plen;
        else
            return -1;
    }

    if ((f->net_hdr[0] & 0xF0) == 0x40) {
        struct pico_ipv4_hdr *hdr = (struct pico_ipv4_hdr *)f->net_hdr;
        struct pico_ipv4_route *rt;
        uint16_t iplen = (uint16_t)(
            (f->net_hdr[0] & 0x0F) * sizeof(uint32_t)); /* Read len of forged iphdr */

        if (iplen >= plen) {
            pico_err = PICO_ERR_EINVAL;
            pico_frame_discard(f);
            return -1;
        }
        f->net_len = iplen;
        f->transport_hdr = f->net_hdr + f->net_len;
        rt = route_find(s->stack, &hdr->dst);
        if (!rt) {
            pico_err = PICO_ERR_EHOSTUNREACH;
            pico_frame_discard(f);
            return -1;
        }
        if ((rt->gateway.addr != 0U) && (s4->dontroute)) {
            pico_err = PICO_ERR_EHOSTUNREACH;
            pico_frame_discard(f);
            return -1;
        }
        f->dev = rt->link->dev;
        ret = pico_datalink_send(f); /* implies discard */
        if (ret > 0)
            return (int)plen;
        else
            return -1;
    }
    pico_frame_discard(f);
    pico_err = PICO_ERR_EINVAL;
    return -1;
}
