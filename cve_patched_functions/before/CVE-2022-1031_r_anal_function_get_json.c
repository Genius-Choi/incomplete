R_API char *r_anal_function_get_json(RAnalFunction *function) {
	RAnal *a = function->anal;
	PJ *pj = a->coreb.pjWithEncoding (a->coreb.core);
	const char *realname = NULL, *import_substring = NULL;

	RFlagItem *flag = a->flag_get (a->flb.f, function->addr);
	// Can't access R_FLAGS_FS_IMPORTS, since it is defined in r_core.h
	if (flag && flag->space && !strcmp (flag->space->name, "imports")) {
		// Get substring after last dot
		import_substring = r_str_rchr (function->name, NULL, '.');
		if (import_substring) {
			realname = import_substring + 1;
		}
	} else {
		realname = function->name;
	}
	
	char *args = strdup ("");
	char *sdb_ret = r_str_newf ("func.%s.ret", realname);
	char *sdb_args = r_str_newf ("func.%s.args", realname);
	// RList *args_list = r_list_newf ((RListFree) free);
	unsigned int i;
	const char *ret_type = sdb_const_get (a->sdb_types, sdb_ret, 0);
	const char *argc_str = sdb_const_get (a->sdb_types, sdb_args, 0);

	int argc = argc_str? atoi (argc_str): 0;

	pj_o (pj);
	pj_ks (pj, "name", function->name);
	const bool no_return = r_anal_noreturn_at_addr (a, function->addr);
	pj_kb (pj, "noreturn", no_return);
	pj_ks (pj, "ret", r_str_get_fail (ret_type, "void"));
	if (function->cc) {
		pj_ks (pj, "cc", function->cc);
	}
	pj_kn (pj, "argc", argc);
	pj_k (pj, "args");
	pj_a (pj);
	for (i = 0; i < argc; i++) {
		char *sdb_arg_i = r_str_newf ("func.%s.arg.%d", realname, i);
		char *arg_i = sdb_get (a->sdb_types, sdb_arg_i, 0);
		if (!arg_i) {
			continue;
		}
		pj_o (pj);
		char *comma = strchr (arg_i, ',');
		if (comma) {
			*comma = 0;
			pj_ks (pj, "name", comma + 1);
			pj_ks (pj, "type", arg_i);
			r_strf_var (regname, 32, "A%d", i);
			const char *cc_arg = r_reg_get_name (a->reg, r_reg_get_name_idx (regname));
			if (cc_arg) {
				pj_ks (pj, "cc", cc_arg);
			}
		}
		free (arg_i);
		free (sdb_arg_i);
		pj_end (pj);
	}
	pj_end (pj);
	free (sdb_args);
	free (sdb_ret);
	free (args);
	pj_end (pj);
	return pj_drain (pj);
}
