llvh::Optional<ModuleIDsTable> readModuleIDs(
    ::hermes::parser::JSONObject *metadata) {
  assert(metadata && "No metadata to read module IDs from");

  using namespace ::hermes::parser;

  JSONObject *moduleIDs =
      llvh::dyn_cast_or_null<JSONObject>(metadata->get("moduleIDs"));
  if (!moduleIDs) {
    return llvh::None;
  }

  ModuleIDsTable result;

  llvh::DenseMap<uint32_t, llvh::StringRef> filenameByModuleID;

  for (auto itFile : *moduleIDs) {
    llvh::StringRef filename =
        llvh::sys::path::remove_leading_dotslash(itFile.first->str());
    JSONNumber *moduleID = llvh::dyn_cast<JSONNumber>(itFile.second);
    if (!moduleID) {
      llvh::errs() << "Invalid value in module ID table for file: " << filename
                   << '\n';
      return llvh::None;
    }
    uint32_t uintModuleID = (uint32_t)moduleID->getValue();
    if (uintModuleID != moduleID->getValue()) {
      llvh::errs() << "Module IDs must be unsigned integers: Found "
                   << moduleID->getValue() << '\n';
      return llvh::None;
    }
    auto emplaceRes = result.try_emplace(filename, uintModuleID);
    if (!emplaceRes.second) {
      llvh::errs() << "Duplicate entry in module ID table for file: "
                   << filename << '\n';
      return llvh::None;
    }
    auto inverseRes = filenameByModuleID.try_emplace(uintModuleID, filename);
    if (!inverseRes.second) {
      llvh::errs() << "Duplicate entry in module ID table for ID: "
                   << uintModuleID << '\n';
      return llvh::None;
    }
  }

  return result;
}
