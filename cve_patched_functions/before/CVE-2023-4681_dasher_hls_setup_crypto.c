static GF_Err dasher_hls_setup_crypto(GF_DasherCtx *ctx, GF_DashStream *ds)
{
#ifndef GPAC_DISABLE_CRYPTO
	GF_Err e;
	u32 pid_id=1;
	u32 i, count;
	const GF_PropertyValue *p;
	GF_CryptInfo *cinfo = NULL;
	const char *drm = ctx->hlsdrm;
	if (!ctx->do_m3u8) return GF_OK;
	if (ds->is_encrypted) return GF_OK;
	p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_CRYPT_INFO);
	if (p)
		drm = p->value.string;
	else
		cinfo = ctx->cinfo;
	if (!drm && !cinfo) return GF_OK;

	if (ctx->sfile) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[Dasher] Cannot use HLS segment encryption with single file output\n"));
		return GF_BAD_PARAM;
	}

	if (!cinfo) {
		cinfo = gf_crypt_info_load(drm, &e);
		if (!cinfo) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_DASH, ("[Dasher] Cannot load HLS DRM file %s\n", drm ));
			return e;
		}
		if (p) {
			if (ds->cinfo) gf_crypt_info_del(ds->cinfo);
			ds->cinfo = cinfo;
		} else {
			ctx->cinfo = cinfo;
		}
	}
	ds->tci = NULL;
	p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_ID);
	if (p) pid_id = p->value.uint;
	count = gf_list_count(cinfo->tcis);
	for (i=0; i<count; i++) {
		GF_TrackCryptInfo *tci = gf_list_get(cinfo->tcis, i);
		if (tci->trackID && (tci->trackID != pid_id)) continue;

		ds->tci = tci;
		break;
	}
	if (!ds->tci) return GF_OK;

	ds->key_idx = 0;
	ds->iv_low = ds->iv_high = 0;
	for (i=0; i<8; i++) {
		ds->iv_high |= ds->tci->keys[ds->key_idx].IV[i];
		ds->iv_low |= ds->tci->keys[ds->key_idx].IV[i + 8];
		if (i<7) {
			ds->iv_high <<= 8;
			ds->iv_low <<= 8;
		}
	}
	return GF_OK;
#else
	return GF_NOT_SUPPORTED;
#endif
}
