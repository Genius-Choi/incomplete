int ecall_msg_recv(struct ecall *ecall,
		   uint32_t curr_time, /* in seconds */
		   uint32_t msg_time, /* in seconds */
		   const char *userid_sender,
		   const char *clientid_sender,
		   struct econn_message *msg)
{
	char userid_anon[ANON_ID_LEN];
	int err = 0;
	bool update_ids = false;

	info("ecall(%p): msg_recv: %H\n", ecall, econn_message_brief, msg);

	if (!ecall || !userid_sender || !clientid_sender || !msg)
		return EINVAL;

	ecall_trace(ecall, msg, false, ECONN_TRANSP_BACKEND,
		    "SE %H\n", econn_message_brief, msg);

	if (userid_sender && !ecall->userid_peer) {
		ecall_set_peer_userid(ecall, userid_sender);
		update_ids = true;
	}
	if (clientid_sender && !ecall->clientid_peer) {
		ecall_set_peer_clientid(ecall, clientid_sender);
		update_ids = true;
	}
	
	if (update_ids) {
		info("ecall(%p): updating ids on flow: %p\n", ecall, ecall->flow);
	}
	IFLOW_CALL(ecall->flow, set_remote_userclientid,
		   ecall->userid_peer, ecall->clientid_peer);
	
	if (ECONN_PROPSYNC == msg->msg_type) {
		err = handle_propsync(ecall, msg);
		if (err) {
			warning("ecall(%p): recv: handle_propsync failed\n", ecall);
		}
		return err;
	}

	/* Check that message was received via correct transport */
	if (ECONN_TRANSP_BACKEND != econn_transp_resolve(msg->msg_type)) {
		warning("ecall: recv: wrong transport for type %s\n",
			econn_msg_name(msg->msg_type));
	}

	/* Messages from the same userid.
	 */
	if (0 == str_casecmp(ecall->userid_self, userid_sender) &&
		ecall->conv_type == ICALL_CONV_TYPE_ONEONONE) {

		if (msg->msg_type == ECONN_REJECT || 
			(msg->msg_type == ECONN_SETUP && msg->resp)) {

			/* Received SETUP(r) or REJECT from other Client.
			 * We must stop the ringing.
			 */
			info("ecall: other client %s"
			     " -- stop ringtone\n", msg->msg_type == ECONN_REJECT ? 
			     "rejected" : "answered");

			if (ecall->econn &&
				econn_current_state(ecall->econn) == ECONN_PENDING_INCOMING) {

				int why = msg->msg_type == ECONN_REJECT ? EREMOTE : EALREADY;
				econn_close(ecall->econn, why,
					msg ? msg->time : ECONN_MESSAGE_TIME_UNKNOWN);
			}
			else {
				info("no pending incoming econns\n");
			}
		}
		else {
			info("ecall(%p): ignore message %s from"
			     " same user (%s)\n", ecall,
			     econn_msg_name(msg->msg_type), anon_id(userid_anon, userid_sender));
		}

		goto out;
	}

	/* create a new ECONN */
	if (!ecall->econn &&
	    econn_is_creator_full(ecall->userid_self, ecall->clientid_self,
				  userid_sender, clientid_sender, msg)) {

		err = ecall_create_econn(ecall);
		if (err) {
			warning("ecall: transp_recv: econn_alloc failed:"
				" %m\n", err);
			goto out;
		}
	}

	/* forward the received message to ECONN */
	econn_recv_message(ecall->econn, userid_sender, clientid_sender, msg);

 out:
	return err;
}
