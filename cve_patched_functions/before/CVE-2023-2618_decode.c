Ref<DecoderResult> DecodedBitStreamParser::decode(ArrayRef<char> bytes, Version* version,
                                                  ErrorCorrectionLevel const& ecLevel,
                                                  ErrorHandler& err_handler, int iVersion) {
    Ref<BitSource> bits_(new BitSource(bytes));
    BitSource& bits(*bits_);
    string result;
    result.reserve(50);
    Mode* mode = 0;
    string modeName;
    ArrayRef<ArrayRef<char> > byteSegments(0);

    CharacterSetECI* currentCharacterSetECI = 0;
    bool fc1InEffect = false;

    outputCharset = "UTF-8";
    do {
        // While still another segment to read...
        if (bits.available() < 4) {
            // OK, assume we're done. Really, a TERMINATOR mode should have been
            // recorded here
            mode = &Mode::TERMINATOR;
        } else {
            mode = &Mode::forBits(bits.readBits(4, err_handler),
                                  err_handler);  // mode is encoded by 4 bits
            if (err_handler.ErrCode()) return Ref<DecoderResult>();
        }

        if (mode != &Mode::TERMINATOR) {
            if ((mode == &Mode::FNC1_FIRST_POSITION) || (mode == &Mode::FNC1_SECOND_POSITION)) {
                // We do little with FNC1 except alter the parsed result a bit
                // according to the spec
                fc1InEffect = true;
            } else if (mode == &Mode::STRUCTURED_APPEND) {
                if (bits.available() < 16) {
                    err_handler = zxing::FormatErrorHandler("decode");
                    return Ref<DecoderResult>();
                }
                // not really supported; all we do is ignore it
                // Read next 8 bits (symbol sequence #) and 8 bits (parity
                // data), then continue
                bits.readBits(16, err_handler);
                if (err_handler.ErrCode()) return Ref<DecoderResult>();
            } else if (mode == &Mode::ECI) {
                // Count doesn't apply to ECI
                int value = parseECIValue(bits, err_handler);
                if (err_handler.ErrCode()) Ref<DecoderResult>();
                currentCharacterSetECI = CharacterSetECI::getCharacterSetECIByValueFind(value);
                if (currentCharacterSetECI == 0) {
                    err_handler = zxing::FormatErrorHandler("decode");
                    return Ref<DecoderResult>();
                }
            } else {
                // First handle Hanzi mode which does not start with character
                // count
                if (mode == &Mode::HANZI) {
                    // chinese mode contains a sub set indicator right after
                    // mode indicator
                    int subset = bits.readBits(4, err_handler);
                    int countHanzi =
                        bits.readBits(mode->getCharacterCountBits(version), err_handler);
                    if (err_handler.ErrCode()) return Ref<DecoderResult>();
                    if (subset == GB2312_SUBSET) {
                        decodeHanziSegment(bits_, result, countHanzi, err_handler);
                        if (err_handler.ErrCode()) Ref<DecoderResult>();
                        outputCharset = "GB2312";
                        modeName = mode->getName();
                    }
                } else {
                    // "Normal" QR code modes:
                    // How many characters will follow, encoded in this mode?
                    int count = bits.readBits(mode->getCharacterCountBits(version), err_handler);
                    if (err_handler.ErrCode()) return Ref<DecoderResult>();
                    if (mode == &Mode::NUMERIC) {
                        decodeNumericSegment(bits_, result, count, err_handler);
                        if (err_handler.ErrCode()) {
                            err_handler = zxing::FormatErrorHandler("decode");
                            return Ref<DecoderResult>();
                        }
                        modeName = mode->getName();
                    } else if (mode == &Mode::ALPHANUMERIC) {
                        decodeAlphanumericSegment(bits_, result, count, fc1InEffect, err_handler);
                        if (err_handler.ErrCode()) Ref<DecoderResult>();
                        modeName = mode->getName();
                    } else if (mode == &Mode::BYTE) {
                        decodeByteSegment(bits_, result, count, currentCharacterSetECI,
                                          byteSegments, err_handler);
                        if (err_handler.ErrCode()) {
                            err_handler = zxing::FormatErrorHandler("decode");
                            return Ref<DecoderResult>();
                        }
                        modeName = mode->getName();
                        // outputCharset = getResultCharset();
                    } else if (mode == &Mode::KANJI) {
                        // int countKanji =
                        // bits.readBits(mode->getCharacterCountBits(version));
                        // cout<<"countKanji: "<<countKanji<<endl;
                        // decodeKanjiSegment(bits_, result, countKanji);
                        decodeKanjiSegment(bits_, result, count, err_handler);
                        if (err_handler.ErrCode()) Ref<DecoderResult>();
                        modeName = mode->getName();
                    } else {
                        err_handler = zxing::FormatErrorHandler("decode");
                        return Ref<DecoderResult>();
                    }
                }
            }
        }
    } while (mode != &Mode::TERMINATOR);
    return Ref<DecoderResult>(new DecoderResult(bytes, Ref<String>(new String(result)),
                                                byteSegments, (string)ecLevel,
                                                (string)outputCharset, iVersion, modeName));
}
