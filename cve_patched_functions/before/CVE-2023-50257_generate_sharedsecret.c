SharedSecretHandle* generate_sharedsecret(EVP_PKEY* private_key, EVP_PKEY* public_key)
{
    assert(private_key);
    assert(public_key);

    SharedSecretHandle* handle = nullptr;
    EVP_PKEY_CTX* ctx = EVP_PKEY_CTX_new(private_key, NULL);

    if(ctx != nullptr)
    {
        if(EVP_PKEY_derive_init(ctx) > 0)
        {
            if(EVP_PKEY_derive_set_peer(ctx, public_key) > 0)
            {
                size_t length = 0;
                if(EVP_PKEY_derive(ctx, NULL, &length) > 0)
                {
                    SharedSecret::BinaryData data;
                    data.name("SharedSecret");
                    data.value().resize(length);
                    
                    if(EVP_PKEY_derive(ctx, data.value().data(), &length) > 0)
                    {
                        data.value().resize(length);
                        handle = new SharedSecretHandle();
                        (*handle)->data_.emplace_back(std::move(data));
                    }
                    else
                        logError(AUTHENTICATION, "OpenSSL library cannot get derive");
                }
                else
                    logError(AUTHENTICATION, "OpenSSL library cannot get length");
            }
            else
                logError(AUTHENTICATION, "OpenSSL library cannot set peer");
        }
        else
            logError(AUTHENTICATION, "OpenSSL library cannot init derive");

        EVP_PKEY_CTX_free(ctx);
    }
    else
        logError(AUTHENTICATION, "OpenSSL library cannot allocate context");

    return handle;
}
