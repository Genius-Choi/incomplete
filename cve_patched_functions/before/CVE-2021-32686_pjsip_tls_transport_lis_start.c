PJ_DEF(pj_status_t) pjsip_tls_transport_lis_start(pjsip_tpfactory *factory,
						const pj_sockaddr *local,
						const pjsip_host_port *a_name)
{
    pj_status_t status = PJ_SUCCESS;
    pj_ssl_sock_param ssock_param, newsock_param;
    struct tls_listener *listener = (struct tls_listener *)factory;
    pj_sockaddr *listener_addr = &listener->factory.local_addr;

    if (listener->ssock)
	return PJ_SUCCESS;

    set_ssock_param(&ssock_param, listener);
    update_bound_addr(listener, local);
    ssock_param.grp_lock = listener->grp_lock;

    /* Create SSL socket */
    status = pj_ssl_sock_create(listener->factory.pool, &ssock_param, 
				&listener->ssock);
    if (status != PJ_SUCCESS)
	return status;

    if (listener->cert) {
	status = pj_ssl_sock_set_certificate(listener->ssock, 
				       listener->factory.pool, listener->cert);
	if (status != PJ_SUCCESS)
	    return status;
    }

    /* Start accepting incoming connections. Note that some TLS/SSL
     * backends may not support for SSL socket server.
     */    
    pj_memcpy(&newsock_param, &ssock_param, sizeof(newsock_param));
    newsock_param.async_cnt = 1;
    newsock_param.cb.on_data_read = &on_data_read;
    newsock_param.cb.on_data_sent = &on_data_sent;
    status = pj_ssl_sock_start_accept2(listener->ssock, listener->factory.pool,
			    (pj_sockaddr_t*)listener_addr,
			    pj_sockaddr_get_len((pj_sockaddr_t*)listener_addr),
			    &newsock_param);

    if (status == PJ_SUCCESS || status == PJ_EPENDING) {
	pj_ssl_sock_info info;	

	/* Retrieve the bound address */
	status = pj_ssl_sock_get_info(listener->ssock, &info);
	if (status == PJ_SUCCESS)
	    pj_sockaddr_cp(listener_addr, (pj_sockaddr_t*)&info.local_addr);

    }
    status = update_factory_addr(listener, a_name);
    if (status != PJ_SUCCESS)
	return status;

    update_transport_info(listener);

    return status;    
}
