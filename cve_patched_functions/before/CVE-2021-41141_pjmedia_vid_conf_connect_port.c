PJ_DEF(pj_status_t) pjmedia_vid_conf_connect_port(
					    pjmedia_vid_conf *vid_conf,
					    unsigned src_slot,
					    unsigned sink_slot,
					    void *opt)
{
    vconf_port *src_port, *dst_port;
    unsigned i;

    /* Check arguments */
    PJ_ASSERT_RETURN(vid_conf &&
		     src_slot<vid_conf->opt.max_slot_cnt && 
		     sink_slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);
    PJ_UNUSED_ARG(opt);

    pj_mutex_lock(vid_conf->mutex);

    /* Ports must be valid. */
    src_port = vid_conf->ports[src_slot];
    dst_port = vid_conf->ports[sink_slot];
    if (!src_port || !src_port->port->get_frame ||
	!dst_port || !dst_port->port->put_frame)
    {
	PJ_LOG(4,(THIS_FILE,"Failed connecting video ports, make sure that "
			    "source has get_frame() & sink has put_frame()"));
	pj_mutex_unlock(vid_conf->mutex);
	return PJ_EINVAL;
    }

    /* Check if connection has been made */
    for (i=0; i<src_port->listener_cnt; ++i) {
	if (src_port->listener_slots[i] == sink_slot)
	    break;
    }

    if (i == src_port->listener_cnt) {
	src_port->listener_slots[src_port->listener_cnt] = sink_slot;
	dst_port->transmitter_slots[dst_port->transmitter_cnt] = src_slot;
	++src_port->listener_cnt;
	++dst_port->transmitter_cnt;

	if (src_port->listener_cnt == 1) {
    	    /* If this is the first listener, initialize source's buffer
    	     * with black color.
    	     */
	    const pjmedia_video_format_info *vfi;
	    pjmedia_video_apply_fmt_param vafp;

	    vfi = pjmedia_get_video_format_info(NULL,
	    					src_port->port->info.fmt.id);
	    pj_bzero(&vafp, sizeof(vafp));
	    vafp.size = src_port->port->info.fmt.det.vid.size;
	    (*vfi->apply_fmt)(vfi, &vafp);

	    if (vfi->color_model == PJMEDIA_COLOR_MODEL_RGB) {
	    	pj_memset(src_port->get_buf, 0, vafp.framebytes);
	    } else if (src_port->port->info.fmt.id == PJMEDIA_FORMAT_I420 ||
	  	       src_port->port->info.fmt.id == PJMEDIA_FORMAT_YV12)
	    {	    	
	    	pj_memset(src_port->get_buf, 16, vafp.plane_bytes[0]);
	    	pj_memset((pj_uint8_t*)src_port->get_buf + vafp.plane_bytes[0],
		      	  0x80, vafp.plane_bytes[1] * 2);
	    }
	}

	update_render_state(vid_conf, dst_port);

	++vid_conf->connect_cnt;
	if (vid_conf->connect_cnt == 1) {
	    pj_status_t status;
	    status = pjmedia_clock_start(vid_conf->clock);
	    if (status != PJ_SUCCESS) {
		PJ_PERROR(4, (THIS_FILE, status, "Failed to start clock"));
		return status;
	    }
	}

	PJ_LOG(4,(THIS_FILE,"Port %d (%.*s) transmitting to port %d (%.*s)",
		  src_slot,
		  (int)src_port->name.slen,
		  src_port->name.ptr,
		  sink_slot,
		  (int)dst_port->name.slen,
		  dst_port->name.ptr));
    }

    pj_mutex_unlock(vid_conf->mutex);

    return PJ_SUCCESS;
}
