authentic_pkcs15_erase_card(struct sc_profile *profile, struct sc_pkcs15_card *p15card)
{
	struct sc_context *ctx = p15card->card->ctx;
	struct sc_file  *file = NULL;
	struct sc_pkcs15_df *df;
	int rv;

	LOG_FUNC_CALLED(ctx);

	if (p15card->file_odf)   {
		sc_log(ctx, "Select ODF path: %s", sc_print_path(&p15card->file_odf->path));
		rv = sc_select_file(p15card->card, &p15card->file_odf->path, NULL);
		LOG_TEST_RET(ctx, rv, "Erase application error: cannot select ODF path");
	}

	for (df = p15card->df_list; df; df = df->next)   {
		struct sc_pkcs15_object *objs[32];
		unsigned obj_type = 0;
		int ii;

		if (df->type == SC_PKCS15_PRKDF)
			obj_type = SC_PKCS15_TYPE_PRKEY;
		else if (df->type == SC_PKCS15_PUKDF)
			obj_type = SC_PKCS15_TYPE_PUBKEY;
		else if (df->type == SC_PKCS15_CDF)
			obj_type = SC_PKCS15_TYPE_CERT;
		else if (df->type == SC_PKCS15_DODF)
			obj_type = SC_PKCS15_TYPE_DATA_OBJECT;
		else
			continue;

		if (df->enumerated)   {
			rv = sc_pkcs15_get_objects(p15card, obj_type, objs, 32);
			LOG_TEST_RET(ctx, rv, "Failed to get PKCS#15 objects to remove");

			for (ii=0; ii<rv; ii++)
				sc_pkcs15_remove_object(p15card, objs[ii]);
		}

		rv = sc_select_file(p15card->card, &df->path, &file);
		if (rv == SC_ERROR_FILE_NOT_FOUND)
			continue;
		LOG_TEST_RET(ctx, rv, "Cannot select object data file");

		rv = sc_erase_binary(p15card->card, 0, file->size, 0);
		if (rv == SC_ERROR_SECURITY_STATUS_NOT_SATISFIED)   {
			rv = sc_pkcs15init_authenticate(profile, p15card, file, SC_AC_OP_UPDATE);
			if (rv < 0)
				sc_file_free(file);

			LOG_TEST_RET(ctx, rv, "'UPDATE' authentication failed");

			rv = sc_erase_binary(p15card->card, 0, file->size, 0);
		}

		sc_file_free(file);
		LOG_TEST_RET(ctx, rv, "Binary erase error");

		profile->dirty = 1;
	}

	LOG_FUNC_RETURN(ctx, SC_SUCCESS);
}
