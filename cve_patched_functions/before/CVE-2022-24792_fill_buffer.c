static pj_status_t fill_buffer(struct file_reader_port *fport)
{
    pj_uint32_t size_left = fport->bufsize;
    unsigned size_to_read;
    pj_ssize_t size;
    pj_status_t status;

    fport->eofpos = NULL;
    
    while (size_left > 0) {

	/* Calculate how many bytes to read in this run. */
	size = size_to_read = size_left;
	status = pj_file_read(fport->fd, 
			      &fport->buf[fport->bufsize-size_left], 
			      &size);
	if (status != PJ_SUCCESS)
	    return status;
	if (size < 0) {
	    /* Should return more appropriate error code here.. */
	    return PJ_ECANCELLED;
	}

        if (size > (pj_ssize_t)fport->data_left) {
            /* We passed the end of the data chunk,
             * only count the portion read from the data chunk.
             */
            size = (pj_ssize_t)fport->data_left;
        }

	size_left -= (pj_uint32_t)size;
        fport->data_left -= (pj_uint32_t)size;
	fport->fpos += size;

	/* If size is less than size_to_read, it indicates that we've
	 * encountered EOF. Rewind the file.
	 */
        if (size < (pj_ssize_t)size_to_read) {
            fport->eof = PJ_TRUE;
            fport->eofpos = fport->buf + fport->bufsize - size_left;

            if (fport->options & PJMEDIA_FILE_NO_LOOP) {
                /* Zero remaining buffer */
                if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_PCM) {
                    pj_bzero(fport->eofpos, size_left);
                } else if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ULAW) {
                    int val = pjmedia_linear2ulaw(0);
                    pj_memset(fport->eofpos, val, size_left);
                } else if (fport->fmt_tag == PJMEDIA_WAVE_FMT_TAG_ALAW) {
                    int val = pjmedia_linear2alaw(0);
                    pj_memset(fport->eofpos, val, size_left);
                }
		size_left = 0;
            }

	    /* Rewind file */
	    fport->fpos = fport->start_data;
	    pj_file_setpos( fport->fd, fport->fpos, PJ_SEEK_SET);
            fport->data_left = fport->data_len;
	}
    }

    /* Convert samples to host rep */
    samples_to_host((pj_int16_t*)fport->buf, 
		    fport->bufsize/fport->bytes_per_sample);

    return PJ_SUCCESS;
}
