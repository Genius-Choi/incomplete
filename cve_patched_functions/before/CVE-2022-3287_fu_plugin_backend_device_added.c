fu_plugin_backend_device_added(FuPlugin *self, FuDevice *device, GError **error)
{
	FuDevice *proxy;
	FuPluginPrivate *priv = GET_PRIVATE(self);
	GType device_gtype = fu_device_get_specialized_gtype(FU_DEVICE(device));
	g_autoptr(FuDevice) dev = NULL;
	g_autoptr(FuDeviceLocker) locker = NULL;

	/* fall back to plugin default */
	if (device_gtype == G_TYPE_INVALID) {
		if (priv->device_gtypes->len > 1) {
			g_set_error_literal(error,
					    FWUPD_ERROR,
					    FWUPD_ERROR_INTERNAL,
					    "too many GTypes to choose a default");
			return FALSE;
		}
		device_gtype = g_array_index(priv->device_gtypes, GType, 0);
	}

	/* create new device and incorporate existing properties */
	dev = g_object_new(device_gtype, "context", priv->ctx, NULL);
	fu_device_incorporate(dev, FU_DEVICE(device));
	if (!fu_plugin_runner_device_created(self, dev, error))
		return FALSE;

	/* there are a lot of different devices that match, but not all respond
	 * well to opening -- so limit some ones with issued updates */
	if (fu_device_has_internal_flag(dev, FU_DEVICE_INTERNAL_FLAG_ONLY_SUPPORTED)) {
		if (!fu_device_probe(dev, error))
			return FALSE;
		fu_device_convert_instance_ids(dev);
		if (!fu_plugin_check_supported_device(self, dev)) {
			g_autofree gchar *guids = fu_device_get_guids_as_str(dev);
			g_debug("%s has no updates, so ignoring device", guids);
			return TRUE;
		}
	}

	/* open and add */
	proxy = fu_device_get_proxy(device);
	if (proxy != NULL) {
		g_autoptr(FuDeviceLocker) locker_proxy = NULL;
		locker_proxy = fu_device_locker_new(proxy, error);
		if (locker_proxy == NULL)
			return FALSE;
	}
	locker = fu_device_locker_new(dev, error);
	if (locker == NULL)
		return FALSE;
	fu_plugin_device_add(self, dev);
	fu_plugin_runner_device_added(self, dev);
	return TRUE;
}
