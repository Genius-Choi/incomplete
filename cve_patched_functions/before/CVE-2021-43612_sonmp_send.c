sonmp_send(struct lldpd *global,
    struct lldpd_hardware *hardware)
{
	const u_int8_t mcastaddr[] = SONMP_MULTICAST_ADDR;
	const u_int8_t llcorg[] = LLC_ORG_NORTEL;
	struct lldpd_chassis *chassis;
	struct lldpd_mgmt *mgmt;
	u_int8_t *packet, *pos, *pos_pid, *end;
	int length;
	struct in_addr address;

	log_debug("sonmp", "send SONMP PDU to %s",
	    hardware->h_ifname);

	chassis = hardware->h_lport.p_chassis;
	length = hardware->h_mtu;
	if ((packet = (u_int8_t*)calloc(1, length)) == NULL)
		return ENOMEM;
	pos = packet;

	/* Ethernet header */
	if (!(
	      /* SONMP multicast address as target */
	      POKE_BYTES(mcastaddr, sizeof(mcastaddr)) &&
	      /* Source MAC addresss */
	      POKE_BYTES(&hardware->h_lladdr, ETHER_ADDR_LEN) &&
	      /* SONMP frame is of fixed size */
	      POKE_UINT16(SONMP_SIZE)))
		goto toobig;

	/* LLC header */
	if (!(
	      /* DSAP and SSAP */
	      POKE_UINT8(0xaa) && POKE_UINT8(0xaa) &&
	      /* Control field */
	      POKE_UINT8(0x03) &&
	      /* ORG */
	      POKE_BYTES(llcorg, sizeof(llcorg)) &&
	      POKE_SAVE(pos_pid) && /* We will modify PID later to
				       create a new frame */
	      POKE_UINT16(LLC_PID_SONMP_HELLO)))
		goto toobig;


	address.s_addr = htonl(INADDR_ANY);
	TAILQ_FOREACH(mgmt, &chassis->c_mgmt, m_entries) {
		if (mgmt->m_family == LLDPD_AF_IPV4) {
			address.s_addr = mgmt->m_addr.inet.s_addr;
		}
		break;
	}

	/* SONMP */
	if (!(
		  /* Our IP address */
		  POKE_BYTES(&address, sizeof(struct in_addr)) &&
		  /* Segment on three bytes, we don't have slots, so we
		 skip the first two bytes */
		  POKE_UINT16(0) &&
		  POKE_UINT8(hardware->h_ifindex) &&
		  POKE_UINT8(1) &&  /* Chassis: Other */
		  POKE_UINT8(12) &&	/* Back: Ethernet, Fast Ethernet and Gigabit */
		  POKE_UINT8(SONMP_TOPOLOGY_NEW) && /* Should work. We have no state */
		  POKE_UINT8(1) &&	/* Links: Dunno what it is */
		  POKE_SAVE(end)))
		goto toobig;
				
	if (interfaces_send_helper(global, hardware,
		(char *)packet, end - packet) == -1) {
		log_warn("sonmp", "unable to send packet on real device for %s",
			   hardware->h_ifname);
		free(packet);
		return ENETDOWN;
	}

	POKE_RESTORE(pos_pid);	/* Modify LLC PID */
	(void)POKE_UINT16(LLC_PID_SONMP_FLATNET);
	POKE_RESTORE(packet);	/* Go to the beginning */
	PEEK_DISCARD(ETHER_ADDR_LEN - 1); /* Modify the last byte of the MAC address */
	(void)POKE_UINT8(1);

	if (interfaces_send_helper(global, hardware,
		(char *)packet, end - packet) == -1) {
		log_warn("sonmp", "unable to send second SONMP packet on real device for %s",
			   hardware->h_ifname);
		free(packet);
		return ENETDOWN;
	}

	free(packet);
	hardware->h_tx_cnt++;
	return 0;
 toobig:
	free(packet);
	return -1;
}
