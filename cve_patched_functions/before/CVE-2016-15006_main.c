int main(int argc, char const *argv[])
{
	FILE* mainFile;
	FILE* keyFile = NULL;

	if ((progName = strrchr(argv[0], '/')) != NULL) {
		++progName;
	} else {
		progName = argv[0];
	}
	if (argc < 2) {
		usage(1);
	} else if(argc >= 5 ) { 
		printf("Error: Too many arguments\n");
		usage(1);
	} else if (strcmp(argv[1], "-h") == 0 || strcmp(argv[1], "--help") == 0) {
		usage(0);
	}

	if (argc >= 3)
	{
		//test if the option -s is present
		if (strcmp(argv[2], "-s") == 0 || strcmp(argv[2], "--standard") == 0){
			scrambling = 0;
			//if there is a keyfile, warns that it will not be used 
			if(argc >= 4){
				if((keyFile = fopen(argv[3], "r")) == NULL){
					perror(argv[3]);
					usage(1);
				}
				printf("Warning: with the -s|--standard option, the keyfile will not bu used\n");
				keyFile = NULL;
			}
		//else the option -i
		} else if (strcmp(argv[2], "-i") == 0 || strcmp(argv[2], "--inverted") == 0){
			isCodingInverted = 1;
			//if i is present, checks if there is a keyfile in the third argument
			if(argc >= 4){
				if((keyFile = fopen(argv[3], "r")) == NULL){
					perror(argv[3]);
					usage(1);
				}
			}
		//if no option is present test if the second argument is a keyfile
		} else if ((keyFile = fopen(argv[2], "r")) == NULL) {
			perror(argv[2]);
			usage(1);
		} else if(keyFile != NULL && argc >= 4){
			printf("Error: Too many arguments\n");
			usage(1);
		}
		
	}

	if (argv[1][strlen(argv[1])-1] == '/' && argv[1][strlen(argv[1])-2] == '/')
	{
		printf("error: several trailing '/' in the path of your file\n");
		printf("exiting\n");
		exit(1);
	}

	//outside their scope because we need to free them at the end
	char* tarName = NULL;
	char* dirName = NULL;
	char *copyOfArgv1 = (char*) calloc(1, sizeof(char) * strlen(argv[1]));
	strcpy(copyOfArgv1, argv[1]);
	if (isADirectory(copyOfArgv1)){
		char command[1008] = {'\0'};
		//we don't need that anymore
		printf("regrouping the folder in one file using tar, may be long...");
		fflush(stdout);
		// get the name of the folder in a string and get the path
		if ((fileName = strrchr(argv[1], '/')) != NULL) {
			//if the '/' is the last character in the string, delete it and get the fileName again
			if (strlen(fileName) == 1){
				dirName = (char*) calloc(1, sizeof(char) * (strlen(argv[1]) + 5));
				strcpy(dirName, argv[1]);
				*(dirName+(fileName-argv[1])) = '\0';
				if ((fileName = strrchr(dirName, '/')) != NULL){
					++fileName;
					strncpy(pathToMainFile, dirName, fileName - dirName);
					pathToMainFile[fileName - dirName] = '\0';
				}
				else{
					fileName = dirName;
				}
			}
			else {
				++fileName;
				strncpy(pathToMainFile, argv[1], fileName - argv[1]);
				pathToMainFile[fileName - argv[1]] = '\0';
			}
		}
		else {
			fileName = argv[1];
		}
		// get the full path of the tarFile in a dynamic variable tarName
		tarName = (char*) calloc(1, sizeof(char) * (strlen(fileName) + 5));
		sprintf (tarName, "%s.tar", fileName);

		//all of the following is to make a clean string for the tar commands (taking care of spaces)
		char* cleanFileName       = processTarString((char*)fileName);
		char* cleanPathToMainFile = processTarString(pathToMainFile);
		char* cleanTarName        = processTarString(tarName);
		
		// use of cd to prevent tar to archive all the path architecture 
		// (ex: /usr/myname/my/path/theFolderWeWant/)
		sprintf (command, "cd %s && tar -cf %s %s &>/dev/null", cleanPathToMainFile, cleanTarName, cleanFileName); //&>/dev/null

		//free the temporary strings
		free(cleanPathToMainFile);
		free(cleanTarName);
		free(cleanFileName);

		// make the archive of the folder with tar
		int status;
		if((status = system(command)) != 0){ //if problems when taring
			printf("\nerror: unable to tar your file\n");
			printf("exiting\n");
			exit(1);
		}else{
			printf("\rregrouping the folder in one file using tar... Done          \n");			
		}

		fileName = tarName;

		// trying to open the new archive
		char pathPlusName[strlen(pathToMainFile)+strlen(fileName)];
		sprintf(pathPlusName, "%s%s", pathToMainFile, fileName);
		if ((mainFile = fopen(pathPlusName, "r")) == NULL) {
			perror(pathPlusName);
			printf("exiting\n");
			return EXIT_FAILURE;
		}
	}
	else{
		if ((fileName = strrchr(argv[1], '/')) != NULL) {
			++fileName;
			strncpy(pathToMainFile, argv[1], fileName - argv[1]);		
		} else {
			fileName = argv[1];
		}
		if ((mainFile = fopen(argv[1], "r")) == NULL) {
			perror(argv[1]);
			printf("exiting\n");
			return EXIT_FAILURE;
		}
	}
	free(copyOfArgv1);

	fseek(mainFile, 0, SEEK_END);
	long mainFileSize = ftell(mainFile);
	rewind(mainFile);
	numberOfBuffer = ceilRound((float)mainFileSize / (float)(BUFFER_SIZE));
	if (numberOfBuffer < 1)
	{
		numberOfBuffer = 1;
	}

	char procedureResponse[2]; 
	isCrypting = -1;
	do{
		printf("Crypt(C) or Decrypt(d):");
		readString(procedureResponse, 2);
		printf("\033[F\033[J");
		if (procedureResponse[0] == 'C' || procedureResponse[0] == 'c') {
			isCrypting = 1;
		}
		else if(procedureResponse[0] == 'D' || procedureResponse[0] == 'd'){
			isCrypting = 0;
		}
	}while(isCrypting == -1);
	
	printf("Password:");
	readString(passPhrase, 16383);
	printf("\033[F\033[J");
	getSeed(passPhrase);
	scramble(keyFile);

	if (isCrypting){
		code(mainFile);
	}
	else{
		decode(mainFile);
	}
	printf("Done                                                                  \n");
	fclose(mainFile);

	//we can free (last use in code/decode)
	if(tarName != NULL){
		free(tarName);
	}
	if(dirName != NULL){
		free(dirName);
	}

	return 0;
}
