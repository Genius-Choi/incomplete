static int http1_on_header(http1_parser_s *parser, char *name, size_t name_len,
                           char *data, size_t data_len) {
  FIOBJ sym;
  FIOBJ obj;
  if (!http1_pr2handle(parser2http(parser)).headers) {
    FIO_LOG_ERROR("(http1 parse ordering error) missing HashMap for header "
                  "%s: %s",
                  name, data);
    http_send_error2(500, parser2http(parser)->p.uuid,
                     parser2http(parser)->p.settings);
    return -1;
  }
  parser2http(parser)->header_size += name_len + data_len;
  if (parser2http(parser)->header_size >=
          parser2http(parser)->max_header_size ||
      fiobj_hash_count(http1_pr2handle(parser2http(parser)).headers) >
          HTTP_MAX_HEADER_COUNT) {
    if (parser2http(parser)->p.settings->log) {
      FIO_LOG_WARNING("(HTTP) security alert - header flood detected.");
    }
    http_send_error(&http1_pr2handle(parser2http(parser)), 413);
    return -1;
  }
  sym = fiobj_str_new(name, name_len);
  obj = fiobj_str_new(data, data_len);
  set_header_add(http1_pr2handle(parser2http(parser)).headers, sym, obj);
  fiobj_free(sym);
  return 0;
}
