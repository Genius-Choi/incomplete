dynamic_monitor_process_queue(struct xrdp_mm *self)
{
    LOG_DEVEL(LOG_LEVEL_TRACE, "dynamic_monitor_process_queue:");

    if (self == 0)
    {
        return 0;
    }

    struct xrdp_wm *wm = self->wm;

    if (!xrdp_wm_can_resize(wm))
    {
        return 0;
    }

    if (self->resize_data == NULL && self->resize_queue != NULL)
    {
        if  (self->resize_queue->count <= 0)
        {
            LOG_DEVEL(LOG_LEVEL_DEBUG, "Resize queue is empty.");
            return 0;
        }
        LOG_DEVEL(LOG_LEVEL_DEBUG, "dynamic_monitor_process_queue: Queue is"
                  " not empty. Filling out description.");
        const struct display_size_description *queue_head =
            (struct display_size_description *)
            list_get_item(self->resize_queue, 0);

        const int invalid_dimensions = queue_head->session_width <= 0
                                       || queue_head->session_height <= 0;

        if (invalid_dimensions)
        {
            LOG(LOG_LEVEL_DEBUG,
                "dynamic_monitor_process_queue: Not allowing"
                " resize due to invalid dimensions (w: %d x h: %d)",
                queue_head->session_width,
                queue_head->session_height);
        }

        const struct display_size_description *current_size
                = &wm->client_info->display_sizes;

        const int already_this_size = queue_head->session_width
                                      == current_size->session_width
                                      && queue_head->session_height
                                      == current_size->session_height;

        if (already_this_size)
        {
            LOG(LOG_LEVEL_DEBUG,
                "dynamic_monitor_process_queue: Not resizing."
                " Already this size. (w: %d x h: %d)",
                queue_head->session_width,
                queue_head->session_height);
        }

        if (!invalid_dimensions && !already_this_size)
        {
            const int LAYOUT_DATA_SIZE =
                sizeof(struct display_control_monitor_layout_data);
            self->resize_data = (struct display_control_monitor_layout_data *)
                                g_malloc(LAYOUT_DATA_SIZE, 1);
            g_memcpy(&(self->resize_data->description), queue_head,
                     sizeof(struct display_size_description));
            const int time = g_time3();
            self->resize_data->start_time = time;
            self->resize_data->last_state_update_timestamp = time;
            self->resize_data->using_egfx = (self->egfx != NULL);
            advance_resize_state_machine(self, WMRZ_ENCODER_DELETE);
        }
        else
        {
            g_set_wait_obj(self->resize_ready);
        }
        list_remove_item(self->resize_queue, 0);
        return 0;
    }
    else
    {
        LOG_DEVEL(LOG_LEVEL_DEBUG, "dynamic_monitor_process_queue:"
                  " Resize data is not null.");
    }

    if (self->resize_data == NULL)
    {
        return 0;
    }

    if (self->resize_data->state == WMRZ_COMPLETE)
    {
        LOG(LOG_LEVEL_INFO, "dynamic_monitor_process_queue: Clearing"
            " completed resize (w: %d x h: %d). It took %d milliseconds.",
            self->resize_data->description.session_width,
            self->resize_data->description.session_height,
            g_time3() - self->resize_data->start_time);
        g_set_wait_obj(self->resize_ready);
    }
    else if (self->resize_data->state == WMRZ_ERROR)
    {
        LOG(LOG_LEVEL_INFO, "dynamic_monitor_process_queue: Clearing"
            " failed request to resize to: (w: %d x h: %d)",
            self->resize_data->description.session_width,
            self->resize_data->description.session_height);
        g_set_wait_obj(self->resize_ready);
    }
    else
    {
        // No errors, process it!
        return process_display_control_monitor_layout_data(self->wm);
    }
    g_free(self->resize_data);
    self->resize_data = NULL;
    return 0;
}
