static int dump_clusters_to_stdout(struct exfat2img *ei,
				   unsigned int start_clu, unsigned int end_clu,
				   bool fill_zero)
{
	unsigned int clu, clu_count;
	unsigned char cc;
	unsigned int cc_clu_count, cc_len;
	off_t start_off, end_off_excl;
	char buf[1 + EI_CC_PAYLOAD_LEN];

	clu = start_clu;
	clu_count = end_clu - start_clu + 1;

	if (ei->save_cc) {
		/* if the count of clusters is less than 5, use SKIP_1 or COPY_2 */
		cc_clu_count = clu_count < 5 ? 1 : clu_count;
		cc_len = cc_clu_count == 1 ? 1 : 1 + EI_CC_PAYLOAD_LEN;
		if (fill_zero)
			cc = cc_clu_count == 1 ? EI_CC_SKIP_1 : EI_CC_SKIP_2;
		else
			cc = cc_clu_count == 1 ? EI_CC_COPY_1 : EI_CC_COPY_2;
	} else {
		cc = EI_CC_INVALID;
		cc_clu_count = clu_count;
	}

	while (clu <= end_clu) {
		if (cc != EI_CC_INVALID) {
			buf[0] = cc;
			*((__le32 *)&buf[1]) =
				cpu_to_le32(cc_clu_count);
			if (write(ei->out_fd, buf, cc_len) != (ssize_t)cc_len) {
				exfat_err("failed to write cc %d : %u\n for %u ~ %u clusters\n",
					  cc, cc_clu_count,
					  start_clu, start_clu + cc_clu_count - 1);
			}
		}

		if (cc == EI_CC_COPY_1 || cc == EI_CC_COPY_2) {
			start_off = exfat_c2o(ei->exfat, clu);
			end_off_excl = exfat_c2o(ei->exfat, clu + cc_clu_count);

			if (dump_bytes_to_stdout(ei, start_off, end_off_excl,
						 false) < 0)
				return -EIO;
		} else {
			ei->stdout_offset += (off_t)cc_clu_count * ei->exfat->clus_size;
		}
		clu += cc_clu_count;
	}

	return 0;
}
