process_retire_connection_id_frame (struct ietf_full_conn *conn,
        struct lsquic_packet_in *packet_in, const unsigned char *p, size_t len)
{
    struct lsquic_conn *const lconn = &conn->ifc_conn;
    struct conn_cid_elem *cce;
    uint64_t seqno;
    int parsed_len;

    /* [draft-ietf-quic-transport-25] Section 19.16
     *
     * - Peer cannot retire zero-lenth CID. (MUST treat as PROTOCOL_VIOLATION)
     * - Peer cannot retire CID with sequence number that has not been
     *   allocated yet. (MUST treat as PROTOCOL_VIOLATION)
     * - Peer cannot retire CID that matches the DCID in packet.
     *   (MAY treat as PROTOCOL_VIOLATION)
     */
    if (conn->ifc_settings->es_scid_len == 0)
    {
        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION, "cannot retire zero-length CID");
        return 0;
    }

    parsed_len = conn->ifc_conn.cn_pf->pf_parse_retire_cid_frame(p, len,
                                                                    &seqno);
    if (parsed_len < 0)
        return 0;

    EV_LOG_CONN_EVENT(LSQUIC_LOG_CONN_ID, "got RETIRE_CONNECTION_ID frame: "
                                                        "seqno=%"PRIu64, seqno);
    if (seqno >= conn->ifc_scid_seqno)
    {
        ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION, "cannot retire CID seqno="
                        "%"PRIu64" as it has not been allocated yet", seqno);
        return 0;
    }

    for (cce = lconn->cn_cces; cce < END_OF_CCES(lconn); ++cce)
        if ((lconn->cn_cces_mask & (1 << (cce - lconn->cn_cces))
                && (cce->cce_flags & CCE_SEQNO)
                && cce->cce_seqno == seqno))
            break;
    /* NOTE: https://github.com/litespeedtech/lsquic/issues/334
    conn->ifc_active_cids_count -= seqno >= conn->ifc_first_active_cid_seqno;
    */
    if (cce < END_OF_CCES(lconn))
    {
        if (LSQUIC_CIDS_EQ(&cce->cce_cid, &packet_in->pi_dcid))
        {
            ABORT_QUIETLY(0, TEC_PROTOCOL_VIOLATION, "cannot retire CID "
                "seqno=%"PRIu64", for it is used as DCID in the packet", seqno);
            return 0;
        }
        retire_cid(conn, cce, packet_in->pi_received);
        if (lconn->cn_cur_cce_idx == cce - lconn->cn_cces)
        {
            cce = find_cce_by_cid(conn, &packet_in->pi_dcid);
            if (cce)
            {
                cce->cce_flags |= CCE_USED;
                lconn->cn_cur_cce_idx = cce - lconn->cn_cces;
                LSQ_DEBUGC("current SCID was retired; set current SCID to "
                    "%"CID_FMT" based on DCID in incoming packet",
                    CID_BITS(&packet_in->pi_dcid));
            }
            else
                LSQ_WARN("current SCID was retired; no new SCID candidate");
                /* This could theoretically happen when zero-length CIDs were
                 * used.  Currently, there should be no way lsquic could get
                 * into this situation.
                 */
        }
    }
    else
        LSQ_DEBUG("cannot retire CID seqno=%"PRIu64": not found", seqno);
    LOG_SCIDS(conn);

    return parsed_len;
}
