authentic_docp_set_acls(struct sc_card *card, struct sc_file *file,
		unsigned char *ops, size_t ops_len,
		struct sc_authentic_sdo_docp *docp)
{
	struct sc_context *ctx = card->ctx;
	unsigned ii, offs;

	LOG_FUNC_CALLED(ctx);
	if (ops_len > sizeof(docp->acl_data) / 2)
		LOG_FUNC_RETURN(ctx, SC_ERROR_INVALID_ARGUMENTS);

	for (ii=0, offs=0; ii<ops_len; ii++)   {
		const struct sc_acl_entry *entry;

		entry = sc_file_get_acl_entry(file, *(ops + ii));
		if (entry->method == SC_AC_NEVER)   {
			docp->acl_data[offs++] = 0x00;
			docp->acl_data[offs++] = 0x00;
		}
		else if (entry->method == SC_AC_NONE)   {
			docp->acl_data[offs++] = 0x00;
			docp->acl_data[offs++] = 0x00;
		}
		else if (entry->method == SC_AC_CHV)   {
			if (!(entry->key_ref & AUTHENTIC_V3_CREDENTIAL_ID_MASK)
					|| (entry->key_ref & ~AUTHENTIC_V3_CREDENTIAL_ID_MASK))
				LOG_TEST_RET(ctx, SC_ERROR_NOT_SUPPORTED, "Non supported Credential Reference");

			docp->acl_data[offs++] = 0x00;
			docp->acl_data[offs++] = 0x01 << (entry->key_ref - 1);
		}
	}

	docp->acl_data_len = offs;
	LOG_FUNC_RETURN(ctx, offs);
}
