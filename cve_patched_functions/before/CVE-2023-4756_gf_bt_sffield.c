void gf_bt_sffield(GF_BTParser *parser, GF_FieldInfo *info, GF_Node *n)
{
	switch (info->fieldType) {
	case GF_SG_VRML_SFINT32:
		gf_bt_parse_int(parser, info->name, (SFInt32 *)info->far_ptr);
		if (parser->last_error) return;
		break;
	case GF_SG_VRML_SFBOOL:
		gf_bt_parse_bool(parser, info->name, (SFBool *)info->far_ptr);
		if (parser->last_error) return;
		break;
	case GF_SG_VRML_SFFLOAT:
		gf_bt_parse_float(parser, info->name, (SFFloat *)info->far_ptr);
		if (parser->last_error) return;
		break;
	case GF_SG_VRML_SFDOUBLE:
		gf_bt_parse_double(parser, info->name, (SFDouble *)info->far_ptr);
		if (parser->last_error) return;
		break;
	case GF_SG_VRML_SFTIME:
		gf_bt_parse_double(parser, info->name, (SFDouble *)info->far_ptr);
		if (parser->last_error) return;
		gf_bt_check_time_offset(parser, n, info);
		break;
	case GF_SG_VRML_SFCOLOR:
		gf_bt_parse_color(parser, info->name, (SFColor *)info->far_ptr);
		break;
	case GF_SG_VRML_SFCOLORRGBA:
		gf_bt_parse_colorRGBA(parser, info->name, (SFColorRGBA *)info->far_ptr);
		break;
	case GF_SG_VRML_SFVEC2F:
		gf_bt_parse_float(parser, info->name, & ((SFVec2f *)info->far_ptr)->x);
		if (parser->last_error) return;
		/*many VRML files use ',' separator*/
		gf_bt_check_code(parser, ',');
		gf_bt_parse_float(parser, info->name, & ((SFVec2f *)info->far_ptr)->y);
		if (parser->last_error) return;
		break;
	case GF_SG_VRML_SFVEC2D:
		gf_bt_parse_double(parser, info->name, & ((SFVec2d *)info->far_ptr)->x);
		if (parser->last_error) return;
		/*many VRML files use ',' separator*/
		gf_bt_check_code(parser, ',');
		gf_bt_parse_double(parser, info->name, & ((SFVec2d *)info->far_ptr)->y);
		if (parser->last_error) return;
		break;
	case GF_SG_VRML_SFVEC3F:
		gf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->x);
		if (parser->last_error) return;
		/*many VRML files use ',' separator*/
		gf_bt_check_code(parser, ',');
		gf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->y);
		if (parser->last_error) return;
		/*many VRML files use ',' separator*/
		gf_bt_check_code(parser, ',');
		gf_bt_parse_float(parser, info->name, & ((SFVec3f *)info->far_ptr)->z);
		if (parser->last_error) return;
		break;
	case GF_SG_VRML_SFVEC3D:
		gf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->x);
		if (parser->last_error) return;
		/*many VRML files use ',' separator*/
		gf_bt_check_code(parser, ',');
		gf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->y);
		if (parser->last_error) return;
		/*many VRML files use ',' separator*/
		gf_bt_check_code(parser, ',');
		gf_bt_parse_double(parser, info->name, & ((SFVec3d *)info->far_ptr)->z);
		if (parser->last_error) return;
		break;
	case GF_SG_VRML_SFVEC4F:
		gf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->x);
		if (parser->last_error) return;
		/*many VRML files use ',' separator*/
		gf_bt_check_code(parser, ',');
		gf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->y);
		if (parser->last_error) return;
		/*many VRML files use ',' separator*/
		gf_bt_check_code(parser, ',');
		gf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->z);
		if (parser->last_error) return;
		/*many VRML files use ',' separator*/
		gf_bt_check_code(parser, ',');
		gf_bt_parse_float(parser, info->name, & ((SFVec4f *)info->far_ptr)->q);
		if (parser->last_error) return;
		break;
	case GF_SG_VRML_SFROTATION:
		gf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->x);
		if (parser->last_error) return;
		gf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->y);
		if (parser->last_error) return;
		gf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->z);
		if (parser->last_error) return;
		gf_bt_parse_float(parser, info->name, & ((SFRotation *)info->far_ptr)->q);
		if (parser->last_error) return;
		break;
	case GF_SG_VRML_SFSTRING:
	{
		u8 delim = 0;
		if (gf_bt_check_code(parser, '\"')) delim = '\"';
		else if (gf_bt_check_code(parser, '\'')) delim = '\'';
		if (delim) {
			char *str = gf_bt_get_string(parser, delim);
			if (!str)
				goto err;
			if (((SFString *)info->far_ptr)->buffer) gf_free(((SFString *)info->far_ptr)->buffer);
			((SFString *)info->far_ptr)->buffer = NULL;
			if (strlen(str))
				((SFString *)info->far_ptr)->buffer = str;
			else
				gf_free(str);

			if (n && (n->sgprivate->tag==TAG_MPEG4_BitWrapper)) {
				gf_sm_update_bitwrapper_buffer(n, parser->load->fileName);
			}
		} else {
			goto err;
		}
	}
	break;
	case GF_SG_VRML_SFURL:
	{
		u8 delim = 0;
		if (gf_bt_check_code(parser, '\"')) delim = '\"';
		else if (gf_bt_check_code(parser, '\'')) delim = '\'';
		if (delim) {
			SFURL *url = (SFURL *)info->far_ptr;
			char *str = gf_bt_get_string(parser, delim);
			if (!str) goto err;
			if (url->url) gf_free(url->url);
			url->url = NULL;
			url->OD_ID = 0;
			if (strchr(str, '#')) {
				url->url = str;
			} else {
				u32 id = 0;
				char *odstr = str;
				if (!strnicmp(str, "od://", 5)) odstr += 5;
				else if (!strnicmp(str, "od:", 3)) odstr += 3;
				/*be careful, an url like "11-regression-test.mp4" will return 1 on sscanf :)*/
				if (sscanf(odstr, "%u", &id) == 1) {
					char szURL[20];
					sprintf(szURL, "%u", id);
					if (strcmp(szURL, odstr)) id=0;
				}
				if (id) {
					url->OD_ID = id;
					gf_free(str);
				} else {
					url->url = str;
				}
			}
		} else {
			s32 val;
			gf_bt_parse_int(parser, info->name, & val );
			if (parser->last_error) return;
			((SFURL *)info->far_ptr)->OD_ID = val;
		}
	}
	break;
	case GF_SG_VRML_SFCOMMANDBUFFER:
	{
		SFCommandBuffer *cb = (SFCommandBuffer *)info->far_ptr;
		if (gf_bt_check_code(parser, '{')) {
			GF_Command *prev_com = parser->cur_com;
			while (!parser->last_error) {
				if (gf_bt_check_code(parser, '}')) break;
				parser->last_error = gf_bt_parse_bifs_command(parser, NULL, cb->commandList);
			}
			parser->cur_com = prev_com;
		}
	}
	break;
	case GF_SG_VRML_SFIMAGE:
	{
		u32 i, size, v;
		SFImage *img = (SFImage *)info->far_ptr;
		gf_bt_parse_int(parser, "width", (SFInt32 *)&img->width);
		if (parser->last_error) return;
		gf_bt_parse_int(parser, "height", (SFInt32 *)&img->height);
		if (parser->last_error) return;
		gf_bt_parse_int(parser, "nbComp", (SFInt32 *)&v);
		if (parser->last_error) return;
		img->numComponents = v;
		size = img->width * img->height * img->numComponents;
		if (img->pixels) gf_free(img->pixels);
		img->pixels = (unsigned char*)gf_malloc(sizeof(char) * size);
		for (i=0; i<size; i++) {
			char *str = gf_bt_get_next(parser, 0);
			if (strstr(str, "0x")) sscanf(str, "%x", &v);
			else sscanf(str, "%u", &v);
			switch (img->numComponents) {
			case 1:
				img->pixels[i] = (char) v;
				break;
			case 2:
				img->pixels[i] = (char) (v>>8)&0xFF;
				img->pixels[i+1] = (char) (v)&0xFF;
				i++;
				break;
			case 3:
				img->pixels[i] = (char) (v>>16)&0xFF;
				img->pixels[i+1] = (char) (v>>8)&0xFF;
				img->pixels[i+2] = (char) (v)&0xFF;
				i+=2;
				break;
			case 4:
				img->pixels[i] = (char) (v>>24)&0xFF;
				img->pixels[i+1] = (char) (v>>16)&0xFF;
				img->pixels[i+2] = (char) (v>>8)&0xFF;
				img->pixels[i+3] = (char) (v)&0xFF;
				i+=3;
				break;
			}
		}
	}
	break;
	case GF_SG_VRML_SFSCRIPT:
	{
		SFScript *sc = (SFScript *) info->far_ptr;
		if (!gf_bt_check_code(parser, '\"')) {
			gf_bt_report(parser, GF_BAD_PARAM, "\" expected in Script");
		}
		sc->script_text = (char*)gf_bt_get_string(parser, '\"');
	}
	break;
	case GF_SG_VRML_SFATTRREF:
	{
		SFAttrRef *ar = (SFAttrRef*) info->far_ptr;
		char *str = gf_bt_get_next(parser, 1);
		if (!gf_bt_check_code(parser, '.')) {
			gf_bt_report(parser, GF_BAD_PARAM, "'.' expected in SFAttrRef");
		} else {
			GF_FieldInfo pinfo;
			ar->node = gf_bt_peek_node(parser, str);
			str = gf_bt_get_next(parser, 0);
			if (gf_node_get_field_by_name(ar->node, str, &pinfo) != GF_OK) {
				gf_bt_report(parser, GF_BAD_PARAM, "field %s is not a member of node %s", str, gf_node_get_class_name(ar->node) );
			} else {
				ar->fieldIndex = pinfo.fieldIndex;
			}
		}

	}
	break;
	default:
		parser->last_error = GF_NOT_SUPPORTED;
		break;

	}
	gf_bt_check_code(parser, ',');
	return;
err:
	gf_bt_report(parser, GF_BAD_PARAM, "%s: Invalid field syntax", info->name);
}
