typedArrayOf(void *, Runtime &runtime, NativeArgs args) {
  // 1. Let len be the actual number of arguments passed to this function.
  uint64_t len = args.getArgCount();
  // 2. Let items be the List of arguments passed to this function. (args is
  // items).
  // 3. Let C be the this value.
  CallResult<bool> isConstructorRes = isConstructor(runtime, args.getThisArg());
  if (LLVM_UNLIKELY(isConstructorRes == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  if (!*isConstructorRes) {
    // 4. If IsConstructor(C) is false, throw a TypeError exception.
    return runtime.raiseTypeError(
        "Cannot invoke %TypedArray%.of when %TypedArray% is not a constructor "
        "function");
  }
  auto C = Handle<Callable>::vmcast(args.getThisHandle());
  // 5. Let newObj be ? TypedArrayCreate(C, len).
  auto newObj = typedArrayCreate(runtime, C, len);
  if (newObj == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  // 6. Let k be 0.
  MutableHandle<> k(runtime, HermesValue::encodeNumberValue(0));
  GCScope scope(runtime);
  auto marker = scope.createMarker();
  // 7. Repeat, while k < len.
  for (; k->getNumberAs<uint64_t>() < len;
       k = HermesValue::encodeNumberValue(k->getNumberAs<uint64_t>() + 1)) {
    // a. Let kValue be items[k].
    auto kValue = args.getArg(k->getNumberAs<uint64_t>());
    // b. Let Pk be ! ToString(k).
    // c. Perform ? Set(newObj, Pk, kValue, true).
    if (JSObject::putComputed_RJS(
            *newObj, runtime, k, runtime.makeHandle(kValue)) ==
        ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
    // d. Increase k by 1. (In the loop increment).
    scope.flushToMarker(marker);
  }
  // Return newObj.
  return newObj->getHermesValue();
}
