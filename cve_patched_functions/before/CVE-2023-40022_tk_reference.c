	tk_reference,
	tk_integral,
	tk_bool,
	tk_char,
	tk_real
} type_kind_t;

#define STRING_EMPTY(str) ((str)->b == (str)->p)
#define PREPEND_BLANK(str) \
	{ \
		if (!STRING_EMPTY(str)) \
			string_prepend(str, " "); \
	}
#define APPEND_BLANK(str) \
	{ \
		if (!STRING_EMPTY(str)) \
			string_append(str, " "); \
	}
#define LEN_STRING(str) ((STRING_EMPTY(str)) ? 0 : ((str)->p - (str)->b))

/* The scope separator appropriate for the language being demangled.  */

#define SCOPE_STRING(work) ((work->options & DMGL_JAVA) ? "." : "::")

#define ARM_VTABLE_STRING "__vtbl__" /* Lucid/ARM virtual table prefix */
#define ARM_VTABLE_STRLEN 8 /* strlen (ARM_VTABLE_STRING) */

/* Prototypes for local functions */

static char *
	mop_up PARAMS((struct work_stuff *, string *, int));

static void
	squangle_mop_up PARAMS((struct work_stuff *));

#if 0
static int
demangle_method_args PARAMS ((struct work_stuff *, const char **, string *));
#endif

static char *
	internal_cplus_demangle PARAMS((struct work_stuff *, const char *));

static int
	demangle_template_template_parm PARAMS((struct work_stuff * work,
		const char **, string *));

static int
	demangle_template PARAMS((struct work_stuff * work, const char **, string *,
		string *, int, int));

static int
	arm_pt PARAMS((struct work_stuff *, const char *, int, const char **,
		const char **));

static int
	demangle_class_name PARAMS((struct work_stuff *, const char **, string *));

static int
	demangle_qualified PARAMS((struct work_stuff *, const char **, string *,
		int, int));

static int
	demangle_class PARAMS((struct work_stuff *, const char **, string *));

static int
	demangle_fund_type PARAMS((struct work_stuff *, const char **, string *));

static int
	demangle_signature PARAMS((struct work_stuff *, const char **, string *));

static int
	demangle_prefix PARAMS((struct work_stuff *, const char **, string *));

static int
	gnu_special PARAMS((struct work_stuff *, const char **, string *));

static int
	arm_special PARAMS((const char **, string *));

static void
	string_need PARAMS((string *, int));

static void
	string_delete PARAMS((string *));

static void
	string_init PARAMS((string *));

static void
	string_clear PARAMS((string *));

#if 0
static int
string_empty PARAMS ((string *));
#endif

static void
	string_append PARAMS((string *, const char *));

static void
	string_appends PARAMS((string *, string *));

static void
	string_appendn PARAMS((string *, const char *, int));

static void
	string_prepend PARAMS((string *, const char *));

static void
	string_prependn PARAMS((string *, const char *, int));

static int
	get_count PARAMS((const char **, int *));

static int
	consume_count PARAMS((const char **));

static int
	consume_count_with_underscores PARAMS((const char **));

static int
	demangle_args PARAMS((struct work_stuff *, const char **, string *));

static int
	demangle_nested_args PARAMS((struct work_stuff *, const char **, string *));

static int
	do_type PARAMS((struct work_stuff *, const char **, string *));

static int
	do_arg PARAMS((struct work_stuff *, const char **, string *));

static void
	demangle_function_name PARAMS((struct work_stuff *, const char **, string *,
		const char *));

static void
	remember_type PARAMS((struct work_stuff *, const char *, int));

static void
	remember_Btype PARAMS((struct work_stuff *, const char *, int, int));

static int
	register_Btype PARAMS((struct work_stuff *));

static void
	remember_Ktype PARAMS((struct work_stuff *, const char *, int));

static void
	forget_types PARAMS((struct work_stuff *));

static void
	forget_B_and_K_types PARAMS((struct work_stuff *));

static void
	string_prepends PARAMS((string *, string *));

static int
	demangle_template_value_parm PARAMS((struct work_stuff *, const char **,
		string *, type_kind_t));

static int
	do_hpacc_template_const_value PARAMS((struct work_stuff *, const char **, string *));

static int
	do_hpacc_template_literal PARAMS((struct work_stuff *, const char **, string *));

static int
	snarf_numeric_literal PARAMS((const char **, string *));

/* There is a TYPE_QUAL value for each type qualifier.  They can be
   combined by bitwise-or to form the complete set of qualifiers for a
   type.  */

#define TYPE_UNQUALIFIED   0x0
#define TYPE_QUAL_CONST    0x1
#define TYPE_QUAL_VOLATILE 0x2
#define TYPE_QUAL_RESTRICT 0x4

static int
	code_for_qualifier PARAMS((int));

static const char *
	qualifier_string PARAMS((int));

static const char *
	demangle_qualifier PARAMS((int));

/* Translate count to integer, consuming tokens in the process.
   Conversion terminates on the first non-digit character.

   Trying to consume something that isn't a count results in no
   consumption of input and a return of -1.

   Overflow consumes the rest of the digits, and returns -1.  */

static int
	consume_count(type)
		const char **type;
{
	int count = 0;

	if (!isdigit((unsigned char)**type))
		return -1;

	while (isdigit((unsigned char)**type)) {
		count *= 10;

		/* Check for overflow.
		   We assume that count is represented using two's-complement;
		   no power of two is divisible by ten, so if an overflow occurs
		   when multiplying by ten, the result will not be a multiple of
		   ten.  */
		if ((count % 10) != 0) {
			while (isdigit((unsigned char)**type))
				(*type)++;
			return -1;
		}

		count += **type - '0';
		(*type)++;
	}

	return (count);
}

/* Like consume_count, but for counts that are preceded and followed
   by '_' if they are greater than 10.  Also, -1 is returned for
   failure, since 0 can be a valid value.  */

static int
	consume_count_with_underscores(mangled)
		const char **mangled;
{
	int idx;

	if (**mangled == '_') {
		(*mangled)++;
		if (!isdigit((unsigned char)**mangled))
			return -1;

		idx = consume_count(mangled);
		if (**mangled != '_')
			/* The trailing underscore was missing. */
			return -1;

		(*mangled)++;
	} else {
		if (**mangled < '0' || **mangled > '9')
			return -1;

		idx = **mangled - '0';
		(*mangled)++;
	}

	return idx;
}

/* C is the code for a type-qualifier.  Return the TYPE_QUAL
   corresponding to this qualifier.  */

