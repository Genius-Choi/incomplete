void DCR_CLASS dcr_colorcheck(DCRAW* p)
{
#define NSQ 24
	// Coordinates of the GretagMacbeth ColorChecker squares
	// p->width, p->height, 1st_column, 1st_row
	static const int cut[NSQ][4] = {
		{ 241, 231, 234, 274 },
		{ 251, 235, 534, 274 },
		{ 255, 239, 838, 272 },
		{ 255, 240, 1146, 274 },
		{ 251, 237, 1452, 278 },
		{ 243, 238, 1758, 288 },
		{ 253, 253, 218, 558 },
		{ 255, 249, 524, 562 },
		{ 261, 253, 830, 562 },
		{ 260, 255, 1144, 564 },
		{ 261, 255, 1450, 566 },
		{ 247, 247, 1764, 576 },
		{ 255, 251, 212, 862 },
		{ 259, 259, 518, 862 },
		{ 263, 261, 826, 864 },
		{ 265, 263, 1138, 866 },
		{ 265, 257, 1450, 872 },
		{ 257, 255, 1762, 874 },
		{ 257, 253, 212, 1164 },
		{ 262, 251, 516, 1172 },
		{ 263, 257, 826, 1172 },
		{ 263, 255, 1136, 1176 },
		{ 255, 252, 1452, 1182 },
		{ 257, 253, 1760, 1180 } };
	// ColorChecker Chart under 6500-kelvin illumination
	static const double gmb_xyY[NSQ][3] = {
		{ 0.400, 0.350, 10.1 },		// Dark Skin
		{ 0.377, 0.345, 35.8 },		// Light Skin
		{ 0.247, 0.251, 19.3 },		// Blue Sky
		{ 0.337, 0.422, 13.3 },		// Foliage
		{ 0.265, 0.240, 24.3 },		// Blue Flower
		{ 0.261, 0.343, 43.1 },		// Bluish Green
		{ 0.506, 0.407, 30.1 },		// Orange
		{ 0.211, 0.175, 12.0 },		// Purplish Blue
		{ 0.453, 0.306, 19.8 },		// Moderate Red
		{ 0.285, 0.202, 6.6 },		// Purple
		{ 0.380, 0.489, 44.3 },		// Yellow Green
		{ 0.473, 0.438, 43.1 },		// Orange Yellow
		{ 0.187, 0.129, 6.1 },		// Blue
		{ 0.305, 0.478, 23.4 },		// Green
		{ 0.539, 0.313, 12.0 },		// Red
		{ 0.448, 0.470, 59.1 },		// Yellow
		{ 0.364, 0.233, 19.8 },		// Magenta
		{ 0.196, 0.252, 19.8 },		// Cyan
		{ 0.310, 0.316, 90.0 },		// White
		{ 0.310, 0.316, 59.1 },		// Neutral 8
		{ 0.310, 0.316, 36.2 },		// Neutral 6.5
		{ 0.310, 0.316, 19.8 },		// Neutral 5
		{ 0.310, 0.316, 9.0 },		// Neutral 3.5
		{ 0.310, 0.316, 3.1 } };		// Black
	double gmb_cam[NSQ][4], gmb_xyz[NSQ][3];
	double inverse[NSQ][3], cam_xyz[4][3], num;
	int c, i, j, k, sq, row, col, count[4];

	memset (gmb_cam, 0, sizeof gmb_cam);
	for (sq=0; sq < NSQ; sq++) {
		FORCC(p) count[c] = 0;
		for   (row=cut[sq][3]; row < cut[sq][3]+cut[sq][1]; row++)
			for (col=cut[sq][2]; col < cut[sq][2]+cut[sq][0]; col++) {
				c = FC(row,col);
				if (c >= p->colors) c -= 2;
				gmb_cam[sq][c] += BAYER(row,col);
				count[c]++;
			}
			FORCC(p) gmb_cam[sq][c] = gmb_cam[sq][c]/count[c] - p->black;
			gmb_xyz[sq][0] = gmb_xyY[sq][2] * gmb_xyY[sq][0] / gmb_xyY[sq][1];
			gmb_xyz[sq][1] = gmb_xyY[sq][2];
			gmb_xyz[sq][2] = gmb_xyY[sq][2] *
				(1 - gmb_xyY[sq][0] - gmb_xyY[sq][1]) / gmb_xyY[sq][1];
	}
	dcr_pseudoinverse (gmb_xyz, inverse, NSQ);
	for (i=0; i < p->colors; i++)
		for (j=0; j < 3; j++)
			for (cam_xyz[i][j] = k=0; k < NSQ; k++)
				cam_xyz[i][j] += gmb_cam[k][i] * inverse[k][j];
	dcr_cam_xyz_coeff (p, cam_xyz);
	if (p->opt.verbose) {
		printf ("    { \"%s %s\", %d,\n\t{", p->make, p->model, p->black);
		num = 10000 / (cam_xyz[1][0] + cam_xyz[1][1] + cam_xyz[1][2]);
		FORCC(p) for (j=0; j < 3; j++)
			printf ("%c%d", (c | j) ? ',':' ', (int) (cam_xyz[c][j] * num + 0.5));
		puts (" } },");
	}
#undef NSQ
}
