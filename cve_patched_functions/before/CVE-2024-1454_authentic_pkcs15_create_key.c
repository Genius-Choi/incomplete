authentic_pkcs15_create_key(struct sc_profile *profile, struct sc_pkcs15_card *p15card,
					struct sc_pkcs15_object *object)
{
	struct sc_card *card = p15card->card;
	struct sc_context *ctx = card->ctx;
	struct sc_authentic_sdo *sdo = NULL;
	struct sc_pkcs15_prkey_info *key_info = (struct sc_pkcs15_prkey_info *) object->data;
	struct sc_file	*file_p_prvkey = NULL, *parent = NULL;
	size_t keybits = key_info->modulus_length;
	int	 rv;

	LOG_FUNC_CALLED(ctx);
	sc_log(ctx,
	       "create private key(keybits:%"SC_FORMAT_LEN_SIZE_T"u,usage:%X,access:%X,ref:%X)",
	       keybits, key_info->usage, key_info->access_flags,
	       key_info->key_reference);
	if (keybits < 1024 || keybits > 2048 || (keybits % 256))
		LOG_TEST_RET(ctx, SC_ERROR_INVALID_ARGUMENTS, "Invalid RSA key size");

	rv = authentic_pkcs15_new_file(profile, card, SC_PKCS15_TYPE_PRKEY_RSA, key_info->key_reference, &file_p_prvkey);
	LOG_TEST_RET(ctx, rv, "IasEcc pkcs15 new PRKEY_RSA file error");

	key_info->key_reference |= AUTHENTIC_OBJECT_REF_FLAG_LOCAL;

	rv = sc_select_file(card, &file_p_prvkey->path, &parent);
	if (rv != SC_SUCCESS)
		sc_file_free(file_p_prvkey);
	LOG_TEST_RET(ctx, rv, "DF for the private objects not defined");

	rv = sc_pkcs15init_authenticate(profile, p15card, parent, SC_AC_OP_CRYPTO);
	sc_file_free(parent);
	if (rv != SC_SUCCESS)
		sc_file_free(file_p_prvkey);
	LOG_TEST_RET(ctx, rv, "SC_AC_OP_CRYPTO authentication failed for parent DF");

	key_info->access_flags = SC_PKCS15_PRKEY_ACCESS_NEVEREXTRACTABLE
		| SC_PKCS15_PRKEY_ACCESS_ALWAYSSENSITIVE
		| SC_PKCS15_PRKEY_ACCESS_SENSITIVE;

	rv = authentic_sdo_allocate_prvkey(profile, card, key_info, &sdo);
	if (rv != SC_SUCCESS || sdo == NULL) {
		sc_log(ctx, "IasEcc: init SDO private key failed");
		sc_file_free(file_p_prvkey);
		LOG_FUNC_RETURN(ctx, rv);
	}

	rv = sc_card_ctl(card, SC_CARDCTL_AUTHENTIC_SDO_CREATE, sdo);
	if (rv == SC_ERROR_FILE_ALREADY_EXISTS)   {
		unsigned long caps = p15card->card->caps;

		p15card->card->caps &= ~SC_CARD_CAP_USE_FCI_AC;
		rv = sc_pkcs15init_authenticate(profile, p15card, file_p_prvkey, SC_AC_OP_DELETE);
		p15card->card->caps = caps;
		LOG_TEST_GOTO_ERR(ctx, rv, "SC_AC_OP_CRYPTO authentication failed for parent DF");

		rv = sc_card_ctl(card, SC_CARDCTL_AUTHENTIC_SDO_DELETE, sdo);
		LOG_TEST_GOTO_ERR(ctx, rv, "SC_CARDCTL_AUTHENTIC_SDO_DELETE failed for private key");

		rv = sc_card_ctl(card, SC_CARDCTL_AUTHENTIC_SDO_CREATE, sdo);
	}
	LOG_TEST_GOTO_ERR(ctx, rv, "SC_CARDCTL_AUTHENTIC_SDO_CREATE failed");

	rv = authentic_pkcs15_fix_access(p15card, file_p_prvkey, object);
	LOG_TEST_GOTO_ERR(ctx, rv, "cannot fix access rules for private key");

	rv = authentic_pkcs15_fix_usage(p15card, object);
	LOG_TEST_GOTO_ERR(ctx, rv, "cannot fix access rules for private key");

	/* Here fix the key's supported algorithms, if these ones will be implemented
	 * (see src/libopensc/pkcs15-prkey.c).
	 */

	sdo->file = file_p_prvkey;
	sc_log(ctx, "sdo->file:%p", sdo->file);

	rv = sc_pkcs15_allocate_object_content(ctx, object, (unsigned char *)sdo, sizeof(struct sc_authentic_sdo));
	LOG_TEST_GOTO_ERR(ctx, rv, "Failed to allocate PrvKey SDO as object content");

err:
	if (sdo == NULL || sdo->file != file_p_prvkey)
		sc_file_free(file_p_prvkey);
	authentic_free_sdo_data(sdo);
	free(sdo);
	LOG_FUNC_RETURN(ctx, rv);
}
