x509_verify_asn1_time_to_time_t(const ASN1_TIME *atime, int notAfter)
{
	struct tm tm = { 0 };
	int type;

	type = ASN1_time_parse(atime->data, atime->length, &tm, atime->type);
	if (type == -1)
		return -1;

	/* RFC 5280 section 4.1.2.5 */
	if (tm.tm_year < 150 && type != V_ASN1_UTCTIME)
		return -1;
	if (tm.tm_year >= 150 && type != V_ASN1_GENERALIZEDTIME)
		return -1;

	if (notAfter) {
		/*
		 * If we are a completely broken operating system with a
		 * 32 bit time_t, and we have been told this is a notAfter
		 * date, limit the date to a 32 bit representable value.
		 */
		if (!ASN1_time_tm_clamp_notafter(&tm))
			return -1;
	}

	/*
	 * Defensively fail if the time string is not representable as
	 * a time_t. A time_t must be sane if you care about times after
	 * Jan 19 2038.
	 */
	return timegm(&tm);
}
