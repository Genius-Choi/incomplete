SWITCH_DECLARE(switch_status_t) switch_rtp_add_dtls(switch_rtp_t *rtp_session, dtls_fingerprint_t *local_fp, dtls_fingerprint_t *remote_fp, dtls_type_t type, uint8_t want_DTLSv1_2)
{
	switch_dtls_t *dtls;
	const char *var;
	int ret;
	const char *kind = "";
	unsigned long ssl_method_error = 0;
	unsigned long ssl_ctx_error = 0;
	const SSL_METHOD *ssl_method;
	SSL_CTX *ssl_ctx;
#if OPENSSL_VERSION_NUMBER < 0x30000000
	BIO *bio;
	DH *dh;
#endif
	switch_status_t status = SWITCH_STATUS_SUCCESS;
#ifndef OPENSSL_NO_EC
#if OPENSSL_VERSION_NUMBER < 0x10002000L
	EC_KEY* ecdh;
#endif
#endif

#ifndef HAVE_OPENSSL_DTLS_SRTP
	return SWITCH_STATUS_FALSE;
#endif

	if (!switch_rtp_ready(rtp_session)) {
		return SWITCH_STATUS_FALSE;
	}

	switch_mutex_lock(rtp_session->ice_mutex);

	if (!((type & DTLS_TYPE_RTP) || (type & DTLS_TYPE_RTCP)) || !((type & DTLS_TYPE_CLIENT) || (type & DTLS_TYPE_SERVER))) {
		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT, "INVALID TYPE!\n");
	}

	switch_rtp_del_dtls(rtp_session, type);

	if ((type & DTLS_TYPE_RTP) && (type & DTLS_TYPE_RTCP)) {
		kind = "RTP/RTCP";
	} else if ((type & DTLS_TYPE_RTP)) {
		kind = "RTP";
	} else {
		kind = "RTCP";
	}

	switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO,
					  "Activate %s %s DTLS %s\n", kind, rtp_type(rtp_session), (type & DTLS_TYPE_SERVER) ? "server" : "client");

	if (((type & DTLS_TYPE_RTP) && rtp_session->dtls) || ((type & DTLS_TYPE_RTCP) && rtp_session->rtcp_dtls)) {
		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, "DTLS ALREADY INIT\n");
		switch_goto_status(SWITCH_STATUS_FALSE, done);
	}

	dtls = switch_core_alloc(rtp_session->pool, sizeof(*dtls));

	dtls->pem = switch_core_sprintf(rtp_session->pool, "%s%s%s.pem", SWITCH_GLOBAL_dirs.certs_dir, SWITCH_PATH_SEPARATOR, DTLS_SRTP_FNAME);

	if (switch_file_exists(dtls->pem, rtp_session->pool) == SWITCH_STATUS_SUCCESS) {
		dtls->pvt = dtls->rsa = dtls->pem;
	} else {
		dtls->pvt = switch_core_sprintf(rtp_session->pool, "%s%s%s.key", SWITCH_GLOBAL_dirs.certs_dir, SWITCH_PATH_SEPARATOR, DTLS_SRTP_FNAME);
		dtls->rsa = switch_core_sprintf(rtp_session->pool, "%s%s%s.crt", SWITCH_GLOBAL_dirs.certs_dir, SWITCH_PATH_SEPARATOR, DTLS_SRTP_FNAME);
	}

	dtls->ca = switch_core_sprintf(rtp_session->pool, "%s%sca-bundle.crt", SWITCH_GLOBAL_dirs.certs_dir, SWITCH_PATH_SEPARATOR);

#if OPENSSL_VERSION_NUMBER >= 0x10100000
	ssl_method = (type & DTLS_TYPE_SERVER) ? DTLS_server_method() : DTLS_client_method();
#else
    #ifdef HAVE_OPENSSL_DTLSv1_2_method
		ssl_method = (type & DTLS_TYPE_SERVER) ? (want_DTLSv1_2 ? DTLSv1_2_server_method() : DTLSv1_server_method()) : (want_DTLSv1_2 ? DTLSv1_2_client_method() : DTLSv1_client_method());
	#else
		ssl_method = (type & DTLS_TYPE_SERVER) ? DTLSv1_server_method() : DTLSv1_client_method();
    #endif // HAVE_OPENSSL_DTLSv1_2_method
#endif

	if (!ssl_method) {
		ssl_method_error = ERR_peek_error();
		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "%s ssl_method is NULL [%lu]\n", rtp_type(rtp_session), ssl_method_error);
	}

	dtls->ssl_ctx = ssl_ctx = SSL_CTX_new(ssl_method);

	if (!ssl_ctx) {
		ssl_ctx_error = ERR_peek_error();
		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "%s SSL_CTX_new failed [%lu]\n", rtp_type(rtp_session), ssl_ctx_error);
		switch_channel_hangup(switch_core_session_get_channel(rtp_session->session), SWITCH_CAUSE_NORMAL_TEMPORARY_FAILURE);
		switch_goto_status(SWITCH_STATUS_FALSE, done);
	}

	switch_assert(dtls->ssl_ctx);

#if OPENSSL_VERSION_NUMBER < 0x30000000
	bio = BIO_new_file(dtls->pem, "r");
	dh = PEM_read_bio_DHparams(bio, NULL, NULL, NULL);
	BIO_free(bio);
	if (dh) {
		SSL_CTX_set_tmp_dh(dtls->ssl_ctx, dh);
		DH_free(dh);
	}
#else
	if(!SSL_CTX_set_dh_auto(dtls->ssl_ctx, 1)) {
		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "Failed enable auto DH!\n");
	}
#endif
	SSL_CTX_set_mode(dtls->ssl_ctx, SSL_MODE_AUTO_RETRY);

	//SSL_CTX_set_verify(dtls->ssl_ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, NULL);
	SSL_CTX_set_verify(dtls->ssl_ctx, SSL_VERIFY_NONE, NULL);

	//SSL_CTX_set_cipher_list(dtls->ssl_ctx, "ECDH:!RC4:!SSLv3:RSA_WITH_AES_128_CBC_SHA");
	//SSL_CTX_set_cipher_list(dtls->ssl_ctx, "ECDHE-RSA-AES256-GCM-SHA384");
	SSL_CTX_set_cipher_list(dtls->ssl_ctx, "ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH");
	//SSL_CTX_set_cipher_list(dtls->ssl_ctx, "SUITEB128");
	SSL_CTX_set_read_ahead(dtls->ssl_ctx, 1);
#ifdef HAVE_OPENSSL_DTLS_SRTP
	//SSL_CTX_set_tlsext_use_srtp(dtls->ssl_ctx, "SRTP_AES128_CM_SHA1_80:SRTP_AES128_CM_SHA1_32");
	SSL_CTX_set_tlsext_use_srtp(dtls->ssl_ctx, "SRTP_AES128_CM_SHA1_80");
#endif

	dtls->type = type;
	dtls->read_bio = BIO_new(BIO_s_mem());
	switch_assert(dtls->read_bio);

	dtls->write_bio = BIO_new(BIO_s_mem());
	switch_assert(dtls->write_bio);

	BIO_set_mem_eof_return(dtls->read_bio, -1);
	BIO_set_mem_eof_return(dtls->write_bio, -1);

	if ((ret=SSL_CTX_use_certificate_file(dtls->ssl_ctx, dtls->rsa, SSL_FILETYPE_PEM)) != 1) {
		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "%s DTLS cert err [%d]\n", rtp_type(rtp_session), SSL_get_error(dtls->ssl, ret));
		switch_goto_status(SWITCH_STATUS_FALSE, done);
	}

	if ((ret=SSL_CTX_use_PrivateKey_file(dtls->ssl_ctx, dtls->pvt, SSL_FILETYPE_PEM)) != 1) {
		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "%s DTLS key err [%d]\n", rtp_type(rtp_session), SSL_get_error(dtls->ssl, ret));
		switch_goto_status(SWITCH_STATUS_FALSE, done);
	}

	if (SSL_CTX_check_private_key(dtls->ssl_ctx) == 0) {
		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "%s DTLS check key failed\n", rtp_type(rtp_session));
		switch_goto_status(SWITCH_STATUS_FALSE, done);
	}

	if (!zstr(dtls->ca) && switch_file_exists(dtls->ca, rtp_session->pool) == SWITCH_STATUS_SUCCESS
		&& (ret = SSL_CTX_load_verify_locations(dtls->ssl_ctx, dtls->ca, NULL)) != 1) {
		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "%s DTLS check chain cert failed [%d]\n",
						  rtp_type(rtp_session) ,
						  SSL_get_error(dtls->ssl, ret));
		switch_goto_status(SWITCH_STATUS_FALSE, done);
	}

	dtls->ssl = SSL_new(dtls->ssl_ctx);

#if OPENSSL_VERSION_NUMBER < 0x10100000L
	dtls->filter_bio = BIO_new(BIO_dtls_filter());
#else
	switch_assert(dtls_bio_filter_methods);
	dtls->filter_bio = BIO_new(dtls_bio_filter_methods);
#endif

	switch_assert(dtls->filter_bio);

	BIO_push(dtls->filter_bio, dtls->write_bio);

	SSL_set_bio(dtls->ssl, dtls->read_bio, dtls->filter_bio);

	SSL_set_mode(dtls->ssl, SSL_MODE_AUTO_RETRY);
	SSL_set_read_ahead(dtls->ssl, 1);


	//SSL_set_verify(dtls->ssl, (SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT), cb_verify_peer);

#ifndef OPENSSL_NO_EC
#if OPENSSL_VERSION_NUMBER < 0x10002000L
	ecdh = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);
	if (!ecdh) {
		switch_goto_status(SWITCH_STATUS_FALSE, done);
	}
	SSL_set_options(dtls->ssl, SSL_OP_SINGLE_ECDH_USE);
	SSL_set_tmp_ecdh(dtls->ssl, ecdh);
	EC_KEY_free(ecdh);
#elif OPENSSL_VERSION_NUMBER < 0x10100000L
	SSL_set_ecdh_auto(dtls->ssl, 1);
	SSL_set_options(dtls->ssl, SSL_OP_SINGLE_ECDH_USE);
#endif
#endif

	SSL_set_verify(dtls->ssl, SSL_VERIFY_NONE, NULL);
	SSL_set_app_data(dtls->ssl, dtls);

	dtls->local_fp = local_fp;
	dtls->remote_fp = remote_fp;
	dtls->rtp_session = rtp_session;
	dtls->mtu = 1200;

	if (rtp_session->session) {
		switch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);
		if ((var = switch_channel_get_variable(channel, "rtp_dtls_mtu"))) {
			int mtu = atoi(var);

			if (mtu > 0 && mtu < MAX_DTLS_MTU) {
				dtls->mtu = mtu;
			}

		}
	}
	
	BIO_ctrl(dtls->filter_bio, BIO_CTRL_DGRAM_SET_MTU, dtls->mtu, NULL);
	
	switch_core_cert_expand_fingerprint(remote_fp, remote_fp->str);

	if ((type & DTLS_TYPE_RTP)) {
		rtp_session->dtls = dtls;
		dtls->sock_output = rtp_session->sock_output;
		dtls->remote_addr = rtp_session->remote_addr;
	}

	if ((type & DTLS_TYPE_RTCP)) {
		rtp_session->rtcp_dtls = dtls;
		if (!(type & DTLS_TYPE_RTP)) {
			dtls->sock_output = rtp_session->rtcp_sock_output;
			dtls->remote_addr = rtp_session->rtcp_remote_addr;
		}
	}

	if ((type & DTLS_TYPE_SERVER)) {
		SSL_set_accept_state(dtls->ssl);
	} else {
		SSL_set_connect_state(dtls->ssl);
	}

	dtls_set_state(dtls, DS_HANDSHAKE);

	rtp_session->flags[SWITCH_RTP_FLAG_VIDEO_BREAK] = 1;
	switch_rtp_break(rtp_session);

 done:

	switch_mutex_unlock(rtp_session->ice_mutex);

	return status;

}
