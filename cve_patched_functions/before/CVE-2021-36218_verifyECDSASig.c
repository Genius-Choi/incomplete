bool verifyECDSASig(string& pubKeyStr, const char *hashHex, const char *signatureR,
        const char *signatureS, int base) {

    CHECK_STATE(hashHex)
    CHECK_STATE(signatureR)
    CHECK_STATE(signatureS)

    auto x = pubKeyStr.substr(0, 64);
    auto y = pubKeyStr.substr(64, 128);

    mpz_t msgMpz;
    mpz_init(msgMpz);
    if (mpz_set_str(msgMpz, hashHex, 16) == -1) {
        spdlog::error("invalid message hash {}", hashHex);
        mpz_clear(msgMpz);
        return false;
    }

    signature sig = signature_init();
    if (signature_set_str(sig, signatureR, signatureS, base) != 0) {
        spdlog::error("Failed to set str signature");
        mpz_clear(msgMpz);
        signature_free(sig);
        return false;
    }

    domain_parameters curve = domain_parameters_init();
    domain_parameters_load_curve(curve, secp256k1);

    point publicKey = point_init();

    point_set_hex(publicKey, x.c_str(), y.c_str());
    if (!signature_verify(msgMpz, sig, publicKey, curve)) {
        spdlog::error("ECDSA sig not verified");
        mpz_clear(msgMpz);
        signature_free(sig);
        domain_parameters_clear(curve);
        point_clear(publicKey);
        return false;
    }

    mpz_clear(msgMpz);
    signature_free(sig);
    domain_parameters_clear(curve);
    point_clear(publicKey);

    return true;
}
