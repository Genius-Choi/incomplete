static int fb_compact_serialize_variant(
    StringBuffer& sb, const Variant& var, int depth) {
  if (depth > 256) {
    return 1;
  }

  switch (var.getType()) {
    case KindOfUninit:
    case KindOfNull:
      fb_compact_serialize_code(sb, FB_CS_NULL);
      return 0;

    case KindOfBoolean:
      if (var.toInt64()) {
        fb_compact_serialize_code(sb, FB_CS_TRUE);
      } else {
        fb_compact_serialize_code(sb, FB_CS_FALSE);
      }
      return 0;

    case KindOfInt64:
      fb_compact_serialize_int64(sb, var.toInt64());
      return 0;

    case KindOfDouble: {
      fb_compact_serialize_code(sb, FB_CS_DOUBLE);
      double d = var.toDouble();
      sb.append(reinterpret_cast<char*>(&d), 8);
      return 0;
    }

    case KindOfPersistentString:
    case KindOfString:
    case KindOfFunc:
    case KindOfClass:
      fb_compact_serialize_string(sb, var.toString());
      return 0;

    case KindOfPersistentVec:
    case KindOfVec: {
      Array arr = var.toArray();
      assertx(arr->isVecType());
      if (UNLIKELY(RuntimeOption::EvalLogArrayProvenance)) {
        raise_array_serialization_notice(SerializationSite::FBCompactSerialize,
                                         arr.get());
      }
      fb_compact_serialize_vec(sb, std::move(arr), depth);
      return 0;
    }

    case KindOfPersistentDict:
    case KindOfDict: {
      Array arr = var.toArray();
      assertx(arr->isDictType());
      if (UNLIKELY(RuntimeOption::EvalLogArrayProvenance)) {
        raise_array_serialization_notice(SerializationSite::FBCompactSerialize,
                                         arr.get());
      }
      fb_compact_serialize_array_as_map(sb, std::move(arr), depth);
      return 0;
    }

    case KindOfPersistentKeyset:
    case KindOfKeyset: {
      Array arr = var.toArray();
      assertx(arr->isKeysetType());
      fb_compact_serialize_keyset(sb, std::move(arr));
      return 0;
    }

    case KindOfPersistentDArray:
    case KindOfDArray:
    case KindOfPersistentVArray:
    case KindOfVArray:
    case KindOfPersistentArray:
    case KindOfArray: {
      Array arr = var.toArray();
      assertx(arr->isPHPArrayType());
      int64_t index_limit;
      if (UNLIKELY(RuntimeOption::EvalLogArrayProvenance) &&
          arrprov::arrayWantsTag(arr.get())) {
        raise_array_serialization_notice(
          SerializationSite::FBCompactSerialize,
          arr.get()
        );
      }
      if (fb_compact_serialize_is_list(arr, index_limit)) {
        fb_compact_serialize_array_as_list_map(
          sb, std::move(arr), index_limit, depth);
      } else {
        fb_compact_serialize_array_as_map(sb, std::move(arr), depth);
      }
      return 0;
    }

    case KindOfClsMeth: {
      Array arr = var.toArray();
      if (RuntimeOption::EvalHackArrDVArrs) {
        assertx(arr->isVecType());
        fb_compact_serialize_vec(sb, std::move(arr), depth);
      } else {
        assertx(arr->isPHPArrayType());
        int64_t index_limit;
        fb_compact_serialize_is_list(arr, index_limit);
        fb_compact_serialize_array_as_list_map(
          sb, std::move(arr), index_limit, depth);
      }
      return 0;
    }

    case KindOfObject:
    case KindOfResource:
    case KindOfRecord: // TODO(T41025646)
      fb_compact_serialize_code(sb, FB_CS_NULL);
      raise_warning(
        "fb_compact_serialize(): unable to serialize "
        "object/resource/ref/func/class/record"
      );
      break;
    case KindOfRFunc:
      SystemLib::throwInvalidOperationExceptionObject(
        "Unable to serialize reified function pointer"
      );
      break;
  }

  return 1;
}
