wait_for_sync_resolv(gboolean *completed) {
    int nfds;
    fd_set rfds, wfds;
    struct timeval tv;

    while (!*completed) {
        /*
         * Not yet resolved; wait for something to show up on the
         * address-to-name C-ARES channel.
         *
         * To quote the source code for ares_timeout() as of C-ARES
         * 1.12.0, "WARNING: Beware that this is linear in the number
         * of outstanding requests! You are probably far better off
         * just calling ares_process() once per second, rather than
         * calling ares_timeout() to figure out when to next call
         * ares_process().", although we should have only one request
         * outstanding.
         *
         * And, yes, we have to reset it each time, as select(), in
         * some OSes modifies the timeout to reflect the time remaining
         * (e.g., Linux) and select() in other OSes doesn't (most if not
         * all other UN*Xes, Windows?), so we can't rely on *either*
         * behavior.
         */
        tv.tv_sec = 1;
        tv.tv_usec = 0;

        FD_ZERO(&rfds);
        FD_ZERO(&wfds);
        nfds = ares_fds(ghba_chan, &rfds, &wfds);
        if (nfds > 0) {
            if (select(nfds, &rfds, &wfds, NULL, &tv) == -1) { /* call to select() failed */
                /* If it's interrupted by a signal, no need to put out a message */
                if (errno != EINTR)
                    fprintf(stderr, "Warning: call to select() failed, error is %s\n", g_strerror(errno));
                return;
            }
            ares_process(ghba_chan, &rfds, &wfds);
        }
    }
}
