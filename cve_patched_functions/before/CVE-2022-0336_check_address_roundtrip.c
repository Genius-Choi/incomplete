static int check_address_roundtrip(const char *address, int family,
				   const uint8_t *address_bytes,
				   char *buffer, int buffer_len)
{
	/*
	 * Check that the address is in the canonical RFC5952 format for IPv6,
	 * and lacks extra leading zeros for each dotted decimal for IPv4.
	 * Handily this is what inet_ntop() gives you.
	 */
	const char *address_redux = inet_ntop(family, address_bytes,
					      buffer, buffer_len);
	if (address_redux == NULL){
		DBG_INFO("Address round trip %s failed unexpectedly"
			 " with errno %d\n", address, errno);
		return -1;
	}
	if (strcasecmp(address, address_redux) != 0){
		DBG_INFO("Address %s round trips to %s; fail!\n",
			 address, address_redux);
		/* If the address family is IPv6, and the address is in a
		   certain range

		 */
		if (strchr(address_redux, '.') != NULL){
			DEBUG(0, ("The IPv6 address '%s' has the misfortune of "
				  "lying in a range that was once used for "
				  "IPv4 embedding (that is, it might also be "
				  "represented as '%s').\n", address,
				  address_redux));
		}
		return -1;
	}
	return 0;
}
