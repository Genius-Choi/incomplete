get_copy_of_entry(Slapi_PBlock *pb, const entry_address *addr, back_txn *txn, int plock_parameter, int must_exist) /* JCM - Move somewhere more appropriate */
{
	int	err= 0;
	int rc= LDAP_SUCCESS;
	backend *be;
	struct backentry *entry;

	slapi_pblock_get( pb, SLAPI_BACKEND, &be);

	if( addr->uniqueid!=NULL)
	{
		entry = uniqueid2entry(be, addr->uniqueid, txn, &err );
	}
	else
	{
		if (addr->sdn) {
			entry = dn2entry( be, addr->sdn, txn, &err );
		} else {
			err = 1;
		}
	}
	if ( 0 != err && DB_NOTFOUND != err )
	{
		if(must_exist)
		{
			LDAPDebug( LDAP_DEBUG_ANY,
			           "Operation error fetching %s (%s), error %d.\n", 
			           addr->sdn?slapi_sdn_get_dn(addr->sdn):"Null DN",
			           (addr->uniqueid==NULL?"null":addr->uniqueid), err );
		}
		if ( LDAP_INVALID_DN_SYNTAX == err ) {
			rc = LDAP_INVALID_DN_SYNTAX; /* respect the error */
		} else {
			rc= LDAP_OPERATIONS_ERROR;
		}
	}
	else
	{
		/* If an entry is found, copy it into the PBlock. */
		if(entry!=NULL)
		{
			ldbm_instance *inst;
			slapi_pblock_set( pb, plock_parameter, slapi_entry_dup(entry->ep_entry) );
			inst = (ldbm_instance *) be->be_instance_info;
			CACHE_RETURN( &inst->inst_cache, &entry );
		}
	}
	return rc;
}
