static int on_config_ech(h2o_configurator_command_t *cmd, yoml_t *configs, ptls_ech_create_opener_t **_opener,
                         ptls_iovec_t *retry_configs)
{
    struct ech_create_opener_t *opener =
        h2o_mem_alloc(sizeof(opener) + sizeof(opener->configs[0]) * (configs->data.sequence.size + 1));
    *opener = (struct ech_create_opener_t){{ech_create_opener}};
    *_opener = &opener->super;

    /* By default, retry_configs is not set, indicating that ECH support is not to be advertised. Note that while in the midst of
     * turning off ECH, we might continue accepting ECH handshakes but not advertise retry_configs. */
    *retry_configs = ptls_iovec_init(NULL, 0);

    /* parse configs being provided */
    for (size_t config_index = 0; config_index < configs->data.sequence.size; ++config_index) {
        yoml_t *element = configs->data.sequence.elements[config_index];
        if (element->type != YOML_TYPE_MAPPING) {
            h2o_configurator_errprintf(cmd, element, "elements of ech must be a mapping");
            return -1;
        }
        if (on_config_one_ech(cmd, element, opener->configs + config_index) != 0)
            return -1;

        /* append to retry_config */
        if (opener->configs[config_index].advertise) {
            if (retry_configs->base == NULL)
                *retry_configs = ptls_iovec_init(h2o_mem_alloc(2), 2);
            retry_configs->base =
                h2o_mem_realloc(retry_configs->base, retry_configs->len + opener->configs[config_index].ech_config.len);
            memcpy(retry_configs->base + retry_configs->len, opener->configs[config_index].ech_config.base,
                   opener->configs[config_index].ech_config.len);
            retry_configs->len += opener->configs[config_index].ech_config.len;
        }
    }

    /* terminate the list of configs */
    opener->configs[configs->data.sequence.size] = (struct ech_opener_config_t){NULL};

    /* write the length of retry_configs */
    if (retry_configs->base != NULL) {
        uint16_t len = retry_configs->len - 2;
        retry_configs->base[0] = (uint8_t)(len >> 8);
        retry_configs->base[1] = (uint8_t)len;
    }

    return 0;
}
