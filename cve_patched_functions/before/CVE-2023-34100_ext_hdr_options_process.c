ext_hdr_options_process(uint8_t *ext_buf)
{
  /*
   * Length field in the extension header: length of the header in units of
   * 8 bytes, excluding the first 8 bytes
   * length field in an option : the length of data in the option
   */
  uint16_t opt_offset = 2; /* 2 first bytes in ext header */
  struct uip_hbho_hdr *ext_hdr = (struct uip_hbho_hdr *)ext_buf;
  uint16_t ext_hdr_len = (ext_hdr->len << 3) + 8;

  while(opt_offset + 2 <= ext_hdr_len) { /* + 2 for opt header */
    struct uip_ext_hdr_opt *opt_hdr = (struct uip_ext_hdr_opt *)(ext_buf + opt_offset);
    uint16_t opt_len = opt_hdr->len + 2;

    if(opt_offset + opt_len > ext_hdr_len) {
      LOG_ERR("Extension header option too long: dropping packet\n");
      uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_OPTION,
          (ext_buf + opt_offset) - uip_buf);
      return 2;
    }

    switch(opt_hdr->type) {
    /*
     * for now we do not support any options except padding ones
     * PAD1 does not make sense as the header must be 8bytes aligned,
     * hence we can only have
     */
    case UIP_EXT_HDR_OPT_PAD1:
      LOG_DBG("Processing PAD1 option\n");
      opt_offset += 1;
      break;
    case UIP_EXT_HDR_OPT_PADN:
      LOG_DBG("Processing PADN option\n");
      opt_offset += opt_len;
      break;
    case UIP_EXT_HDR_OPT_RPL:
      /* Fixes situation when a node that is not using RPL
       * joins a network which does. The received packages will include the
       * RPL header and processed by the "default" case of the switch
       * (0x63 & 0xC0 = 0x40). Hence, the packet is discarded as the header
       * is considered invalid.
       * Using this fix, the header is ignored, and the next header (if
       * present) is processed.
       */
      LOG_DBG("Processing RPL option\n");
      if(!NETSTACK_ROUTING.ext_header_hbh_update(ext_buf, opt_offset)) {
        LOG_ERR("RPL Option Error: Dropping Packet\n");
        return 1;
      }
      opt_offset += opt_len;
      break;
#if UIP_MCAST6_ENGINE == UIP_MCAST6_ENGINE_MPL
    case UIP_EXT_HDR_OPT_MPL:
      /* MPL (RFC7731) Introduces the 0x6D hop by hop option. Hosts that do not
      *  recognise the option should drop the packet. Since we want to keep the packet,
      *  we want to process the option and not revert to the default case.
      */
      LOG_DBG("Processing MPL option\n");
      opt_offset += opt_len + opt_len;
      break;
#endif
    default:
      /*
       * check the two highest order bits of the option
       * - 00 skip over this option and continue processing the header.
       * - 01 discard the packet.
       * - 10 discard the packet and, regardless of whether or not the
       *   packet's Destination Address was a multicast address, send an
       *   ICMP Parameter Problem, Code 2, message to the packet's
       *   Source Address, pointing to the unrecognized Option Type.
       * - 11 discard the packet and, only if the packet's Destination
       *   Address was not a multicast address, send an ICMP Parameter
       *   Problem, Code 2, message to the packet's Source Address,
       *   pointing to the unrecognized Option Type.
       */
      LOG_DBG("Unrecognized option, MSB 0x%x\n", opt_hdr->type);
      switch(opt_hdr->type & 0xC0) {
      case 0:
        break;
      case 0x40:
        return 1;
      case 0xC0:
        if(uip_is_addr_mcast(&UIP_IP_BUF->destipaddr)) {
          return 1;
        }
      case 0x80:
        uip_icmp6_error_output(ICMP6_PARAM_PROB, ICMP6_PARAMPROB_OPTION,
            (ext_buf + opt_offset) - uip_buf);
        return 2;
      }
      /* in the cases were we did not discard, update ext_opt* */
      opt_offset += opt_len;
      break;
    }
  }
  return 0;
}
