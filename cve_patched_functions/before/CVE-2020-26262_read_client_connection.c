static int read_client_connection(turn_turnserver *server,
				  	  	  	  	  ts_ur_super_session *ss, ioa_net_data *in_buffer,
				  	  	  	  	  int can_resume, int count_usage) {

	FUNCSTART;

	if (!server || !ss || !in_buffer || !(ss->client_socket) || ss->to_be_closed || ioa_socket_tobeclosed(ss->client_socket)) {
		FUNCEND;
		return -1;
	}

	int ret = (int)ioa_network_buffer_get_size(in_buffer->nbh);
	if (ret < 0) {
		FUNCEND;
		return -1;
	}

	if(count_usage) {
		++(ss->received_packets);
		ss->received_bytes += (uint32_t)ioa_network_buffer_get_size(in_buffer->nbh);
		turn_report_session_usage(ss, 0);
	}

	if (eve(server->verbose)) {
		TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,
			      "%s: data.buffer=0x%lx, data.len=%ld\n", __FUNCTION__,
			      (long)ioa_network_buffer_data(in_buffer->nbh), 
			      (long)ioa_network_buffer_get_size(in_buffer->nbh));
	}

	uint16_t chnum = 0;
	uint32_t old_stun_cookie = 0;

	size_t blen = ioa_network_buffer_get_size(in_buffer->nbh);
	size_t orig_blen = blen;
	SOCKET_TYPE st = get_ioa_socket_type(ss->client_socket);
	SOCKET_APP_TYPE sat = get_ioa_socket_app_type(ss->client_socket);
	int is_padding_mandatory = is_stream_socket(st);

	if(sat == HTTP_CLIENT_SOCKET) {

		if(server->verbose) {
			TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, "%s: HTTP connection input: %s\n", __FUNCTION__, (char*)ioa_network_buffer_data(in_buffer->nbh));
		}

		handle_http_echo(ss->client_socket);

	} else if(sat == HTTPS_CLIENT_SOCKET) {

		//???

	} else if (stun_is_channel_message_str(ioa_network_buffer_data(in_buffer->nbh),
					&blen,
					&chnum,
					is_padding_mandatory)) {

		if(ss->is_tcp_relay) {
			//Forbidden
			FUNCEND;
			return -1;
		}

		int rc = 0;

		if(blen<=orig_blen) {
			ioa_network_buffer_set_size(in_buffer->nbh,blen);
			rc = write_to_peerchannel(ss, chnum, in_buffer);
		}

		if (eve(server->verbose)) {
			TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, "%s: wrote to peer %d bytes\n",
					__FUNCTION__, (int) rc);
		}

		FUNCEND;
		return 0;

	} else if (stun_is_command_message_full_check_str(ioa_network_buffer_data(in_buffer->nbh), ioa_network_buffer_get_size(in_buffer->nbh), 0, &(ss->enforce_fingerprints))) {

		ioa_network_buffer_handle nbh = ioa_network_buffer_allocate(server->e);
		int resp_constructed = 0;

		uint16_t method = stun_get_method_str(ioa_network_buffer_data(in_buffer->nbh),
						ioa_network_buffer_get_size(in_buffer->nbh));

		handle_turn_command(server, ss, in_buffer, nbh, &resp_constructed, can_resume);

		if((method != STUN_METHOD_BINDING) && (method != STUN_METHOD_SEND))
			report_turn_session_info(server,ss,0);

		if(ss->to_be_closed || ioa_socket_tobeclosed(ss->client_socket)) {
			FUNCEND;
			ioa_network_buffer_delete(server->e, nbh);
			return 0;
		}

		if (resp_constructed) {

			if ((server->fingerprint) || ss->enforce_fingerprints) {
				size_t len = ioa_network_buffer_get_size(nbh);
				if (stun_attr_add_fingerprint_str(ioa_network_buffer_data(nbh), &len) < 0) {
					FUNCEND	;
					ioa_network_buffer_delete(server->e, nbh);
					return -1;
				}
				ioa_network_buffer_set_size(nbh, len);
			}

			int ret = write_client_connection(server, ss, nbh, TTL_IGNORE, TOS_IGNORE);

			FUNCEND	;
			return ret;
		} else {
			ioa_network_buffer_delete(server->e, nbh);
			return 0;
		}

	} else if (old_stun_is_command_message_str(ioa_network_buffer_data(in_buffer->nbh), ioa_network_buffer_get_size(in_buffer->nbh), &old_stun_cookie) && !(*(server->no_stun))) {

		ioa_network_buffer_handle nbh = ioa_network_buffer_allocate(server->e);
		int resp_constructed = 0;

		handle_old_stun_command(server, ss, in_buffer, nbh, &resp_constructed, old_stun_cookie);

		if (resp_constructed) {

			int ret = write_client_connection(server, ss, nbh, TTL_IGNORE, TOS_IGNORE);

			FUNCEND	;
			return ret;
		} else {
			ioa_network_buffer_delete(server->e, nbh);
			return 0;
		}
	} else {
		SOCKET_TYPE st = get_ioa_socket_type(ss->client_socket);
		if(is_stream_socket(st)) {
			if(is_http((char*)ioa_network_buffer_data(in_buffer->nbh),
			ioa_network_buffer_get_size(in_buffer->nbh))) {

				const char *proto = "HTTP";
				if ((st == TCP_SOCKET) &&
					(
						try_acme_redirect(
							(char*)ioa_network_buffer_data(in_buffer->nbh),
							ioa_network_buffer_get_size(in_buffer->nbh),
							server->acme_redirect,
							ss->client_socket
						) == 0
					)
				) {
					ss->to_be_closed = 1;
					return 0;
				} else if (*server->web_admin_listen_on_workers) {
					if(st==TLS_SOCKET) {
						proto = "HTTPS";
						set_ioa_socket_app_type(ss->client_socket,HTTPS_CLIENT_SOCKET);
						TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, "%s: %s (%s %s) request: %s\n", __FUNCTION__, proto, get_ioa_socket_cipher(ss->client_socket), get_ioa_socket_ssl_method(ss->client_socket), ioa_network_buffer_get_size(in_buffer->nbh));
						if(server->send_https_socket) {
							TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, "%s socket to be detached: 0x%lx, st=%d, sat=%d\n", __FUNCTION__,(long)ss->client_socket, get_ioa_socket_type(ss->client_socket), get_ioa_socket_app_type(ss->client_socket));
							ioa_socket_handle new_s = detach_ioa_socket(ss->client_socket);
							if(new_s) {
								TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, "%s new detached socket: 0x%lx, st=%d, sat=%d\n", __FUNCTION__,(long)new_s, get_ioa_socket_type(new_s), get_ioa_socket_app_type(new_s));
								server->send_https_socket(new_s);
							}
							ss->to_be_closed = 1;
						}
					} else {
						set_ioa_socket_app_type(ss->client_socket,HTTP_CLIENT_SOCKET);
						if(server->verbose) {
							TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO, "%s: %s request: %s\n", __FUNCTION__, proto, ioa_network_buffer_get_size(in_buffer->nbh));
						}
						handle_http_echo(ss->client_socket);
					}
					return 0;
				} else {
					ss->to_be_closed = 1;
					return 0;
				}
			}
		}
	}
    
	//Unrecognized message received, ignore it

	FUNCEND;
	return -1;
}
