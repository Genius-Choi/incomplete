static int do_match(struct sss_certmap_ctx *ctx,
                    struct krb5_match_rule *parsed_match_rule,
                    struct sss_cert_content *cert_content)
{
    struct component_list *comp;
    bool match = false;
    size_t c;

    if (parsed_match_rule == NULL || cert_content == NULL) {
        return EINVAL;
    }

    /* Issuer */
    for (comp = parsed_match_rule->issuer; comp != NULL; comp = comp->next) {
        match = (cert_content->issuer_str != NULL
                    && regexec(&(comp->regexp), cert_content->issuer_str,
                               0, NULL, 0) == 0);
        if (match && parsed_match_rule->r == relation_or) {
            /* match */
            return 0;
        } else if (!match && parsed_match_rule->r == relation_and) {
            /* no match */
            return ENOENT;
        }

    }

    /* Subject */
    for (comp = parsed_match_rule->subject; comp != NULL; comp = comp->next) {
        match = (cert_content->subject_str != NULL
                    && regexec(&(comp->regexp), cert_content->subject_str,
                               0, NULL, 0) == 0);
        if (match && parsed_match_rule->r == relation_or) {
            /* match */
            return 0;
        } else if (!match && parsed_match_rule->r == relation_and) {
            /* no match */
            return ENOENT;
        }

    }

    /* Key Usage */
    for (comp = parsed_match_rule->ku; comp != NULL; comp = comp->next) {
        match = ((cert_content->key_usage & comp->ku) == comp->ku);
        if (match && parsed_match_rule->r == relation_or) {
            /* match */
            return 0;
        } else if (!match && parsed_match_rule->r == relation_and) {
            /* no match */
            return ENOENT;
        }
    }

    /* Extended Key Usage */
    for (comp = parsed_match_rule->eku; comp != NULL; comp = comp->next) {
        for (c = 0; comp->eku_oid_list[c] != NULL; c++) {
            match = string_in_list(comp->eku_oid_list[c],
                                   discard_const(
                                         cert_content->extended_key_usage_oids),
                                   true);
            if (match && parsed_match_rule->r == relation_or) {
                /* match */
                return 0;
            } else if (!match && parsed_match_rule->r == relation_and) {
                /* no match */
                return ENOENT;
            }
        }
    }

    /* SAN */
    for (comp = parsed_match_rule->san; comp != NULL; comp = comp->next) {
        match = do_san_match(ctx, comp, cert_content->san_list);
        if (match && parsed_match_rule->r == relation_or) {
            /* match */
            return 0;
        } else if (!match && parsed_match_rule->r == relation_and) {
            /* no match */
            return ENOENT;
        }
    }

    if (match) {
        /* match */
        return 0;
    }

    /* no match */
    return ENOENT;
}
