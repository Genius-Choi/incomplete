iolog_parse_json(FILE *fp, const char *filename, struct json_object *root)
{
    struct json_object *frame = root;
    struct json_stack stack = JSON_STACK_INTIALIZER(stack);
    unsigned int lineno = 0;
    char *name = NULL;
    char *cp, *buf = NULL;
    size_t bufsize = 0;
    ssize_t len;
    bool ret = false;
    bool saw_comma = false;
    long long num;
    char ch;
    debug_decl(iolog_parse_json, SUDO_DEBUG_UTIL);

    root->parent = NULL;
    TAILQ_INIT(&root->items);

    while ((len = getdelim(&buf, &bufsize, '\n', fp)) != -1) {
	char *ep = buf + len - 1;
	cp = buf;

	lineno++;

	/* Trim trailing whitespace. */
	while (ep > cp && isspace((unsigned char)*ep))
	    ep--;
	ep[1] = '\0';

	for (;;) {
	    const char *errstr;

	    /* Trim leading whitespace, skip blank lines. */
	    while (isspace((unsigned char)*cp))
		cp++;

	    /* Check for comma separator and strip it out. */
	    if (*cp == ',') {
		saw_comma = true;
		cp++;
		while (isspace((unsigned char)*cp))
		    cp++;
	    }

	    /* End of line? */
	    if (*cp == '\0')
		break;

	    switch (*cp) {
	    case '{':
		if (name == NULL && frame->parent != NULL) {
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("objects must consist of name:value pairs"));
		    goto done;
		}
		if (!saw_comma && !TAILQ_EMPTY(&frame->items)) {
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("missing separator between values"));
		    goto done;
		}
		cp++;
		saw_comma = false;
		frame = json_stack_push(&stack, &frame->items, frame,
		    JSON_OBJECT, name, lineno);
		if (frame == NULL)
		    goto done;
		name = NULL;
		break;
	    case '}':
		if (stack.depth == 0 || frame->parent == NULL ||
			frame->parent->type != JSON_OBJECT) {
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("unmatched close brace"));
		    goto done;
		}
		cp++;
		frame = stack.frames[--stack.depth];
		saw_comma = false;
		break;
	    case '[':
		if (frame->parent == NULL) {
		    /* Must have an enclosing object. */
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("unexpected array"));
		    goto done;
		}
		if (!saw_comma && !TAILQ_EMPTY(&frame->items)) {
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("missing separator between values"));
		    goto done;
		}
		cp++;
		saw_comma = false;
		frame = json_stack_push(&stack, &frame->items, frame,
		    JSON_ARRAY, name, lineno);
		if (frame == NULL)
		    goto done;
		name = NULL;
		break;
	    case ']':
		if (stack.depth == 0 || frame->parent == NULL ||
			frame->parent->type != JSON_ARRAY) {
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("unmatched close bracket"));
		    goto done;
		}
		cp++;
		frame = stack.frames[--stack.depth];
		saw_comma = false;
		break;
	    case '"':
		if (frame->parent == NULL) {
		    /* Must have an enclosing object. */
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("unexpected string"));
		    goto done;
		}

		if (!expect_value) {
		    /* Parse "name": */
		    if ((name = json_parse_string(&cp)) == NULL)
			goto done;
		    /* TODO: allow colon on next line? */
		    if (*cp != ':') {
			sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			    U_("missing colon after name"));
			goto done;
		    }
		    cp++;
		} else {
		    if (!saw_comma && !TAILQ_EMPTY(&frame->items)) {
			sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			    U_("missing separator between values"));
			goto done;
		    }
		    saw_comma = false;
		    if (!json_insert_str(&frame->items, name, &cp, lineno))
			goto done;
		    name = NULL;
		}
		break;
	    case 't':
		if (strncmp(cp, "true", sizeof("true") - 1) != 0)
		    goto parse_error;
		if (!expect_value) {
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("unexpected boolean"));
		    goto done;
		}
		cp += sizeof("true") - 1;
		if (*cp != ',' && !isspace((unsigned char)*cp) && *cp != '\0')
		    goto parse_error;
		if (!saw_comma && !TAILQ_EMPTY(&frame->items)) {
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("missing separator between values"));
		    goto done;
		}
		saw_comma = false;

		if (!json_insert_bool(&frame->items, name, true, lineno))
		    goto done;
		name = NULL;
		break;
	    case 'f':
		if (strncmp(cp, "false", sizeof("false") - 1) != 0)
		    goto parse_error;
		if (!expect_value) {
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("unexpected boolean"));
		    goto done;
		}
		cp += sizeof("false") - 1;
		if (*cp != ',' && !isspace((unsigned char)*cp) && *cp != '\0')
		    goto parse_error;
		if (!saw_comma && !TAILQ_EMPTY(&frame->items)) {
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("missing separator between values"));
		    goto done;
		}
		saw_comma = false;

		if (!json_insert_bool(&frame->items, name, false, lineno))
		    goto done;
		name = NULL;
		break;
	    case 'n':
		if (strncmp(cp, "null", sizeof("null") - 1) != 0)
		    goto parse_error;
		if (!expect_value) {
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("unexpected null"));
		    goto done;
		}
		cp += sizeof("null") - 1;
		if (*cp != ',' && !isspace((unsigned char)*cp) && *cp != '\0')
		    goto parse_error;
		if (!saw_comma && !TAILQ_EMPTY(&frame->items)) {
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("missing separator between values"));
		    goto done;
		}
		saw_comma = false;

		if (!json_insert_null(&frame->items, name, lineno))
		    goto done;
		name = NULL;
		break;
	    case '+': case '-': case '0': case '1': case '2': case '3':
	    case '4': case '5': case '6': case '7': case '8': case '9':
		if (!expect_value) {
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("unexpected number"));
		    goto done;
		}
		/* XXX - strtonumx() would be simpler here. */
		len = strcspn(cp, " \f\n\r\t\v,");
		ch = cp[len];
		cp[len] = '\0';
		if (!saw_comma && !TAILQ_EMPTY(&frame->items)) {
		    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, 
			U_("missing separator between values"));
		    goto done;
		}
		saw_comma = false;
		num = sudo_strtonum(cp, LLONG_MIN, LLONG_MAX, &errstr);
		if (errstr != NULL) {
		    sudo_warnx("%s:%u:%td: %s: %s", filename, lineno, cp - buf,
			cp, U_(errstr));
		    goto done;
		}
		cp += len;
		*cp = ch;

		if (!json_insert_num(&frame->items, name, num, lineno))
		    goto done;
		name = NULL;
		break;
	    default:
		goto parse_error;
	    }
	}
    }
    if (stack.depth != 0) {
	frame = stack.frames[stack.depth - 1];
	if (frame->parent == NULL || frame->parent->type == JSON_OBJECT) {
	    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf,
		U_("unmatched close brace"));
	} else {
	    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf,
		U_("unmatched close bracket"));
	}
	goto done;
    }

    ret = true;
    goto done;

parse_error:
    sudo_warnx("%s:%u:%td: %s", filename, lineno, cp - buf, U_("parse error"));
done:
    free(buf);
    free(name);
    if (!ret)
	free_json_items(&root->items);

    debug_return_bool(ret);
}
