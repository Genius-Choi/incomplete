static int32_t load_bl33x(void)
{
	static int32_t loaded = IO_NOT_SUPPORTED;
	uintptr_t dst, partition, handle;
	uint32_t noload, cert, len, i;
	uintptr_t offset;
	int32_t rc;
	size_t cnt;
	const int32_t img[] = {
		BL33_IMAGE_ID,
		BL332_IMAGE_ID,
		BL333_IMAGE_ID,
		BL334_IMAGE_ID,
		BL335_IMAGE_ID,
		BL336_IMAGE_ID,
		BL337_IMAGE_ID,
		BL338_IMAGE_ID
	};

	if (loaded != IO_NOT_SUPPORTED) {
		return loaded;
	}

	for (i = 1; i < rcar_image_number; i++) {
		rc = file_to_offset(img[i], &offset, &cert, &noload,
				    &partition);
		if (rc != IO_SUCCESS) {
			WARN("%s: failed to get offset\n", __func__);
			loaded = IO_FAIL;
			return loaded;
		}

		rcar_read_certificate((uint64_t) cert, &len, &dst);
		((io_drv_spec_t *) rcar_spec)->partition = partition;

		rc = io_open(rcar_handle, rcar_spec, &handle);
		if (rc != IO_SUCCESS) {
			WARN("%s: Failed to open FIP (%i)\n", __func__, rc);
			loaded = IO_FAIL;
			return loaded;
		}

		rc = io_seek(handle, IO_SEEK_SET, offset);
		if (rc != IO_SUCCESS) {
			WARN("%s: failed to seek\n", __func__);
			loaded = IO_FAIL;
			return loaded;
		}

		rc = check_load_area(dst, len);
		if (rc != IO_SUCCESS) {
			WARN("%s: check load area\n", __func__);
			loaded = IO_FAIL;
			return loaded;
		}

		rc = io_read(handle, dst, len, &cnt);
		if (rc != IO_SUCCESS) {
			WARN("%s: failed to read\n", __func__);
			loaded = IO_FAIL;
			return loaded;
		}
#if TRUSTED_BOARD_BOOT
		rc = auth_mod_verify_img(img[i], (void *)dst, len);
		if (rc != 0) {
			memset((void *)dst, 0x00, len);
			loaded = IO_FAIL;
			return loaded;
		}
#endif
		io_close(handle);
	}

	loaded = IO_SUCCESS;

	return loaded;
}
