SWITCH_DECLARE(void) switch_rtp_destroy(switch_rtp_t **rtp_session)
{
	void *pop;
	switch_socket_t *sock;
#ifdef ENABLE_SRTP
	int x;
#endif

	if (!rtp_session || !*rtp_session || !(*rtp_session)->ready) {
		return;
	}

	if ((*rtp_session)->vb) {
		/* retrieve counter for ALL received NACKed packets */
		uint32_t nack_jb_ok = switch_jb_get_nack_success((*rtp_session)->vb);
		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG((*rtp_session)->session), SWITCH_LOG_DEBUG, 
				"NACK: Added to JB: [%u]\n", nack_jb_ok);
	}

	(*rtp_session)->flags[SWITCH_RTP_FLAG_SHUTDOWN] = 1;

	READ_INC((*rtp_session));
	WRITE_INC((*rtp_session));

	(*rtp_session)->ready = 0;

	WRITE_DEC((*rtp_session));
	READ_DEC((*rtp_session));

	if ((*rtp_session)->flags[SWITCH_RTP_FLAG_VAD]) {
		switch_rtp_disable_vad(*rtp_session);
	}

	switch_mutex_lock((*rtp_session)->flag_mutex);

	switch_rtp_kill_socket(*rtp_session);

	while (switch_queue_trypop((*rtp_session)->dtmf_data.dtmf_inqueue, &pop) == SWITCH_STATUS_SUCCESS) {
		switch_safe_free(pop);
	}

	while (switch_queue_trypop((*rtp_session)->dtmf_data.dtmf_queue, &pop) == SWITCH_STATUS_SUCCESS) {
		switch_safe_free(pop);
	}

	if ((*rtp_session)->jb) {
		switch_jb_destroy(&(*rtp_session)->jb);
	}

	if ((*rtp_session)->vb) {
		switch_jb_destroy(&(*rtp_session)->vb);
	}

	if ((*rtp_session)->vbw) {
		switch_jb_destroy(&(*rtp_session)->vbw);
	}

	if ((*rtp_session)->dtls && (*rtp_session)->dtls == (*rtp_session)->rtcp_dtls) {
		(*rtp_session)->rtcp_dtls = NULL;
	}

	if ((*rtp_session)->dtls) {
		free_dtls(&(*rtp_session)->dtls);
	}

	if ((*rtp_session)->rtcp_dtls) {
		free_dtls(&(*rtp_session)->rtcp_dtls);
	}

	if ((*rtp_session)->rtcp_sock_input == (*rtp_session)->sock_input) {
		(*rtp_session)->rtcp_sock_input = NULL;
	}

	if ((*rtp_session)->rtcp_sock_output == (*rtp_session)->sock_output) {
		(*rtp_session)->rtcp_sock_output = NULL;
	}

	sock = (*rtp_session)->sock_input;
	(*rtp_session)->sock_input = NULL;
	switch_socket_close(sock);

	if ((*rtp_session)->sock_output != sock) {
		sock = (*rtp_session)->sock_output;
		(*rtp_session)->sock_output = NULL;
		switch_socket_close(sock);
	}

	if ((sock = (*rtp_session)->rtcp_sock_input)) {
		(*rtp_session)->rtcp_sock_input = NULL;
		switch_socket_close(sock);
	}

	if ((*rtp_session)->rtcp_sock_output && (*rtp_session)->rtcp_sock_output != sock) {
		sock = (*rtp_session)->rtcp_sock_output;
		(*rtp_session)->rtcp_sock_output = NULL;
		switch_socket_close(sock);
	}

#ifdef ENABLE_SRTP
	if ((*rtp_session)->flags[SWITCH_RTP_FLAG_SECURE_SEND]) {
		for(x = 0; x < 2; x++) {
			if ((*rtp_session)->send_ctx[x]) {
				srtp_dealloc((*rtp_session)->send_ctx[x]);
				(*rtp_session)->send_ctx[x] = NULL;
			}
		}
		(*rtp_session)->flags[SWITCH_RTP_FLAG_SECURE_SEND] = 0;
	}

	if ((*rtp_session)->flags[SWITCH_RTP_FLAG_SECURE_RECV]) {
		for (x = 0; x < 2; x++) {
			if ((*rtp_session)->recv_ctx[x]) {
				srtp_dealloc((*rtp_session)->recv_ctx[x]);
				(*rtp_session)->recv_ctx[x] = NULL;
			}
		}
		(*rtp_session)->flags[SWITCH_RTP_FLAG_SECURE_RECV] = 0;
	}
#endif

	if ((*rtp_session)->timer.timer_interface) {
		switch_core_timer_destroy(&(*rtp_session)->timer);
	}

	if ((*rtp_session)->write_timer.timer_interface) {
		switch_core_timer_destroy(&(*rtp_session)->write_timer);
	}

	switch_rtp_release_port((*rtp_session)->rx_host, (*rtp_session)->rx_port);
	switch_mutex_unlock((*rtp_session)->flag_mutex);

	return;
}
