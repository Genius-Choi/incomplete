static void svg_parse_path(SVG_PathData *d_attribute, char *attribute_content, GF_Err *out_e)
{
	GF_List *d_commands = d_attribute->commands;
	GF_List *d_points = d_attribute->points;
	char *d = attribute_content;

	if (strlen(d)) {
		SVG_Point *pt, cur_pt, prev_m_pt;
		u8 *command;
		u32 i, k;
		char c, prev_c = 'M';
#ifdef REMOVE_ALLOC
		GF_SAFEALLOC(pt, SVG_Point)
		if (!pt) return;
#endif
		i = 0;
		cur_pt.x = cur_pt.y = 0;
		prev_m_pt.x = prev_m_pt.y = 0;
		while(1) {
			while ( (d[i]==' ') || (d[i] =='\t') ) i++;
			c = d[i];
			if (! c) break;
next_command:
			switch (c) {
			case 'm':
			case 'M':
				i++;
#ifndef REMOVE_ALLOC
				GF_SAFEALLOC(command, u8)
				if (!command) return;
				gf_list_add(d_commands, command);
				*command = SVG_PATHCOMMAND_M;

				GF_SAFEALLOC(pt, SVG_Point)
				if (!pt) return;
				gf_list_add(d_points, pt);
#endif
				i += svg_parse_number(&(d[i]), &(pt->x), 0, out_e);
				i += svg_parse_number(&(d[i]), &(pt->y), 0, out_e);
				if (c == 'm') {
					pt->x += cur_pt.x;
					pt->y += cur_pt.y;
				}
				cur_pt.x = pt->x;
				cur_pt.y = pt->y;
				prev_m_pt = cur_pt;
				prev_c = c;
				break;
			case 'L':
			case 'l':
				i++;
#ifndef REMOVE_ALLOC
				GF_SAFEALLOC(command, u8)
				if (!command) return;
				gf_list_add(d_commands, command);
				*command = SVG_PATHCOMMAND_L;

				GF_SAFEALLOC(pt, SVG_Point)
				if (!pt) return;
				gf_list_add(d_points, pt);
#endif
				i += svg_parse_number(&(d[i]), &(pt->x), 0, out_e);
				i += svg_parse_number(&(d[i]), &(pt->y), 0, out_e);
				if (c == 'l') {
					pt->x += cur_pt.x;
					pt->y += cur_pt.y;
				}
				cur_pt.x = pt->x;
				cur_pt.y = pt->y;
				prev_c = c;
				break;
			case 'H':
			case 'h':
				i++;
#ifndef REMOVE_ALLOC
				GF_SAFEALLOC(command, u8)
				if (!command) return;
				gf_list_add(d_commands, command);
				*command = SVG_PATHCOMMAND_L;

				GF_SAFEALLOC(pt, SVG_Point)
				if (!pt) return;
				gf_list_add(d_points, pt);
#endif
				i += svg_parse_number(&(d[i]), &(pt->x), 0, out_e);
				if (c == 'h') {
					pt->x += cur_pt.x;
				}
				pt->y = cur_pt.y;
				cur_pt.x = pt->x;
				prev_c = c;
				break;
			case 'V':
			case 'v':
				i++;
#ifndef REMOVE_ALLOC
				GF_SAFEALLOC(command, u8)
				if (!command) return;
				gf_list_add(d_commands, command);
				*command = SVG_PATHCOMMAND_L;

				GF_SAFEALLOC(pt, SVG_Point)
				if (!pt) return;
				gf_list_add(d_points, pt);
#endif
				i += svg_parse_number(&(d[i]), &(pt->y), 0, out_e);
				if (c == 'v') {
					pt->y += cur_pt.y;
				}
				pt->x = cur_pt.x;
				cur_pt.y = pt->y;
				prev_c = c;
				break;
			case 'C':
			case 'c':
				i++;
#ifndef REMOVE_ALLOC
				GF_SAFEALLOC(command, u8)
				if (!command) return;
				gf_list_add(d_commands, command);
				*command = SVG_PATHCOMMAND_C;
#endif

				for (k=0; k<3; k++) {
#ifndef REMOVE_ALLOC
					GF_SAFEALLOC(pt, SVG_Point)
					if (!pt) return;
					gf_list_add(d_points, pt);
#endif
					i += svg_parse_number(&(d[i]), &(pt->x), 0, out_e);
					i += svg_parse_number(&(d[i]), &(pt->y), 0, out_e);
					if (c == 'c') {
						pt->x += cur_pt.x;
						pt->y += cur_pt.y;
					}
				}
				cur_pt.x = pt->x;
				cur_pt.y = pt->y;
				prev_c = c;
				break;
			case 'S':
			case 's':
				i++;
#ifndef REMOVE_ALLOC
				GF_SAFEALLOC(command, u8)
				if (!command) return;
				gf_list_add(d_commands, command);
				*command = SVG_PATHCOMMAND_S;
#endif

				for (k=0; k<2; k++) {
#ifndef REMOVE_ALLOC
					GF_SAFEALLOC(pt, SVG_Point)
					if (!pt) return;
					gf_list_add(d_points, pt);
#endif
					i += svg_parse_number(&(d[i]), &(pt->x), 0, out_e);
					i += svg_parse_number(&(d[i]), &(pt->y), 0, out_e);
					if (c == 's') {
						pt->x += cur_pt.x;
						pt->y += cur_pt.y;
					}
				}
				cur_pt.x = pt->x;
				cur_pt.y = pt->y;
				prev_c = c;
				break;
			case 'Q':
			case 'q':
				i++;
#ifndef REMOVE_ALLOC
				GF_SAFEALLOC(command, u8)
				if (!command) return;
				gf_list_add(d_commands, command);
				*command = SVG_PATHCOMMAND_Q;
#endif

				for (k=0; k<2; k++) {
#ifndef REMOVE_ALLOC
					GF_SAFEALLOC(pt, SVG_Point)
					if (!pt) return;
					gf_list_add(d_points, pt);
#endif
					i += svg_parse_number(&(d[i]), &(pt->x), 0, out_e);
					i += svg_parse_number(&(d[i]), &(pt->y), 0, out_e);
					if (c == 'q') {
						pt->x += cur_pt.x;
						pt->y += cur_pt.y;
					}
				}
				cur_pt.x = pt->x;
				cur_pt.y = pt->y;
				prev_c = c;
				break;
			case 'T':
			case 't':
				i++;
#ifndef REMOVE_ALLOC
				GF_SAFEALLOC(command, u8)
				if (!command) return;
				gf_list_add(d_commands, command);
				*command = SVG_PATHCOMMAND_T;

				GF_SAFEALLOC(pt, SVG_Point)
				if (!pt) return;
				gf_list_add(d_points, pt);
#endif
				i += svg_parse_number(&(d[i]), &(pt->x), 0, out_e);
				i += svg_parse_number(&(d[i]), &(pt->y), 0, out_e);
				if (c == 't') {
					pt->x += cur_pt.x;
					pt->y += cur_pt.y;
				}
				cur_pt.x = pt->x;
				cur_pt.y = pt->y;
				prev_c = c;
				break;
			case 'A':
			case 'a':
			{
				Fixed tmp;
				i++;
#ifndef REMOVE_ALLOC
				GF_SAFEALLOC(command, u8)
				if (!command) return;
				gf_list_add(d_commands, command);
				*command = SVG_PATHCOMMAND_A;

				pt = gf_malloc(sizeof(SVG_Point));
				if (!pt) return;
				gf_list_add(d_points, pt);
#endif
				i += svg_parse_number(&(d[i]), &(pt->x), 0, out_e);
				i += svg_parse_number(&(d[i]), &(pt->y), 0, out_e);

				i += svg_parse_number(&(d[i]), &(tmp), 0, out_e);
				i += svg_parse_number(&(d[i]), &(tmp), 0, out_e);
				i += svg_parse_number(&(d[i]), &(tmp), 0, out_e);

#ifndef REMOVE_ALLOC
				pt = gf_malloc(sizeof(SVG_Point));
				if (!pt) return;
				gf_list_add(d_points, pt);
#endif
				i += svg_parse_number(&(d[i]), &(pt->x), 0, out_e);
				i += svg_parse_number(&(d[i]), &(pt->y), 0, out_e);
				if (c == 'a') {
					pt->x += cur_pt.x;
					pt->y += cur_pt.y;
				}
				cur_pt.x = pt->x;
				cur_pt.y = pt->y;
			}
			prev_c = c;
			break;
			case 'Z':
			case 'z':
				i++;
#ifndef REMOVE_ALLOC
				GF_SAFEALLOC(command, u8)
				if (!command) return;
				gf_list_add(d_commands, command);
				*command = SVG_PATHCOMMAND_Z;
#endif
				prev_c = c;
				cur_pt = prev_m_pt;
				break;
			default:
				i--;
				switch (prev_c) {
				case 'M':
					c = 'L';
					break;
				case 'm':
					c = 'l';
					break;
				default:
					c = prev_c;
				}
				goto next_command;
			}
		}
	}
}
