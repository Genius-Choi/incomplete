static bool convert_result(int res, fastly_compute_at_edge_types_error_t *err) {
  if (res == 0)
    return true;
  switch (res) {
  case 1:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_GENERIC_ERROR;
    break;
  case 2:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_INVALID_ARGUMENT;
    break;
  case 3:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BAD_HANDLE;
    break;
  case 4:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BUFFER_LEN;
    break;
  case 5:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_UNSUPPORTED;
    break;
  case 6:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_BAD_ALIGN;
    break;
  case 7:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_HTTP_INVALID;
    break;
  case 8:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_HTTP_USER;
    break;
  case 9:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_HTTP_INCOMPLETE;
    break;
  case 10:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_OPTIONAL_NONE;
    break;
  case 11:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_HTTP_HEAD_TOO_LARGE;
    break;
  case 12:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_HTTP_INVALID_STATUS;
    break;
  case 13:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_LIMIT_EXCEEDED;
    break;
  case 100:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_UNKNOWN_ERROR;
    break;
  default:
    *err = FASTLY_COMPUTE_AT_EDGE_TYPES_ERROR_UNKNOWN_ERROR;
  }
  return false;
}
