QPDF::parse(char const* password)
{
    PCRE header_re("\\A((?s).*?)%PDF-(1.\\d+)\\b");
    PCRE eof_re("(?s:startxref\\s+(\\d+)\\s+%%EOF\\b)");

    if (password)
    {
	this->provided_password = password;
    }

    // Find the header anywhere in the first 1024 bytes of the file,
    // plus add a little extra space for the header itself.
    char buffer[1045];
    memset(buffer, '\0', sizeof(buffer));
    this->file->read(buffer, sizeof(buffer) - 1);
    std::string line(buffer);
    PCRE::Match m1 = header_re.match(line.c_str());
    if (m1)
    {
        size_t global_offset = m1.getMatch(1).length();
        if (global_offset != 0)
        {
            // Empirical evidence strongly suggests that when there is
            // leading material prior to the PDF header, all explicit
            // offsets in the file are such that 0 points to the
            // beginning of the header.
            QTC::TC("qpdf", "QPDF global offset");
            this->file = new OffsetInputSource(this->file, global_offset);
        }
	this->pdf_version = m1.getMatch(2);
	if (atof(this->pdf_version.c_str()) < 1.2)
	{
	    this->tokenizer.allowPoundAnywhereInName();
	}
    }
    else
    {
	QTC::TC("qpdf", "QPDF not a pdf file");
	throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(),
		      "", 0, "not a PDF file");
    }

    // PDF spec says %%EOF must be found within the last 1024 bytes of
    // the file.  We add an extra 30 characters to leave room for the
    // startxref stuff.
    static int const tbuf_size = 1054;
    this->file->seek(0, SEEK_END);
    if (this->file->tell() > tbuf_size)
    {
	this->file->seek(-tbuf_size, SEEK_END);
    }
    else
    {
	this->file->rewind();
    }
    char* buf = new char[tbuf_size + 1];
    // Put buf in an array-style PointerHolder to guarantee deletion
    // of buf.
    PointerHolder<char> b(true, buf);
    memset(buf, '\0', tbuf_size + 1);
    this->file->read(buf, tbuf_size);

    // Since buf may contain null characters, we can't do a regexp
    // search on buf directly.  Find the last occurrence within buf
    // where the regexp matches.
    char* p = buf;
    char const* candidate = "";
    while ((p = static_cast<char*>(memchr(p, 's', tbuf_size - (p - buf)))) != 0)
    {
	if (eof_re.match(p))
	{
	    candidate = p;
	}
	++p;
    }

    try
    {
	PCRE::Match m2 = eof_re.match(candidate);
	if (! m2)
	{
	    QTC::TC("qpdf", "QPDF can't find startxref");
	    throw QPDFExc(qpdf_e_damaged_pdf, this->file->getName(), "", 0,
			  "can't find startxref");
	}
	qpdf_offset_t xref_offset = QUtil::string_to_ll(m2.getMatch(1).c_str());
	read_xref(xref_offset);
    }
    catch (QPDFExc& e)
    {
	if (this->attempt_recovery)
	{
	    reconstruct_xref(e);
	    QTC::TC("qpdf", "QPDF reconstructed xref table");
	}
	else
	{
	    throw e;
	}
    }

    initializeEncryption();
    findAttachmentStreams();
}
