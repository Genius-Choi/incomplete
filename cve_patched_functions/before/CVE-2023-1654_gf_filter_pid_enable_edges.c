static u32 gf_filter_pid_enable_edges(GF_FilterSession *fsess, GF_FilterRegDesc *reg_desc, u32 src_cap_idx, const GF_FilterRegister *src_freg, u32 rlevel, s32 dst_stream_type, GF_FilterRegDesc *parent_desc, GF_FilterPid *pid, u32 pid_stream_type)
{
	u32 i=0;
	Bool enable_graph = GF_FALSE;
	Bool aborted_graph_too_deep = GF_FALSE;

	//we found the source reg we want to connect to!
	if (src_freg == reg_desc->freg) {
		return 1;
	}
	//the subgraph is too deep, abort marking edges but don't decide
	if (rlevel > fsess->max_resolve_chain_len) {
		return 2;
	}
	//we don't allow loops in dynamic chain resolution, so consider the parent edge invalid
	if (reg_desc->in_edges_enabling)
		return 0;

	/*if dst type is FILE, reg_desc is a muxer or the loaded destination (a demuxer or a file)
	we only accept dst type FILE for the first call (ie reg desc is the loaded destination), and forbid muxers in the middle of the chain
	for dynamic resolution. This avoids situations such as StreamTypeA->mux->demux->streamtypeB which cannot be resolved

	note that it is still possible to use a mux or demux in the chain, but they have to be explicitly loaded
	*/
	if ((rlevel>1) && (dst_stream_type==GF_STREAM_FILE))
		return 0;

	reg_desc->in_edges_enabling = 1;

	for (i=0; i<reg_desc->nb_edges; i++) {
		u32 res;
		s32 source_stream_type;
		GF_FilterRegEdge *edge = &reg_desc->edges[i];
		//this edge is not for our target source cap bundle
		if (edge->dst_cap_idx != src_cap_idx) continue;

		//edge is already disabled (the subgraph doesn't match our source), don't test it
		if (edge->status == EDGE_STATUS_DISABLED)
			continue;

		//if source is not edge origin and edge is only valid for explicitly loaded filters, disable edge
		if (edge->loaded_filter_only && (edge->src_reg->freg != pid->filter->freg) ) {
			edge->status = EDGE_STATUS_DISABLED;
			edge->disabled_depth = rlevel+1;
			continue;
		}

		//edge is already enabled (the subgraph matches our source), don't test it but remember to indicate the graph is valid
		if (edge->status == EDGE_STATUS_ENABLED) {
			enable_graph = GF_TRUE;
			continue;
		}

		//candidate edge, check stream type
		source_stream_type = edge->src_stream_type;

		if (pid->filter->freg == edge->src_reg->freg)
			source_stream_type = pid_stream_type;

		//source edge cap indicates multiple stream types (demuxer/encoder/decoder dundle)
		if (source_stream_type<0) {
			//if destination type is known (>=0 and NOT file, inherit it
			//otherwise, we we can't filter out yet
			if ((dst_stream_type>0) && (dst_stream_type != GF_STREAM_FILE))
				source_stream_type = dst_stream_type;
		}
		//inherit source type if not specified
		if (!source_stream_type && dst_stream_type>0)
			source_stream_type = dst_stream_type;
		//if source is encrypted type and dest type is set, use dest type
		if ((source_stream_type==GF_STREAM_ENCRYPTED) && (dst_stream_type>0) && (dst_stream_type!=GF_STREAM_FILE))
			source_stream_type = dst_stream_type;
		//if dest is encrypted type and source type is set, use source type
		if ((dst_stream_type==GF_STREAM_ENCRYPTED) && source_stream_type>0)
			dst_stream_type = source_stream_type;

		//if stream types are know (>0) and not source files, do not mark the edges if they mismatch
		//moving from non-file type A to non-file type B requires an explicit filter
		if ((dst_stream_type>0) && (source_stream_type>0) && (source_stream_type != GF_STREAM_FILE) && (dst_stream_type != GF_STREAM_FILE) && (source_stream_type != dst_stream_type)) {

			//exception: we allow text|scene|od ->video for dynamic compositor
			if (!(reg_desc->freg->flags & GF_FS_REG_EXPLICIT_ONLY) && (dst_stream_type==GF_STREAM_VISUAL)
				&& ((source_stream_type==GF_STREAM_TEXT) || (source_stream_type==GF_STREAM_SCENE) || (source_stream_type==GF_STREAM_OD) )
			) {

			} else {
				edge->status = EDGE_STATUS_DISABLED;
				edge->disabled_depth = rlevel+1;
				continue;
			}
		}

		res = gf_filter_pid_enable_edges(fsess, edge->src_reg, edge->src_cap_idx, src_freg, rlevel+1, source_stream_type, reg_desc, pid, pid_stream_type);
		//if subgraph matches our source reg, mark the edge towards this subgraph as enabled
		if (res==1) {
			edge->status = EDGE_STATUS_ENABLED;
			enable_graph = GF_TRUE;
		}
		//if sub-graph below is too deep, don't mark the edge since we might need to resolve it again with a shorter subgraph
		else if (res==2) {
			aborted_graph_too_deep = GF_TRUE;
		}
		//otherwise the subgraph doesn't match our source reg, mark as disaled and never test again
		else if (res==0) {
			edge->status = EDGE_STATUS_DISABLED;
			edge->disabled_depth = rlevel+1;
		}
	}
	reg_desc->in_edges_enabling = 0;
	//we had enabled edges, the subgraph is valid
	if (enable_graph) return 1;
	//we aborted because too deep, indicate it to the caller so that the edge is not disabled
	if (aborted_graph_too_deep) return 2;
	//disable subgraph
	return 0;
}
