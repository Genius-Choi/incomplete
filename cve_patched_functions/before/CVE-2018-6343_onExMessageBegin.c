HTTPSession::onExMessageBegin(HTTPCodec::StreamID streamID,
                              HTTPCodec::StreamID controlStream,
                              bool unidirectional,
                              HTTPMessage* msg) {
  VLOG(4) << "processing new ExMessage=" << streamID
          << " on controlStream=" << controlStream << ", " << *this;
  if (infoCallback_) {
    infoCallback_->onRequestBegin(*this);
  }
  if (controlStream == 0) {
    LOG(ERROR) << "ExMessage=" << streamID << " should have an active control "
               << "stream=" << controlStream << ", " << *this;
    invalidStream(streamID, ErrorCode::PROTOCOL_ERROR);
    return;
  }

  HTTPTransaction* controlTxn = findTransaction(controlStream);
  if (!controlTxn) {
    // control stream is broken, or remote sends a bogus stream id
    LOG(ERROR) << "no control stream=" << controlStream << ", " << *this;
    return;
  }

  http2::PriorityUpdate messagePriority = getMessagePriority(msg);
  auto txn = createTransaction(streamID,
                               HTTPCodec::NoStream,
                               HTTPCodec::ExAttributes(controlStream,
                                                       unidirectional),
                               messagePriority);
  if (!txn) {
    return;  // This could happen if the socket is bad.
  }
  // control stream may be paused if the upstream is not ready yet
  if (controlTxn->isIngressPaused()) {
    txn->pauseIngress();
  }
}
