virtio_ipu_init(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{

	struct virtio_ipu *ipu;

	pthread_mutexattr_t attr;
	int rc;

	ipu = calloc(1, sizeof(struct virtio_ipu));
	if (!ipu) {
		IPRINTF(LWRN, "calloc returns NULL\n");
		return -1;
	}
	ipu->vbs_k.ipu_kstatus = VIRTIO_DEV_INITIAL;
	ipu->vbs_k.ipu_fd = -1;

	/* init mutex attribute properly */
	rc = pthread_mutexattr_init(&attr);
	if (rc)
		IPRINTF(LDBG, "mutexattr init failed with erro %d!\n", rc);

	if (virtio_uses_msix()) {
		rc = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_DEFAULT);
		IPRINTF(LDBG, "mutexattr_settype failed with error %d!\n", rc);
	} else {
		rc = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
		IPRINTF(LDBG, "mutexattr_settype failed with error %d!\n", rc);
	}

	rc = pthread_mutex_init(&ipu->mtx, &attr);
	if (rc)
		IPRINTF(LDBG, "mutex init failed with error %d!\n", rc);

	virtio_linkup(&ipu->base,
		      &virtio_ipu_ops_k,
		      ipu,
		      dev,
		      ipu->vq,
		      BACKEND_VBSK);

	rc = virtio_ipu_k_init(ipu);
	if (rc < 0) {
		IPRINTF(LWRN, "VBS-K init failed with error %d!\n", rc);
		ipu->vbs_k.ipu_kstatus = VIRTIO_DEV_INIT_FAILED;
		pthread_mutex_destroy(&ipu->mtx);
		free(ipu);
		return -1;
	}

	ipu->vbs_k.ipu_kstatus = VIRTIO_DEV_INIT_SUCCESS;
	ipu->base.mtx = &ipu->mtx;

	ipu->vq[0].qsize = VIRTIO_IPU_RINGSZ;
	ipu->vq[1].qsize = VIRTIO_IPU_RINGSZ;

	/* initialize config space */
	pci_set_cfgdata16(dev, PCIR_DEVICE, VIRTIO_DEV_IPU);
	pci_set_cfgdata16(dev, PCIR_VENDOR, INTEL_VENDOR_ID);
	pci_set_cfgdata8(dev, PCIR_CLASS, PCIC_MEMORY);
	pci_set_cfgdata16(dev, PCIR_SUBDEV_0, VIRTIO_TYPE_IPU);
	pci_set_cfgdata16(dev, PCIR_SUBVEND_0, INTEL_VENDOR_ID);

	if (virtio_interrupt_init(&ipu->base, virtio_uses_msix())) {
		pthread_mutex_destroy(&ipu->mtx);
		close(ipu->vbs_k.ipu_fd);
		free(ipu);
		return -1;
	}

	virtio_set_io_bar(&ipu->base, 0);

	return 0;
}
