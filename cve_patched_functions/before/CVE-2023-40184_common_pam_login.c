common_pam_login(struct auth_info *auth_info,
                 const char *user,
                 const char *pass,
                 const char *client_ip,
                 int authentication_required)
{
    int perror;
    char service_name[256];
    struct conv_func_data conv_func_data;
    struct pam_conv pamc;

    /*
     * Set up the data required by the conversation function, and the
     * structure which allows us to pass this to pam_start()
     */
    conv_func_data.pass = (authentication_required) ? pass : NULL;
    pamc.conv = verify_pam_conv;
    pamc.appdata_ptr = (void *) &conv_func_data;

    get_service_name(service_name);
    perror = pam_start(service_name, user, &pamc, &(auth_info->ph));

    if (perror != PAM_SUCCESS)
    {
        LOG(LOG_LEVEL_ERROR, "pam_start failed: %s",
            pam_strerror(auth_info->ph, perror));
        pam_end(auth_info->ph, perror);
        return E_SCP_LOGIN_GENERAL_ERROR;
    }

    if (client_ip != NULL && client_ip[0] != '\0')
    {
        perror = pam_set_item(auth_info->ph, PAM_RHOST, client_ip);
        if (perror != PAM_SUCCESS)
        {
            LOG(LOG_LEVEL_ERROR, "pam_set_item(PAM_RHOST) failed: %s",
                pam_strerror(auth_info->ph, perror));
        }
    }

    perror = pam_set_item(auth_info->ph, PAM_TTY, service_name);
    if (perror != PAM_SUCCESS)
    {
        LOG(LOG_LEVEL_ERROR, "pam_set_item(PAM_TTY) failed: %s",
            pam_strerror(auth_info->ph, perror));
    }

    if (authentication_required)
    {
        perror = pam_authenticate(auth_info->ph, 0);

        if (perror != PAM_SUCCESS)
        {
            LOG(LOG_LEVEL_ERROR, "pam_authenticate failed: %s",
                pam_strerror(auth_info->ph, perror));
            pam_end(auth_info->ph, perror);
            return E_SCP_LOGIN_NOT_AUTHENTICATED;
        }
    }
    /* From man page:
       The pam_acct_mgmt function is used to determine if the users account is
       valid. It checks for authentication token and account expiration and
       verifies access restrictions. It is typically called after the user has
       been authenticated.
     */
    perror = pam_acct_mgmt(auth_info->ph, 0);

    if (perror != PAM_SUCCESS)
    {
        LOG(LOG_LEVEL_ERROR, "pam_acct_mgmt failed: %s",
            pam_strerror(auth_info->ph, perror));
        pam_end(auth_info->ph, perror);
        return E_SCP_LOGIN_NOT_AUTHORIZED;
    }

    /* Set the appdata_ptr passed to the conversation function to
     * NULL, as the existing value is going out of scope */
    pamc.appdata_ptr = NULL;
    perror = pam_set_item(auth_info->ph, PAM_CONV, &pamc);
    if (perror != PAM_SUCCESS)
    {
        LOG(LOG_LEVEL_ERROR, "pam_set_item(PAM_CONV) failed: %s",
            pam_strerror(auth_info->ph, perror));
    }

    return E_SCP_LOGIN_OK;
}
