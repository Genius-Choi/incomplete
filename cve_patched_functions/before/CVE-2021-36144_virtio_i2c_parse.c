virtio_i2c_parse(struct virtio_i2c *vi2c, char *optstr)
{
	char *cp, *t, *dsdt_str, *p;
	uint16_t client_addr[MAX_I2C_VDEV];
	int addr, bus, n_adapter, n_client;

	/*
	 * virtio-i2c,<bus>:<client_addr[@<node>]>[:<client_addr[@<node>]>],
	 * [<bus>:<client_addr[@<node>]>[:<client_addr>[@<node>]]]
	 *
	 * bus (dec): native adatper bus number.
	 * 	e.g. 2 for /dev/i2c-2
	 * client_addr (hex): address for native client device
	 * 	e.g. 0x1C or 1C
	 * @<node>: node is the acpi node name defined in acpi_node_table[]
	 * 	e.g. @cam1 means adding 'cam1' node to dsdt table.
	 *
	 * Note: client address can not repeat.
	 */
	n_adapter = 0;
	while (optstr != NULL) {
		cp = strsep(&optstr, ",");
		/*
		 * <bus>:<client_addr>[:<client_addr>]...
		 */
		n_client = 0;
		bus = -1;
		while (cp != NULL && *cp !='\0') {
			if (*cp == ':')
				cp++;

			if (bus == -1) {
				if (dm_strtoi(cp, &t, 10, &bus) || bus < 0)
					return -1;
			} else {
				if (dm_strtoi(cp, &t, 16, &addr) || addr < 0)
					return -1;
				if (n_client > MAX_I2C_VDEV) {
					WPRINTF("too many devices, only support %d \n", MAX_I2C_VDEV);
					return -1;
				}
				client_addr[n_client] = (uint16_t)(addr & (MAX_I2C_VDEV - 1));
				p = &vi2c->acpi_nodes[client_addr[n_client]][0];
				if (t != NULL && *t == '@') {
					t++;
					dsdt_str = strsep(&t, ":,");
					snprintf(p, MAX_NODE_NAME_LEN, "%s", dsdt_str);
				} else {
					snprintf(p, MAX_NODE_NAME_LEN, "default");
				}
				DPRINTF("native i2c adapter %d:0x%x (%s)\n",
						bus,
						client_addr[n_client],
						p);
				n_client++;
			}
			cp = t;
		}
		if (n_adapter >= MAX_NATIVE_I2C_ADAPTER) {
			WPRINTF("too many adapter, only support %d \n", MAX_NATIVE_I2C_ADAPTER);
			return -1;
		}
		vi2c->native_adapter[n_adapter] = native_adapter_create(bus, client_addr, n_client);
		if (!vi2c->native_adapter[n_adapter])
			return -1;
		n_adapter++;
	}
	vi2c->native_adapter_num = n_adapter;

	return 0;
}
