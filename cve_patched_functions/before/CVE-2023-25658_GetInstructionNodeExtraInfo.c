std::string HloDotDumper::GetInstructionNodeExtraInfo(
    const HloInstruction* instr) {
  std::vector<std::string> lines;

  // Get the instruction's extra attributes excluding the names of its
  // subcomputations, since those are drawn explicitly in the graph.
  for (const auto& line : instr->ExtraAttributesToString(
           HloPrintOptions().set_print_subcomputation_mode(
               HloPrintOptions::PrintSubcomputationMode::kOff))) {
    // Some instructions have giant device identifier fields, so truncate their
    // length to 128.
    constexpr int kMaxDeviceIdFieldLen = 128;
    if ((absl::StartsWith(line, "replica_groups=") ||
         absl::StartsWith(line, "source_target_pairs=")) &&
        line.length() > kMaxDeviceIdFieldLen) {
      lines.push_back(HtmlLikeStringSanitize(
          StrCat(line.substr(0, kMaxDeviceIdFieldLen - 3), "...")));
    } else {
      lines.push_back(HtmlLikeStringSanitize(line));
    }
  }

  // Show the shape and layout of the instruction, unless it's an inlined fusion
  // node -- there the shape and layout is present in the output node.
  if (instr->opcode() != HloOpcode::kFusion ||
      !ShouldShowFusionSubcomputation(instr)) {
    // Show layout of instructions with more than one dimension.  Don't show
    // layout on tuples or tensors with just one dimension (which only have one
    // possible layout) to avoid visual noise.
    bool shape_is_multidim = false;
    ShapeUtil::ForEachSubshape(instr->shape(),
                               [&](const Shape& s, const ShapeIndex&) {
                                 shape_is_multidim |= s.dimensions_size() > 1;
                               });
    std::string instr_shape;
    if (instr->opcode() != HloOpcode::kTuple && shape_is_multidim) {
      instr_shape = ShapeUtil::HumanStringWithLayout(instr->shape());
    } else {
      instr_shape = ShapeUtil::HumanString(instr->shape());
    }

    // Some instructions have giant tuples as their shapes, so truncate the
    // HLO's shape to kMaxShapeLen characters.
    constexpr int kMaxShapeLen = 64;
    if (instr_shape.length() > kMaxShapeLen) {
      instr_shape = StrCat(
          absl::string_view(instr_shape).substr(0, kMaxShapeLen - 3), "...");
    }
    lines.push_back(HtmlLikeStringSanitize(instr_shape));
  }
  if (debug_options_.xla_hlo_graph_addresses()) {
    lines.push_back(StrFormat("[%p]", instr));
  }
  return StrJoin(lines, "<br/>");
}
