pci_xhci_device_doorbell(struct pci_xhci_vdev *xdev,
			 uint32_t slot,
			 uint32_t epid,
			 uint32_t streamid)
{
	struct pci_xhci_dev_emu *dev;
	struct pci_xhci_dev_ep	*devep;
	struct xhci_dev_ctx	*dev_ctx;
	struct xhci_endp_ctx	*ep_ctx;
	struct pci_xhci_trb_ring *sctx_tr;
	struct xhci_trb	*trb;
	uint64_t	ringaddr;
	uint32_t	ccs;

	UPRINTF(LDBG, "doorbell slot %u epid %u stream %u\r\n",
		slot, epid, streamid);

	if (slot <= 0 || slot > XHCI_MAX_SLOTS || !xdev->slot_allocated[slot]) {
		UPRINTF(LWRN, "invalid doorbell slot %u\r\n", slot);
		return;
	}

	dev = XHCI_SLOTDEV_PTR(xdev, slot);
	if (!dev)
		return;

	devep = &dev->eps[epid];
	dev_ctx = pci_xhci_get_dev_ctx(xdev, slot);
	if (!dev_ctx)
		return;
	ep_ctx = &dev_ctx->ctx_ep[epid];

	sctx_tr = NULL;

	UPRINTF(LDBG, "device doorbell ep[%u] %08x %08x %016lx %08x\r\n",
		epid, ep_ctx->dwEpCtx0, ep_ctx->dwEpCtx1, ep_ctx->qwEpCtx2,
		ep_ctx->dwEpCtx4);

	if (ep_ctx->qwEpCtx2 == 0)
		return;

	/*
	 * In USB emulation with port mapping, the following transfer should
	 * NOT be called, or else the interrupt transfer will result
	 * of invalid and infinite loop. It is used by usb_mouse.c only.
	 */
	/* handle pending transfers */
	if (dev->dev_ue && dev->dev_ue->ue_devtype == USB_DEV_STATIC &&
			devep->ep_xfer->ndata > 0) {
		pci_xhci_try_usb_xfer(xdev, dev, devep, ep_ctx, slot, epid);
		return;
	}

	/* get next trb work item */
	if (XHCI_EPCTX_0_MAXP_STREAMS_GET(ep_ctx->dwEpCtx0) != 0) {
		sctx_tr = &devep->ep_sctx_trbs[streamid];
		ringaddr = sctx_tr->ringaddr;
		ccs = sctx_tr->ccs;
		trb = XHCI_GADDR(xdev, sctx_tr->ringaddr & ~0xFUL);
		if (!trb) {
			UPRINTF(LDBG, "Invalid gpa 0x%lx in write device doorbell!\r\n",
				sctx_tr->ringaddr & ~0xFUL);
			return;
		}
		UPRINTF(LDBG, "doorbell, stream %u, ccs %lx, trb ccs %x\r\n",
			streamid, ep_ctx->qwEpCtx2 & XHCI_TRB_3_CYCLE_BIT,
			trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT);
	} else {
		ringaddr = devep->ep_ringaddr;
		ccs = devep->ep_ccs;
		trb = devep->ep_tr;
		UPRINTF(LDBG, "doorbell, ccs %lx, trb ccs %x\r\n",
			ep_ctx->qwEpCtx2 & XHCI_TRB_3_CYCLE_BIT,
			trb->dwTrb3 & XHCI_TRB_3_CYCLE_BIT);
	}

	if (XHCI_TRB_3_TYPE_GET(trb->dwTrb3) == 0) {
		UPRINTF(LDBG, "ring %lx trb[%lx] EP %u is RESERVED?\r\n",
			ep_ctx->qwEpCtx2, devep->ep_ringaddr, epid);
		return;
	}

	pci_xhci_handle_transfer(xdev, dev, devep, ep_ctx, trb, slot, epid,
				 ringaddr, ccs, streamid);
}
