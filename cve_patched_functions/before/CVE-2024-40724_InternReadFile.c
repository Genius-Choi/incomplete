void PLYImporter::InternReadFile(const std::string &pFile, aiScene *pScene, IOSystem *pIOHandler) {
    const std::string mode = "rb";
    std::unique_ptr<IOStream> fileStream(pIOHandler->Open(pFile, mode));
    if (!fileStream) {
        throw DeadlyImportError("Failed to open file ", pFile, ".");
    }

    // Get the file-size
    const size_t fileSize(fileStream->FileSize());
    if (0 == fileSize) {
        throw DeadlyImportError("File ", pFile, " is empty.");
    }

    IOStreamBuffer<char> streamedBuffer(1024 * 1024);
    streamedBuffer.open(fileStream.get());

    // the beginning of the file must be PLY - magic, magic
    std::vector<char> headerCheck;
    streamedBuffer.getNextLine(headerCheck);

    if ((headerCheck.size() < 3) ||
            (headerCheck[0] != 'P' && headerCheck[0] != 'p') ||
            (headerCheck[1] != 'L' && headerCheck[1] != 'l') ||
            (headerCheck[2] != 'Y' && headerCheck[2] != 'y')) {
        streamedBuffer.close();
        throw DeadlyImportError("Invalid .ply file: Incorrect magic number (expected 'ply' or 'PLY').");
    }

    std::vector<char> mBuffer2;
    streamedBuffer.getNextLine(mBuffer2);
    mBuffer = (unsigned char *)&mBuffer2[0];

    char *szMe = (char *)&this->mBuffer[0];
    const char *end = &mBuffer2[0] + mBuffer2.size();
    SkipSpacesAndLineEnd(szMe, (const char **)&szMe, end);

    // determine the format of the file data and construct the aiMesh
    PLY::DOM sPlyDom;
    this->pcDOM = &sPlyDom;

    if (TokenMatch(szMe, "format", 6)) {
        if (TokenMatch(szMe, "ascii", 5)) {
            SkipLine(szMe, (const char **)&szMe, end);
            if (!PLY::DOM::ParseInstance(streamedBuffer, &sPlyDom, this)) {
                if (mGeneratedMesh != nullptr) {
                    delete (mGeneratedMesh);
                    mGeneratedMesh = nullptr;
                }

                streamedBuffer.close();
                throw DeadlyImportError("Invalid .ply file: Unable to build DOM (#1)");
            }
        } else if (!::strncmp(szMe, "binary_", 7)) {
            szMe += 7;
            const bool bIsBE(isBigEndian(szMe));

            // skip the line, parse the rest of the header and build the DOM
            if (!PLY::DOM::ParseInstanceBinary(streamedBuffer, &sPlyDom, this, bIsBE)) {
                if (mGeneratedMesh != nullptr) {
                    delete (mGeneratedMesh);
                    mGeneratedMesh = nullptr;
                }

                streamedBuffer.close();
                throw DeadlyImportError("Invalid .ply file: Unable to build DOM (#2)");
            }
        } else {
            if (mGeneratedMesh != nullptr) {
                delete (mGeneratedMesh);
                mGeneratedMesh = nullptr;
            }

            streamedBuffer.close();
            throw DeadlyImportError("Invalid .ply file: Unknown file format");
        }
    } else {
        AI_DEBUG_INVALIDATE_PTR(this->mBuffer);
        if (mGeneratedMesh != nullptr) {
            delete (mGeneratedMesh);
            mGeneratedMesh = nullptr;
        }

        streamedBuffer.close();
        throw DeadlyImportError("Invalid .ply file: Missing format specification");
    }

    // free the file buffer
    streamedBuffer.close();

    if (mGeneratedMesh == nullptr) {
        throw DeadlyImportError("Invalid .ply file: Unable to extract mesh data ");
    }

    // if no face list is existing we assume that the vertex
    // list is containing a list of points
    bool pointsOnly = mGeneratedMesh->mFaces == nullptr ? true : false;
    if (pointsOnly) {
        mGeneratedMesh->mPrimitiveTypes = aiPrimitiveType::aiPrimitiveType_POINT;
    }

    // now load a list of all materials
    std::vector<aiMaterial *> avMaterials;
    std::string defaultTexture;
    LoadMaterial(&avMaterials, defaultTexture, pointsOnly);

    // now generate the output scene object. Fill the material list
    pScene->mNumMaterials = (unsigned int)avMaterials.size();
    pScene->mMaterials = new aiMaterial *[pScene->mNumMaterials];
    for (unsigned int i = 0; i < pScene->mNumMaterials; ++i) {
        pScene->mMaterials[i] = avMaterials[i];
    }

    // fill the mesh list
    pScene->mNumMeshes = 1;
    pScene->mMeshes = new aiMesh *[pScene->mNumMeshes];
    pScene->mMeshes[0] = mGeneratedMesh;
    mGeneratedMesh = nullptr;

    // generate a simple node structure
    pScene->mRootNode = new aiNode();
    pScene->mRootNode->mNumMeshes = pScene->mNumMeshes;
    pScene->mRootNode->mMeshes = new unsigned int[pScene->mNumMeshes];

    for (unsigned int i = 0; i < pScene->mRootNode->mNumMeshes; ++i) {
        pScene->mRootNode->mMeshes[i] = i;
    }
}
