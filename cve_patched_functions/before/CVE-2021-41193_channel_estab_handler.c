static void channel_estab_handler(struct iflow *iflow, void *arg)
{
	struct ecall *ecall = arg;
	int err = 0;

	assert(ECALL_MAGIC == ecall->magic);

	if (iflow != ecall->flow) {
		info("ecall(%p): ignoring %s on wrong flow\n", ecall, __FUNCTION__);
		return;
	}
	info("ecall(%p): data channel established\n", ecall);

	tmr_cancel(&ecall->dc_tmr);

	econn_set_datachan_established(ecall->econn);

	if (ecall->delayed_restart) {
		ecall->delayed_restart = false;
		ecall_restart(ecall, ecall->call_type);
		return;
	}

	/* Update the cbr status */
	if (IFLOW_CALLE(ecall->flow, get_audio_cbr, true)){
		err = econn_props_update(ecall->props_local,
					 "audiocbr", "true");
		if (err) {
			warning("ecall: econn_props_update(audiocbr)",
			        " failed (%m)\n", err);
			goto error;
		}
	}

	/* sync the properties to the remote peer */
	if (!ecall->devpair
	    && econn_can_send_propsync(ecall->econn)) {
		err = econn_send_propsync(ecall->econn, false,
					  ecall->props_local);
		if (err) {
			warning("ecall: channel_estab: econn_send_propsync"
				" failed (%m)\n", err);
			goto error;
		}
	}

	ecall->update = false;
	ecall->num_retries = 0;

	if (ecall->icall.audio_levelh) {
		tmr_start(&ecall->audio.level.tmr, TIMEOUT_AUDIO_LEVEL,
			  audio_level_handler, ecall);
	}
	
	ICALL_CALL_CB(ecall->icall, datachan_estabh,
		&ecall->icall, ecall->userid_peer, ecall->clientid_peer,
		ecall->update, ecall->icall.arg);

	return;

 error:
	ecall_close(ecall, err, ECONN_MESSAGE_TIME_UNKNOWN);
}
