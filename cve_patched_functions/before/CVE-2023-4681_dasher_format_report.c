void dasher_format_report(GF_Filter *filter, GF_DasherCtx *ctx)
{
	u32 i, count, nb_pc=0;
	Double max_ts=0;
	u32 total_pc = 0;
	char szDS[200];
	char *szStatus = NULL;

	if (!gf_filter_reporting_enabled(filter))
		return;
	if (!ctx->update_report)
		return;
	//don't update at each packet, this would be too much
	if ((ctx->update_report>0) && (ctx->update_report < 20))
		return;

	ctx->update_report = 0;

	sprintf(szDS, "P%s", ctx->current_period->period->ID ? ctx->current_period->period->ID : "1");
	gf_dynstrcat(&szStatus, szDS, NULL);

	count = gf_list_count(ctx->current_period->streams);
	for (i=0; i<count; i++) {
		s32 pc=-1;
		Double mpdtime;
		u32 set_idx;
		u32 rep_idx;
		u8 stype;
		GF_DashStream *ds = gf_list_get(ctx->current_period->streams, i);
		if (ds->muxed_base) continue;

		set_idx = 1 + gf_list_find(ctx->current_period->period->adaptation_sets, ds->set);
		rep_idx = 1 + gf_list_find(ds->set->representations, ds->rep);
		if (ds->stream_type==GF_STREAM_VISUAL) stype='V';
		else if (ds->stream_type==GF_STREAM_AUDIO) stype='A';
		else if (ds->stream_type==GF_STREAM_TEXT) stype='T';
		else stype='M';

		if (ds->done || ds->subdur_done) {
			sprintf(szDS, "AS#%d.%d(%c) done (%d segs)", set_idx, rep_idx, stype, ds->seg_number);
			pc = 10000;
		} else {
			Double done;
			if (ctx->cues) {
				done = (Double) (ds->last_dts);
				done /= ds->timescale;
				snprintf(szDS, 200, "AS#%d.%d(%c) seg #%d %02.2fs", set_idx, rep_idx, stype, ds->seg_number, done);
			} else {
				Double pcent, ddur;
				done = (Double) ds->adjusted_next_seg_start;
				done -= (Double) ds->last_dts;
				if (done<0)
					done=0;
				done /= ds->timescale;
				ddur = ((Double)ds->dash_dur.num) / ds->dash_dur.den;
				done = ddur - done;
				//this may happen since we don't print info at segment start
				if (done<0)
					done=0;
				pcent = done / ddur;
				pc = (s32) (done * 10000);
				snprintf(szDS, 200, "AS#%d.%d(%c) seg #%d %02.2fs (%02.2f %%)", set_idx, rep_idx, stype, ds->seg_number, done, 100*pcent);
			}

			mpdtime = (Double) ds->last_dts;
			mpdtime -= (Double) ds->first_dts;
			if (mpdtime<0) mpdtime=0;
			mpdtime /= ds->timescale;

			if (ds->duration.den && ds->duration.num) {
				done = mpdtime;

				done *= ds->duration.den;
				done /= ds->duration.num;
				pc = (u32) (10000*done);
			}
			if (max_ts<mpdtime)
				max_ts = mpdtime;
		}
		//don't use max, do an average
		total_pc += pc;
		nb_pc++;
		gf_dynstrcat(&szStatus, szDS, " ");
	}
	if (nb_pc)
		total_pc /= nb_pc;

	if (total_pc!=10000) {
		sprintf(szDS, " / MPD %.2fs %d %%", max_ts, total_pc/100);
		gf_dynstrcat(&szStatus, szDS, NULL);
	}
	gf_filter_update_status(filter, total_pc, szStatus);
	gf_free(szStatus);
}
