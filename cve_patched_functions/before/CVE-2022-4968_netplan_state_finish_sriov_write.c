netplan_state_finish_sriov_write(const NetplanState* np_state, const char* rootdir, __unused GError** error)
{
    NetplanNetDefinition* def = NULL;
    NetplanNetDefinition* pf = NULL;
    gboolean any_sriov = FALSE;
    gboolean ret = TRUE;

    if (np_state) {
        GHashTable* rebind_pfs = g_hash_table_new(g_str_hash, g_str_equal);
        GHashTable* apply_pfs = g_hash_table_new(g_str_hash, g_str_equal);

        /* Find netdev interface names for SR-IOV PFs
         * We consider an interface to be a PF if at least of the conditions below is true:
         * 1) the user explicitly set a desired number of VFs
         * 2) there is at least one interface with a link to it (meaning the interface is a VF of this PF)
         * 3) the user set the embedded-switch-mode (which can be applied regardless if the interface has VFs) 
         * */
        for (GList* iterator = np_state->netdefs_ordered; iterator; iterator = iterator->next) {
            def = (NetplanNetDefinition*) iterator->data;
            pf = NULL;
            if (def->sriov_explicit_vf_count < G_MAXUINT || def->sriov_link || def->embedded_switch_mode) {
                any_sriov = TRUE;
                if (def->sriov_explicit_vf_count < G_MAXUINT || def->embedded_switch_mode)
                    pf = def;
                else if (def->sriov_link)
                    pf = def->sriov_link;

                if (pf) {
                    if (pf->set_name)
                        g_hash_table_add(apply_pfs, pf->set_name);
                    else if (!pf->has_match) /* netdef_id == interface name */
                        g_hash_table_add(apply_pfs, pf->id);
                    else
                        g_warning("%s: Cannot determine SR-IOV PF interface name.", pf->id);
                }
            }

            if (pf && pf->sriov_delay_virtual_functions_rebind) {
                if (pf->set_name)
                    g_hash_table_add(rebind_pfs, pf->set_name);
                else if (!pf->has_match) /* netdef_id == interface name */
                    g_hash_table_add(rebind_pfs, pf->id);
                else
                    g_warning("%s: Cannot rebind SR-IOV virtual functions, unknown interface name. "
                              "Use 'netplan rebind <IFACE>' to rebind manually or use the 'set-name' stanza.",
                              pf->id);
            }
        }

        if (any_sriov) {
            ret = write_sriov_apply_systemd_unit(apply_pfs, rootdir, NULL);
            if (!ret) {
                // LCOV_EXCL_START
                g_warning("netplan-sriov-apply.service cannot be created.");
                goto error;
                // LCOV_EXCL_STOP
            }

            /*
             * The sriov-apply service will always be created (as long as there is any sr-iov configuration)
             * and the sriov-rebind MUST only run after apply. As sriov-apply will always be there if sriov-rebind
             * is present, using the After= dependency statement is enough (Requires= is not necessary).
            */
            if (g_hash_table_size(rebind_pfs) > 0) {
                ret = write_sriov_rebind_systemd_unit(rebind_pfs, rootdir, NULL);
                if (!ret)
                // LCOV_EXCL_START
                    g_warning("netplan-sriov-rebind.service cannot be created.");
                // LCOV_EXCL_STOP
            }
        }

error:
        g_hash_table_destroy(rebind_pfs);
        g_hash_table_destroy(apply_pfs);
    }

    return ret;
}
