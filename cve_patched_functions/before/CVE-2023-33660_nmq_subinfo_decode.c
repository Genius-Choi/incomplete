nmq_subinfo_decode(nng_msg *msg, void *l, uint8_t ver)
{
	char           *topic;
	uint8_t         *payload_ptr, *var_ptr;
	uint32_t        num = 0, len, len_of_varint = 0, len_of_str = 0, subid = 0;
	uint16_t        len_of_topic = 0;
	size_t          bpos = 0, remain = 0;
	struct subinfo *sn = NULL;
	nni_list       *ll = l;

	if (!l || !msg)
		return (-1);

	var_ptr = nni_msg_body(msg);
	len = 0;
	len_of_varint = 0;
	// get variable length of properties
	if (ver == MQTT_PROTOCOL_VERSION_v5) {
		len = get_var_integer(
		    (uint8_t *) nni_msg_body(msg) + 2, &len_of_varint);
		if (len > nni_msg_remaining_len(msg))
			return -1;
	}
	log_trace("prop len %d varint %d remain %d", len, len_of_varint, nni_msg_remaining_len(msg));
	payload_ptr = (uint8_t *) nni_msg_body(msg) + 2 + len + len_of_varint;

	int pos = 2 + len_of_varint, target_pos = 2 + len_of_varint + len;
	while (pos < target_pos) {
		switch (*(var_ptr + pos)) {
		case USER_PROPERTY:
			// key
			NNI_GET16(var_ptr + pos, len_of_str);
			pos += len_of_str;
			if (pos > target_pos)
				return (-3);
			len_of_str = 0;
			// value
			NNI_GET16(var_ptr + pos, len_of_str);
			pos += len_of_str;
			if (pos > target_pos)
				return (-3);
			len_of_str = 0;
			break;
		case SUBSCRIPTION_IDENTIFIER:
			subid = get_var_integer(var_ptr + pos, &len_of_varint);
			if (subid == 0)
				return (-1);
			pos += len_of_varint;
			break;
		default:
			log_error("Invalid property id");
			return (-2);
		}
	}
	if (pos > target_pos)
		return (-2);

	remain = nni_msg_remaining_len(msg) - target_pos;

	while (bpos < remain) {
		// Check the index of topic len
		if (bpos + 2 > remain)
			return (-3);
		NNI_GET16(payload_ptr + bpos, len_of_topic);
		if (len_of_str > remain)
			return -1;
		bpos += 2;

		if (len_of_topic == 0)
			continue;
		// Check the index of topic body
		if (bpos + len_of_topic > remain)
			return (-3);

		log_trace(
		    "The current process topic is %s", payload_ptr + bpos);
		if ((sn = nng_alloc(sizeof(struct subinfo))) == NULL)
			return (-2);
		if ((topic = nng_alloc(len_of_topic + 1)) == NULL)
			return (-2);

		strncpy(topic, (char *) payload_ptr + bpos, len_of_topic);
		topic[len_of_topic] = 0x00;

		sn->topic = topic;
		bpos += len_of_topic;
		// Check the index of topic option
		if (bpos > remain)
			return (-3);

		sn->subid = subid;
		// qos no_local rap retain_handling
		sn->qos      = (uint8_t) ((0x03 & *(payload_ptr + bpos)));
		sn->no_local = (uint8_t) ((0x04 & *(payload_ptr + bpos)));
		sn->rap      = (uint8_t) ((0x08 & *(payload_ptr + bpos)) > 0);
		sn->retain_handling = (uint8_t) ((0x1f & *(payload_ptr + bpos)));
		memcpy(sn, payload_ptr + bpos, 1);
		NNI_LIST_NODE_INIT(&sn->node);

		if (0 != nmq_subinfol_add_or(ll, sn)) {
			// already exists
			nng_free(sn->topic, strlen(sn->topic));
			nng_free(sn, sizeof(*sn));
		}

		bpos += 1;
		num++;
	}

	return num;
}
