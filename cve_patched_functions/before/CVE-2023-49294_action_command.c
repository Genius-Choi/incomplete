static int action_command(struct mansession *s, const struct message *m)
{
	const char *cmd = astman_get_header(m, "Command");
	char *buf = NULL, *final_buf = NULL, *delim, *output;
	char template[] = "/tmp/ast-ami-XXXXXX";	/* template for temporary file */
	int fd, ret;
	off_t len;

	if (ast_strlen_zero(cmd)) {
		astman_send_error(s, m, "No command provided");
		return 0;
	}

	if (check_blacklist(cmd)) {
		astman_send_error(s, m, "Command blacklisted");
		return 0;
	}

	if ((fd = mkstemp(template)) < 0) {
		astman_send_error_va(s, m, "Failed to create temporary file: %s", strerror(errno));
		return 0;
	}

	ret = ast_cli_command(fd, cmd);
	astman_send_response_full(s, m, ret == RESULT_SUCCESS ? "Success" : "Error", MSG_MOREDATA, NULL);

	/* Determine number of characters available */
	if ((len = lseek(fd, 0, SEEK_END)) < 0) {
		astman_append(s, "Message: Failed to determine number of characters: %s\r\n", strerror(errno));
		goto action_command_cleanup;
	}

	/* This has a potential to overflow the stack.  Hence, use the heap. */
	buf = ast_malloc(len + 1);
	final_buf = ast_malloc(len + 1);

	if (!buf || !final_buf) {
		astman_append(s, "Message: Memory allocation failure\r\n");
		goto action_command_cleanup;
	}

	if (lseek(fd, 0, SEEK_SET) < 0) {
		astman_append(s, "Message: Failed to set position on temporary file: %s\r\n", strerror(errno));
		goto action_command_cleanup;
	}

	if (read(fd, buf, len) < 0) {
		astman_append(s, "Message: Failed to read from temporary file: %s\r\n", strerror(errno));
		goto action_command_cleanup;
	}

	buf[len] = '\0';
	term_strip(final_buf, buf, len);
	final_buf[len] = '\0';

	/* Trim trailing newline */
	if (len && final_buf[len - 1] == '\n') {
		final_buf[len - 1] = '\0';
	}

	astman_append(s, "Message: Command output follows\r\n");

	delim = final_buf;
	while ((output = strsep(&delim, "\n"))) {
		astman_append(s, "Output: %s\r\n", output);
	}

action_command_cleanup:
	astman_append(s, "\r\n");

	close(fd);
	unlink(template);

	ast_free(buf);
	ast_free(final_buf);

	return 0;
}
