R_API void r_anal_dwarf_integrate_functions(RAnal *anal, RFlag *flags, Sdb *dwarf_sdb) {
	r_return_if_fail (anal && dwarf_sdb);

	/* get all entries with value == func */
	SdbList *sdb_list = sdb_foreach_list_filter (dwarf_sdb, filter_sdb_function_names, false);
	SdbListIter *it;
	SdbKv *kv;
	/* iterate all function entries */
	ls_foreach (sdb_list, it, kv) {
		char *func_sname = kv->base.key;

		char *addr_key = r_str_newf ("fcn.%s.addr", func_sname);
		ut64 faddr = sdb_num_get (dwarf_sdb, addr_key, 0);
		free (addr_key);

		/* if the function is analyzed so we can edit */
		RAnalFunction *fcn = r_anal_get_function_at (anal, faddr);
		if (fcn) {
			/* prepend dwarf debug info stuff with dbg. */
			char *real_name_key = r_str_newf ("fcn.%s.name", func_sname);
			char *real_name = sdb_get (dwarf_sdb, real_name_key, 0);
			free (real_name_key);

			char *dwf_name = r_str_newf ("dbg.%s", real_name);
			free (real_name);

			r_anal_function_rename (fcn, dwf_name);
			free (dwf_name);

			char *tmp = r_str_newf ("fcn.%s.sig", func_sname);
			char *fcnstr = sdb_get (dwarf_sdb, tmp, 0);
			free (tmp);
			/* Apply signature as a comment at a function address */
			r_meta_set_string (anal, R_META_TYPE_COMMENT, faddr, fcnstr);
			free (fcnstr);
		}
		char *var_names_key = r_str_newf ("fcn.%s.vars", func_sname);
		char *vars = sdb_get (dwarf_sdb, var_names_key, NULL);
		char *var_name;
		sdb_aforeach (var_name, vars) {
			char *var_key = r_str_newf ("fcn.%s.var.%s", func_sname, var_name);
			char *var_data = sdb_get (dwarf_sdb, var_key, NULL);
			if (!var_data) {
				goto loop_end;
			}
			char *extra = NULL;
			char *kind = sdb_anext (var_data, &extra);
			char *type = NULL;
			extra = sdb_anext (extra, &type);
			st64 offset = 0;
			if (*kind != 'r') {
				offset = strtol (extra, NULL, 10);
			}
			if (*kind == 'g') { /* global, fixed addr TODO add size to variables? */
				char *global_name = r_str_newf ("global_%s", var_name);
				r_flag_unset_off (flags, offset);
				r_flag_set_next (flags, global_name, offset, 4);
				free (global_name);
			} else if (*kind == 's' && fcn) {
				r_anal_function_set_var (fcn, offset - fcn->maxstack, *kind, type, 4, false, var_name);
			} else if (*kind == 'r' && fcn) {
				RRegItem *i = r_reg_get (anal->reg, extra, -1);
				if (!i) {
					goto loop_end;
				}
				r_anal_function_set_var (fcn, i->index, *kind, type, 4, false, var_name);
			} else if (fcn) { /* kind == 'b' */
				r_anal_function_set_var (fcn, offset - fcn->bp_off, *kind, type, 4, false, var_name);
			}
			free (var_key);
			free (var_data);
		loop_end:
			sdb_aforeach_next (var_name);
		}
		free (var_names_key);
		free (vars);
	}
	ls_free (sdb_list);
}
