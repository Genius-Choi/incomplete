static int decode_bgp_link_node_nlri_tlvs(tvbuff_t *tvb, proto_tree *tree, gint offset, packet_info *pinfo, guint16 expected_sub_tlv)
{
    guint16 length;
    guint16 type;
    proto_tree* tlv_tree;
    proto_item* tlv_item;

    type = tvb_get_ntohs(tvb, offset);
    length = tvb_get_ntohs(tvb, offset + 2);

    if (expected_sub_tlv != type) {
        expert_add_info_format(pinfo, tree, &ei_bgp_ls_error, "Expected/actual tlv mismatch, expected: %u, actual: %u", expected_sub_tlv, type);
    }

    switch(type){

        /*local and remote node descriptors */
        case BGP_NLRI_TLV_LOCAL_NODE_DESCRIPTORS:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_local_node_descriptors, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_mp_reach_nlri);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            decode_bgp_link_node_descriptor(tvb, tlv_tree, offset + 4, pinfo, length);
        break;

        case BGP_NLRI_TLV_REMOTE_NODE_DESCRIPTORS:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_remote_node_descriptors, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_mp_reach_nlri);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            decode_bgp_link_node_descriptor(tvb, tlv_tree, offset + 4, pinfo, length);
        break;
        }

    return length +4 ;
}
