static int drm_atomic_plane_check(const struct drm_plane_state *old_plane_state,
				  const struct drm_plane_state *new_plane_state)
{
	struct drm_plane *plane = new_plane_state->plane;
	struct drm_crtc *crtc = new_plane_state->crtc;
	const struct drm_framebuffer *fb = new_plane_state->fb;
	unsigned int fb_width, fb_height;
	struct drm_mode_rect *clips;
	uint32_t num_clips;
	int ret;

	/* either *both* CRTC and FB must be set, or neither */
	if (crtc && !fb) {
		drm_dbg_atomic(plane->dev, "[PLANE:%d:%s] CRTC set but no FB\n",
			       plane->base.id, plane->name);
		return -EINVAL;
	} else if (fb && !crtc) {
		drm_dbg_atomic(plane->dev, "[PLANE:%d:%s] FB set but no CRTC\n",
			       plane->base.id, plane->name);
		return -EINVAL;
	}

	/* if disabled, we don't care about the rest of the state: */
	if (!crtc)
		return 0;

	/* Check whether this plane is usable on this CRTC */
	if (!(plane->possible_crtcs & drm_crtc_mask(crtc))) {
		drm_dbg_atomic(plane->dev,
			       "Invalid [CRTC:%d:%s] for [PLANE:%d:%s]\n",
			       crtc->base.id, crtc->name,
			       plane->base.id, plane->name);
		return -EINVAL;
	}

	/* Check whether this plane supports the fb pixel format. */
	ret = drm_plane_check_pixel_format(plane, fb->format->format,
					   fb->modifier);
	if (ret) {
		drm_dbg_atomic(plane->dev,
			       "[PLANE:%d:%s] invalid pixel format %p4cc, modifier 0x%llx\n",
			       plane->base.id, plane->name,
			       &fb->format->format, fb->modifier);
		return ret;
	}

	/* Give drivers some help against integer overflows */
	if (new_plane_state->crtc_w > INT_MAX ||
	    new_plane_state->crtc_x > INT_MAX - (int32_t) new_plane_state->crtc_w ||
	    new_plane_state->crtc_h > INT_MAX ||
	    new_plane_state->crtc_y > INT_MAX - (int32_t) new_plane_state->crtc_h) {
		drm_dbg_atomic(plane->dev,
			       "[PLANE:%d:%s] invalid CRTC coordinates %ux%u+%d+%d\n",
			       plane->base.id, plane->name,
			       new_plane_state->crtc_w, new_plane_state->crtc_h,
			       new_plane_state->crtc_x, new_plane_state->crtc_y);
		return -ERANGE;
	}

	fb_width = fb->width << 16;
	fb_height = fb->height << 16;

	/* Make sure source coordinates are inside the fb. */
	if (new_plane_state->src_w > fb_width ||
	    new_plane_state->src_x > fb_width - new_plane_state->src_w ||
	    new_plane_state->src_h > fb_height ||
	    new_plane_state->src_y > fb_height - new_plane_state->src_h) {
		drm_dbg_atomic(plane->dev,
			       "[PLANE:%d:%s] invalid source coordinates "
			       "%u.%06ux%u.%06u+%u.%06u+%u.%06u (fb %ux%u)\n",
			       plane->base.id, plane->name,
			       new_plane_state->src_w >> 16,
			       ((new_plane_state->src_w & 0xffff) * 15625) >> 10,
			       new_plane_state->src_h >> 16,
			       ((new_plane_state->src_h & 0xffff) * 15625) >> 10,
			       new_plane_state->src_x >> 16,
			       ((new_plane_state->src_x & 0xffff) * 15625) >> 10,
			       new_plane_state->src_y >> 16,
			       ((new_plane_state->src_y & 0xffff) * 15625) >> 10,
			       fb->width, fb->height);
		return -ENOSPC;
	}

	clips = __drm_plane_get_damage_clips(new_plane_state);
	num_clips = drm_plane_get_damage_clips_count(new_plane_state);

	/* Make sure damage clips are valid and inside the fb. */
	while (num_clips > 0) {
		if (clips->x1 >= clips->x2 ||
		    clips->y1 >= clips->y2 ||
		    clips->x1 < 0 ||
		    clips->y1 < 0 ||
		    clips->x2 > fb_width ||
		    clips->y2 > fb_height) {
			drm_dbg_atomic(plane->dev,
				       "[PLANE:%d:%s] invalid damage clip %d %d %d %d\n",
				       plane->base.id, plane->name, clips->x1,
				       clips->y1, clips->x2, clips->y2);
			return -EINVAL;
		}
		clips++;
		num_clips--;
	}

	if (plane_switching_crtc(old_plane_state, new_plane_state)) {
		drm_dbg_atomic(plane->dev,
			       "[PLANE:%d:%s] switching CRTC directly\n",
			       plane->base.id, plane->name);
		return -EINVAL;
	}

	return 0;
}
