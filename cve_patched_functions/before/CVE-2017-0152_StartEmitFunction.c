void ByteCodeGenerator::StartEmitFunction(ParseNode *pnodeFnc)
{
    Assert(pnodeFnc->nop == knopFncDecl || pnodeFnc->nop == knopProg);

    FuncInfo *funcInfo = pnodeFnc->sxFnc.funcInfo;

    if (funcInfo->byteCodeFunction->IsFunctionParsed())
    {
        if (!(flags & (fscrEval | fscrImplicitThis | fscrImplicitParents)))
        {
            // Only set the environment depth if it's truly known (i.e., not in eval or event handler).
            funcInfo->GetParsedFunctionBody()->SetEnvDepth(this->envDepth);
        }

        if (pnodeFnc->sxFnc.FIBPreventsDeferral())
        {
            for (Scope *scope = this->currentScope; scope; scope = scope->GetEnclosingScope())
            {
                if (scope->GetScopeType() != ScopeType_FunctionBody && 
                    scope->GetScopeType() != ScopeType_Global &&
                    scope->GetScopeType() != ScopeType_GlobalEvalBlock &&
                    scope->GetMustInstantiate())
                {
                    funcInfo->byteCodeFunction->SetAttributes((Js::FunctionInfo::Attributes)(funcInfo->byteCodeFunction->GetAttributes() & ~Js::FunctionInfo::Attributes::CanDefer));
                    break;
                }
            }
        }
    }

    if (funcInfo->GetCallsEval())
    {
        funcInfo->byteCodeFunction->SetDontInline(true);
    }

    Scope * const funcExprScope = funcInfo->funcExprScope;
    if (funcExprScope)
    {
        if (funcInfo->GetCallsEval())
        {
            Assert(funcExprScope->GetIsObject());
        }

        if (funcExprScope->GetIsObject())
        {
            funcExprScope->SetCapturesAll(true);
            funcExprScope->SetMustInstantiate(true);
            PushScope(funcExprScope);
        }
        else
        {
            Symbol *sym = funcInfo->root->sxFnc.GetFuncSymbol();
            if (funcInfo->paramScope->GetCanMergeWithBodyScope())
            {
                funcInfo->bodyScope->AddSymbol(sym);
            }
            else
            {
                funcInfo->paramScope->AddSymbol(sym);
            }
            sym->EnsureScopeSlot(funcInfo);
        }
    }

    Scope * const bodyScope = funcInfo->GetBodyScope();
    Scope * const paramScope = funcInfo->GetParamScope();

    if (pnodeFnc->nop != knopProg)
    {
        if (!bodyScope->GetIsObject() && NeedObjectAsFunctionScope(funcInfo, pnodeFnc))
        {
            Assert(bodyScope->GetIsObject());
        }

        if (bodyScope->GetIsObject())
        {
            bodyScope->SetLocation(funcInfo->frameObjRegister);
        }
        else
        {
            bodyScope->SetLocation(funcInfo->frameSlotsRegister);
        }

        if (!paramScope->GetCanMergeWithBodyScope())
        {
            if (paramScope->GetIsObject())
            {
                paramScope->SetLocation(funcInfo->frameObjRegister);
            }
            else
            {
                paramScope->SetLocation(funcInfo->frameSlotsRegister);
            }
        }

        if (bodyScope->GetIsObject())
        {
            // Win8 908700: Disable under F12 debugger because there are too many cached scopes holding onto locals.
            funcInfo->SetHasCachedScope(
                !PHASE_OFF(Js::CachedScopePhase, funcInfo->byteCodeFunction) &&
                !funcInfo->Escapes() &&
                funcInfo->frameObjRegister != Js::Constants::NoRegister &&
                !ApplyEnclosesArgs(pnodeFnc, this) &&
                funcInfo->paramScope->GetCanMergeWithBodyScope() && // There is eval in the param scope
                (PHASE_FORCE(Js::CachedScopePhase, funcInfo->byteCodeFunction) || !IsInDebugMode())
#if ENABLE_TTD
                && !funcInfo->GetParsedFunctionBody()->GetScriptContext()->GetThreadContext()->IsRuntimeInTTDMode()
#endif
            );

            if (funcInfo->GetHasCachedScope())
            {
                Assert(funcInfo->funcObjRegister == Js::Constants::NoRegister);
                Symbol *funcSym = funcInfo->root->sxFnc.GetFuncSymbol();
                if (funcSym && funcSym->GetIsFuncExpr())
                {
                    if (funcSym->GetLocation() == Js::Constants::NoRegister)
                    {
                        funcInfo->funcObjRegister = funcInfo->NextVarRegister();
                    }
                    else
                    {
                        funcInfo->funcObjRegister = funcSym->GetLocation();
                    }
                }
                else
                {
                    funcInfo->funcObjRegister = funcInfo->NextVarRegister();
                }
                Assert(funcInfo->funcObjRegister != Js::Constants::NoRegister);
            }

            ParseNode *pnode;
            Symbol *sym;

            if (funcInfo->GetHasArguments())
            {
                // Process function's formal parameters
                MapFormals(pnodeFnc, [&](ParseNode *pnode)
                {
                    if (pnode->IsVarLetOrConst())
                    {
                        pnode->sxVar.sym->EnsureScopeSlot(funcInfo);
                    }
                });

                MapFormalsFromPattern(pnodeFnc, [&](ParseNode *pnode) { pnode->sxVar.sym->EnsureScopeSlot(funcInfo); });

                // Only allocate scope slot for "arguments" when really necessary. "hasDeferredChild"
                // doesn't require scope slot for "arguments" because inner functions can't access
                // outer function's arguments directly.
                sym = funcInfo->GetArgumentsSymbol();
                Assert(sym);
                if (sym->NeedsSlotAlloc(funcInfo))
                {
                    sym->EnsureScopeSlot(funcInfo);
                }
            }

            sym = funcInfo->root->sxFnc.GetFuncSymbol();

            if (sym && sym->NeedsSlotAlloc(funcInfo))
            {
                if (funcInfo->funcExprScope && funcInfo->funcExprScope->GetIsObject())
                {
                    sym->SetScopeSlot(0);
                }
                else if (funcInfo->GetFuncExprNameReference())
                {
                    sym->EnsureScopeSlot(funcInfo);
                }
            }

            if (!funcInfo->GetHasArguments())
            {
                Symbol *formal;
                Js::ArgSlot pos = 1;
                auto moveArgToReg = [&](ParseNode *pnode)
                {
                    if (pnode->IsVarLetOrConst())
                    {
                        formal = pnode->sxVar.sym;
                        // Get the param from its argument position into its assigned register.
                        // The position should match the location; otherwise, it has been shadowed by parameter with the same name.
                        if (formal->GetLocation() + 1 == pos)
                        {
                            pnode->sxVar.sym->EnsureScopeSlot(funcInfo);
                        }
                    }
                    pos++;
                };
                MapFormals(pnodeFnc, moveArgToReg);
                MapFormalsFromPattern(pnodeFnc, [&](ParseNode *pnode) { pnode->sxVar.sym->EnsureScopeSlot(funcInfo); });
            }

            this->EnsureSpecialScopeSlots(funcInfo, bodyScope);

            auto ensureFncDeclScopeSlots = [&](ParseNode *pnodeScope)
            {
                for (pnode = pnodeScope; pnode;)
                {
                    switch (pnode->nop)
                    {
                    case knopFncDecl:
                        if (pnode->sxFnc.IsDeclaration())
                        {
                            EnsureFncDeclScopeSlot(pnode, funcInfo);
                        }
                        pnode = pnode->sxFnc.pnodeNext;
                        break;
                    case knopBlock:
                        pnode = pnode->sxBlock.pnodeNext;
                        break;
                    case knopCatch:
                        pnode = pnode->sxCatch.pnodeNext;
                        break;
                    case knopWith:
                        pnode = pnode->sxWith.pnodeNext;
                        break;
                    }
                }
            };
            pnodeFnc->sxFnc.MapContainerScopes(ensureFncDeclScopeSlots);

            for (pnode = pnodeFnc->sxFnc.pnodeVars; pnode; pnode = pnode->sxVar.pnodeNext)
            {
                sym = pnode->sxVar.sym;
                if (!(pnode->sxVar.isBlockScopeFncDeclVar && sym->GetIsBlockVar()))
                {
                    if (sym->GetIsCatch() || (pnode->nop == knopVarDecl && sym->GetIsBlockVar()))
                    {
                        sym = funcInfo->bodyScope->FindLocalSymbol(sym->GetName());
                    }
                    if (sym->GetSymbolType() == STVariable && !sym->GetIsArguments()
                        && (!funcInfo->IsInnerArgumentsSymbol(sym) || funcInfo->GetHasArguments()))
                    {
                        sym->EnsureScopeSlot(funcInfo);
                    }
                }
            }

            if (pnodeFnc->sxFnc.pnodeBody)
            {
                Assert(pnodeFnc->sxFnc.pnodeScopes->nop == knopBlock);
                this->EnsureLetConstScopeSlots(pnodeFnc->sxFnc.pnodeBodyScope, funcInfo);
            }
        }
        else
        {
            ParseNode *pnode;
            Symbol *sym;

            this->EnsureSpecialScopeSlots(funcInfo, bodyScope);

            pnodeFnc->sxFnc.MapContainerScopes([&](ParseNode *pnodeScope) { this->EnsureFncScopeSlots(pnodeScope, funcInfo); });

            for (pnode = pnodeFnc->sxFnc.pnodeVars; pnode; pnode = pnode->sxVar.pnodeNext)
            {
                sym = pnode->sxVar.sym;
                if (!(pnode->sxVar.isBlockScopeFncDeclVar && sym->GetIsBlockVar()))
                {
                    if (sym->GetIsCatch() || (pnode->nop == knopVarDecl && sym->GetIsBlockVar()))
                    {
                        sym = funcInfo->bodyScope->FindLocalSymbol(sym->GetName());
                    }
                    if (sym->GetSymbolType() == STVariable && sym->NeedsSlotAlloc(funcInfo) && !sym->GetIsArguments()
                        && (!funcInfo->IsInnerArgumentsSymbol(sym) || funcInfo->GetHasArguments()))
                    {
                        sym->EnsureScopeSlot(funcInfo);
                    }
                }
            }

            auto ensureScopeSlot = [&](ParseNode *pnode)
            {
                if (pnode->IsVarLetOrConst())
                {
                    sym = pnode->sxVar.sym;
                    if (sym->GetSymbolType() == STFormal && sym->NeedsSlotAlloc(funcInfo))
                    {
                        sym->EnsureScopeSlot(funcInfo);
                    }
                }
            };
            // Process function's formal parameters
            MapFormals(pnodeFnc, ensureScopeSlot);
            MapFormalsFromPattern(pnodeFnc, ensureScopeSlot);

            if (funcInfo->GetHasArguments())
            {
                sym = funcInfo->GetArgumentsSymbol();
                Assert(sym);

                // There is no eval so the arguments may be captured in a lambda.
                // But we cannot relay on slots getting allocated while the lambda is emitted as the function body may be reparsed.
                sym->EnsureScopeSlot(funcInfo);
            }

            if (pnodeFnc->sxFnc.pnodeBody)
            {
                this->EnsureLetConstScopeSlots(pnodeFnc->sxFnc.pnodeScopes, funcInfo);
                this->EnsureLetConstScopeSlots(pnodeFnc->sxFnc.pnodeBodyScope, funcInfo);
            }
        }

        if (!paramScope->GetCanMergeWithBodyScope() && bodyScope->GetScopeSlotCount() == 0 && !bodyScope->GetHasOwnLocalInClosure())
        {
            // When we have split scope the body scope may be wrongly marked as must instantiate even though the capture occurred
            // in param scope. This check is to make sure if no capture occurs in body scope make in not must instantiate.
            bodyScope->SetMustInstantiate(false);
        }
        else
        {
            bodyScope->SetMustInstantiate(funcInfo->frameObjRegister != Js::Constants::NoRegister || funcInfo->frameSlotsRegister != Js::Constants::NoRegister);
        }
        paramScope->SetMustInstantiate(!paramScope->GetCanMergeWithBodyScope());
    }
    else
    {
        bool newScopeForEval = (funcInfo->byteCodeFunction->GetIsStrictMode() && (this->GetFlags() & fscrEval));

        if (newScopeForEval)
        {
            Assert(bodyScope->GetIsObject());
        }
    }

    if (paramScope && !paramScope->GetCanMergeWithBodyScope())
    {
        ParseNodePtr paramBlock = pnodeFnc->sxFnc.pnodeScopes;
        Assert(paramBlock->nop == knopBlock && paramBlock->sxBlock.blockType == Parameter);

        PushScope(paramScope);

        // While emitting the functions we have to stop when we see the body scope block.
        // Otherwise functions defined in the body scope will not be able to get the right references.
        this->EmitScopeList(paramBlock->sxBlock.pnodeScopes, pnodeFnc->sxFnc.pnodeBodyScope);
        Assert(this->GetCurrentScope() == paramScope);
    }

    PushScope(bodyScope);
}
