wsemul_vt100_output_c0c1(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate, int kernel)
{
	u_int n;
	int rc = 0;

	switch (instate->inchar) {
	case ASCII_NUL:
	default:
		/* ignore */
		break;
	case ASCII_BEL:
		if (edp->state == VT100_EMUL_STATE_STRING) {
			/* acts as an equivalent to the ``ESC \'' string end */
			wsemul_vt100_handle_dcs(edp);
			edp->state = VT100_EMUL_STATE_NORMAL;
		} else {
			wsdisplay_emulbell(edp->cbcookie);
		}
		break;
	case ASCII_BS:
		if (edp->ccol > 0) {
			edp->ccol--;
			edp->flags &= ~VTFL_LASTCHAR;
		}
		break;
	case ASCII_CR:
		edp->ccol = 0;
		break;
	case ASCII_HT:
		if (edp->tabs) {
			if (!COLS_LEFT)
				break;
			for (n = edp->ccol + 1; n < NCOLS - 1; n++)
				if (edp->tabs[n])
					break;
		} else {
			n = edp->ccol + min(8 - (edp->ccol & 7), COLS_LEFT);
		}
		edp->ccol = n;
		break;
	case ASCII_SO: /* LS1 */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab0 = 1;
		break;
	case ASCII_SI: /* LS0 */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab0 = 0;
		break;
	case ASCII_ESC:
		if (kernel) {
			printf("wsemul_vt100_output_c0c1: ESC in kernel "
			    "output ignored\n");
			break;	/* ignore the ESC */
		}

		if (edp->state == VT100_EMUL_STATE_STRING) {
			/* might be a string end */
			edp->state = VT100_EMUL_STATE_STRING_ESC;
		} else {
			/* XXX cancel current escape sequence */
			edp->state = VT100_EMUL_STATE_ESC;
		}
		break;
	case ASCII_CAN:
	case ASCII_SUB:
		/* cancel current escape sequence */
		edp->state = VT100_EMUL_STATE_NORMAL;
		break;
	case ASCII_LF:
	case ASCII_VT:
	case ASCII_FF:
		rc = wsemul_vt100_nextline(edp);
		break;
	}

	if (COLS_LEFT != 0)
		edp->flags &= ~VTFL_LASTCHAR;

	return rc;
}
