x509_verify_build_chains(struct x509_verify_ctx *ctx, X509 *cert,
    struct x509_verify_chain *current_chain, int full_chain, char *name)
{
	X509 *candidate;
	int i, depth, count, ret, is_root;

	/*
	 * If we are finding chains with an xsc, just stop after we have
	 * one chain, there's no point in finding more, it just exercises
	 * the potentially buggy callback processing in the calling software.
	 */
	if (ctx->xsc != NULL && ctx->chains_count > 0)
		return;

	depth = sk_X509_num(current_chain->certs);
	if (depth > 0)
		depth--;

	if (depth >= ctx->max_depth &&
	    !x509_verify_cert_error(ctx, cert, depth,
		X509_V_ERR_CERT_CHAIN_TOO_LONG, 0))
		return;

	count = ctx->chains_count;

	ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;
	ctx->error_depth = depth;

	if (ctx->saved_error != 0)
		ctx->error = ctx->saved_error;
	if (ctx->saved_error_depth != 0)
		ctx->error_depth = ctx->saved_error_depth;

	if (ctx->xsc != NULL) {
		/*
		 * Long ago experiments at Muppet labs resulted in a
		 * situation where software not only sees these errors
		 * but forced developers to expect them in certain cases.
		 * so we must mimic this awfulness for the legacy case.
		 */
		if (cert->ex_flags & EXFLAG_SS)
			ctx->error = (depth == 0) ?
			    X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:
			    X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;
	}

	/* Check for legacy mode roots */
	if (ctx->xsc != NULL) {
		if ((ret = ctx->xsc->get_issuer(&candidate, ctx->xsc, cert)) < 0) {
			x509_verify_cert_error(ctx, cert, depth,
			    X509_V_ERR_STORE_LOOKUP, 0);
			return;
		}
		if (ret > 0) {
			if (x509_verify_potential_parent(ctx, candidate, cert)) {
				is_root = x509_verify_check_chain_end(candidate,
				    full_chain);
				x509_verify_consider_candidate(ctx, cert,
				    is_root, candidate, current_chain,
				    full_chain, name);
			}
			X509_free(candidate);
		}
	} else {
		/* Check to see if we have a trusted root issuer. */
		for (i = 0; i < sk_X509_num(ctx->roots); i++) {
			candidate = sk_X509_value(ctx->roots, i);
			if (x509_verify_potential_parent(ctx, candidate, cert)) {
				is_root = x509_verify_check_chain_end(candidate,
				    full_chain);
				x509_verify_consider_candidate(ctx, cert,
				    is_root, candidate, current_chain,
				    full_chain, name);
			}
		}
	}

	/* Check intermediates after checking roots */
	if (ctx->intermediates != NULL) {
		for (i = 0; i < sk_X509_num(ctx->intermediates); i++) {
			candidate = sk_X509_value(ctx->intermediates, i);
			if (x509_verify_potential_parent(ctx, candidate, cert)) {
				x509_verify_consider_candidate(ctx, cert,
				    0, candidate, current_chain,
				    full_chain, name);
			}
		}
	}

	if (ctx->chains_count > count) {
		if (ctx->xsc != NULL) {
			ctx->xsc->error = X509_V_OK;
			ctx->xsc->error_depth = depth;
			ctx->xsc->current_cert = cert;
		}
	} else if (ctx->error_depth == depth) {
		if (!x509_verify_ctx_set_xsc_chain(ctx, current_chain, 0, 0))
			return;
	}
}
