GF_Err rfc_6381_get_codec_hevc(char *szCodec, u32 subtype, GF_HEVCConfig *hvcc)
{
	u8 c;
	char szTemp[RFC6381_CODEC_NAME_SIZE_MAX];
	assert(hvcc);

	snprintf(szCodec, RFC6381_CODEC_NAME_SIZE_MAX, "%s.", gf_4cc_to_str(subtype));
	if (hvcc->profile_space==1) strcat(szCodec, "A");
	else if (hvcc->profile_space==2) strcat(szCodec, "B");
	else if (hvcc->profile_space==3) strcat(szCodec, "C");
	//profile idc encoded as a decimal number
	sprintf(szTemp, "%d", hvcc->profile_idc);
	strcat(szCodec, szTemp);
	//general profile compatibility flags: hexa, bit-reversed
	{
		u32 val = hvcc->general_profile_compatibility_flags;
		u32 i, res = 0;
		for (i=0; i<32; i++) {
			res |= val & 1;
			if (i==31) break;
			res <<= 1;
			val >>=1;
		}
		sprintf(szTemp, ".%X", res);
		strcat(szCodec, szTemp);
	}

	if (hvcc->tier_flag) strcat(szCodec, ".H");
	else strcat(szCodec, ".L");
	sprintf(szTemp, "%d", hvcc->level_idc);
	strcat(szCodec, szTemp);

	c = hvcc->progressive_source_flag << 7;
	c |= hvcc->interlaced_source_flag << 6;
	c |= hvcc->non_packed_constraint_flag << 5;
	c |= hvcc->frame_only_constraint_flag << 4;
	c |= (hvcc->constraint_indicator_flags >> 40);
	sprintf(szTemp, ".%X", c);
	strcat(szCodec, szTemp);
	if (hvcc->constraint_indicator_flags & 0xFFFFFFFF) {
		c = (hvcc->constraint_indicator_flags >> 32) & 0xFF;
		sprintf(szTemp, ".%X", c);
		strcat(szCodec, szTemp);
		if (hvcc->constraint_indicator_flags & 0x00FFFFFF) {
			c = (hvcc->constraint_indicator_flags >> 24) & 0xFF;
			sprintf(szTemp, ".%X", c);
			strcat(szCodec, szTemp);
			if (hvcc->constraint_indicator_flags & 0x0000FFFF) {
				c = (hvcc->constraint_indicator_flags >> 16) & 0xFF;
				sprintf(szTemp, ".%X", c);
				strcat(szCodec, szTemp);
				if (hvcc->constraint_indicator_flags & 0x000000FF) {
					c = (hvcc->constraint_indicator_flags >> 8) & 0xFF;
					sprintf(szTemp, ".%X", c);
					strcat(szCodec, szTemp);
					c = (hvcc->constraint_indicator_flags ) & 0xFF;
					sprintf(szTemp, ".%X", c);
					strcat(szCodec, szTemp);
				}
			}
		}
	}
	return GF_OK;
}
