int PackMachBase<T>::canUnpack()
{
    unsigned const lc_seg = lc_segment[sizeof(Addr)>>3];
    fi->seek(0, SEEK_SET);
    fi->readx(&mhdri, sizeof(mhdri));

    if (((unsigned) Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) !=mhdri.magic
    ||  my_cputype   !=mhdri.cputype
    ||  my_filetype  !=mhdri.filetype
    )
        return false;
    my_cpusubtype = mhdri.cpusubtype;

    unsigned const ncmds = mhdri.ncmds;
    int headway = (int)mhdri.sizeofcmds;
    // old style:   LC_SEGMENT + LC_UNIXTHREAD  [smaller, varies by $ARCH]
    // new style: 3*LC_SEGMENT + LC_MAIN        [larger]
    if ((2 == ncmds
        && headway < (int)(sizeof(Mach_segment_command) + 4*4))
    ||  (3 <= ncmds
        && headway < (int)(3 * sizeof(Mach_segment_command)
                    + sizeof(Mach_main_command)))) {
        infoWarning("Mach_header.sizeofcmds = %d too small", headway);
        throwCantUnpack("file corrupted");
    }
    sz_mach_headers = headway + sizeof(mhdri);
    if (2048 < headway) {
        infoWarning("Mach_header.sizeofcmds(%d) > 2048", headway);
    }
    rawmseg_buf.alloc(mhdri.sizeofcmds);
    rawmseg = (Mach_segment_command *)rawmseg_buf.getVoidPtr();
    fi->readx(rawmseg, mhdri.sizeofcmds);

    Mach_segment_command const *ptrTEXT = nullptr;
    upx_uint64_t rip = 0;
    unsigned style = 0;
    off_t offLINK = 0;
    unsigned pos_next = 0;
    unsigned nseg = 0;
    Mach_command const *ptr = (Mach_command const *)rawmseg;
    for (unsigned j= 0; j < ncmds;
            ptr = (Mach_command const *)(ptr->cmdsize + (char const *)ptr), ++j) {
        if ((unsigned)headway < ptr->cmdsize) {
                infoWarning("bad Mach_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx",
                    j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,
                    (unsigned long) file_size, (unsigned long)ptr->cmdsize);
                throwCantUnpack("file corrupted");
        }
        if (lc_seg == ptr->cmd) {
            Mach_segment_command const *const segptr = (Mach_segment_command const *)ptr;
            if ((unsigned long)file_size < segptr->filesize
            ||  (unsigned long)file_size < segptr->fileoff
            ||  (unsigned long)file_size < (segptr->filesize + segptr->fileoff)) {
                infoWarning("bad Mach_segment_command[%u]{@0x%lx,+0x%x}: file_size=0x%lx  cmdsize=0x%lx"
                      "  filesize=0x%lx  fileoff=0x%lx",
                    j, (unsigned long) (sizeof(mhdri) + ((char const *)ptr - (char const *)rawmseg)), headway,
                    (unsigned long) file_size, (unsigned long)ptr->cmdsize,
                    (unsigned long)segptr->filesize, (unsigned long)segptr->fileoff);
                throwCantUnpack("file corrupted");
            }
            ++nseg;
            if (!strcmp("__XHDR", segptr->segname)) {
                // PackHeader precedes __LINKEDIT (pre-Sierra MacOS 10.12)
                style = 391;  // UPX 3.91
            }
            if (!strcmp("__TEXT", segptr->segname)) {
                ptrTEXT = segptr;
                style = 391;  // UPX 3.91
            }
            if (!strcmp("UPX_DATA", segptr->segname)) {
                // PackHeader follows loader at __LINKEDIT (Sierra MacOS 10.12)
                style = 392;  // UPX 3.92
            }
            if (!strcmp("__LINKEDIT", segptr->segname)) {
                offLINK = segptr->fileoff;
                if (segptr->filesize == blankLINK) {
                    style = 395;
                }
                if (offLINK < (off_t) pos_next) {
                    offLINK = pos_next;
                }
            }
            pos_next = segptr->filesize + segptr->fileoff;
            if ((headway -= ptr->cmdsize) < 0) {
                infoWarning("Mach_command[%u]{@%lu}.cmdsize = %u", j,
                    (unsigned long) (sizeof(mhdri) + mhdri.sizeofcmds - (headway + ptr->cmdsize)),
                    (unsigned)ptr->cmdsize);
                throwCantUnpack("sum(.cmdsize) exceeds .sizeofcmds");
            }
        }
        else if (Mach_command::LC_UNIXTHREAD==ptr->cmd) {
            rip = entryVMA = threadc_getPC(ptr);
        }
    }
    if (3==nseg && 395 != style) { // __PAGEZERO, __TEXT, __LINKEDIT;  no __XHDR, no UPX_DATA
        style = 392;
    }
    if (391==style && 0==offLINK && 2==ncmds && ptrTEXT) { // pre-3.91 ?
        offLINK = ptrTEXT->fileoff + ptrTEXT->filesize;  // fake __LINKEDIT at EOF
    }
    if (0 == style || 0 == offLINK) {
        return false;
    }

    int const small = 32 + sizeof(overlay_offset);
    unsigned bufsize = 4096;
    if (391 == style) { // PackHeader precedes __LINKEDIT
        fi->seek(offLINK - bufsize, SEEK_SET);
    } else
    if (392 == style) {
        if (MH_DYLIB == my_filetype) {
            fi->seek(fi->st_size() - bufsize, SEEK_SET);
        }
        else { // PackHeader follows loader at __LINKEDIT
            if ((off_t)bufsize > (fi->st_size() - offLINK)) {
                bufsize = fi->st_size() - offLINK;
            }
            fi->seek(offLINK, SEEK_SET);
        }
    } else
    if (395 == style) {
        fi->seek(offLINK - bufsize - sizeof(PackHeader), SEEK_SET);
    }
    MemBuffer buf(bufsize);

    fi->readx(buf, bufsize);
    int i = bufsize;
    while (i > small && 0 == buf[--i]) { }
    i -= small;
    // allow incompressible extents
    if (i < 1 || !getPackHeader(buf + i, bufsize - i, true)) {
        // Breadcrumbs failed.
        // Pirates might overwrite the UPX! marker.  Try harder.
        upx_uint64_t const rip_off = ptrTEXT ? (rip - ptrTEXT->vmaddr) : 0;
        if (ptrTEXT && rip && rip_off < ptrTEXT->vmsize) {
            fi->seek(ptrTEXT->fileoff + rip_off, SEEK_SET);
            fi->readx(buf, bufsize);
            unsigned char const *b = &buf[0];
            unsigned disp = *(TE32 const *)&b[1];
            // Emulate the code
            if (0xe8==b[0] && disp < bufsize
            &&  0x5d==b[5+disp] && 0xe8==b[6+disp]) {
                unsigned disp2 = 0u - *(TE32 const *)&b[7+disp];
                if (disp2 < (12+disp) && 0x5b==b[11+disp-disp2]) {
                    struct b_info const *bptr = (struct b_info const *)&b[11+disp];
                    // This is the folded stub.
                    // FIXME: check b_method?
                    if (bptr->sz_cpr < bptr->sz_unc && bptr->sz_unc < 0x1000) {
                        b = bptr->sz_cpr + (unsigned char const *)(1+ bptr);
                        // FIXME: check PackHeader::putPackHeader(), packhead.cpp
                        overlay_offset = *(TE32 const *)(32 + b);
                        if (overlay_offset < 0x1000) {
                            return true;  // success
                        }
                        overlay_offset = 0;
                    }
                }
            }
        }
        if (391==style) {
            TE32 const *uptr = (TE32 const *)&buf[bufsize];
            while (0==*--uptr) /*empty*/ ;
            overlay_offset = *uptr;
            if (mhdri.sizeofcmds <= overlay_offset && overlay_offset < 0x1000) {
                return true;  // success
            }
            overlay_offset = 0;
            return false;
        }
        if (392==style) {
            overlay_offset = 0x100c;  // (l_info precedes;) p_info; b_info; cpr_data
            // p_info isn't used for execution, so it has less value for checking:
            //      0== .p_progid
            //      .p_filesize == .p_blocksize
            fi->seek(overlay_offset, SEEK_SET);
            fi->readx(buf, bufsize);
            struct p_info const *const p_ptr = (struct p_info const *)&buf[0];
            struct b_info const *const b_ptr = (struct b_info const *)(1+ p_ptr);
            TE32 const *uptr = (TE32 const *)(1+ b_ptr);
            if (b_ptr->sz_unc < 0x4000
            &&  b_ptr->sz_cpr < b_ptr->sz_unc ) {
                unsigned const method = b_ptr->b_method;
                if ((M_NRV2B_LE32 == method || M_NRV2E_LE32 == method)
                &&  (0xff>>2)==(uptr[0] >> (2+ 24))  // 1st 6 bytes are unique literals
                &&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == uptr[1]) {
                    return true;
                }
                unsigned const magic = get_te32(1+ (char const *)uptr);
                if ((M_NRV2B_8 == method || M_NRV2E_8 == method)
                && 0xfc==(0xfc & uptr[0])
                &&  (Mach_header::MH_MAGIC + (sizeof(Addr)>>3)) == magic) {
                    return true;
                }
                // FIXME: M_LZMA
            }

            overlay_offset = 0;
            // The first non-zero word scanning backwards from __LINKEDIT.fileoff
            // is the total length of compressed data which precedes it
            //(distance to l_info), so that's another method.
            fi->seek(offLINK - 0x1000, SEEK_SET);
            fi->readx(buf, 0x1000);
            unsigned const *const lo = (unsigned const *)&buf[0];
            unsigned const *p;
            for (p = (unsigned const *)&buf[0x1000]; p > lo; ) if (*--p) {
                overlay_offset  = *(TE32 const *)p;
                if ((off_t)overlay_offset < offLINK) {
                    overlay_offset = ((char const *)p - (char const *)lo) +
                        (offLINK - 0x1000) - overlay_offset + sizeof(l_info);
                    fi->seek(overlay_offset, SEEK_SET);
                    fi->readx(buf, bufsize);
                    if (b_ptr->sz_unc < 0x4000
                    &&  b_ptr->sz_cpr < b_ptr->sz_unc ) {
                        return true;
                    }
                }
            }
        }
    }

    overlay_offset = 0;  // impossible value
    int l = ph.buf_offset + ph.getPackHeaderSize();
    if (0 <= l && (unsigned)(l + sizeof(TE32)) <=bufsize) {
        overlay_offset = get_te32(buf + i + l);
    }
    if (       overlay_offset < sz_mach_headers
    ||  (off_t)overlay_offset >= file_size) {
        infoWarning("file corrupted");
        MemBuffer buf2(umin(1<<14, file_size));
        fi->seek(sz_mach_headers, SEEK_SET);
        fi->readx(buf2, buf2.getSize());
        unsigned const *p = (unsigned const *)&buf2[0];
        unsigned const *const e_buf2 = (unsigned const *)&buf2[buf2.getSize() - 4*sizeof(*p)];
        for (; p <= e_buf2; ++p)
        if (   0==p[0]  // p_info.p_progid
        &&     0!=p[1]  // p_info.p_filesize
        &&  p[2]==p[1]  // p_info.p_blocksize == p_info.p_filesize
        &&  (unsigned)file_size < get_te32(&p[1])  // compression was worthwhile
        &&  sz_mach_headers==get_te32(&p[3])  // b_info.sz_unc
        ) {
            overlay_offset = ((char const *)p - (char const *)&buf2[0]) + sz_mach_headers;
            if (!(3&overlay_offset  // not word aligned
                    ||        overlay_offset < sz_mach_headers
                    || (off_t)overlay_offset >= file_size)) {
                infoWarning("attempting recovery, overlay_offset = %#x", overlay_offset);
                return true;
            }
        }
        throwCantUnpack("file corrupted");
    }
    return true;
}
