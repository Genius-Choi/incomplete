    int SipDialogController::processResponseInsideDialog( nta_outgoing_t* orq, sip_t const* sip )  {
        DR_LOG(log_debug) << "SipDialogController::processResponseInsideDialog: "  ;
    	ostringstream o ;
        std::shared_ptr<RIP> rip  ;
        sip_method_t method = sip->sip_cseq->cs_method;
        int statusCode = sip->sip_status->st_status ;

        if( findRIPByOrq( orq, rip ) ) {
            DR_LOG(log_debug) << "SipDialogController::processResponseInsideDialog: found request for "  << sip->sip_cseq->cs_method_name << " sip status " << statusCode ;

            string encodedMessage ;
            bool truncated ;
            msg_t* msg = nta_outgoing_getresponse(orq) ;  // adds a reference
            SipMsgData_t meta( msg, orq, "network") ;
            EncodeStackMessage( sip, encodedMessage ) ;
            
            m_pController->getClientController()->route_response_inside_transaction( encodedMessage, meta, orq, sip, rip->getTransactionId(), rip->getDialogId() ) ;            

            if (method == sip_method_invite && 200 == statusCode) {
                tport_t *tp = nta_outgoing_transport(orq) ; 
                sip_session_expires_t* se = sip_session_expires(sip) ;

                // start a timerD for this successful reINVITE
                if (tport_is_dgram(tp) )m_timerDHandler.addInvite(orq);
                
                /* reset session expires timer, if provided */
                if( se ) {
                    std::shared_ptr<SipDialog> dlg ;
                    nta_leg_t* leg = nta_leg_by_call_id(m_pController->getAgent(), sip->sip_call_id->i_id);
                    DR_LOG(log_debug) << "SipDialogController::processResponseInsideDialog: searching for dialog by leg " << std::hex << (void *) leg;
                    if(leg && findDialogByLeg( leg, dlg )) {
                        DR_LOG(log_debug) << "SipDialogController::processResponseInsideDialog: (re)setting session expires timer to " <<  se->x_delta;
                        //TODO: if session-expires value is less than min-se ACK and then BYE with Reason header    
                        dlg->setSessionTimer( se->x_delta, 
                            !se->x_refresher || 0 == strcmp( se->x_refresher, "uac") ? 
                                SipDialog::we_are_refresher : 
                                SipDialog::they_are_refresher ) ;
                    }
                    else {
                        DR_LOG(log_debug) << "SipDialogController::processResponseInsideDialog: unable to find dialog for leg " << std::hex << (void *) leg;
                    }
                }
                else {
                    DR_LOG(log_debug) << "SipDialogController::processResponseInsideDialog: no session expires header found";
                }
            }
            if (rip->shouldClearDialogOnResponse()) {
                string dialogId = rip->getDialogId() ;
                if (sip->sip_cseq->cs_method == sip_method_bye && (sip->sip_status->st_status == 407 || sip->sip_status->st_status == 401)) {
                    DR_LOG(log_debug) << "SipDialogController::processResponseInsideDialog: NOT clearing dialog after receiving 401/407 response to BYE"  ;
                }
                else if( dialogId.length() > 0 ) {
                    DR_LOG(log_debug) << "SipDialogController::processResponseInsideDialog: clearing dialog after receiving response to BYE or notify w/ subscription-state terminated"  ;
                    SD_Clear(m_dialogs, dialogId ) ;
                }
                else {
                    DR_LOG(log_debug) << "SipDialogController::processResponseInsideDialog: got 200 OK to BYE but don't have dialog id"  ;
                    assert(false) ;
                }
            }
            clearRIP( orq ) ;     
            msg_destroy(msg) ;   // releases reference
        }
        else {
            DR_LOG(log_error) << "SipDialogController::processResponseInsideDialog: unable to find request associated with response"  ;            
            nta_outgoing_destroy( orq ) ;
        }
  
		return 0 ;
    }
