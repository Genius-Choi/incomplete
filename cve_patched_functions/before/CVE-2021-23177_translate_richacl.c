translate_richacl(struct archive_read_disk *a, struct archive_entry *entry,
    struct richacl *richacl)
{
	int ae_id, ae_tag, ae_perm;
	int entry_acl_type, i;
	const char *ae_name;

	struct richace *richace;

	richacl_for_each_entry(richace, richacl) {
		ae_name = NULL;
		ae_tag = 0;
		ae_perm = 0;
		ae_id = -1;

		switch (richace->e_type) {
		case RICHACE_ACCESS_ALLOWED_ACE_TYPE:
			entry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_ALLOW;
			break;
		case RICHACE_ACCESS_DENIED_ACE_TYPE:
			entry_acl_type = ARCHIVE_ENTRY_ACL_TYPE_DENY;
			break;
		default: /* Unknown entry type, skip */
			continue;
		}

		/* Unsupported */
		if (richace->e_flags & RICHACE_UNMAPPED_WHO)
			continue;

		if (richace->e_flags & RICHACE_SPECIAL_WHO) {
			switch (richace->e_id) {
			case RICHACE_OWNER_SPECIAL_ID:
				ae_tag = ARCHIVE_ENTRY_ACL_USER_OBJ;
				break;
			case RICHACE_GROUP_SPECIAL_ID:
				ae_tag = ARCHIVE_ENTRY_ACL_GROUP_OBJ;
				break;
			case RICHACE_EVERYONE_SPECIAL_ID:
				ae_tag = ARCHIVE_ENTRY_ACL_EVERYONE;
				break;
			default: /* Unknown special ID type */
				continue;
			}
		} else {
			ae_id = richace->e_id;
			if (richace->e_flags & RICHACE_IDENTIFIER_GROUP) {
				ae_tag = ARCHIVE_ENTRY_ACL_GROUP;
				ae_name = archive_read_disk_gname(&a->archive,
				    (gid_t)(richace->e_id));
			} else {
				ae_tag = ARCHIVE_ENTRY_ACL_USER;
				ae_name = archive_read_disk_uname(&a->archive,
				    (uid_t)(richace->e_id));
			}
		}
		for (i = 0; i < acl_nfs4_flag_map_size; ++i) {
			if ((richace->e_flags &
			    acl_nfs4_flag_map[i].p_perm) != 0)
				ae_perm |= acl_nfs4_flag_map[i].a_perm;
		}
		for (i = 0; i < acl_nfs4_perm_map_size; ++i) {
			if ((richace->e_mask &
			    acl_nfs4_perm_map[i].p_perm) != 0)
				ae_perm |=
				    acl_nfs4_perm_map[i].a_perm;
		}

		archive_entry_acl_add_entry(entry, entry_acl_type,
		    ae_perm, ae_tag, ae_id, ae_name);
	}
	return (ARCHIVE_OK);
}
