_netplan_netdef_write_nm(
        __unused const NetplanState* np_state,
        const NetplanNetDefinition* netdef,
        const char* rootdir,
        gboolean* has_been_written,
        GError** error)
{
    gboolean no_error = TRUE;

    /* Placeholder interfaces are not supposed to be rendered */
    if (netdef->type == NETPLAN_DEF_TYPE_NM_PLACEHOLDER_)
        return TRUE;

    SET_OPT_OUT_PTR(has_been_written, FALSE);
    if (netdef->backend != NETPLAN_BACKEND_NM) {
        g_debug("NetworkManager: definition %s is not for us (backend %i)", netdef->id, netdef->backend);
        return TRUE;
    }

    if (netdef->match.driver && !netdef->set_name) {
        g_set_error(error, NETPLAN_BACKEND_ERROR, NETPLAN_ERROR_UNSUPPORTED, "ERROR: %s: NetworkManager definitions do not support matching by driver\n", netdef->id);
        return FALSE;
    }

    if (netdef->address_options) {
        g_set_error(error, NETPLAN_BACKEND_ERROR, NETPLAN_ERROR_UNSUPPORTED, "ERROR: %s: NetworkManager does not support address options\n", netdef->id);
        return FALSE;
    }

    if (netdef->type == NETPLAN_DEF_TYPE_VETH) {
        /*
         * Final validation of veths that can't be fully done during parsing due to the
         * order the interfaces are parsed.
         */
        if (!validate_veth_pair(np_state, netdef, error))
            return FALSE;
    }

    if (netdef->type == NETPLAN_DEF_TYPE_WIFI) {
        GHashTableIter iter;
        gpointer key;
        const NetplanWifiAccessPoint* ap;
        if (netdef->access_points) {
            g_hash_table_iter_init(&iter, netdef->access_points);
            while (g_hash_table_iter_next(&iter, &key, (gpointer) &ap) && no_error) {
                no_error = write_nm_conf_access_point(netdef, rootdir, ap, error);
            }
        }
    } else {
        g_assert(netdef->access_points == NULL);
        no_error = write_nm_conf_access_point(netdef, rootdir, NULL, error);
    }
    SET_OPT_OUT_PTR(has_been_written, TRUE);
    return no_error;
}
