typedArrayPrototypeFill(void *, Runtime &runtime, NativeArgs args) {
  if (JSTypedArrayBase::validateTypedArray(runtime, args.getThisHandle()) ==
      ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto self = args.vmcastThis<JSTypedArrayBase>();
  const double len = self->getLength();
  CallResult<HermesValue> res = ExecutionStatus::EXCEPTION;
  switch (self->getKind()) {
    default:
      res = toNumber_RJS(runtime, args.getArgHandle(0));
      break;
    case CellKind::BigInt64ArrayKind:
    case CellKind::BigUint64ArrayKind:
      res = toBigInt_RJS(runtime, args.getArgHandle(0));
      break;
  }
  if (res == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto value = runtime.makeHandle(res.getValue());
  res = toIntegerOrInfinity(runtime, args.getArgHandle(1));
  if (res == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  const double relativeStart = res->getNumber();
  auto end = args.getArgHandle(2);
  if (!end->isUndefined()) {
    res = toIntegerOrInfinity(runtime, end);
    if (res == ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
  }
  const double relativeEnd = end->isUndefined() ? len : res->getNumber();
  // At this point it is safe to convert to integers because the values will be
  // in the range [0, len], and len is an integer.
  const int64_t k = convertNegativeBoundsRelativeToLength(relativeStart, len);
  const int64_t last = convertNegativeBoundsRelativeToLength(relativeEnd, len);

  // 9. If IsDetachedBuffer(O.[[ViewedArrayBuffer]]) is true, throw a TypeError
  // exception.
  if (!self->attached(runtime)) {
    return runtime.raiseTypeError("Cannot fill a detached TypedArray");
  }

  if (k >= last) {
    // Early return to avoid the case of zero requested fill space.
    return self.getHermesValue();
  }

  if (JSObject::setOwnIndexed(self, runtime, k, value) ==
      ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto elementSize = self->getByteWidth();
  uint8_t *begin = self->begin(runtime);
  // Fill with the same raw bytes as the first one.
  switch (elementSize) {
    case 1:
      std::fill(begin + k, begin + last, *(begin + k));
      break;
    case 2: {
      auto *src = reinterpret_cast<uint16_t *>(begin);
      std::fill(src + k, src + last, *(src + k));
      break;
    }
    case 4: {
      auto *src = reinterpret_cast<uint32_t *>(begin);
      std::fill(src + k, src + last, *(src + k));
      break;
    }
    case 8: {
      auto *src = reinterpret_cast<uint64_t *>(begin);
      std::fill(src + k, src + last, *(src + k));
      break;
    }
    default:
      llvm_unreachable("No element that is that wide");
      break;
  }
  return self.getHermesValue();
}
