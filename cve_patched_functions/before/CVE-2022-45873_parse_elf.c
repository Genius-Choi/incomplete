static int parse_elf(int fd, const char *executable, char **ret, JsonVariant **ret_package_metadata) {
        _cleanup_(json_variant_unrefp) JsonVariant *package_metadata = NULL, *elf_metadata = NULL;
        _cleanup_(set_freep) Set *modules = NULL;
        _cleanup_free_ char *buf = NULL; /* buf should be freed last, c.f closed first (via stack_context_destroy) */
        _cleanup_(stack_context_destroy) StackContext c = {
                .package_metadata = &package_metadata,
                .modules = &modules,
        };
        const char *elf_type;
        GElf_Ehdr elf_header;
        size_t sz = 0;
        int r;

        assert(fd >= 0);

        if (lseek(fd, 0, SEEK_SET) == (off_t) -1)
                return log_warning_errno(errno, "Failed to seek to beginning of the ELF file: %m");

        if (ret) {
                c.f = open_memstream_unlocked(&buf, &sz);
                if (!c.f)
                        return log_oom();
        }

        sym_elf_version(EV_CURRENT);

        c.elf = sym_elf_begin(fd, ELF_C_READ_MMAP, NULL);
        if (!c.elf)
                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), "Could not parse ELF file, elf_begin() failed: %s", sym_elf_errmsg(sym_elf_errno()));

        if (!sym_gelf_getehdr(c.elf, &elf_header))
                return log_warning_errno(SYNTHETIC_ERRNO(EINVAL), "Could not parse ELF file, gelf_getehdr() failed: %s", sym_elf_errmsg(sym_elf_errno()));

        if (elf_header.e_type == ET_CORE) {
                _cleanup_free_ char *out = NULL;

                r = parse_core(fd, executable, ret ? &out : NULL, &package_metadata);
                if (r < 0)
                        return log_warning_errno(r, "Failed to inspect core file: %m");

                if (out)
                        fprintf(c.f, "%s", out);

                elf_type = "coredump";
        } else {
                _cleanup_(json_variant_unrefp) JsonVariant *id_json = NULL;
                const char *e = executable ?: "(unnamed)";
                bool interpreter_found = false;

                r = parse_buildid(NULL, c.elf, e, &c, &id_json);
                if (r < 0)
                        return log_warning_errno(r, "Failed to parse build-id of ELF file: %m");

                r = parse_package_metadata(e, id_json, c.elf, &interpreter_found, &c);
                if (r < 0)
                        return log_warning_errno(r, "Failed to parse package metadata of ELF file: %m");

                /* If we found a build-id and nothing else, return at least that. */
                if (!package_metadata && id_json) {
                        r = json_build(&package_metadata, JSON_BUILD_OBJECT(JSON_BUILD_PAIR(e, JSON_BUILD_VARIANT(id_json))));
                        if (r < 0)
                                return log_warning_errno(r, "Failed to build JSON object: %m");
                }

                if (interpreter_found)
                        elf_type = "executable";
                else
                        elf_type = "library";
        }

        /* Note that e_type is always DYN for both executables and libraries, so we can't tell them apart from the header,
         * but we will search for the PT_INTERP section when parsing the metadata. */
        r = json_build(&elf_metadata, JSON_BUILD_OBJECT(JSON_BUILD_PAIR("elfType", JSON_BUILD_STRING(elf_type))));
        if (r < 0)
                return log_warning_errno(r, "Failed to build JSON object: %m");

#if HAVE_DWELF_ELF_E_MACHINE_STRING
        const char *elf_architecture = sym_dwelf_elf_e_machine_string(elf_header.e_machine);
        if (elf_architecture) {
                _cleanup_(json_variant_unrefp) JsonVariant *json_architecture = NULL;

                r = json_build(&json_architecture,
                                JSON_BUILD_OBJECT(JSON_BUILD_PAIR("elfArchitecture", JSON_BUILD_STRING(elf_architecture))));
                if (r < 0)
                        return log_warning_errno(r, "Failed to build JSON object: %m");

                r = json_variant_merge(&elf_metadata, json_architecture);
                if (r < 0)
                        return log_warning_errno(r, "Failed to merge JSON objects: %m");

                if (ret)
                        fprintf(c.f, "ELF object binary architecture: %s\n", elf_architecture);
        }
#endif

        /* We always at least have the ELF type, so merge that (and possibly the arch). */
        r = json_variant_merge(&elf_metadata, package_metadata);
        if (r < 0)
                return log_warning_errno(r, "Failed to merge JSON objects: %m");

        if (ret) {
                r = fflush_and_check(c.f);
                if (r < 0)
                        return log_warning_errno(r, "Could not parse ELF file, flushing file buffer failed: %m");

                c.f = safe_fclose(c.f);
                *ret = TAKE_PTR(buf);
        }
        if (ret_package_metadata)
                *ret_package_metadata = TAKE_PTR(elf_metadata);

        return 0;
}
