unsigned int static GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlock *pblock)
{
    unsigned int nProofOfWorkLimit = bnProofOfWorkLimit.GetCompact();

    // The genesis block
    if(pindexLast == NULL) return nProofOfWorkLimit;

    // The next block
    int nHeight = pindexLast->nHeight + 1;

    // The initial settings
    int nTargetSpacing  = nTargetSpacingZero;
    int nTargetTimespan = nTargetTimespanZero;

    // The 1st hard fork
    if(nHeight >= nForkOne) {
        nTargetSpacing  = nTargetSpacingOne;
        nTargetTimespan = nTargetTimespanOne;
    }

    // The 2nd hard fork
    if(nHeight >= nForkTwo) {
        nTargetSpacing  = nTargetSpacingTwo;
        nTargetTimespan = nTargetTimespanTwo;
    }

    // The 3nd hard fork; testnet starts here
    if(nHeight >= nForkThree || fTestNet) {
        nTargetSpacing  = nTargetSpacingThree;
        nTargetTimespan = nTargetTimespanThree;
    }

    // The 4th hard fork; testnet hard forks as well
    if((nHeight >= nForkFour) || (fTestNet && (nHeight >= nTestnetForkOne))) {
        nTargetSpacing  = nTargetSpacingFour;
        nTargetTimespan = nTargetTimespanFour;
    }

    /* The 5th hard fork and 2nd testnet hard fork */
    if((nHeight >= nForkFive) || (fTestNet && (nHeight >= nTestnetForkTwo))) {
        if(!fNeoScrypt) fNeoScrypt = true;
        /* Difficulty reset after the switch */
        if(nHeight == nForkFive)
          return(bnNeoScryptSwitch.GetCompact());
    }

    // 2400, 600, 108, 126 and 20 blocks respectively
    int nInterval = nTargetTimespan / nTargetSpacing;

    // Just in case a hard fork isn't aligned properly
    bool fHardFork = (nHeight == nForkOne) || (nHeight == nForkTwo) || (nHeight == nForkThree) || (nHeight == nForkFour) || (nHeight == nForkFive);
    if(fTestNet) {
        if((nHeight == nTestnetForkOne) || (nHeight == nTestnetForkTwo)) fHardFork = true;
        else fHardFork = false;
    }

    // Difficulty rules for regular blocks
    if((nHeight % nInterval != 0) && !(fHardFork)) {

        // Testnet has a special difficulty rule
        if(fTestNet) {
            // Reset the difficulty if the difference in time stamps between
            // this and the previous block is over 2x of nTargetSpacing
            if(pblock->nTime > pindexLast->nTime + nTargetSpacing*2)
              return nProofOfWorkLimit;
            else {
                // Return the difficulty of the last regular block
                // with no minimal difficulty set as above
                const CBlockIndex* pindex = pindexLast;
                while(pindex->pprev && (pindex->nHeight % nInterval != 0) && (pindex->nBits == nProofOfWorkLimit))
                  pindex = pindex->pprev;
                return pindex->nBits;
            }
        }

        return pindexLast->nBits;
    }

    // Basic 100 blocks averaging after the 4th livenet or 1st testnet hard fork
    if((nHeight >= nForkFour) || (fTestNet && (nHeight >= nTestnetForkOne))) {
        nInterval *= 5;
        nTargetTimespan *= 5;
    }

    // The 1st retarget after the genesis
    if(nInterval >= nHeight) nInterval = nHeight - 1;

    // Go back by nInterval
    const CBlockIndex* pindexFirst = pindexLast;
    for(int i = 0; pindexFirst && (i < nInterval); i++)
      pindexFirst = pindexFirst->pprev;
    assert(pindexFirst);

    int nActualTimespan = pindexLast->GetBlockTime() - pindexFirst->GetBlockTime();

    printf("RETARGET: nActualTimespan = %d before bounds\n", nActualTimespan);

    // Extended 500 blocks averaging after the 4th livenet or 1st testnet hard fork
    if((nHeight >= nForkFour) || (fTestNet && (nHeight >= nTestnetForkOne))) {
        nInterval *= 4;

        for(int i = 0; pindexFirst && (i < nInterval); i++)
          pindexFirst = pindexFirst->pprev;

        int nActualTimespanExtended =
          (pindexLast->GetBlockTime() - pindexFirst->GetBlockTime())/5;

        // Average between the basic and extended windows
        int nActualTimespanAvg = (nActualTimespan + nActualTimespanExtended)/2;

        // Apply 0.1 damping
        nActualTimespan = nActualTimespanAvg + 9*nTargetTimespan;
        nActualTimespan /= 10;

        printf("RETARGET: nActualTimespanExtended = %d (%d), nActualTimeSpanAvg = %d, nActualTimespan (damped) = %d\n",
          nActualTimespanExtended, nActualTimespanExtended*5, nActualTimespanAvg, nActualTimespan);
    }

    // The initial settings (4.0 difficulty limiter)
    int nActualTimespanMax = nTargetTimespan*4;
    int nActualTimespanMin = nTargetTimespan/4;

    // The 1st hard fork (1.8 difficulty limiter)
    if(nHeight >= nForkOne) {
        nActualTimespanMax = nTargetTimespan*99/55;
        nActualTimespanMin = nTargetTimespan*55/99;
    }

    // The 3rd hard fork (1.09 difficulty limiter)
    if(nHeight >= nForkThree) {
        nActualTimespanMax = nTargetTimespan*109/100;
        nActualTimespanMin = nTargetTimespan*100/109;
    }

    // The 4th livenet or 1st testnet hard fork (1.02 difficulty limiter)
    if((nHeight >= nForkFour) || (fTestNet && (nHeight >= nTestnetForkOne))) {
        nActualTimespanMax = nTargetTimespan*102/100;
        nActualTimespanMin = nTargetTimespan*100/102;
    }

    /* The 5th livenet or 2nd testnet hard fork (+2% to -5% difficulty limiter) */
    if((nHeight >= nForkFive) || (fTestNet && (nHeight >= nTestnetForkTwo))) {
        nActualTimespanMax = nTargetTimespan * 105 / 100;
    }

    if(nActualTimespan < nActualTimespanMin) nActualTimespan = nActualTimespanMin;
    if(nActualTimespan > nActualTimespanMax) nActualTimespan = nActualTimespanMax;

    printf("RETARGET: nActualTimespan = %d after bounds\n", nActualTimespan);
    printf("RETARGET: nTargetTimespan = %d, nTargetTimespan/nActualTimespan = %.4f\n",
      nTargetTimespan, (float) nTargetTimespan/nActualTimespan);

    // Retarget
    CBigNum bnNew;
    bnNew.SetCompact(pindexLast->nBits);
    bnNew *= nActualTimespan;
    bnNew /= nTargetTimespan;

    if(bnNew > bnProofOfWorkLimit) bnNew = bnProofOfWorkLimit;

    printf("GetNextWorkRequired RETARGET\n");
    printf("Before: %08x  %s\n", pindexLast->nBits, CBigNum().SetCompact(pindexLast->nBits).getuint256().ToString().c_str());
    printf("After:  %08x  %s\n", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());

    return bnNew.GetCompact();
}
