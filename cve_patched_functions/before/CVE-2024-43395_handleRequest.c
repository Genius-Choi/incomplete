    void handleRequest(HTTPServerRequest &request, HTTPServerResponse &response) override {
        WebSocket * ws = NULL;
        try {
            ws = new WebSocket(request, response);
        } catch (NetException &e) {
            return;
        }
        (*retainCount)++;
        ws->setReceiveTimeout(Poco::Timespan(1, 0));
#if POCO_VERSION >= 0x01090100
        if (config.http_max_websocket_message > 0) ws->setMaxPayloadSize(config.http_max_websocket_message);
#endif
        ws_handle ws_orig;
        ws_handle * wsh = &ws_orig;
        wsh->ws = ws;
        wsh->isServer = true;
        wsh->port = srv->port();
        wsh->clientID = &request;
        {
            std::lock_guard<std::mutex> lock(comp->openWebsocketsMutex);
            comp->openWebsockets.push_back(&wsh);
        }
        queueEvent(comp, websocket_server_connect, &wsh);
        char * buf = new char[config.http_max_websocket_message];
        while (wsh->ws) {
            int flags = 0;
            int res;
            try {
                res = ws->receiveFrame(buf, config.http_max_websocket_message, flags);
                if (res < 0 || (res == 0 && flags == 0)) {
                    wsh->ws = NULL;
                    websocket_closed_data * d = new websocket_closed_data;
                    d->clientID = wsh->clientID;
                    d->code = 0;
                    queueEvent(comp, websocket_server_closed, d);
                    break;
                }
            } catch (Poco::TimeoutException &e) {
                if (!wsh->ws) {
                    websocket_closed_data * d = new websocket_closed_data;
                    d->clientID = wsh->clientID;
                    d->code = 1006;
                    d->reason = "Timed out";
                    queueEvent(comp, websocket_server_closed, d);
                    break;
                }
                continue;
            } catch (NetException &e) {
                wsh->ws = NULL;
                websocket_closed_data * d = new websocket_closed_data;
                d->clientID = wsh->clientID;
                d->code = 1006;
                d->reason = e.message();
                queueEvent(comp, websocket_server_closed, d);
                break;
            }
            if ((flags & 0x0f) == WebSocket::FRAME_OP_CLOSE) {
                wsh->ws = NULL;
                websocket_closed_data * d = new websocket_closed_data;
                d->clientID = wsh->clientID;
                if (res >= 2) {
                    d->code = (((uint8_t*)buf)[0] << 8) | ((uint8_t*)buf)[1];
                    d->reason = std::string(buf + 2, res - 2);
                } else d->code = 0;
                queueEvent(comp, websocket_server_closed, d);
                break;
            } else if ((flags & 0x0f) == WebSocket::FRAME_OP_PING) {
                ws->sendFrame(buf, res, WebSocket::FRAME_FLAG_FIN | WebSocket::FRAME_OP_PONG);
            } else {
                ws_message * message = new ws_message;
                message->clientID = wsh->clientID;
                message->binary = (flags & WebSocket::FRAME_OP_BITMASK) == WebSocket::FRAME_OP_BINARY;
                message->data = std::string((const char*)buf, res);
                queueEvent(comp, websocket_server_message, message);
            }
            std::this_thread::yield();
        }
        {
            std::lock_guard<std::mutex> lock(comp->openWebsocketsMutex);
            auto it = std::find(comp->openWebsockets.begin(), comp->openWebsockets.end(), (void*)&wsh);
            if (it != comp->openWebsockets.end()) comp->openWebsockets.erase(it);
        }
        try {ws->shutdown();} catch (...) {}
        std::lock_guard<std::mutex> lock(wsh->lock);
        wsh->ws = NULL;
        if (wsh->ud != NULL) *wsh->ud = NULL;
        delete ws;
    }
