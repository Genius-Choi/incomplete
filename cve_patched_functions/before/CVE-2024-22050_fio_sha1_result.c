char *fio_sha1_result(fio_sha1_s *s) {
  size_t in_buffer = s->length & 63;
  if (in_buffer > 55) {
    memcpy(s->buffer + in_buffer, sha1_padding, 64 - in_buffer);
    fio_sha1_perform_all_rounds(s, s->buffer);
    memcpy(s->buffer, sha1_padding + 1, 56);
  } else if (in_buffer != 55) {
    memcpy(s->buffer + in_buffer, sha1_padding, 56 - in_buffer);
  } else {
    s->buffer[55] = sha1_padding[0];
  }
  /* store the length in BITS - alignment should be promised by struct */
  /* this must the number in BITS, encoded as a BIG ENDIAN 64 bit number */
  uint64_t *len = (uint64_t *)(s->buffer + 56);
  *len = s->length << 3;
  *len = fio_lton64(*len);
  fio_sha1_perform_all_rounds(s, s->buffer);

  /* change back to little endian */
  s->digest.i[0] = fio_ntol32(s->digest.i[0]);
  s->digest.i[1] = fio_ntol32(s->digest.i[1]);
  s->digest.i[2] = fio_ntol32(s->digest.i[2]);
  s->digest.i[3] = fio_ntol32(s->digest.i[3]);
  s->digest.i[4] = fio_ntol32(s->digest.i[4]);

  return (char *)s->digest.str;
}
