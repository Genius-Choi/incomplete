static int nextrune(struct cstate *g)
{
	g->source += chartorune(&g->yychar, g->source);
	if (g->yychar == '\\') {
		g->source += chartorune(&g->yychar, g->source);
		switch (g->yychar) {
		case 0: die(g, "unterminated escape sequence"); break;
		case 'f': g->yychar = '\f'; return 0;
		case 'n': g->yychar = '\n'; return 0;
		case 'r': g->yychar = '\r'; return 0;
		case 't': g->yychar = '\t'; return 0;
		case 'v': g->yychar = '\v'; return 0;
		case 'c':
			g->yychar = (*g->source++) & 31;
			return 0;
		case 'x':
			g->yychar = hex(g, *g->source++) << 4;
			g->yychar += hex(g, *g->source++);
			if (g->yychar == 0) {
				g->yychar = '0';
				return 1;
			}
			return 0;
		case 'u':
			g->yychar = hex(g, *g->source++) << 12;
			g->yychar += hex(g, *g->source++) << 8;
			g->yychar += hex(g, *g->source++) << 4;
			g->yychar += hex(g, *g->source++);
			if (g->yychar == 0) {
				g->yychar = '0';
				return 1;
			}
			return 0;
		}
		if (strchr(ESCAPES, g->yychar))
			return 1;
		if (isunicodeletter(g->yychar) || g->yychar == '_') /* check identity escape */
			die(g, "invalid escape character");
		return 0;
	}
	return 0;
}
