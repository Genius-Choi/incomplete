BOOL CEAnsi::OurWriteConsoleA(HANDLE hConsoleOutput, const char *lpBuffer, DWORD nNumberOfCharsToWrite, LPDWORD lpNumberOfCharsWritten)
{
	_ASSERTE(this != nullptr);
	BOOL lbRc = FALSE;
	wchar_t* buf = nullptr;
	wchar_t szTemp[280]; // would be enough in most cases
	CEStr ptrTemp;
	INT_PTR bufMax;
	// ReSharper disable once CppJoinDeclarationAndAssignment
	DWORD cp;
	// ReSharper disable once CppJoinDeclarationAndAssignment
	CpCvtResult cvt{};
	const char* pSrc = nullptr;
	const char* pTokenStart = nullptr;
	wchar_t* pDst = nullptr;
	wchar_t* pDstEnd = nullptr;
	DWORD nWritten = 0;
	DWORD nTotalWritten = 0;

	ORIGINAL_KRNL(WriteConsoleA);

	// Nothing to write? Or flush buffer?
	if (!lpBuffer || !nNumberOfCharsToWrite || !hConsoleOutput || (hConsoleOutput == INVALID_HANDLE_VALUE))
	{
		if (lpNumberOfCharsWritten)
			*lpNumberOfCharsWritten = 0;
		lbRc = TRUE;
		goto fin;
	}

	if ((nNumberOfCharsToWrite + 3) >= countof(szTemp))
	{
		bufMax = nNumberOfCharsToWrite + 3;
		buf = ptrTemp.GetBuffer(bufMax);
	}
	else
	{
		buf = szTemp;
		bufMax = countof(szTemp);
	}
	if (!buf)
	{
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		goto fin;
	}

	cp = GetCodePage();
	m_Cvt.SetCP(cp);

	lbRc = TRUE;
	pSrc = pTokenStart = lpBuffer;
	pDst = buf; pDstEnd = buf + bufMax - 3;
	for (DWORD n = 0; n < nNumberOfCharsToWrite; n++, pSrc++)
	{
		if (pDst >= pDstEnd)
		{
			_ASSERTE((pDst < (buf+bufMax)) && "wchar_t buffer overflow while converting");
			buf[(pDst - buf)] = 0; // It's not required, just to easify debugging
			lbRc = OurWriteConsoleW(hConsoleOutput, buf, static_cast<DWORD>(pDst - buf), &nWritten, nullptr);
			if (lbRc) nTotalWritten += nWritten;
			pDst = buf;
		}
		cvt = m_Cvt.Convert(*pSrc, *pDst);
		switch (cvt)  // NOLINT(clang-diagnostic-switch-enum)
		{
		case ccr_OK:
		case ccr_BadUnicode:
			pDst++;
			break;
		case ccr_Surrogate:
		case ccr_BadTail:
		case ccr_DoubleBad:
			m_Cvt.GetTail(*(++pDst));
			pDst++;
			break;
		default:
			break;
		}
	}

	if (pDst > buf)
	{
		_ASSERTE((pDst < (buf+bufMax)) && "wchar_t buffer overflow while converting");
		buf[(pDst - buf)] = 0; // It's not required, just to easify debugging
		lbRc = OurWriteConsoleW(hConsoleOutput, buf, static_cast<DWORD>(pDst - buf), &nWritten, nullptr);
		if (lbRc)
			nTotalWritten += nWritten;
	}

	// Issue 1291:	Python fails to print string sequence with ASCII character followed by Chinese character.
	if (lpNumberOfCharsWritten && lbRc)
	{
		*lpNumberOfCharsWritten = nNumberOfCharsToWrite;
	}

fin:
	std::ignore = pTokenStart;
	std::ignore = nTotalWritten;
	return lbRc;
}
