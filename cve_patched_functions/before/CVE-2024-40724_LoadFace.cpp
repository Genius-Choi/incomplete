void PLYImporter::LoadFace(const PLY::Element *pcElement, const PLY::ElementInstance *instElement,
        unsigned int pos) {
    ai_assert(nullptr != pcElement);
    ai_assert(nullptr != instElement);

    if (mGeneratedMesh == nullptr) {
        throw DeadlyImportError("Invalid .ply file: Vertices should be declared before faces");
    }

    bool bOne = false;

    // index of the vertex index list
    unsigned int iProperty = 0xFFFFFFFF;
    PLY::EDataType eType = EDT_Char;
    bool bIsTriStrip = false;

    // index of the material index property
    // unsigned int iMaterialIndex = 0xFFFFFFFF;
    // PLY::EDataType eType2 = EDT_Char;

    // texture coordinates
    unsigned int iTextureCoord = 0xFFFFFFFF;
    PLY::EDataType eType3 = EDT_Char;

    // face = unique number of vertex indices
    if (PLY::EEST_Face == pcElement->eSemantic) {
        unsigned int _a = 0;
        for (std::vector<PLY::Property>::const_iterator a = pcElement->alProperties.begin();
                a != pcElement->alProperties.end(); ++a, ++_a) {
            if (PLY::EST_VertexIndex == (*a).Semantic) {
                // must be a dynamic list!
                if (!(*a).bIsList) {
                    continue;
                }

                iProperty = _a;
                bOne = true;
                eType = (*a).eType;
            } else if (PLY::EST_TextureCoordinates == (*a).Semantic) {
                // must be a dynamic list!
                if (!(*a).bIsList) {
                    continue;
                }
                iTextureCoord = _a;
                bOne = true;
                eType3 = (*a).eType;
            }
        }
    }
    // triangle strip
    // TODO: triangle strip and material index support???
    else if (PLY::EEST_TriStrip == pcElement->eSemantic) {
        unsigned int _a = 0;
        for (std::vector<PLY::Property>::const_iterator a = pcElement->alProperties.begin();
                a != pcElement->alProperties.end(); ++a, ++_a) {
            // must be a dynamic list!
            if (!(*a).bIsList) {
                continue;
            }
            iProperty = _a;
            bOne = true;
            bIsTriStrip = true;
            eType = (*a).eType;
            break;
        }
    }

    // check whether we have at least one per-face information set
    if (bOne) {
        if (mGeneratedMesh->mFaces == nullptr) {
            mGeneratedMesh->mNumFaces = pcElement->NumOccur;
            mGeneratedMesh->mFaces = new aiFace[mGeneratedMesh->mNumFaces];
        }

        if (!bIsTriStrip) {
            // parse the list of vertex indices
            if (0xFFFFFFFF != iProperty) {
                const unsigned int iNum = (unsigned int)GetProperty(instElement->alProperties, iProperty).avList.size();
                mGeneratedMesh->mFaces[pos].mNumIndices = iNum;
                mGeneratedMesh->mFaces[pos].mIndices = new unsigned int[iNum];

                std::vector<PLY::PropertyInstance::ValueUnion>::const_iterator p =
                        GetProperty(instElement->alProperties, iProperty).avList.begin();

                for (unsigned int a = 0; a < iNum; ++a, ++p) {
                    mGeneratedMesh->mFaces[pos].mIndices[a] = PLY::PropertyInstance::ConvertTo<unsigned int>(*p, eType);
                }
            }

            // parse the material index
            // cannot be handled without processing the whole file first
            /*if (0xFFFFFFFF != iMaterialIndex)
        {
            mGeneratedMesh->mFaces[pos]. = PLY::PropertyInstance::ConvertTo<unsigned int>(
            GetProperty(instElement->alProperties, iMaterialIndex).avList.front(), eType2);
        }*/

            if (0xFFFFFFFF != iTextureCoord) {
                const unsigned int iNum = (unsigned int)GetProperty(instElement->alProperties, iTextureCoord).avList.size();

                // should be 6 coords
                std::vector<PLY::PropertyInstance::ValueUnion>::const_iterator p =
                        GetProperty(instElement->alProperties, iTextureCoord).avList.begin();

                if ((iNum / 3) == 2) // X Y coord
                {
                    for (unsigned int a = 0; a < iNum; ++a, ++p) {
                        unsigned int vindex = mGeneratedMesh->mFaces[pos].mIndices[a / 2];
                        if (vindex < mGeneratedMesh->mNumVertices) {
                            if (mGeneratedMesh->mTextureCoords[0] == nullptr) {
                                mGeneratedMesh->mNumUVComponents[0] = 2;
                                mGeneratedMesh->mTextureCoords[0] = new aiVector3D[mGeneratedMesh->mNumVertices];
                            }

                            if (a % 2 == 0) {
                                mGeneratedMesh->mTextureCoords[0][vindex].x = PLY::PropertyInstance::ConvertTo<ai_real>(*p, eType3);
                            } else {
                                mGeneratedMesh->mTextureCoords[0][vindex].y = PLY::PropertyInstance::ConvertTo<ai_real>(*p, eType3);
                            }

                            mGeneratedMesh->mTextureCoords[0][vindex].z = 0;
                        }
                    }
                }
            }
        } else { // triangle strips
            // normally we have only one triangle strip instance where
            // a value of -1 indicates a restart of the strip
            bool flip = false;
            const std::vector<PLY::PropertyInstance::ValueUnion> &quak = GetProperty(instElement->alProperties, iProperty).avList;
            // pvOut->reserve(pvOut->size() + quak.size() + (quak.size()>>2u)); //Limits memory consumption

            int aiTable[2] = { -1, -1 };
            for (std::vector<PLY::PropertyInstance::ValueUnion>::const_iterator a = quak.begin(); a != quak.end(); ++a) {
                const int p = PLY::PropertyInstance::ConvertTo<int>(*a, eType);

                if (-1 == p) {
                    // restart the strip ...
                    aiTable[0] = aiTable[1] = -1;
                    flip = false;
                    continue;
                }
                if (-1 == aiTable[0]) {
                    aiTable[0] = p;
                    continue;
                }
                if (-1 == aiTable[1]) {
                    aiTable[1] = p;
                    continue;
                }

                if (mGeneratedMesh->mFaces == nullptr) {
                    mGeneratedMesh->mNumFaces = pcElement->NumOccur;
                    mGeneratedMesh->mFaces = new aiFace[mGeneratedMesh->mNumFaces];
                }

                mGeneratedMesh->mFaces[pos].mNumIndices = 3;
                mGeneratedMesh->mFaces[pos].mIndices = new unsigned int[3];
                mGeneratedMesh->mFaces[pos].mIndices[0] = aiTable[0];
                mGeneratedMesh->mFaces[pos].mIndices[1] = aiTable[1];
                mGeneratedMesh->mFaces[pos].mIndices[2] = p;

                // every second pass swap the indices.
                flip = !flip;
                if (flip) {
                    std::swap(mGeneratedMesh->mFaces[pos].mIndices[0], mGeneratedMesh->mFaces[pos].mIndices[1]);
                }

                aiTable[0] = aiTable[1];
                aiTable[1] = p;
            }
        }
    }
}
