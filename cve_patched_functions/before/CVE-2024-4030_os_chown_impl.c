os_chown_impl(PyObject *module, path_t *path, uid_t uid, gid_t gid,
              int dir_fd, int follow_symlinks)
/*[clinic end generated code: output=4beadab0db5f70cd input=b08c5ec67996a97d]*/
{
    int result;

#if defined(HAVE_FCHOWNAT)
    int fchownat_unsupported = 0;
#endif

#if !(defined(HAVE_LCHOWN) || defined(HAVE_FCHOWNAT))
    if (follow_symlinks_specified("chown", follow_symlinks))
        return NULL;
#endif
    if (dir_fd_and_fd_invalid("chown", dir_fd, path->fd) ||
        fd_and_follow_symlinks_invalid("chown", path->fd, follow_symlinks))
        return NULL;

    if (PySys_Audit("os.chown", "OIIi", path->object, uid, gid,
                    dir_fd == DEFAULT_DIR_FD ? -1 : dir_fd) < 0) {
        return NULL;
    }

    Py_BEGIN_ALLOW_THREADS
#ifdef HAVE_FCHOWN
    if (path->fd != -1)
        result = fchown(path->fd, uid, gid);
    else
#endif
#ifdef HAVE_LCHOWN
    if ((!follow_symlinks) && (dir_fd == DEFAULT_DIR_FD))
        result = lchown(path->narrow, uid, gid);
    else
#endif
#ifdef HAVE_FCHOWNAT
    if ((dir_fd != DEFAULT_DIR_FD) || (!follow_symlinks)) {
      if (HAVE_FCHOWNAT_RUNTIME) {
        result = fchownat(dir_fd, path->narrow, uid, gid,
                          follow_symlinks ? 0 : AT_SYMLINK_NOFOLLOW);
      } else {
         fchownat_unsupported = 1;
      }
    } else
#endif
        result = chown(path->narrow, uid, gid);
    Py_END_ALLOW_THREADS

#ifdef HAVE_FCHOWNAT
    if (fchownat_unsupported) {
        /* This would be incorrect if the current platform
         * doesn't support lchown.
         */
        argument_unavailable_error(NULL, "dir_fd");
        return NULL;
    }
#endif

    if (result)
        return path_error(path);

    Py_RETURN_NONE;
}
