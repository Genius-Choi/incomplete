void __oe_handle_main(
    uint64_t arg1,
    uint64_t arg2,
    uint64_t cssa,
    void* tcs,
    uint64_t* output_arg1,
    uint64_t* output_arg2)
{
    oe_code_t code = oe_get_code_from_call_arg1(arg1);
    uint16_t func = oe_get_func_from_call_arg1(arg1);
    uint16_t arg1_result = oe_get_result_from_call_arg1(arg1);
    uint64_t arg_in = arg2;
    *output_arg1 = 0;
    *output_arg2 = 0;

    /* Get pointer to the thread data structure */
    oe_sgx_td_t* td = td_from_tcs(tcs);

    /* Initialize the enclave the first time it is ever entered. Note that
     * this function DOES NOT call global constructors. Global construction
     * is performed while handling OE_ECALL_INIT_ENCLAVE. */
    oe_initialize_enclave(td);

    /* td's host_ecall_context is set in enter.S and this is the first chance we
       get to validate it. */
    oe_ecall_context_t* ecall_context = td->host_ecall_context;
    if (!oe_is_outside_enclave(ecall_context, sizeof(*ecall_context)))
        td->host_ecall_context = NULL;

    /* Ensure that ecall_context is 8-byte aligned against the xAPIC
     * vunlerability */
    if (((uint64_t)ecall_context % 8) != 0)
        td->host_ecall_context = NULL;

    /* Stitch the stack. Pass the caller's frame for fix up.
     * Note that before stitching, the caller's frame points
     * to the host stack right before switiching to the enclave
     * stack (see .construct_stack_frame in enter.S).
     * The function is called after oe_initialize_enclave
     * (relocations have been applied) so that we can safely
     * access globals that are referenced via GOT. */
    _stitch_ecall_stack(td, __builtin_frame_address(1));

    // Block enclave enter based on current enclave status.
    switch (__oe_enclave_status)
    {
        case OE_OK:
        {
            break;
        }
        case OE_ENCLAVE_ABORTING:
        {
            // Block any ECALL except first time OE_ECALL_DESTRUCTOR call.
            // Don't block ORET here.
            if (code == OE_CODE_ECALL)
            {
                if (func == OE_ECALL_DESTRUCTOR)
                {
                    // Termination function should be only called once.
                    __oe_enclave_status = OE_ENCLAVE_ABORTED;
                }
                else
                {
                    // Return crashing status.
                    *output_arg1 =
                        oe_make_call_arg1(OE_CODE_ERET, func, 0, OE_OK);
                    *output_arg2 = __oe_enclave_status;
                    return;
                }
            }

            break;
        }
        default:
        {
            // Return crashed status.
            *output_arg1 = oe_make_call_arg1(OE_CODE_ERET, func, 0, OE_OK);
            *output_arg2 = OE_ENCLAVE_ABORTED;
            return;
        }
    }

    /* If this is a normal (non-exception) entry */
    if (cssa == 0)
    {
        switch (code)
        {
            case OE_CODE_ECALL:
            {
                /* The invocation of the virtual exception handler is not
                 * allowed when cssa=0. */
                if (func == OE_ECALL_VIRTUAL_EXCEPTION_HANDLER)
                    oe_abort_with_td(td);

                /* State machine check */
                if (td->state != OE_TD_STATE_ENTERED)
                    oe_abort_with_td(td);

                /* At this point, we are ready to execute the ecall.
                 * Update the state to RUNNING */
                td->state = OE_TD_STATE_RUNNING;

                _handle_ecall(td, func, arg_in, output_arg1, output_arg2);
                break;
            }
            case OE_CODE_ORET:
                /* Eventually calls oe_exit_enclave() and never returns here if
                 * successful */
                _handle_oret(td, func, arg1_result, arg_in);
                // fallthrough

            default:
                /* Unexpected case */
                oe_abort_with_td(td);
        }
    }
    else if (cssa == 1)
    {
        /* cssa == 1 indicates the entry after an AEX. We only allow the
         * invocation of the virtual exception handler in this case. */
        if ((code == OE_CODE_ECALL) &&
            (func == OE_ECALL_VIRTUAL_EXCEPTION_HANDLER))
        {
            _handle_ecall(td, func, arg_in, output_arg1, output_arg2);
            return;
        }

        /* Unexpected case */
        oe_abort_with_td(td);
    }
    else /* cssa > 1 */
    {
        /* Currently OE only supports an enclave with nssa = 2, which means
         * that cssa can never exceed 1 (indicating nested AEX). */
        oe_abort_with_td(td);
    }
}
