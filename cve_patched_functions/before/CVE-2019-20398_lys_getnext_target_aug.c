lys_getnext_target_aug(struct lys_node_augment *last, const struct lys_module *mod, const struct lys_node *aug_target)
{
    struct lys_node *child;
    struct lys_node_augment *aug;
    int i, j, last_found;

    assert(mod && aug_target);

    if (!last) {
        last_found = 1;
    } else {
        last_found = 0;
    }

    /* search module augments */
    for (i = 0; i < mod->augment_size; ++i) {
        if (!mod->augment[i].target) {
            /* still unresolved, skip */
            continue;
        }

        if (mod->augment[i].target == aug_target) {
            if (last_found) {
                /* next match after last */
                return &mod->augment[i];
            }

            if (&mod->augment[i] == last) {
                last_found = 1;
            }
        }
    }

    /* search submodule augments */
    for (i = 0; i < mod->inc_size; ++i) {
        for (j = 0; j < mod->inc[i].submodule->augment_size; ++j) {
            if (!mod->inc[i].submodule->augment[j].target) {
                continue;
            }

            if (mod->inc[i].submodule->augment[j].target == aug_target) {
                if (last_found) {
                    /* next match after last */
                    return &mod->inc[i].submodule->augment[j];
                }

                if (&mod->inc[i].submodule->augment[j] == last) {
                    last_found = 1;
                }
            }
        }
    }

    /* we also need to check possible augments to choices */
    LY_TREE_FOR(aug_target->child, child) {
        if (child->nodetype == LYS_CHOICE) {
            aug = lys_getnext_target_aug(last, mod, child);
            if (aug) {
                return aug;
            }
        }
    }

    return NULL;
}
