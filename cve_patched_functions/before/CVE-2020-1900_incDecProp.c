TypedValue ObjectData::incDecProp(Class* ctx, IncDecOp op, const StringData* key) {
  auto const lookup = getPropImpl<true, true, false>(ctx, key);
  auto prop = lookup.val;

  if (prop && lookup.accessible) {
    if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {
      throwMutateConstProp(lookup.slot);
    }
    if (type(prop) == KindOfUninit) {
      tvWriteNull(prop);
    }

    /*
     * If this property has a type-hint, we can't do the inc-dec truely in
     * place. We need to verify that the new value satisfies the type-hint
     * before assigning back to the property (if we raise a warning and throw,
     * we don't want to have already put the value into the prop).
     *
     * If the prop is an integer and we're doing the common pre/post inc/dec
     * ops, we know the type won't change, so we can skip the type-hint check in
     * that case.
     */
    auto const fast = [&]{
      if (RuntimeOption::EvalCheckPropTypeHints <= 0) return true;
      auto const isAnyCheckable = lookup.prop && [&] {
        if (lookup.prop->typeConstraint.isCheckable()) return true;
        for (auto const& ub : lookup.prop->ubs) {
          if (ub.isCheckable()) return true;
        }
        return false;
      }();
      if (!isAnyCheckable) return true;

      if (!isIntType(type(prop))) return false;
      return
        op == IncDecOp::PreInc || op == IncDecOp::PostInc ||
        op == IncDecOp::PreDec || op == IncDecOp::PostDec;
    }();
    if (fast) return IncDecBody(op, tvAssertPlausible(prop));

    TypedValue temp;
    tvDup(tvAssertPlausible(*prop), temp);
    SCOPE_FAIL { tvDecRefGen(&temp); };
    auto result = IncDecBody(op, &temp);
    SCOPE_FAIL { tvDecRefGen(&result); };
    verifyTypeHint(m_cls, lookup.prop, &temp);
    tvMove(temp, tvAssertPlausible(prop));
    return result;
  }

  if (UNLIKELY(!*key->data())) throw_invalid_property_name(StrNR(key));

  // Native accessors.
  if (m_cls->rtAttribute(Class::HasNativePropHandler)) {
    if (auto r = invokeNativeGetProp(key)) {
      SCOPE_EXIT { tvDecRefGen(r.val); };
      auto const dest = IncDecBody(op, tvAssertPlausible(&r.val));
      if (invokeNativeSetProp(key, tvAssertPlausible(r.val))) {
        return dest;
      }
    }
  }

  if (prop) raise_error("Cannot access protected property");

  // No visible/accessible property, and no applicable native method:
  // create a new dynamic property.  (We know this is a new property,
  // or it would've hit the visible && accessible case above.)
  prop = makeDynProp(key);
  assertx(type(prop) == KindOfNull); // cannot exist yet
  return IncDecBody(op, prop);
}
