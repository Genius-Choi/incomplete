static GF_Err txtin_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)
{
	GF_Err e;
	u32 codec_id=0;
	Bool gen_ttxt_dsi=GF_FALSE;
	Bool gen_webvtt_dsi=GF_FALSE;
	const char *src = NULL;
	GF_TXTIn *ctx = gf_filter_get_udta(filter);
	const GF_PropertyValue *prop;

	if (is_remove) {
		ctx->ipid = NULL;
		return GF_OK;
	}

	ctx->unframed = GF_FALSE;
	ctx->simple_text = GF_FALSE;

	if (! gf_filter_pid_check_caps(pid))
		return GF_NOT_SUPPORTED;

	prop = gf_filter_pid_get_property(pid, GF_PROP_PID_CODECID);
	if (ctx->srt_to_tx3g) {
		ctx->unframed = GF_TRUE;
		prop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);
		ctx->timescale = prop ? prop->value.uint : 1000;
	}
	else if (ctx->vtt_to_tx3g) {
		ctx->unframed = GF_TRUE;
		prop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);
		ctx->timescale = prop ? prop->value.uint : 1000;
	}
	else if (prop && (
		(prop->value.uint==GF_CODECID_WEBVTT)
		|| (prop->value.uint==GF_CODECID_SUBS_SSA)
	)) {
		codec_id = prop->value.uint;
		ctx->unframed = GF_TRUE;
		prop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);
		ctx->timescale = prop ? prop->value.uint : 1000;
	} else if (prop && (
		(prop->value.uint==GF_CODECID_SIMPLE_TEXT)
		|| (prop->value.uint==GF_CODECID_SUBS_TEXT)
	)) {
		codec_id = prop->value.uint;
		ctx->unframed = GF_TRUE;
		prop = gf_filter_pid_get_property(pid, GF_PROP_PID_TIMESCALE);
		ctx->timescale = prop ? prop->value.uint : 1000;
		gf_filter_pid_set_framing_mode(pid, GF_TRUE);
		if (!prop) {
			ctx->simple_text = GF_TRUE;
			gf_filter_pid_set_framing_mode(pid, GF_TRUE);
		}
	} else {
		//otherwise we must have a file path
		prop = gf_filter_pid_get_property(pid, GF_PROP_PID_FILEPATH);
		if (prop && prop->value.string) src = prop->value.string;

		if (!src)
			return GF_NOT_SUPPORTED;
	}

	if (!ctx->ipid) {
		GF_FilterEvent fevt;
		ctx->ipid = pid;

		if (src) {
			//we work with full file only, send a play event on source to indicate that
			GF_FEVT_INIT(fevt, GF_FEVT_PLAY, pid);
			fevt.play.start_range = 0;
			fevt.base.on_pid = ctx->ipid;
			fevt.play.full_file_only = GF_TRUE;
			gf_filter_pid_send_event(ctx->ipid, &fevt);
			ctx->file_name = gf_strdup(src);
		}
	} else {
		if (pid != ctx->ipid) {
			return GF_REQUIRES_NEW_INSTANCE;
		}
		if (src) {
			if (!strcmp(ctx->file_name, src)) return GF_OK;

			ttxtin_reset(ctx);
			ctx->is_setup = GF_FALSE;
			gf_free(ctx->file_name);
			ctx->file_name = gf_strdup(src);
		}
	}
	if (src) {
		//guess type
		e = gf_text_guess_format(ctx, ctx->file_name, &ctx->fmt);
		if (e) return e;
		if (!ctx->fmt) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTLoad] Unknown text format for %s\n", ctx->file_name));
			return GF_NOT_SUPPORTED;
		}
	} else {
		if (ctx->vtt_to_tx3g)
			ctx->fmt = GF_TXTIN_MODE_SRT;
		else if (ctx->srt_to_tx3g)
			ctx->fmt = GF_TXTIN_MODE_SRT;
		else if (codec_id == GF_CODECID_WEBVTT)
			ctx->fmt = GF_TXTIN_MODE_WEBVTT;
		else if (codec_id == GF_CODECID_SUBS_SSA)
			ctx->fmt = GF_TXTIN_MODE_SSA;
		else
			ctx->fmt = ctx->simple_text ? GF_TXTIN_MODE_SIMPLE : GF_TXTIN_MODE_SRT;
		if (!ctx->opid)
			ctx->opid = gf_filter_pid_new(filter);
	}

	if (ctx->webvtt && (ctx->fmt == GF_TXTIN_MODE_SRT))
		ctx->fmt = GF_TXTIN_MODE_WEBVTT;

	if (!src) {
		gf_filter_pid_copy_properties(ctx->opid, pid);
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );

		if (!ctx->simple_text)
			codec_id = (ctx->fmt == GF_TXTIN_MODE_WEBVTT) ? GF_CODECID_WEBVTT : GF_CODECID_TX3G;
		else if (ctx->stxtmod)
			codec_id = (ctx->stxtmod==STXT_MODE_VTT) ? GF_CODECID_WEBVTT : GF_CODECID_TX3G;

		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(codec_id) );
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL);
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, NULL);
	}

	switch (ctx->fmt) {
	case GF_TXTIN_MODE_SRT:
		ctx->text_process = txtin_process_srt;
		if (!ctx->is_setup && ctx->unframed) gen_ttxt_dsi = GF_TRUE;
		break;
#ifndef GPAC_DISABLE_VTT
	case GF_TXTIN_MODE_WEBVTT:
		ctx->text_process = txtin_process_webvtt;
		if (!ctx->is_setup && ctx->unframed) gen_webvtt_dsi = GF_TRUE;
		break;
#endif
	case GF_TXTIN_MODE_TTXT:
		ctx->text_process = txtin_process_ttxt;
		break;
	case GF_TXTIN_MODE_TEXML:
		ctx->text_process = txtin_process_texml;
		break;
	case GF_TXTIN_MODE_SUB:
		ctx->text_process = gf_text_process_sub;
		if (!ctx->is_setup && ctx->unframed) gen_ttxt_dsi = GF_TRUE;
		break;
	case GF_TXTIN_MODE_TTML:
		ctx->text_process = gf_text_process_ttml;
		break;
	case GF_TXTIN_MODE_SSA:
		ctx->text_process = gf_text_process_ssa;
		if (!ctx->is_setup && ctx->unframed) gen_ttxt_dsi = GF_TRUE;
		break;
#ifndef GPAC_DISABLE_SWF_IMPORT
	case GF_TXTIN_MODE_SWF_SVG:
		ctx->text_process = gf_text_process_swf;
		break;
#endif
	case GF_TXTIN_MODE_SIMPLE:
		ctx->text_process = txtin_process_simple;
		if (ctx->stxtmod==STXT_MODE_TX3G) gen_ttxt_dsi = 1;
		else if (ctx->stxtmod==STXT_MODE_VTT) gen_webvtt_dsi = 1;
		break;
	default:
		return GF_BAD_PARAM;
	}

	if (gen_ttxt_dsi) {
		txtin_setup_srt(filter, ctx, GF_TRUE);
	}
	if (gen_webvtt_dsi) {
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA((u8 *) "WEBVTT", 7 ) );
	}

	//when translating from unframed srt/vtt to framed tx3g/vtt, the number of input samples will be at most doubled by inserting blank samples
	if (ctx->unframed && !ctx->no_empty) {
		const GF_PropertyValue *p = gf_filter_pid_get_property(ctx->ipid, GF_PROP_PID_NB_FRAMES);
		if (p)
			gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NB_FRAMES, &PROP_UINT(p->value.uint*2));
	}

	return GF_OK;
}
