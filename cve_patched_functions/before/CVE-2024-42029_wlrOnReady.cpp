static void wlrOnReady(void* data, zwlr_screencopy_frame_v1* frame, uint32_t tv_sec_hi, uint32_t tv_sec_lo, uint32_t tv_nsec) {
    const auto PSESSION = (CScreencopyPortal::SSession*)data;

    Debug::log(TRACE, "[sc] wlrOnReady for {}", (void*)PSESSION);

    PSESSION->sharingData.status = FRAME_READY;

    PSESSION->sharingData.tvSec         = ((((uint64_t)tv_sec_hi) << 32) + (uint64_t)tv_sec_lo);
    PSESSION->sharingData.tvNsec        = tv_nsec;
    PSESSION->sharingData.tvTimestampNs = PSESSION->sharingData.tvSec * SPA_NSEC_PER_SEC + PSESSION->sharingData.tvNsec;

    Debug::log(TRACE, "[sc] frame timestamp sec: {} nsec: {} combined: {}ns", PSESSION->sharingData.tvSec, PSESSION->sharingData.tvNsec, PSESSION->sharingData.tvTimestampNs);

    g_pPortalManager->m_sPortals.screencopy->m_pPipewire->enqueue(PSESSION);

    if (g_pPortalManager->m_sPortals.screencopy->m_pPipewire->streamFromSession(PSESSION))
        g_pPortalManager->m_sPortals.screencopy->queueNextShareFrame(PSESSION);

    zwlr_screencopy_frame_v1_destroy(frame);
    PSESSION->sharingData.frameCallback = nullptr;
}
