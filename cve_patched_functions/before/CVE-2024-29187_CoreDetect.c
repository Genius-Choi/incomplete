extern "C" HRESULT CoreDetect(
    __in BURN_ENGINE_STATE* pEngineState,
    __in_opt HWND hwndParent
    )
{
    HRESULT hr = S_OK;
    BOOL fDetectBegan = FALSE;
    BURN_PACKAGE* pPackage = NULL;
    HRESULT hrFirstPackageFailure = S_OK;

    LogId(REPORT_STANDARD, MSG_DETECT_BEGIN, pEngineState->packages.cPackages);

    // Always reset the detect state which means the plan should be reset too.
    pEngineState->fDetected = FALSE;
    pEngineState->fPlanned = FALSE;
    DetectReset(&pEngineState->registration, &pEngineState->packages);
    PlanReset(&pEngineState->plan, &pEngineState->variables, &pEngineState->containers, &pEngineState->packages, &pEngineState->layoutPayloads);

    hr = RegistrationSetDynamicVariables(&pEngineState->registration, &pEngineState->variables);
    ExitOnFailure(hr, "Failed to reset the dynamic registration variables during detect.");

    fDetectBegan = TRUE;
    hr = UserExperienceOnDetectBegin(&pEngineState->userExperience, pEngineState->registration.fCached, pEngineState->registration.detectedRegistrationType, pEngineState->packages.cPackages);
    ExitOnRootFailure(hr, "UX aborted detect begin.");

    pEngineState->userExperience.hwndDetect = hwndParent;

    hr = SearchesExecute(&pEngineState->searches, &pEngineState->variables);
    ExitOnFailure(hr, "Failed to execute searches.");

    hr = DependencyDetectBundle(&pEngineState->dependencies, &pEngineState->registration);
    ExitOnFailure(hr, "Failed to detect the dependencies.");

    // Load all of the related bundles.
    hr = RegistrationDetectRelatedBundles(&pEngineState->registration);
    ExitOnFailure(hr, "Failed to detect related bundles.");

    hr = DetectForwardCompatibleBundles(&pEngineState->userExperience, &pEngineState->registration);
    ExitOnFailure(hr, "Failed to detect forward compatible bundle.");

    // Report the related bundles.
    hr = DetectReportRelatedBundles(&pEngineState->userExperience, &pEngineState->registration, pEngineState->command.relationType, &pEngineState->registration.fEligibleForCleanup);
    ExitOnFailure(hr, "Failed to report detected related bundles.");

    // Do update detection.
    hr = DetectUpdate(pEngineState->registration.sczId, &pEngineState->userExperience, &pEngineState->update);
    ExitOnFailure(hr, "Failed to detect update.");

    // Detecting MSPs requires special initialization before processing each package but
    // only do the detection if there are actually patch packages to detect because it
    // can be expensive.
    if (pEngineState->packages.cPatchInfo)
    {
        hr = MspEngineDetectInitialize(&pEngineState->packages);
        ExitOnFailure(hr, "Failed to initialize MSP engine detection.");

        hr = MsiEngineDetectInitialize(&pEngineState->packages);
        ExitOnFailure(hr, "Failed to initialize MSI engine detection.");
    }

    for (DWORD i = 0; i < pEngineState->packages.cPackages; ++i)
    {
        pPackage = pEngineState->packages.rgPackages + i;

        hr = DetectPackage(pEngineState, pPackage);

        // If the package detection failed, ensure the package state is set to unknown.
        if (FAILED(hr))
        {
            if (SUCCEEDED(hrFirstPackageFailure))
            {
                hrFirstPackageFailure = hr;
            }

            pPackage->currentState = BOOTSTRAPPER_PACKAGE_STATE_UNKNOWN;
            pPackage->cacheRegistrationState = BURN_PACKAGE_REGISTRATION_STATE_UNKNOWN;
            pPackage->installRegistrationState = BURN_PACKAGE_REGISTRATION_STATE_UNKNOWN;
            pPackage->compatiblePackage.fDetected = FALSE;
        }
    }

    // Log the detected states.
    for (DWORD iPackage = 0; iPackage < pEngineState->packages.cPackages; ++iPackage)
    {
        pPackage = pEngineState->packages.rgPackages + iPackage;

        // If any packages that can affect registration are present, then the bundle should not automatically be uninstalled.
        if (pEngineState->registration.fEligibleForCleanup && pPackage->fCanAffectRegistration &&
            (BURN_PACKAGE_REGISTRATION_STATE_PRESENT == pPackage->cacheRegistrationState ||
             BURN_PACKAGE_REGISTRATION_STATE_PRESENT == pPackage->installRegistrationState))
        {
            pEngineState->registration.fEligibleForCleanup = FALSE;
        }

        LogId(REPORT_STANDARD, MSG_DETECTED_PACKAGE, pPackage->sczId, LoggingPackageStateToString(pPackage->currentState), LoggingBoolToString(pPackage->fCached), LoggingPackageRegistrationStateToString(pPackage->fCanAffectRegistration, pPackage->installRegistrationState), LoggingPackageRegistrationStateToString(pPackage->fCanAffectRegistration, pPackage->cacheRegistrationState));

        if (BURN_PACKAGE_TYPE_MSI == pPackage->type)
        {
            for (DWORD iFeature = 0; iFeature < pPackage->Msi.cFeatures; ++iFeature)
            {
                const BURN_MSIFEATURE* pFeature = pPackage->Msi.rgFeatures + iFeature;
                LogId(REPORT_STANDARD, MSG_DETECTED_MSI_FEATURE, pPackage->sczId, pFeature->sczId, LoggingMsiFeatureStateToString(pFeature->currentState));
            }
        }
        else if (BURN_PACKAGE_TYPE_MSP == pPackage->type)
        {
            for (DWORD iTargetProduct = 0; iTargetProduct < pPackage->Msp.cTargetProductCodes; ++iTargetProduct)
            {
                const BURN_MSPTARGETPRODUCT* pTargetProduct = pPackage->Msp.rgTargetProducts + iTargetProduct;
                LogId(REPORT_STANDARD, MSG_DETECTED_MSP_TARGET, pPackage->sczId, pTargetProduct->wzTargetProductCode, LoggingPackageStateToString(pTargetProduct->patchPackageState));
            }
        }
    }

LExit:
    if (SUCCEEDED(hr))
    {
        hr = hrFirstPackageFailure;
    }

    if (SUCCEEDED(hr))
    {
        pEngineState->fDetected = TRUE;
    }

    if (fDetectBegan)
    {
        UserExperienceOnDetectComplete(&pEngineState->userExperience, hr, pEngineState->registration.fEligibleForCleanup);
    }

    pEngineState->userExperience.hwndDetect = NULL;

    LogId(REPORT_STANDARD, MSG_DETECT_COMPLETE, hr, !fDetectBegan ? "(failed)" : LoggingRegistrationTypeToString(pEngineState->registration.detectedRegistrationType), !fDetectBegan ? "(failed)" : LoggingBoolToString(pEngineState->registration.fCached), FAILED(hr) ? "(failed)" : LoggingBoolToString(pEngineState->registration.fEligibleForCleanup));

    return hr;
}
