connection_exit_connect(edge_connection_t *edge_conn)
{
  const tor_addr_t *addr;
  uint16_t port;
  connection_t *conn = TO_CONN(edge_conn);
  int socket_error = 0, result;
  const char *why_failed_exit_policy = NULL;

  /* Apply exit policy to non-rendezvous connections. */
  if (! connection_edge_is_rendezvous_stream(edge_conn) &&
      my_exit_policy_rejects(&edge_conn->base_.addr,
                             edge_conn->base_.port,
                             &why_failed_exit_policy)) {
    if (BUG(!why_failed_exit_policy))
      why_failed_exit_policy = "";
    log_info(LD_EXIT,"%s:%d failed exit policy%s. Closing.",
             escaped_safe_str_client(conn->address), conn->port,
             why_failed_exit_policy);
    connection_edge_end(edge_conn, END_STREAM_REASON_EXITPOLICY);
    circuit_detach_stream(circuit_get_by_edge_conn(edge_conn), edge_conn);
    connection_free(conn);
    return;
  }

#ifdef HAVE_SYS_UN_H
  if (conn->socket_family != AF_UNIX) {
#else
  {
#endif /* defined(HAVE_SYS_UN_H) */
    addr = &conn->addr;
    port = conn->port;

    if (tor_addr_family(addr) == AF_INET6)
      conn->socket_family = AF_INET6;

    log_debug(LD_EXIT, "about to try connecting");
    result = connection_connect(conn, conn->address,
                                addr, port, &socket_error);
#ifdef HAVE_SYS_UN_H
  } else {
    /*
     * In the AF_UNIX case, we expect to have already had conn->port = 1,
     * tor_addr_make_unspec(conn->addr) (cf. the way we mark in the incoming
     * case in connection_handle_listener_read()), and conn->address should
     * have the socket path to connect to.
     */
    tor_assert(conn->address && strlen(conn->address) > 0);

    log_debug(LD_EXIT, "about to try connecting");
    result = connection_connect_unix(conn, conn->address, &socket_error);
#endif /* defined(HAVE_SYS_UN_H) */
  }

  switch (result) {
    case -1: {
      int reason = errno_to_stream_end_reason(socket_error);
      connection_edge_end(edge_conn, reason);
      circuit_detach_stream(circuit_get_by_edge_conn(edge_conn), edge_conn);
      connection_free(conn);
      return;
    }
    case 0:
      conn->state = EXIT_CONN_STATE_CONNECTING;

      connection_watch_events(conn, READ_EVENT | WRITE_EVENT);
      /* writable indicates finish;
       * readable/error indicates broken link in windows-land. */
      return;
    /* case 1: fall through */
  }

  conn->state = EXIT_CONN_STATE_OPEN;
  if (connection_get_outbuf_len(conn)) {
    /* in case there are any queued data cells, from e.g. optimistic data */
    connection_watch_events(conn, READ_EVENT|WRITE_EVENT);
  } else {
    connection_watch_events(conn, READ_EVENT);
  }

  /* also, deliver a 'connected' cell back through the circuit. */
  if (connection_edge_is_rendezvous_stream(edge_conn)) {
    /* don't send an address back! */
    connection_edge_send_command(edge_conn,
                                 RELAY_COMMAND_CONNECTED,
                                 NULL, 0);
  } else { /* normal stream */
    uint8_t connected_payload[MAX_CONNECTED_CELL_PAYLOAD_LEN];
    int connected_payload_len =
      connected_cell_format_payload(connected_payload, &conn->addr,
                                    edge_conn->address_ttl);
    if (connected_payload_len < 0) {
      connection_edge_end(edge_conn, END_STREAM_REASON_INTERNAL);
      circuit_detach_stream(circuit_get_by_edge_conn(edge_conn), edge_conn);
      connection_free(conn);
      return;
    }

    connection_edge_send_command(edge_conn,
                                 RELAY_COMMAND_CONNECTED,
                                 (char*)connected_payload,
                                 connected_payload_len);
  }
}
