OFCondition UserIdentityNegotiationSubItemRQ::parseFromBuffer(unsigned char *readBuffer,
                                                              unsigned long &bytesRead,
                                                              unsigned long availData)
{
  /* BYTE POSITIONS
   * 0       Item Type
   * 1       Reserved (=0)
   * 2-3     Item Length
   * 4       User Identity Type
   * 5       Positive Response Requested
   * 6-7     Primary-field length
   * 8-n     Primary-field
   * n+1-n+2 Secondary-field length
   * n+3-m   Secondary-field
   */

  // If n and m are both 0, this takes 10 bytes (absolute minimum)
  if (availData < 10)
  {
      char buffer[256];
      sprintf(buffer, "DUL user identity rq length %ld. Need at least 10 bytes", availData);
      return makeDcmnetCondition(DULC_ILLEGALPDULENGTH, OF_error, buffer);
  }

  bytesRead = 0;
  // Skip "item type" and "reserved" field
  readBuffer += 2;
  // Parse total item content length
  unsigned short itemLength = 0;
  EXTRACT_SHORT_BIG(readBuffer, itemLength);
  readBuffer += 2;

  // Is itemLength larger than the available data from readBuffer?
  if (availData - 4 < itemLength)
  {
      char buffer[256];
      sprintf(buffer, "DUL illegal user identify rq length %ld. Info claims to be %hd bytes.",
              availData, itemLength);
      return makeDcmnetCondition(DULC_ILLEGALPDULENGTH, OF_error, buffer);
  }

  // Do some length checking
  if (itemLength < 6 ) // at least 6 bytes are mandatory: identity type(1) pos. response(1) primLength(2), secfieldlength(2)
    return EC_CorruptedData;

  // Parse user identity type
  const unsigned char identType = *readBuffer;
  if ((identType < 1) || (identType > ASC_USER_IDENTITY_MAX_VALUE))
    m_userIdentityType = ASC_USER_IDENTITY_UNKNOWN;
  else
    m_userIdentityType = OFstatic_cast(T_ASC_UserIdentityNegotiationMode, identType);
  readBuffer++;

  // Parse Positive Response Requested field
  m_posRspRequested = *readBuffer;
  readBuffer++;

  // Parse length of primary field
  EXTRACT_SHORT_BIG(readBuffer, m_primFieldLength);
  readBuffer += 2;

  // 4 bytes read so far and 2 bytes will be read after this sub-field
  if (itemLength - 4 - 2 < m_primFieldLength)
  {
      char buffer[256];
      sprintf(buffer, "DUL illegal user identify rq length %ld. Info claims to be %hd bytes. "
              "Primary field has %hd bytes.", availData, itemLength, m_primFieldLength);
      return makeDcmnetCondition(DULC_ILLEGALPDULENGTH, OF_error, buffer);
  }
  if (m_primFieldLength > 0)
  {
    m_primField = new char[m_primFieldLength];
    memcpy(m_primField, readBuffer, m_primFieldLength);
  }

  readBuffer += m_primFieldLength;
  bytesRead = 8 + m_primFieldLength; // 2+2+1+1+2+primary field length

  EXTRACT_SHORT_BIG(readBuffer, m_secFieldLength);
  readBuffer += 2;
  bytesRead += 2;

  // 6 + m_primField bytes read so far, trying to read m_secFieldLength more bytes
  if (itemLength - 6 - m_primFieldLength < m_secFieldLength)
  {
      char buffer[256];
      sprintf(buffer, "DUL illegal user identify rq length %ld. Info claims to be %hd bytes. "
              "Primary field has %hd bytes. Secondary field has %hd bytes.",
              availData, itemLength, m_primFieldLength, m_secFieldLength);
      return makeDcmnetCondition(DULC_ILLEGALPDULENGTH, OF_error, buffer);
  }

  // only user identity type 2 (Username + password authentication) requires second value field
  if ( (m_userIdentityType == ASC_USER_IDENTITY_USER_PASSWORD) && (m_secFieldLength > 0) )
  {
    m_secField = new char[m_secFieldLength];
    memcpy(m_secField, readBuffer, m_secFieldLength);
    //m_secField.append((const char*)readBuffer, m_secFieldLength);
    readBuffer += m_secFieldLength;
    bytesRead += m_secFieldLength;
  }

  return EC_Normal;
}
