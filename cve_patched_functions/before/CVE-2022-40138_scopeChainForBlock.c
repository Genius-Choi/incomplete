static llvh::Optional<ScopeChain> scopeChainForBlock(
    Runtime &runtime,
    const CodeBlock *cb) {
  OptValue<uint32_t> lexicalDataOffset = cb->getDebugLexicalDataOffset();
  if (!lexicalDataOffset)
    return llvh::None;

  ScopeChain scopeChain;
  RuntimeModule *runtimeModule = cb->getRuntimeModule();
  const hbc::BCProvider *bytecode = runtimeModule->getBytecode();
  const hbc::DebugInfo *debugInfo = bytecode->getDebugInfo();
  while (lexicalDataOffset) {
    GCScopeMarkerRAII marker{runtime};
    scopeChain.functions.emplace_back();
    auto &scopeItem = scopeChain.functions.back();
    // Append a new list to the chain.
    auto names = debugInfo->getVariableNames(*lexicalDataOffset);
    scopeItem.variables.insert(
        scopeItem.variables.end(), names.begin(), names.end());

    // Get the parent item.
    // Stop at the global block.
    auto parentId = debugInfo->getParentFunctionId(*lexicalDataOffset);
    if (!parentId)
      break;

    lexicalDataOffset = runtimeModule->getCodeBlockMayAllocate(*parentId)
                            ->getDebugLexicalDataOffset();

    if (!lexicalDataOffset) {
      // The function has a parent, but the parent doesn't have debug info.
      // This could happen when the parent is global.
      // "global" doesn't have a lexical parent.
      // "global" may have 0 variables, and may have no lexical info
      // (which is the case for synthesized parent scopes in lazy compilation).
      // In such case, BytecodeFunctionGenerator::hasDebugInfo returns false,
      // resulting in no debug offset for global in the bytecode.
      // Note that assert "*parentId == bytecode->getGlobalFunctionIndex()"
      // will fail because the getGlobalFunctionIndex() function returns
      // the entry point instead of the global function. The entry point
      // is not the same as the global function in the context of
      // lazy compilation.
      scopeChain.functions.emplace_back();
    }
  }
  return {std::move(scopeChain)};
}
