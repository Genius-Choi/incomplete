GF_Err gf_svg_attributes_copy(GF_FieldInfo *a, GF_FieldInfo *b, Bool clamp)
{
	if (!a->far_ptr || !b->far_ptr) return GF_BAD_PARAM;
	switch (a->fieldType) {
	/* Numeric types */
	case SVG_Color_datatype:
		*((SVG_Color *)a->far_ptr) = *((SVG_Color *)b->far_ptr);
		if (clamp) svg_color_clamp((SVG_Color *)a->far_ptr);
		break;

	case SVG_Paint_datatype:
	{
		SVG_Paint *pa = (SVG_Paint *)a->far_ptr;
		SVG_Paint *pb = (SVG_Paint *)b->far_ptr;
		pa->type = pb->type;
		if (pb->type == SVG_PAINT_URI) {
			GF_FieldInfo tmp_a, tmp_b;
			tmp_a.fieldType = tmp_b.fieldType = XMLRI_datatype;
			tmp_a.far_ptr = &pa->iri;
			tmp_b.far_ptr = &pb->iri;
			gf_svg_attributes_copy(&tmp_a, &tmp_b, 0);
		} else {
			pa->color = pb->color;
		}
		return GF_OK;
	}
	break;

	case SVG_Number_datatype:
	case SVG_Length_datatype:
	case SVG_Coordinate_datatype:
	case SVG_FontSize_datatype:
		*((SVG_Number *)a->far_ptr) = *((SVG_Number *)b->far_ptr);
		break;

	case SVG_ViewBox_datatype:
		*((SVG_ViewBox *)a->far_ptr) = *((SVG_ViewBox *)b->far_ptr);
		break;

	case SVG_Points_datatype:
		return svg_points_copy((GF_List**)a->far_ptr, (GF_List**)b->far_ptr);

	case SVG_Numbers_datatype:
	case SVG_Coordinates_datatype:
		return svg_numbers_copy((GF_List**)a->far_ptr, (GF_List**)b->far_ptr);

	case SVG_PathData_datatype:
		return svg_path_copy((SVG_PathData*)a->far_ptr, (SVG_PathData*)b->far_ptr);

	case SVG_StrokeDashArray_datatype:
		return svg_dasharray_copy((SVG_StrokeDashArray*)a->far_ptr, (SVG_StrokeDashArray*)b->far_ptr);

	case SVG_Motion_datatype:
		gf_mx2d_copy(*(GF_Matrix2D *)a->far_ptr, *(GF_Matrix2D *)b->far_ptr);
		return GF_OK;

	case SVG_Transform_datatype:
		switch (b->fieldType) {
		case SVG_Transform_Translate_datatype:
			gf_mx2d_init(((SVG_Transform *)a->far_ptr)->mat);
			gf_mx2d_add_translation(&((SVG_Transform *)a->far_ptr)->mat, ((SVG_Point*)b->far_ptr)->x, ((SVG_Point*)b->far_ptr)->y);
			break;
		case SVG_Transform_Scale_datatype:
			gf_mx2d_init(((SVG_Transform *)a->far_ptr)->mat);
			gf_mx2d_add_scale(&((SVG_Transform *)a->far_ptr)->mat, ((SVG_Point*)b->far_ptr)->x, ((SVG_Point*)b->far_ptr)->y);
			break;
		case SVG_Transform_Rotate_datatype:
			gf_mx2d_init(((SVG_Transform *)a->far_ptr)->mat);
			gf_mx2d_add_rotation(&((SVG_Transform *)a->far_ptr)->mat, ((SVG_Point_Angle*)b->far_ptr)->x, ((SVG_Point_Angle*)b->far_ptr)->y, ((SVG_Point_Angle*)b->far_ptr)->angle);
			break;
		case SVG_Transform_SkewX_datatype:
			gf_mx2d_init(((SVG_Transform *)a->far_ptr)->mat);
			gf_mx2d_add_skew_x(&((SVG_Transform *)a->far_ptr)->mat, *(Fixed *)b->far_ptr);
			break;
		case SVG_Transform_SkewY_datatype:
			gf_mx2d_init(((SVG_Transform *)a->far_ptr)->mat);
			gf_mx2d_add_skew_y(&((SVG_Transform *)a->far_ptr)->mat, *(Fixed *)b->far_ptr);
			break;
		case SVG_Transform_datatype:
			gf_mx2d_copy(((SVG_Transform *)a->far_ptr)->mat, ((SVG_Transform *)b->far_ptr)->mat);
			break;
		default:
			GF_LOG(GF_LOG_ERROR, GF_LOG_SCENE, ("[SVG Attributes] forbidden type of transform\n"));
			return GF_NOT_SUPPORTED;
		}
		return GF_OK;

	/* Keyword types */
	case SVG_Boolean_datatype:
	case SVG_FillRule_datatype:
	case SVG_StrokeLineJoin_datatype:
	case SVG_StrokeLineCap_datatype:
	case SVG_FontStyle_datatype:
	case SVG_FontWeight_datatype:
	case SVG_FontVariant_datatype:
	case SVG_TextAnchor_datatype:
	case SVG_Display_datatype:
	case SVG_Visibility_datatype:
	case SVG_GradientUnit_datatype:
	case SVG_PreserveAspectRatio_datatype:
	case XML_Space_datatype:
	case XMLEV_Propagate_datatype:
	case XMLEV_DefaultAction_datatype:
	case XMLEV_Phase_datatype:
	case SMIL_SyncBehavior_datatype:
	case SMIL_AttributeType_datatype:
	case SMIL_CalcMode_datatype:
	case SMIL_Additive_datatype:
	case SMIL_Accumulate_datatype:
	case SMIL_Restart_datatype:
	case SMIL_Fill_datatype:
	case SVG_Overflow_datatype:
	case SVG_ZoomAndPan_datatype:
	case SVG_DisplayAlign_datatype:
	case SVG_TextAlign_datatype:
	case SVG_PointerEvents_datatype:
	case SVG_RenderingHint_datatype:
	case SVG_VectorEffect_datatype:
	case SVG_PlaybackOrder_datatype:
	case SVG_TimelineBegin_datatype:
	case SVG_TransformType_datatype:
	case SVG_Focusable_datatype:
	case SVG_FocusHighlight_datatype:
		*(u8 *)a->far_ptr = *(u8 *)b->far_ptr;
		return GF_OK;

	case SMIL_SyncTolerance_datatype:
		*(SMIL_SyncTolerance*)a->far_ptr = *(SMIL_SyncTolerance*)b->far_ptr;
		return GF_OK;
	/* Other types */
	case SVG_ID_datatype:
	case SVG_LanguageID_datatype:
	case SVG_ContentType_datatype:
	case DOM_String_datatype:
		if (* (SVG_String *)a->far_ptr) gf_free(* (SVG_String *)a->far_ptr);
		* (SVG_String *)a->far_ptr = *(SVG_String *)b->far_ptr ? gf_strdup(*(SVG_String *)b->far_ptr) : NULL;
		return GF_OK;

	case SVG_FontFamily_datatype:
		((SVG_FontFamily *)a->far_ptr)->type = ((SVG_FontFamily *)b->far_ptr)->type;
		if ( ((SVG_FontFamily *)a->far_ptr)->value) gf_free( ((SVG_FontFamily *)a->far_ptr)->value );
		((SVG_FontFamily *)a->far_ptr)->value = (((SVG_FontFamily *)b->far_ptr)->value ? gf_strdup(((SVG_FontFamily *)b->far_ptr)->value) : NULL );
		return GF_OK;

	case XMLRI_datatype:
	case XML_IDREF_datatype:
		((XMLRI *)a->far_ptr)->type = ((XMLRI *)b->far_ptr)->type;
		if (((XMLRI *)a->far_ptr)->string) gf_free(((XMLRI *)a->far_ptr)->string);
		if (((XMLRI *)b->far_ptr)->string) {
			((XMLRI *)a->far_ptr)->string = gf_strdup(((XMLRI *)b->far_ptr)->string);
		} else {
			((XMLRI *)a->far_ptr)->string = gf_strdup("");
		}
		((XMLRI *)a->far_ptr)->target = ((XMLRI *)b->far_ptr)->target;
		if (((XMLRI *)a->far_ptr)->type == XMLRI_ELEMENTID) {
			GF_Node *n = (GF_Node *) ((XMLRI *)b->far_ptr)->target;
			/*TODO Check if assigning IRI from # scenegraph can happen*/
			if (n) gf_node_register_iri(gf_node_get_graph(n), (XMLRI*)a->far_ptr);
		}
		return GF_OK;

	case SVG_Focus_datatype:
	{
		((SVG_Focus *)a->far_ptr)->type = ((SVG_Focus *)b->far_ptr)->type;
		if ( ((SVG_Focus *)b->far_ptr)->target.string)
			((SVG_Focus *)a->far_ptr)->target.string = gf_strdup( ((SVG_Focus *)b->far_ptr)->target.string);
	}
		return GF_OK;

	case SVG_ClipPath_datatype:
		if ( ((SVG_ClipPath *)b->far_ptr)->target.string) {
			if (((SVG_ClipPath *)a->far_ptr)->target.string)
				gf_free(((SVG_ClipPath *)a->far_ptr)->target.string);
			((SVG_ClipPath *)a->far_ptr)->target.string = gf_strdup( ((SVG_ClipPath *)b->far_ptr)->target.string);
		}
		return GF_OK;

	case SMIL_Times_datatype:
	{
		u32 i, count;
		GF_List *dst = *(GF_List **)a->far_ptr;
		GF_List *src = *(GF_List **)b->far_ptr;
		while (gf_list_count(dst)) {
			SMIL_Time *t = gf_list_get(dst, 0);
			gf_list_rem(dst, 0);
			gf_free(t);
		}
		count = gf_list_count(src);
		for (i=0; i<count; i++) {
			SMIL_Time *t2;
			SMIL_Time *t = gf_list_get(src, i);
			t2 = (SMIL_Time*)gf_malloc(sizeof(SMIL_Time));
			memcpy(t2, t, sizeof(SMIL_Time));
			gf_list_add(dst, t2);
		}
	}
	return GF_OK;
	case SMIL_AttributeName_datatype:
	{
		SMIL_AttributeName *saa = (SMIL_AttributeName *)a->far_ptr;
		SMIL_AttributeName *sab = (SMIL_AttributeName *)b->far_ptr;
		saa->tag = sab->tag;
		saa->type = sab->type;
		saa->name = sab->name ? gf_strdup(sab->name) : NULL;
	}
	break;
	case SMIL_Duration_datatype:
	{
		SMIL_Duration *da = (SMIL_Duration*)a->far_ptr;
		SMIL_Duration *db = (SMIL_Duration*)b->far_ptr;
		da->type = db->type;
		da->clock_value = db->clock_value;
	}
	break;
	case SMIL_AnimateValue_datatype:
	{
		SMIL_AnimateValue *sa = (SMIL_AnimateValue*)a->far_ptr;
		SMIL_AnimateValue *sb = (SMIL_AnimateValue*)b->far_ptr;
		sa->type = sb->type;
		if (sb->value) {
			GF_FieldInfo ava, avb;
			sa->value = gf_svg_create_attribute_value(sa->type);
			ava.fieldIndex = avb.fieldIndex = 0;
			ava.fieldType = avb.fieldType = sb->type;
			ava.far_ptr = sa->value;
			avb.far_ptr = sb->value;
			gf_svg_attributes_copy(&ava, &avb, 0);
		}
	}
	break;

	/* Unsupported types */
	case XMLRI_List_datatype:
	case DOM_StringList_datatype:
	case SVG_GradientOffset_datatype:
	case SVG_Clock_datatype:
	case SMIL_KeyTimes_datatype:
	case SMIL_KeyPoints_datatype:
	case SMIL_KeySplines_datatype:
	case SMIL_AnimateValues_datatype:
	case SMIL_RepeatCount_datatype:
	default:
		GF_LOG(GF_LOG_WARNING, GF_LOG_SCENE, ("[SVG Attributes] copy of attributes %s of type %s not supported\n", a->name, gf_svg_attribute_type_to_string(a->fieldType)));
		return GF_OK;
	}
	return GF_OK;
}
