static void print_json_string(RCore *core, const char* block, int len, const char* type) {
	const char* section_name = r_core_get_section_name (core, core->offset);
	if (section_name && strlen (section_name) < 1) {
		section_name = "unknown";
	} else if (section_name) {
		// cleaning useless spaces in section name in json data.
		section_name = r_str_trim_head_ro (section_name);
		char* p;
		for (p = (char*) section_name; *p && *p != ' '; p++) {}
		*p = '\0';
	}
	if (!section_name) {
		section_name = "unknown";
	}
	if (!type) {
		switch (get_string_type (core->block, len)) {
		case 'w': type = "wide"; break;
		case 'a': type = "ascii"; break;
		case 'u': type = "utf"; break;
		default: type = "unknown"; break;
		}
	}
	bool is_wide = !strcmp (type, "wide");
	size_t slen = r_str_nlen (block, len);
	char *tblock = (char *)block;
	if (is_wide) {
		int i;
		// dewide
		tblock = r_mem_dup (block, len);
		for (i = 0; i < len; i++) {
			if (tblock[i] && !tblock[i + 1]) {
				memmove (tblock + i + 1, tblock + i + 2, len - i - 2);
			} else {
				tblock[i] = 0;
				break;
			}
		}
		slen = strlen (tblock);
	}
	PJ *pj = r_core_pj_new (core);
	if (pj) {
		pj_o (pj);
		pj_k (pj, "string");
		// TODO: add pj_kd for data to pass key(string) and value(data,len) instead of pj_ks which null terminates
		char *str = r_str_utf16_encode (tblock, slen); // XXX just block + len should be fine, pj takes care of this
		pj_raw (pj, "\"");
		pj_raw (pj, str);
		free (str);
		pj_raw (pj, "\"");
		pj_kn (pj, "offset", core->offset);
		pj_ks (pj, "section", section_name);
		pj_ki (pj, "length", slen);
		pj_ks (pj, "type", type);
		pj_end (pj);
		r_cons_println (pj_string (pj));
		pj_free (pj);
	}
	if (tblock != block) {
		free (tblock);
	}
}
