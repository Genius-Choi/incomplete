static void dasher_update_rep(GF_DasherCtx *ctx, GF_DashStream *ds)
{
	char szCodec[RFC6381_CODEC_NAME_SIZE_MAX];

	//Outputs are not yet connected, derive mime from init segment extension
	if (!ds->rep->mime_type) {
		const char *subtype = NULL;
		dasher_get_mime_and_ext(ctx, ds, &subtype, NULL);

		if (ds->stream_type==GF_STREAM_VISUAL)
			gf_dynstrcat(&ds->rep->mime_type, "video/", NULL);
		else if (ds->stream_type==GF_STREAM_AUDIO)
			gf_dynstrcat(&ds->rep->mime_type, "audio/", NULL);
		else
			gf_dynstrcat(&ds->rep->mime_type, "application/", NULL);

		gf_dynstrcat(&ds->rep->mime_type, subtype, NULL);
	}

	ds->rep->bandwidth = ds->bitrate;
	if (ds->stream_type==GF_STREAM_VISUAL) {
		ds->rep->width = ds->width;
		ds->rep->height = ds->height;


		if (!ds->rep->sar) {
			GF_SAFEALLOC(ds->rep->sar, GF_MPD_Fractional);
		}
		if (ds->rep->sar) {
			ds->rep->sar->num = ds->sar.num;
			ds->rep->sar->den = ds->sar.den;
		}
		if (ds->fps.num && ds->fps.den) {
			if (!ds->rep->framerate) {
				GF_SAFEALLOC(ds->rep->framerate, GF_MPD_Fractional);
			}
			if (ds->rep->framerate) {
				ds->rep->framerate->num = ds->fps.num;
				ds->rep->framerate->den = ds->fps.den;
				gf_media_get_reduced_frame_rate(&ds->rep->framerate->num, &ds->rep->framerate->den);
			}
		}
	}
	else if (ds->stream_type==GF_STREAM_AUDIO) {
		Bool use_cicp = GF_FALSE;
		Bool use_dolbyx = GF_FALSE;
		GF_MPD_Descriptor *desc;
		char value[256];
		ds->rep->samplerate = ds->sr;

		if (ds->nb_surround || ds->nb_lfe) use_cicp = GF_TRUE;
		if ((ds->codec_id==GF_CODECID_MHAS) || (ds->codec_id==GF_CODECID_MPHA)) use_cicp = GF_TRUE;
		if ((ds->codec_id==GF_CODECID_DTS_EXPRESS_LBR) || (ds->codec_id==GF_CODECID_DTS_CA) || (ds->codec_id==GF_CODECID_DTS_HD_HR_MASTER)
		    || (ds->codec_id==GF_CODECID_DTS_HD_LOSSLESS) || (ds->codec_id==GF_CODECID_DTS_X) || (ds->codec_id==GF_CODECID_DTS_Y))
			use_cicp = GF_TRUE;

		if ((ds->codec_id==GF_CODECID_AC3) || (ds->codec_id==GF_CODECID_EAC3)) {
			//if regular MPEG-DASH, use CICP, otherwise use Dolby signaling
			if (ctx->profile > GF_DASH_PROFILE_FULL) {
				use_dolbyx = GF_TRUE;
			}
		}
		if (use_dolbyx) {
			u32 cicp_layout = 0;
			if (ds->ch_layout)
				cicp_layout = gf_audio_fmt_get_cicp_from_layout(ds->ch_layout);
			if (!cicp_layout)
				cicp_layout = gf_audio_fmt_get_cicp_layout(ds->nb_ch, ds->nb_surround, ds->nb_lfe);

			sprintf(value, "%X", gf_audio_fmt_get_dolby_chanmap(cicp_layout) );
			desc = gf_mpd_descriptor_new(NULL, "tag:dolby.com,2014:dash:audio_channel_configuration:2011", value);
		}
		else if (!use_cicp) {
			sprintf(value, "%d", ds->nb_ch);
			desc = gf_mpd_descriptor_new(NULL, "urn:mpeg:dash:23003:3:audio_channel_configuration:2011", value);
		} else {
			sprintf(value, "%d", gf_audio_fmt_get_cicp_layout(ds->nb_ch, ds->nb_surround, ds->nb_lfe));
			desc = gf_mpd_descriptor_new(NULL, "urn:mpeg:mpegB:cicp:ChannelConfiguration", value);
		}

		gf_mpd_del_list(ds->rep->audio_channels, gf_mpd_descriptor_free, GF_TRUE);

		gf_list_add(ds->rep->audio_channels, desc);
		if (ds->atmos_complexity_type) {
			desc = gf_mpd_descriptor_new(NULL, "tag:dolby.com,2018:dash:EC3_ExtensionType:2018", "JOC");
			gf_list_add(ds->rep->supplemental_properties, desc);

			sprintf(value, "%d", ds->atmos_complexity_type);
			desc = gf_mpd_descriptor_new(NULL, "tag:dolby.com,2018:dash:EC3_ExtensionComplexityIndex:2018", value);
			gf_list_add(ds->rep->supplemental_properties, desc);
		}
	} else {
	}

	if (ctx->from_index <= IDXMODE_MANIFEST) {
		dasher_get_rfc_6381_codec_name(ctx, ds, szCodec, ((ctx->bs_switch==DASHER_BS_SWITCH_INBAND) || (ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS)) ? GF_TRUE : GF_FALSE, GF_TRUE);
		if (ds->rep->codecs) gf_free(ds->rep->codecs);
		ds->rep->codecs = gf_strdup(szCodec);
	}

	if (ds->interlaced) ds->rep->scan_type = GF_MPD_SCANTYPE_INTERLACED;
	else {
		//profiles forcing scanType=progressive for progressive
		switch (ctx->profile) {
		case GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE:
			ds->rep->scan_type = GF_MPD_SCANTYPE_PROGRESSIVE;
			break;
		}
	}

	if (ctx->cp!=GF_DASH_CPMODE_ADAPTATION_SET) {
		gf_mpd_del_list(ds->rep->content_protection, gf_mpd_descriptor_free, 0);
		ds->rep->content_protection = dasher_get_content_protection_desc(ctx, ds, NULL);
	}
}
