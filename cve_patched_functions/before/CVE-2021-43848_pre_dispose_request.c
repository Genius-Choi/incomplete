static void pre_dispose_request(struct st_h2o_http3_server_stream_t *stream)
{
    size_t i;

    /* release vectors */
    for (i = 0; i != stream->sendbuf.vecs.size; ++i) {
        struct st_h2o_http3_server_sendvec_t *vec = stream->sendbuf.vecs.entries + i;
        if (vec->vec.callbacks->update_refcnt != NULL)
            vec->vec.callbacks->update_refcnt(&vec->vec, &stream->req, 0);
    }

    /* dispose request body buffer */
    if (stream->req_body != NULL)
        h2o_buffer_dispose(&stream->req_body);

    /* clean up request streaming */
    if (stream->req.write_req.cb != NULL) {
        struct st_h2o_http3_server_conn_t *conn = get_conn(stream);
        assert(conn->num_streams_req_streaming != 0);
        --conn->num_streams_req_streaming;
        check_run_blocked(conn);
    }

    /* clean up tunnel */
    if (stream->tunnel != NULL) {
        if (stream->tunnel->tunnel != NULL) {
            retain_sendvecs(stream);
            stream->tunnel->tunnel->destroy(stream->tunnel->tunnel);
            stream->tunnel->tunnel = NULL;
        }
        if (h2o_timer_is_linked(&stream->tunnel->up.delayed_write))
            h2o_timer_unlink(&stream->tunnel->up.delayed_write);
        free(stream->tunnel);
        stream->tunnel = NULL;
    }
}
