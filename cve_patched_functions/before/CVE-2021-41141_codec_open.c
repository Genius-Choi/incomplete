static pj_status_t codec_open( pjmedia_codec *codec, 
			       pjmedia_codec_param *attr )
{
    codec_private_t *codec_data = (codec_private_t*) codec->codec_data;
    struct codec_desc *desc = &codec_desc[codec_data->codec_idx];
    pj_pool_t *pool;
    int i, j;

    pool = codec_data->pool;

    /* Cache samples per frame value */
    codec_data->samples_per_frame = desc->samples_per_frame;

    /* Calculate bitstream size */
    i = attr->info.avg_bps * codec_data->samples_per_frame;
    j = desc->clock_rate << 3;
    codec_data->avg_frame_size = (pj_uint16_t)(i / j);
    if (i % j) ++codec_data->avg_frame_size;

#if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR
    /* Init AMR settings */
    if (desc->pt == PJMEDIA_RTP_PT_AMR || desc->pt == PJMEDIA_RTP_PT_AMRWB) {
	amr_settings_t *s;
	pj_uint8_t octet_align = 0;
	pj_int8_t enc_mode;
	
	enc_mode = pjmedia_codec_amr_get_mode(attr->info.avg_bps);
	pj_assert(enc_mode >= 0 && enc_mode <= 8);

	for (i = 0; i < attr->setting.dec_fmtp.cnt; ++i) {
	    const pj_str_t STR_FMTP_OCTET_ALIGN = {"octet-align", 11};
	    
	    /* Fetch octet-align setting. It should be fine to fetch only 
	     * the decoder, since encoder & decoder must use the same setting 
	     * (RFC 4867 section 8.3.1).
	     */
	    if (pj_stricmp(&attr->setting.dec_fmtp.param[i].name, 
			   &STR_FMTP_OCTET_ALIGN) == 0)
	    {
		octet_align=(pj_uint8_t)
			    (pj_strtoul(&attr->setting.dec_fmtp.param[i].val));
		break;
	    }
	}

	for (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {
	    const pj_str_t STR_FMTP_MODE_SET = {"mode-set", 8};

	    /* mode-set, encoding mode is chosen based on local default mode 
	     * setting:
	     * - if local default mode is included in the mode-set, use it
	     * - otherwise, find the closest mode to local default mode;
	     *   if there are two closest modes, prefer to use the higher
	     *   one, e.g: local default mode is 4, the mode-set param
	     *   contains '2,3,5,6', then 5 will be chosen.
	     */
	    if (pj_stricmp(&attr->setting.enc_fmtp.param[i].name, 
			   &STR_FMTP_MODE_SET) == 0)
	    {
		const char *p;
		pj_size_t l;
		pj_int8_t diff = 99;
		
		p = pj_strbuf(&attr->setting.enc_fmtp.param[i].val);
		l = pj_strlen(&attr->setting.enc_fmtp.param[i].val);

		while (l--) {
		    if ((desc->pt==PJMEDIA_RTP_PT_AMR && *p>='0' && *p<='7') ||
		        (desc->pt==PJMEDIA_RTP_PT_AMRWB && *p>='0' && *p<='8'))
		    {
			pj_int8_t tmp = (pj_int8_t)(*p - '0' - enc_mode);

			if (PJ_ABS(diff) > PJ_ABS(tmp) || 
			    (PJ_ABS(diff) == PJ_ABS(tmp) && tmp > diff))
			{
			    diff = tmp;
			    if (diff == 0) break;
			}
		    }
		    ++p;
		}

		if (diff == 99)
		    return PJMEDIA_CODEC_EFAILED;

		enc_mode = (pj_int8_t)(enc_mode + diff);

		break;
	    }
	}

	s = PJ_POOL_ZALLOC_T(pool, amr_settings_t);
	codec_data->codec_setting = s;

	s->enc_mode = enc_mode;
	if (s->enc_mode < 0)
	    return PJMEDIA_CODEC_EINMODE;

	s->enc_setting.amr_nb = (pj_uint8_t)(desc->pt == PJMEDIA_RTP_PT_AMR);
	s->enc_setting.octet_aligned = octet_align;
	s->enc_setting.reorder = PJ_FALSE; /* Note this! passthrough codec
					      doesn't do sensitivity bits 
					      reordering */
	s->enc_setting.cmr = 15;
	
	s->dec_setting.amr_nb = (pj_uint8_t)(desc->pt == PJMEDIA_RTP_PT_AMR);
	s->dec_setting.octet_aligned = octet_align;
	s->dec_setting.reorder = PJ_FALSE; /* Note this! passthrough codec
					      doesn't do sensitivity bits 
					      reordering */
	
	/* Return back bitrate info to application */
	attr->info.avg_bps = s->enc_setting.amr_nb?
			     pjmedia_codec_amrnb_bitrates[s->enc_mode]:
			     pjmedia_codec_amrwb_bitrates[s->enc_mode];
    }
#endif

#if PJMEDIA_HAS_PASSTHROUGH_CODEC_ILBC
    /* Init iLBC settings */
    if (desc->pt == PJMEDIA_RTP_PT_ILBC)
    {
	enum { DEFAULT_MODE = 30 };
	static pj_str_t STR_MODE = {"mode", 4};
	pj_uint16_t dec_fmtp_mode = DEFAULT_MODE, 
		    enc_fmtp_mode = DEFAULT_MODE;

	/* Get decoder mode */
	for (i = 0; i < attr->setting.dec_fmtp.cnt; ++i) {
	    if (pj_stricmp(&attr->setting.dec_fmtp.param[i].name, &STR_MODE) == 0)
	    {
		dec_fmtp_mode = (pj_uint16_t)
				pj_strtoul(&attr->setting.dec_fmtp.param[i].val);
		break;
	    }
	}

	/* Decoder mode must be set */
	PJ_ASSERT_RETURN(dec_fmtp_mode == 20 || dec_fmtp_mode == 30, 
			 PJMEDIA_CODEC_EINMODE);

	/* Get encoder mode */
	for (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {
	    if (pj_stricmp(&attr->setting.enc_fmtp.param[i].name, &STR_MODE) == 0)
	    {
		enc_fmtp_mode = (pj_uint16_t)
				pj_strtoul(&attr->setting.enc_fmtp.param[i].val);
		break;
	    }
	}

	PJ_ASSERT_RETURN(enc_fmtp_mode==20 || enc_fmtp_mode==30, 
			 PJMEDIA_CODEC_EINMODE);

	/* Both sides of a bi-directional session MUST use the same "mode" value.
	 * In this point, possible values are only 20 or 30, so when encoder and
	 * decoder modes are not same, just use the default mode, it is 30.
	 */
	if (enc_fmtp_mode != dec_fmtp_mode) {
	    enc_fmtp_mode = dec_fmtp_mode = DEFAULT_MODE;
	    PJ_LOG(4,(pool->obj_name, 
		      "Normalized iLBC encoder and decoder modes to %d", 
		      DEFAULT_MODE));
	}

	/* Update some attributes based on negotiated mode. */
	attr->info.avg_bps = (dec_fmtp_mode == 30? 13333 : 15200);
	attr->info.frm_ptime = dec_fmtp_mode;

	/* Override average frame size */
	codec_data->avg_frame_size = (dec_fmtp_mode == 30? 50 : 38);

	/* Override samples per frame */
	codec_data->samples_per_frame = (dec_fmtp_mode == 30? 240 : 160);
    }
#endif

    return PJ_SUCCESS;
}
