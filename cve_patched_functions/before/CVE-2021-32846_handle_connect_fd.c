static void handle_connect_fd(struct pci_vtsock_softc *sc, int accept_fd, uint64_t cid, uint32_t port)
{
	int fd, rc;
	char buf[8 + 1 + 8 + 1 + 1]; /* %08x.%08x\n\0 */
	ssize_t bytes;
	struct pci_vtsock_sock *sock = NULL;

	fd = accept(accept_fd, NULL, NULL);
	if (fd < 0) {
		fprintf(stderr,
			"TX: Unable to accept incoming connection: %d (%s)\n",
			errno, strerror(errno));
		return;
	}

	if (fd >= FD_SETSIZE) {
		fprintf(stderr, "TX: Unable to accept incoming connection: fd %d > FD_SETSIZE %d\n",
			fd, FD_SETSIZE);
		close(fd);
		goto err;
	}

	DPRINTF(("TX: Connect attempt on connect fd => %d\n", fd));

	if (cid == VMADDR_CID_ANY) {
		do {
			bytes = read(fd, buf, sizeof(buf)-1);
		} while (bytes == -1 && errno == EAGAIN);

		if (bytes != sizeof(buf) - 1) {
			DPRINTF(("TX: Short read on connect %zd/%zd\n", bytes, sizeof(buf)-1));
			if (bytes == -1) DPRINTF(("TX: errno: %s\n", strerror(errno)));
			goto err;
		}
		buf[sizeof(buf)-1] = '\0';

		if (buf[sizeof(buf)-2] != '\n') {
			DPRINTF(("TX: No newline on connect %s\n", buf));
			goto err;
		}

		DPRINTF(("TX: Connect to %s", buf));

		rc = sscanf(buf, SCNaddr"\n", &cid, &port);
		if (rc != 2) {
			DPRINTF(("TX: Failed to parse connect attempt\n"));
			goto err;
		}
		DPRINTF(("TX: Connection requested to "PRIaddr"\n", cid, port));
	} else {
		DPRINTF(("TX: Forwarding connection to "PRIaddr"\n", cid, port));
	}

	if (cid >= VMADDR_CID_MAX) {
		DPRINTF(("TX: Attempt to connect to CID over 32-bit\n"));
		goto err;
	}
	if (cid != sc->vssc_cfg.guest_cid) {
		DPRINTF(("TX: Attempt to connect to non-guest CID\n"));
		goto err;
	}

	sock = alloc_sock(sc);

	if (sock == NULL) {
		DPRINTF(("TX: No available sockets for connect\n"));
		goto err;
	}

	DPRINTF(("TX: Assigned sock %ld at %p for connect\n",
		 sock - &sc->socks[0], (void *)sock));

	sock->fd = fd;
	sock->peer_addr.cid = cid;
	sock->peer_addr.port = port;
	sock->local_addr.cid = VMADDR_CID_HOST;
	/* Start at 2^16 to be larger than a TCP port, add a
	 * generation counter to reduce port reuse.
	 * XXX Allocate properly.
         */
	sock->local_addr.port = ((uint32_t)(sock - &sc->socks[0] + 1) << 16)
		+ (++sock->port_generation);

	rc = set_socket_options(sock);
	if (rc < 0) goto err;

	put_sock(sock);

	PPRINTF(("TX: SOCK connecting (%d) "PRIaddr" <=> "PRIaddr"\n",
		 sock->fd, FMTADDR(sock->local_addr), FMTADDR(sock->peer_addr)));
	send_response_sock(sc, VIRTIO_VSOCK_OP_REQUEST, 0, sock);

	return;
err:
	if (sock) {
		pthread_rwlock_wrlock(&sc->list_rwlock);
		free_sock(sc, sock);
		pthread_rwlock_unlock(&sc->list_rwlock);
	}
	close(fd);
}
