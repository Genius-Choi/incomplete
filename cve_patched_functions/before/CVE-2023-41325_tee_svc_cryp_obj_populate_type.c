static TEE_Result tee_svc_cryp_obj_populate_type(
		struct tee_obj *o,
		const struct tee_cryp_obj_type_props *type_props,
		const TEE_Attribute *attrs,
		uint32_t attr_count)
{
	TEE_Result res = TEE_SUCCESS;
	uint32_t have_attrs = 0;
	size_t obj_size = 0;
	size_t n = 0;
	int idx = 0;
	const struct attr_ops *ops = NULL;
	void *attr = NULL;

	for (n = 0; n < attr_count; n++) {
		idx = tee_svc_cryp_obj_find_type_attr_idx(
							attrs[n].attributeID,
							type_props);
		/* attribute not defined in current object type */
		if (idx < 0)
			return TEE_ERROR_ITEM_NOT_FOUND;

		have_attrs |= BIT32(idx);
		ops = attr_ops + type_props->type_attrs[idx].ops_index;
		attr = (uint8_t *)o->attr +
		       type_props->type_attrs[idx].raw_offs;
		if (attrs[n].attributeID & TEE_ATTR_FLAG_VALUE)
			res = ops->from_user(attr, &attrs[n].content.value,
					     sizeof(attrs[n].content.value));
		else
			res = ops->from_user(attr, attrs[n].content.ref.buffer,
					     attrs[n].content.ref.length);
		if (res != TEE_SUCCESS)
			return res;

		/*
		 * The attribute that gives the size of the object is
		 * flagged with TEE_TYPE_ATTR_SIZE_INDICATOR.
		 */
		if (type_props->type_attrs[idx].flags &
		    TEE_TYPE_ATTR_SIZE_INDICATOR) {
			/* There should be only one */
			if (obj_size)
				return TEE_ERROR_BAD_STATE;

			/*
			 * For ECDSA/ECDH we need to translate curve into
			 * object size
			 */
			if (attrs[n].attributeID == TEE_ATTR_ECC_CURVE) {
				res = get_ec_key_size(attrs[n].content.value.a,
						      &obj_size);
				if (res != TEE_SUCCESS)
					return res;
			} else {
				TEE_ObjectType obj_type = o->info.objectType;
				size_t sz = o->info.maxObjectSize;

				obj_size = attrs[n].content.ref.length * 8;
				/* Drop the parity bits for legacy objects */
				if (is_gp_legacy_des_key_size(obj_type, sz))
					obj_size -= obj_size / 8;
			}
			if (obj_size > o->info.maxObjectSize)
				return TEE_ERROR_BAD_STATE;
			res = check_key_size(type_props, obj_size);
			if (res != TEE_SUCCESS)
				return TEE_ERROR_BAD_PARAMETERS;
		}

		/*
		 * Bignum attributes limited by the number of bits in
		 * o->info.objectSize are flagged with
		 * TEE_TYPE_ATTR_BIGNUM_MAXBITS.
		 */
		if (type_props->type_attrs[idx].flags &
		    TEE_TYPE_ATTR_BIGNUM_MAXBITS) {
			if (get_used_bits(attrs + n) > o->info.maxObjectSize)
				return TEE_ERROR_BAD_STATE;
		}
	}

	o->have_attrs = have_attrs;
	o->info.objectSize = obj_size;
	/*
	 * In GP Internal API Specification 1.0 the partity bits aren't
	 * counted when telling the size of the key in bits so remove the
	 * parity bits here.
	 */
	if (is_gp_legacy_des_key_size(o->info.objectType,
				      o->info.maxObjectSize))
		o->info.objectSize -= o->info.objectSize / 8;

	return TEE_SUCCESS;
}
