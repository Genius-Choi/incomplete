static int lua_flow_set_activity_filter(lua_State* vm) {
  UserActivityID activityID;
  ActivityFilterID filterID;
  Flow *f;
  activity_filter_config config = {};
  u_int8_t params = 0;

  lua_getglobal(vm, CONST_USERACTIVITY_FLOW);
  f = (Flow*)lua_touserdata(vm, lua_gettop(vm));
  if(!f) return(CONST_LUA_ERROR);

  if(ntop_lua_check(vm, __FUNCTION__, params+1, LUA_TNUMBER)) return(CONST_LUA_ERROR);
  activityID = (UserActivityID)lua_tonumber(vm, ++params);
  if(activityID >= UserActivitiesN) return(CONST_LUA_ERROR);

  if(lua_type(vm, params+1) == LUA_TNUMBER)
    filterID = (ActivityFilterID)lua_tonumber(vm, ++params);
  else
    return(CONST_LUA_ERROR);

  // filter specific parameters
  switch(filterID) {
    case activity_filter_all:
      if(lua_type(vm, params+1) == LUA_TBOOLEAN) {
        config.all.pass = lua_toboolean(vm, ++params);
      }
      switch (params) {
        case 2+0: config.all.pass = true;
      }
      break;

    case activity_filter_web:
      if(lua_type(vm, params+1) == LUA_TNUMBER) {
        config.web.numsamples = lua_tonumber(vm, ++params);

        if(lua_type(vm, params+1) == LUA_TNUMBER) {
          config.web.minbytes = lua_tonumber(vm, ++params);

          if(lua_type(vm, params+1) == LUA_TNUMBER) {
            config.web.maxinterval = lua_tonumber(vm, ++params);

            if(lua_type(vm, params+1) == LUA_TBOOLEAN) {
              config.web.forceWebProfile = lua_toboolean(vm, ++params);

              if(lua_type(vm, params+1) == LUA_TBOOLEAN)
                config.web.serverdominant = lua_toboolean(vm, ++params);
            }
          }
        }
      }
      // defaults
      switch (params) {
        case 2+0: config.web.numsamples = 4;
        case 2+1: config.web.minbytes = 0;
        case 2+2: config.web.maxinterval = 2000;
        case 2+3: config.web.forceWebProfile = true;
        case 2+4: config.web.serverdominant = true;
      }
      break;

    case activity_filter_ratio:
      if(lua_type(vm, params+1) == LUA_TNUMBER) {
        config.ratio.numsamples = lua_tonumber(vm, ++params);

        if(lua_type(vm, params+1) == LUA_TNUMBER) {
          config.ratio.minbytes = lua_tonumber(vm, ++params);

          if(lua_type(vm, params+1) == LUA_TNUMBER)
            config.ratio.clisrv_ratio = lua_tonumber(vm, ++params);
        }
      }
      // defaults
      switch (params) {
        case 2+0: config.ratio.numsamples = 4;
        case 2+1: config.ratio.minbytes = 0;
        case 2+2: config.ratio.clisrv_ratio = -1.f;
      }
      break;

    case activity_filter_interflow:
      if(lua_type(vm, params+1) == LUA_TNUMBER) {
        config.interflow.minflows = min((int)lua_tonumber(vm, ++params), INTER_FLOW_ACTIVITY_SLOTS);

        if(lua_type(vm, params+1) == LUA_TNUMBER) {
          config.interflow.minpkts = lua_tonumber(vm, ++params);

          if(lua_type(vm, params+1) == LUA_TNUMBER) {
            config.interflow.minduration = lua_tonumber(vm, ++params);

            if(lua_type(vm, params+1) == LUA_TBOOLEAN)
              config.interflow.sslonly = lua_toboolean(vm, ++params);
          }
        }
      }
      // defaults
      switch (params) {
        case 2+0: config.interflow.minflows = INTER_FLOW_ACTIVITY_SLOTS;
        case 2+1: config.interflow.minpkts = 200;
        case 2+2: config.interflow.minduration = -1;
        case 2+3: config.interflow.sslonly = false;
      }
      break;

    case activity_filter_metrics_test:
      break;

    case activity_filter_sma:
      if(lua_type(vm, params+1) == LUA_TNUMBER) {
        config.sma.edge = lua_tonumber(vm, ++params);

        if(lua_type(vm, params+1) == LUA_TNUMBER) {
          config.sma.minsamples = lua_tonumber(vm, ++params);

          if(lua_type(vm, params+1) == LUA_TNUMBER) {
            config.sma.timebound = lua_tonumber(vm, ++params);

            if(lua_type(vm, params+1) == LUA_TNUMBER)
              config.sma.sustain = lua_tonumber(vm, ++params);
          }
        }
      }
      // defaults
      switch (params) {
        case 2+0: config.sma.edge = 0;
        case 2+1: config.sma.minsamples = ACTIVITY_FILTER_WMA_SAMPLES;
        case 2+2: config.sma.timebound = 2000;
        case 2+3: config.sma.sustain = 1000;
      }
      break;

    case activity_filter_wma:
      if(lua_type(vm, params+1) == LUA_TNUMBER) {
        config.wma.edge = lua_tonumber(vm, ++params);

        if(lua_type(vm, params+1) == LUA_TNUMBER) {
          config.wma.minsamples = lua_tonumber(vm, ++params);

          if(lua_type(vm, params+1) == LUA_TNUMBER) {
            config.wma.timescale = lua_tonumber(vm, ++params);

            if(lua_type(vm, params+1) == LUA_TNUMBER)
              config.wma.aggrsecs = lua_tonumber(vm, ++params);
          }
        }
      }
      // defaults
      switch (params) {
        case 2+0: config.wma.edge = 0;
        case 2+1: config.wma.minsamples = ACTIVITY_FILTER_WMA_SAMPLES;
        case 2+2: config.wma.timescale = 1.f;
        case 2+3: config.wma.aggrsecs = 0;
      }
      break;

    case activity_filter_command_sequence:
      if(lua_type(vm, params+1) == LUA_TBOOLEAN) {
        config.command_sequence.mustwait = lua_toboolean(vm, ++params);

        if(lua_type(vm, params+1) == LUA_TNUMBER) {
          config.command_sequence.minbytes = lua_tonumber(vm, ++params);

          if(lua_type(vm, params+1) == LUA_TNUMBER) {
            config.command_sequence.maxinterval = lua_tonumber(vm, ++params);

            if(lua_type(vm, params+1) == LUA_TNUMBER) {
              config.command_sequence.mincommands = lua_tonumber(vm, ++params);

              if(lua_type(vm, params+1) == LUA_TNUMBER)
                config.command_sequence.minflips = lua_tonumber(vm, ++params);
            }
          }
        }
      }
      switch (params) {
        case 2+0: config.command_sequence.mustwait = false;
        case 2+1: config.command_sequence.minbytes = 0;
        case 2+2: config.command_sequence.maxinterval = 3000;
        case 2+3: config.command_sequence.mincommands = 1;
        case 2+4: config.command_sequence.minflips = 1;
      }
      break;

    default:
      ntop->getTrace()->traceEvent(TRACE_WARNING, "Invalid activity filter (%d)", filterID);
      return (CONST_LUA_ERROR);
  }

  ntop->getTrace()->traceEvent(TRACE_DEBUG, "Flow %p setActivityFilter: filter=%d activity=%d", f, filterID, activityID);
  f->setActivityFilter(filterID, &config);
  f->setActivityId(activityID);

  return(CONST_LUA_OK);
}
