int BUFFER_prepend(BUFFER_HANDLE handle1, BUFFER_HANDLE handle2)
{
    int result;
    if ((handle1 == NULL) || (handle2 == NULL) || (handle1 == handle2))
    {
        /* Codes_SRS_BUFFER_01_005: [ BUFFER_prepend shall return a non-zero upon value any error that is encountered. ]*/
        result = MU_FAILURE;
    }
    else
    {
        BUFFER* b1 = (BUFFER*)handle1;
        BUFFER* b2 = (BUFFER*)handle2;
        if (b1->buffer == NULL)
        {
            /* Codes_SRS_BUFFER_01_005: [ BUFFER_prepend shall return a non-zero upon value any error that is encountered. ]*/
            result = MU_FAILURE;
        }
        else if (b2->buffer == NULL)
        {
            /* Codes_SRS_BUFFER_01_005: [ BUFFER_prepend shall return a non-zero upon value any error that is encountered. ]*/
            result = MU_FAILURE;
        }
        else
        {
            //put b2 ahead of b1: [b2][b1], return b1
            size_t malloc_size = safe_add_size_t(b1->size, b2->size);
            if (b2->size == 0)
            {
                // do nothing
                result = 0;
            }
            else if (malloc_size == SIZE_MAX)
            {
                LogError("Failure: size_t overflow.");
                result = MU_FAILURE;
            }
            else
            {
                // b2->size != 0
                unsigned char* temp = (unsigned char*)malloc(malloc_size);
                if (temp == NULL)
                {
                    /* Codes_SRS_BUFFER_01_005: [ BUFFER_prepend shall return a non-zero upon value any error that is encountered. ]*/
                    LogError("Failure: allocating temp buffer.");
                    result = MU_FAILURE;
                }
                else
                {
                    /* Codes_SRS_BUFFER_01_004: [ BUFFER_prepend concatenates handle1 onto handle2 without modifying handle1 and shall return zero on success. ]*/
                    // Append the BUFFER
#ifdef _MSC_VER
#pragma warning(disable:6386) // Buffer overrun while writing to 'temp'
#endif
                    (void)memcpy(temp, b2->buffer, b2->size);
                    // start from b1->size to append b1
                    (void)memcpy(&temp[b2->size], b1->buffer, b1->size);
#ifdef _MSC_VER
#pragma warning (default:6386)
#endif
                    free(b1->buffer);
                    b1->buffer = temp;
                    b1->size += b2->size;
                    result = 0;
                }
            }
        }
    }
    return result;
}
