x509_verify_ctx_set_xsc_chain(struct x509_verify_ctx *ctx,
    struct x509_verify_chain *chain, int set_error, int is_trusted)
{
	size_t num_untrusted;
	int i;

	if (ctx->xsc == NULL)
		return 1;

	/*
	 * XXX num_untrusted is the number of untrusted certs at the
	 * bottom of the chain. This works now since we stop at the first
	 * trusted cert. This will need fixing once we allow more than one
	 * trusted certificate.
	 */
	num_untrusted = sk_X509_num(chain->certs);
	if (is_trusted && num_untrusted > 0)
		num_untrusted--;
	ctx->xsc->num_untrusted = num_untrusted;

	sk_X509_pop_free(ctx->xsc->chain, X509_free);
	ctx->xsc->chain = X509_chain_up_ref(chain->certs);
	if (ctx->xsc->chain == NULL)
		return x509_verify_cert_error(ctx, NULL, 0,
		    X509_V_ERR_OUT_OF_MEM, 0);

	if (set_error) {
		ctx->xsc->error = X509_V_OK;
		ctx->xsc->error_depth = 0;
		for (i = 0; i < sk_X509_num(chain->certs); i++) {
			if (chain->cert_errors[i] != X509_V_OK) {
				ctx->xsc->error = chain->cert_errors[i];
				ctx->xsc->error_depth = i;
				break;
			}
		}
	}

	return 1;
}
