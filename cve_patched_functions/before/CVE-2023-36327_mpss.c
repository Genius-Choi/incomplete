static int mpss(void) {
	int i, j, code = RLC_ERR;
	bn_t m[2], n, u[2], v[2], ms[5][2], _v[5][2];
	g1_t g, s[2];
	g2_t h, x[2], y[2], _y[5][2];
	gt_t e[2], f[2];
	mt_t tri[3][2];
	pt_t t[2];

	bn_null(n);
	g1_null(g);
	g2_null(h);

	RLC_TRY {
		bn_new(n);
		g1_new(g);
		g2_new(h);
		g1_get_ord(n);
		for (i = 0; i < 2; i++) {
			bn_null(m[i]);
			bn_null(u[i]);
			bn_null(v[i]);
			g1_null(s[i]);
			g2_null(x[i]);
			g2_null(y[i]);
			gt_null(e[i]);
			gt_null(f[i]);
			mt_null(tri[0][i]);
			mt_null(tri[1][i]);
			mt_null(tri[2][i]);
			pt_null(t[i]);
			bn_new(m[i]);
			bn_rand_mod(m[i], n);
			bn_new(u[i]);
			bn_new(v[i]);
			g1_new(s[i]);
			g2_new(x[i]);
			g2_new(y[i]);
			gt_new(e[i]);
			gt_new(f[i]);
			mt_new(tri[0][i]);
			mt_new(tri[1][i]);
			mt_new(tri[2][i]);
			pt_new(t[i]);
			for (j = 0; j < 5; j++) {
				bn_null(ms[j][i]);
				bn_null(_v[j][i]);
				g2_null(_y[j][i]);
				bn_new(ms[j][i]);
				bn_rand_mod(ms[j][i], n);
				bn_new(_v[j][i]);
				g2_new(_y[j][i]);
			}
		}

		TEST_CASE("multi-party pointcheval-sanders simple signature is correct") {
			pc_map_tri(t);
			mpc_mt_gen(tri[0], n);
			mpc_mt_gen(tri[1], n);
			mpc_mt_gen(tri[2], n);
			gt_exp_gen(e[0], tri[2][0]->b);
			gt_exp_gen(e[1], tri[2][1]->b);
			gt_exp_gen(f[0], tri[2][0]->c);
			gt_exp_gen(f[1], tri[2][1]->c);
			tri[2][0]->bt = &e[0];
			tri[2][1]->bt = &e[1];
			tri[2][0]->ct = &f[0];
			tri[2][1]->ct = &f[1];
			TEST_ASSERT(cp_mpss_gen(u, v, h, x, y) == RLC_OK, end);
			TEST_ASSERT(cp_mpss_bct(x, y) == RLC_OK, end);
			/* Compute signature in MPC. */
			TEST_ASSERT(cp_mpss_sig(g, s, m, u, v, tri[0], tri[1]) == RLC_OK, end);
			/* Verify signature in MPC. */
			cp_mpss_ver(e[0], g, s, m, h, x[0], y[0], tri[2], t);
			TEST_ASSERT(gt_is_unity(e[0]) == 1, end);
			/* Check that signature is also valid for conventional scheme. */
			bn_add(m[0], m[0], m[1]);
			bn_mod(m[0], m[0], n);
			g1_add(s[0], s[0], s[1]);
			g1_norm(s[0], s[0]);
			TEST_ASSERT(cp_pss_ver(g, s[0], m[0], h, x[0], y[0]) == 1, end);
		}
		TEST_END;

		TEST_CASE("multi-party pointcheval-sanders block signature is correct") {
			g1_get_ord(n);
			pc_map_tri(t);
			mpc_mt_gen(tri[0], n);
			mpc_mt_gen(tri[1], n);
			mpc_mt_gen(tri[2], n);
			gt_exp_gen(e[0], tri[2][0]->b);
			gt_exp_gen(e[1], tri[2][1]->b);
			gt_exp_gen(f[0], tri[2][0]->c);
			gt_exp_gen(f[1], tri[2][1]->c);
			tri[2][0]->bt = &e[0];
			tri[2][1]->bt = &e[1];
			tri[2][0]->ct = &f[0];
			tri[2][1]->ct = &f[1];
			TEST_ASSERT(cp_mpsb_gen(u, _v, h, x, _y, 5) == RLC_OK, end);
			TEST_ASSERT(cp_mpsb_bct(x, _y, 5) == RLC_OK, end);
			/* Compute signature in MPC. */
			TEST_ASSERT(cp_mpsb_sig(g, s, ms, u, _v, tri[0], tri[1], 5) == RLC_OK, end);
			/* Verify signature in MPC. */
			cp_mpsb_ver(e[1], g, s, ms, h, x[0], _y, NULL, tri[2], t, 5);
			TEST_ASSERT(gt_is_unity(e[1]) == 1, end);
			gt_exp_gen(e[0], tri[2][0]->b);
			gt_exp_gen(e[1], tri[2][1]->b);
			cp_mpsb_ver(e[1], g, s, ms, h, x[0], _y, _v, tri[2], t, 5);
			TEST_ASSERT(gt_is_unity(e[1]) == 1, end);
			bn_sub_dig(ms[0][0], ms[0][0], 1);
			cp_mpsb_ver(e[1], g, s, ms, h, x[0], _y, _v, tri[2], t, 5);
			TEST_ASSERT(gt_is_unity(e[1]) == 0, end);
		}
		TEST_END;
	}
	RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;

  end:
	bn_free(n);
	g1_free(g);
	g2_free(h);
	for (i = 0; i < 2; i++) {
		bn_free(m[i]);
		bn_free(u[i]);
		bn_free(v[i]);
		g1_free(s[i]);
		g2_free(x[i]);
		g2_free(y[i]);
		gt_free(e[i]);
		gt_free(f[i]);
		mt_free(tri[0][i]);
		mt_free(tri[1][i]);
		mt_free(tri[2][i]);
		pt_free(t[i]);
		for (j = 0; j < 5; j++) {
			bn_free(ms[j][i]);
			bn_free(_v[j][i]);
			g2_free(_y[j][i]);
		}
	}
	return code;
}
