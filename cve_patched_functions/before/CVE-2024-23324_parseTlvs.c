bool Filter::parseTlvs(const uint8_t* buf, size_t len) {
  size_t idx{0};
  while (idx < len) {
    const uint8_t tlv_type = buf[idx];
    idx++;

    if ((idx + 1) >= len) {
      ENVOY_LOG(debug,
                fmt::format("failed to read proxy protocol extension. No bytes for TLV length. "
                            "Extension length is {}, current index is {}, current type is {}.",
                            len, idx, tlv_type));
      return false;
    }

    const uint8_t tlv_length_upper = buf[idx];
    const uint8_t tlv_length_lower = buf[idx + 1];
    const size_t tlv_value_length = (tlv_length_upper << 8) + tlv_length_lower;
    idx += 2;

    // Get the value.
    if ((idx + tlv_value_length - 1) >= len) {
      ENVOY_LOG(
          debug,
          fmt::format("failed to read proxy protocol extension. No bytes for TLV value. "
                      "Extension length is {}, current index is {}, current type is {}, current "
                      "value length is {}.",
                      len, idx, tlv_type, tlv_length_upper));
      return false;
    }

    // Only save to dynamic metadata if this type of TLV is needed.
    absl::string_view tlv_value(reinterpret_cast<char const*>(buf + idx), tlv_value_length);
    auto key_value_pair = config_->isTlvTypeNeeded(tlv_type);
    if (nullptr != key_value_pair) {
      ProtobufWkt::Value metadata_value;
      metadata_value.set_string_value(tlv_value.data(), tlv_value.size());

      std::string metadata_key = key_value_pair->metadata_namespace().empty()
                                     ? "envoy.filters.listener.proxy_protocol"
                                     : key_value_pair->metadata_namespace();

      ProtobufWkt::Struct metadata(
          (*cb_->dynamicMetadata().mutable_filter_metadata())[metadata_key]);
      metadata.mutable_fields()->insert({key_value_pair->key(), metadata_value});
      cb_->setDynamicMetadata(metadata_key, metadata);
    } else {
      ENVOY_LOG(trace,
                "proxy_protocol: Skip TLV of type {} since it's not needed for dynamic metadata",
                tlv_type);
    }

    // Save TLVs to the filter state.
    if (config_->isPassThroughTlvTypeNeeded(tlv_type)) {
      ENVOY_LOG(trace, "proxy_protocol: Storing parsed TLV of type {} to filter state.", tlv_type);
      parsed_tlvs_.push_back({tlv_type, {tlv_value.begin(), tlv_value.end()}});
    }

    idx += tlv_value_length;
    ASSERT(idx <= len);
  }
  return true;
}
