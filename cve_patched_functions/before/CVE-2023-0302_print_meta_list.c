static void print_meta_list(RAnal *a, int type, int rad, ut64 addr, const char *tq) {
	PJ *pj = NULL;
	RTable *t = NULL;
	if (rad == ',') {
		t = r_table_new ("meta");
		RTableColumnType *s = r_table_type ("string");
		RTableColumnType *n = r_table_type ("number");
		r_table_add_column (t, n, "addr", 0);
		r_table_add_column (t, n, "size", 0);
		r_table_add_column (t, s, "type", 0);
		r_table_add_column (t, s, "string", 0);
	} else if (rad == 'j') {
		pj = pj_new ();
		if (!pj) {
			return;
		}
		pj_a (pj);
	}

	RAnalFunction *fcn = NULL;
	if (addr != UT64_MAX) {
		fcn = r_anal_get_fcn_in (a, addr, 0);
		if (!fcn) {
			goto beach;
		}
	}

	RIntervalTreeIter it;
	RAnalMetaItem *item;
	r_interval_tree_foreach (&a->meta, it, item) {
		RIntervalNode *node = r_interval_tree_iter_get (&it);
		if (type != R_META_TYPE_ANY && item->type != type) {
			continue;
		}
		if (fcn && !r_anal_function_contains (fcn, node->start)) {
			continue;
		}
		if (t) {
			const char *type = r_meta_type_tostring (item->type);
			const char *name = item->str;
			r_table_add_rowf (t, "xxss",
				node->start,
				r_meta_node_size (node),
				type, name);
		} else {
			r_meta_print (a, item, node->start, r_meta_node_size (node), rad, pj, true);
		}
	}

beach:
	if (t && tq) {
		r_table_query (t, tq);
	}
	if (!tq || !strstr (tq, "?")) {
		if (t) {
			char *s = r_table_tostring (t);
			r_cons_printf ("%s\n", s);
			free (s);
		} else if (pj) {
			pj_end (pj);
			r_cons_printf ("%s\n", pj_string (pj));
			pj_free (pj);
			pj = NULL;
		}
	}
	pj_free (pj);
}
