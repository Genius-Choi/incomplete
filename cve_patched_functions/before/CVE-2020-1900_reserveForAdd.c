void VariableUnserializer::reserveForAdd(size_t count) {
  // If the array is large, the space for the backrefs could be
  // significant, so we need to check for OOM beforehand. To do this,
  // we need to do some guess work to estimate what memory the vector
  // will consume once we've done the reserve (we assume the vector
  // doubles in capacity as necessary).
  auto const newSize = m_refs.size() + count;
  auto const capacity = m_refs.capacity();
  if (newSize <= capacity) return;
  auto const total =
    (folly::nextPowTwo(newSize) - capacity) *
    sizeof(decltype(m_refs)::value_type);
  if (UNLIKELY(total > kMaxSmallSize && tl_heap->preAllocOOM(total))) {
    check_non_safepoint_surprise();
  }
  m_refs.reserve(newSize);
}
