lglob(filename)
	char *filename;
{
	char *gfilename;

	filename = fexpand(filename);
	if (secure)
		return (filename);

#ifdef DECL_GLOB_LIST
{
	/*
	 * The globbing function returns a list of names.
	 */
	int length;
	char *p;
	char *qfilename;
	DECL_GLOB_LIST(list)

	GLOB_LIST(filename, list);
	if (GLOB_LIST_FAILED(list))
	{
		return (filename);
	}
	length = 1; /* Room for trailing null byte */
	for (SCAN_GLOB_LIST(list, p))
	{
		INIT_GLOB_LIST(list, p);
		qfilename = shell_quote(p);
		if (qfilename != NULL)
		{
			length += strlen(qfilename) + 1;
			free(qfilename);
		}
	}
	gfilename = (char *) ecalloc(length, sizeof(char));
	for (SCAN_GLOB_LIST(list, p))
	{
		INIT_GLOB_LIST(list, p);
		qfilename = shell_quote(p);
		if (qfilename != NULL)
		{
			sprintf(gfilename + strlen(gfilename), "%s ", qfilename);
			free(qfilename);
		}
	}
	/*
	 * Overwrite the final trailing space with a null terminator.
	 */
	*--p = '\0';
	GLOB_LIST_DONE(list);
}
#else
#ifdef DECL_GLOB_NAME
{
	/*
	 * The globbing function returns a single name, and
	 * is called multiple times to walk thru all names.
	 */
	char *p;
	int len;
	int n;
	char *pfilename;
	char *qfilename;
	DECL_GLOB_NAME(fnd,drive,dir,fname,ext,handle)
	
	GLOB_FIRST_NAME(filename, &fnd, handle);
	if (GLOB_FIRST_FAILED(handle))
	{
		return (filename);
	}

	_splitpath(filename, drive, dir, fname, ext);
	len = 100;
	gfilename = (char *) ecalloc(len, sizeof(char));
	p = gfilename;
	do {
		n = (int) (strlen(drive) + strlen(dir) + strlen(fnd.GLOB_NAME) + 1);
		pfilename = (char *) ecalloc(n, sizeof(char));
		SNPRINTF3(pfilename, n, "%s%s%s", drive, dir, fnd.GLOB_NAME);
		qfilename = shell_quote(pfilename);
		free(pfilename);
		if (qfilename != NULL)
		{
			n = (int) strlen(qfilename);
			while (p - gfilename + n + 2 >= len)
			{
				/*
				 * No room in current buffer.
				 * Allocate a bigger one.
				 */
				len *= 2;
				*p = '\0';
				p = (char *) ecalloc(len, sizeof(char));
				strcpy(p, gfilename);
				free(gfilename);
				gfilename = p;
				p = gfilename + strlen(gfilename);
			}
			strcpy(p, qfilename);
			free(qfilename);
			p += n;
			*p++ = ' ';
		}
	} while (GLOB_NEXT_NAME(handle, &fnd) == 0);

	/*
	 * Overwrite the final trailing space with a null terminator.
	 */
	*--p = '\0';
	GLOB_NAME_DONE(handle);
}
#else
#if HAVE_POPEN
{
	/*
	 * We get the shell to glob the filename for us by passing
	 * an "echo" command to the shell and reading its output.
	 */
	FILE *fd;
	char *s;
	char *lessecho;
	char *cmd;
	char *esc;
	int len;

	esc = get_meta_escape();
	if (strlen(esc) == 0)
		esc = "-";
	esc = shell_quote(esc);
	if (esc == NULL)
	{
		return (filename);
	}
	lessecho = lgetenv("LESSECHO");
	if (isnullenv(lessecho))
		lessecho = "lessecho";
	/*
	 * Invoke lessecho, and read its output (a globbed list of filenames).
	 */
	len = (int) (strlen(lessecho) + strlen(filename) + (7*strlen(metachars())) + 24);
	cmd = (char *) ecalloc(len, sizeof(char));
	SNPRINTF4(cmd, len, "%s -p0x%x -d0x%x -e%s ", lessecho,
		(unsigned char) openquote, (unsigned char) closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		sprintf(cmd + strlen(cmd), "-n0x%x ", (unsigned char) *s);
	sprintf(cmd + strlen(cmd), "-- %s", filename);
	fd = shellcmd(cmd);
	free(cmd);
	if (fd == NULL)
	{
		/*
		 * Cannot create the pipe.
		 * Just return the original (fexpanded) filename.
		 */
		return (filename);
	}
	gfilename = readfd(fd);
	pclose(fd);
	if (*gfilename == '\0')
	{
		free(gfilename);
		return (filename);
	}
}
#else
	/*
	 * No globbing functions at all.  Just use the fexpanded filename.
	 */
	gfilename = save(filename);
#endif
#endif
#endif
	free(filename);
	return (gfilename);
}
