static struct ncrx_slot *get_seq_slot(struct ncrx_msg *tmsg, struct ncrx *ncrx)
{
	struct ncrx_slot *slot;
	int64_t delta;
	int idx;

	/* new seq stream */
	if (!ncrx->head_seq) {
		ncrx->head_seq = tmsg->seq;
		ncrx->acked_seq = UINT64_MAX;
		tmsg->seq_reset = 1;
	}

	delta = tmsg->seq - ncrx->head_seq;

	/*
	 * Consider oos if outside reorder window or if the slot is
	 * complete and the last activity on it was more than oos_intv ago.
	 * Emergency messages are never considered oos as they don't follow
	 * the usual transmission pattern and may repeat indefinitely.
	 */
	if (-delta > ncrx->p.nr_slots || delta > ncrx->p.nr_slots) {
		errno = ERANGE;
		return NULL;
	}

	idx = seq_delta_idx(ncrx, delta);
	slot = &ncrx->slots[idx];

	if (-delta > nr_queued(ncrx)) {
		int is_free = slot_is_free(slot);

		if (!tmsg->emg &&
		    (!is_free ||
		     slot->timestamp + ncrx->p.oos_intv < ncrx->now_mono)) {
			errno = ERANGE;
			return NULL;
		}

		if (is_free)
			slot->timestamp = ncrx->now_mono;
		errno = ENOENT;
		return NULL;
	}

	make_room(ncrx, delta);
	slot->timestamp = ncrx->now_mono;

	return slot;
}
