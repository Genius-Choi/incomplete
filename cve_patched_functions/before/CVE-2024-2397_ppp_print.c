ppp_print(netdissect_options *ndo,
          const u_char *p, u_int length)
{
	u_int proto,ppp_header;
        u_int olen = length; /* _o_riginal length */
	u_int hdr_len = 0;

	ndo->ndo_protocol = "ppp";
	/*
	 * Here, we assume that p points to the Address and Control
	 * field (if they present).
	 */
	if (length < 2)
		goto trunc;
        ppp_header = GET_BE_U_2(p);

        switch(ppp_header) {
        case (PPP_PPPD_IN  << 8 | PPP_CONTROL):
            if (ndo->ndo_eflag) ND_PRINT("In  ");
            p += 2;
            length -= 2;
            hdr_len += 2;
            break;
        case (PPP_PPPD_OUT << 8 | PPP_CONTROL):
            if (ndo->ndo_eflag) ND_PRINT("Out ");
            p += 2;
            length -= 2;
            hdr_len += 2;
            break;
        case (PPP_ADDRESS << 8 | PPP_CONTROL):
            p += 2;			/* ACFC not used */
            length -= 2;
            hdr_len += 2;
            break;

        default:
            break;
        }

	if (length < 2)
		goto trunc;
	if (GET_U_1(p) % 2) {
		proto = GET_U_1(p);	/* PFC is used */
		p++;
		length--;
		hdr_len++;
	} else {
		proto = GET_BE_U_2(p);
		p += 2;
		length -= 2;
		hdr_len += 2;
	}

	if (ndo->ndo_eflag) {
		const char *typestr;
		typestr = tok2str(ppptype2str, "unknown", proto);
		ND_PRINT("%s (0x%04x), length %u",
		          typestr,
		          proto,
		          olen);
		if (*typestr == 'u')	/* "unknown" */
			return hdr_len;

		ND_PRINT(": ");
	}

	handle_ppp(ndo, proto, p, length);
	return (hdr_len);
trunc:
	nd_print_trunc(ndo);
	return (0);
}
