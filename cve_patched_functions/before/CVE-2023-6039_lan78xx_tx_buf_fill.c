static struct skb_data *lan78xx_tx_buf_fill(struct lan78xx_net *dev,
					    struct sk_buff *tx_buf)
{
	struct skb_data *entry = (struct skb_data *)tx_buf->cb;
	int remain = dev->tx_urb_size;
	u8 *tx_data = tx_buf->data;
	u32 urb_len = 0;

	entry->num_of_packet = 0;
	entry->length = 0;

	/* Work through the pending SKBs and copy the data of each SKB into
	 * the URB buffer if there room for all the SKB data.
	 *
	 * There must be at least DST+SRC+TYPE in the SKB (with padding enabled)
	 */
	while (remain >= TX_SKB_MIN_LEN) {
		unsigned int pending_bytes;
		unsigned int align_bytes;
		struct sk_buff *skb;
		unsigned int len;

		lan78xx_tx_pend_skb_get(dev, &skb, &pending_bytes);

		if (!skb)
			break;

		align_bytes = (TX_ALIGNMENT - (urb_len % TX_ALIGNMENT)) %
			      TX_ALIGNMENT;
		len = align_bytes + TX_CMD_LEN + skb->len;
		if (len > remain) {
			lan78xx_tx_pend_skb_head_add(dev, skb, &pending_bytes);
			break;
		}

		tx_data += align_bytes;

		lan78xx_fill_tx_cmd_words(skb, tx_data);
		tx_data += TX_CMD_LEN;

		len = skb->len;
		if (skb_copy_bits(skb, 0, tx_data, len) < 0) {
			struct net_device_stats *stats = &dev->net->stats;

			stats->tx_dropped++;
			dev_kfree_skb_any(skb);
			tx_data -= TX_CMD_LEN;
			continue;
		}

		tx_data += len;
		entry->length += len;
		entry->num_of_packet += skb_shinfo(skb)->gso_segs ?: 1;

		dev_kfree_skb_any(skb);

		urb_len = (u32)(tx_data - (u8 *)tx_buf->data);

		remain = dev->tx_urb_size - urb_len;
	}

	skb_put(tx_buf, urb_len);

	return entry;
}
