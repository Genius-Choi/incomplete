hermesInternalGetInstrumentedStats(void *, Runtime &runtime, NativeArgs args) {
  GCScope gcScope(runtime);
  auto resultHandle = runtime.makeHandle(JSObject::create(runtime));
  // Printing the values would be unstable, so prevent that.
  if (runtime.shouldStabilizeInstructionCount())
    return resultHandle.getHermesValue();

  MockedEnvironment::StatsTable *statsTable = nullptr;
  auto *const storage = runtime.getCommonStorage();
  if (storage->env) {
    if (!storage->env->callsToHermesInternalGetInstrumentedStats.empty()) {
      statsTable =
          &storage->env->callsToHermesInternalGetInstrumentedStats.front();
    }
  }

  std::unique_ptr<MockedEnvironment::StatsTable> newStatsTable;
  if (storage->shouldTrace) {
    newStatsTable.reset(new MockedEnvironment::StatsTable());
  }

  /// Adds \p key with \p val to the resultHandle object. \p newStatsTableVal is
  /// the value \p key should have in the newStatsTable object (i.e., during
  /// synth trace recording).
  auto addToResultHandle =
      [&](llvh::StringRef key, HermesValue val, auto newStatsTableVal) {
        Handle<> valHandle = runtime.makeHandle(val);
        auto keySym = symbolForCStr(runtime, key.data());
        if (LLVM_UNLIKELY(keySym == ExecutionStatus::EXCEPTION)) {
          return ExecutionStatus::EXCEPTION;
        }

        auto status = JSObject::defineNewOwnProperty(
            resultHandle,
            runtime,
            **keySym,
            PropertyFlags::defaultNewNamedPropertyFlags(),
            valHandle);

        if (LLVM_UNLIKELY(status == ExecutionStatus::EXCEPTION)) {
          return ExecutionStatus::EXCEPTION;
        }

        if (newStatsTable) {
          newStatsTable->try_emplace(key, newStatsTableVal);
        }

        return ExecutionStatus::RETURNED;
      };

  ExecutionStatus populateRes;
  if (!statsTable) {
    /// Adds a property to resultHandle. \p key provides its name, and \p val,
    /// its value. Adds {\p key, \p val} to newStatsTable if it is not null.
    populateRes = populateInstrumentedStats(
        runtime, [&](llvh::StringRef key, double val) {
          GCScopeMarkerRAII marker{gcScope};

          return addToResultHandle(
              key, HermesValue::encodeDoubleValue(val), val);
        });
  } else {
    /// Adds a property named \p key to resultHandle if it is present in
    /// statsTable. Also copies it to newStatsTable if it is not null. Does
    /// nothing if \p key is not in statsTable.
    populateRes = populateInstrumentedStats(runtime, [&](llvh::StringRef key) {
      auto it = statsTable->find(key);
      if (it == statsTable->end()) {
        return ExecutionStatus::RETURNED;
      }

      GCScopeMarkerRAII marker{gcScope};

      auto valRes = statsTableValueToHermesValue(runtime, it->getValue());
      if (LLVM_UNLIKELY(valRes == ExecutionStatus::EXCEPTION)) {
        return ExecutionStatus::EXCEPTION;
      }

      return addToResultHandle(key, *valRes, it->getValue());
    });
  }

  if (LLVM_UNLIKELY(populateRes == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }

  if (storage->env && statsTable) {
    storage->env->callsToHermesInternalGetInstrumentedStats.pop_front();
  }
  if (LLVM_UNLIKELY(storage->shouldTrace)) {
    storage->tracedEnv.callsToHermesInternalGetInstrumentedStats.push_back(
        *newStatsTable);
  }

  return resultHandle.getHermesValue();
}
