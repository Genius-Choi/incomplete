setup_document_content_list(const gchar* content_uri, GError** error,gchar *documentdir)
{
    GError *err = NULL;
    gint indexcounter = 1;
    xmlNodePtr manifest,spine,itemrefptr,itemptr;
    gboolean errorflag = FALSE;

    if ( open_xml_document(content_uri) == FALSE )
    {
        g_set_error_literal(error,
                            EV_DOCUMENT_ERROR,
                            EV_DOCUMENT_ERROR_INVALID,
                            _("could not parse content manifest"));

        return FALSE ;
    }
    if ( set_xml_root_node((xmlChar*)"package") == FALSE)  {

        g_set_error_literal(error,
                            EV_DOCUMENT_ERROR,
                            EV_DOCUMENT_ERROR_INVALID,
                            _("content file is invalid"));
        return FALSE ;
    }

    if ( ( spine = xml_get_pointer_to_node((xmlChar*)"spine",NULL,NULL) )== NULL )
    {
         g_set_error_literal(error,
                            EV_DOCUMENT_ERROR,
                            EV_DOCUMENT_ERROR_INVALID,
                            _("epub file has no spine"));
        return FALSE ;
    }

    if ( ( manifest = xml_get_pointer_to_node((xmlChar*)"manifest",NULL,NULL) )== NULL )
    {
         g_set_error_literal(error,
                            EV_DOCUMENT_ERROR,
                            EV_DOCUMENT_ERROR_INVALID,
                            _("epub file has no manifest"));
        return FALSE ;
    }

    xmlretval = NULL ;

    /*Get first instance of itemref from the spine*/
    xml_parse_children_of_node(spine,(xmlChar*)"itemref",NULL,NULL);

    if ( xmlretval != NULL )
        itemrefptr = xmlretval ;
    else
    {
        errorflag=TRUE;
    }

    GList *newlist = NULL;

    /*Parse the spine for remaining itemrefs*/
    do
    {
        /*for the first time that we enter the loop, if errorflag is set we break*/
        if ( errorflag )
        {
            break;
        }
        if ( xmlStrcmp(itemrefptr->name,(xmlChar*)"itemref") == 0)
        {
            contentListNode *newnode = g_malloc0(sizeof(newnode));
            newnode->key = (gchar*)xml_get_data_from_node(itemrefptr,XML_ATTRIBUTE,(xmlChar*)"idref");
            if ( newnode->key == NULL )
            {
                g_free (newnode);
                errorflag = TRUE;
                break;
            }
            xmlretval=NULL ;
            xml_parse_children_of_node(manifest,(xmlChar*)"item",(xmlChar*)"id",(xmlChar*)newnode->key);

            if ( xmlretval != NULL )
            {
                itemptr = xmlretval ;
            }
            else
            {
                g_free (newnode->key);
                g_free (newnode);
                errorflag = TRUE;
                break;
            }

            GString* absolutepath = g_string_new(documentdir);
            gchar *relativepath = (gchar*)xml_get_data_from_node(itemptr,XML_ATTRIBUTE,(xmlChar*)"href");
            g_string_append_printf(absolutepath,"/%s",relativepath);
            g_free (relativepath);

            newnode->value = g_filename_to_uri(absolutepath->str,NULL,&err);
            g_string_free(absolutepath,TRUE);

            if ( newnode->value == NULL )
            {
                g_free (newnode->key);
                g_free (newnode);
                errorflag = TRUE;
                break;
            }

            newnode->index = indexcounter++ ;

            newlist = g_list_prepend(newlist, newnode);
        }
        itemrefptr = itemrefptr->next ;
    }
    while ( itemrefptr != NULL );

    if ( errorflag )
    {
        if ( err )
        {
            g_propagate_error(error,err);
        }
        else
        {
            g_set_error_literal(error,
                                EV_DOCUMENT_ERROR,
                                EV_DOCUMENT_ERROR_INVALID,
                                _("Could not set up document tree for loading, some files missing"));
        }
        /*free any nodes that were set up and return empty*/
        g_list_free_full(newlist, (GDestroyNotify)free_tree_nodes);
        return NULL;
    }

    newlist = g_list_reverse(newlist);
    xml_free_doc();
    return newlist;

}
