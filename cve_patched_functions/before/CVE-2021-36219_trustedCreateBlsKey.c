void trustedCreateBlsKey(int *errStatus, char *errString, const char *s_shares,
                    uint8_t *encryptedPrivateKey, uint64_t key_len, uint8_t *encr_bls_key, uint32_t *enc_bls_key_len) {

    LOG_DEBUG (__FUNCTION__);

    char skey[ECDSA_SKEY_LEN];
    sgx_status_t status = sgx_unseal_data(
            (const sgx_sealed_data_t *) encryptedPrivateKey, NULL, 0, (uint8_t *) skey, &key_len);
    if (status != SGX_SUCCESS) {
        *errStatus = 1;
        snprintf(errString, BUF_LEN, "sgx_unseal_key failed with status %d", status);
        return;
    }

    int num_shares = strlen(s_shares) / 192;

    mpz_t sum;
    mpz_init(sum);
    mpz_set_ui(sum, 0);


    for (int i = 0; i < num_shares; i++) {
        char encr_sshare[65];
        strncpy(encr_sshare, s_shares + 192 * i, 64);
        encr_sshare[64] = 0;

        char s_share[193];
        strncpy(s_share, s_shares + 192 * i, 192);
        s_share[192] = 0;

        char common_key[65];
        session_key_recover(skey, s_share, common_key);
        common_key[64] = 0;

        if (common_key == NULL) {
            *errStatus = 1;
            snprintf(errString, BUF_LEN, "invalid common_key");
            mpz_clear(sum);
            return;
        }


        char decr_sshare[65];
        xor_decrypt(common_key, encr_sshare, decr_sshare);
        if (decr_sshare == NULL) {
            *errStatus = 1;
            snprintf(errString, BUF_LEN, "invalid common_key");
            mpz_clear(sum);
            return;
        }

        mpz_t decr_secret_share;
        mpz_init(decr_secret_share);
        if (mpz_set_str(decr_secret_share, decr_sshare, 16) == -1) {
            *errStatus = 1;
            snprintf(errString, BUF_LEN, "invalid decrypted secret share");
            mpz_clear(decr_secret_share);
            return;
        }

        mpz_addmul_ui(sum, decr_secret_share, 1);
        mpz_clear(decr_secret_share);
    }

    mpz_t q;
    mpz_init(q);
    mpz_set_str(q, "21888242871839275222246405745257275088548364400416034343698204186575808495617", 10);

    mpz_t bls_key;
    mpz_init(bls_key);

    mpz_mod(bls_key, sum, q);

    char key_share[mpz_sizeinbase(bls_key, 16) + 2];
    char *key = mpz_get_str(key_share, 16, bls_key);
    snprintf(errString, BUF_LEN, " bls private key is %s", key_share);
    uint32_t sealedLen = sgx_calc_sealed_data_size(0, ECDSA_SKEY_LEN);


    status = sgx_seal_data(0, NULL, ECDSA_SKEY_LEN, (uint8_t *) key_share, sealedLen,
                           (sgx_sealed_data_t *) encr_bls_key);
    if (status != SGX_SUCCESS) {
        *errStatus = -1;
        snprintf(errString, BUF_LEN, "seal bls private key failed with status %d ", status);
        mpz_clear(bls_key);
        mpz_clear(sum);
        mpz_clear(q);
        return;
    }
    *enc_bls_key_len = sealedLen;


    mpz_clear(bls_key);
    mpz_clear(sum);
    mpz_clear(q);
}
