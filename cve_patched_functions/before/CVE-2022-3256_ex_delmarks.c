ex_delmarks(exarg_T *eap)
{
    char_u	*p;
    int		from, to;
    int		i;
    int		lower;
    int		digit;
    int		n;

    if (*eap->arg == NUL && eap->forceit)
	// clear all marks
	clrallmarks(curbuf);
    else if (eap->forceit)
	emsg(_(e_invalid_argument));
    else if (*eap->arg == NUL)
	emsg(_(e_argument_required));
    else
    {
	// clear specified marks only
	for (p = eap->arg; *p != NUL; ++p)
	{
	    lower = ASCII_ISLOWER(*p);
	    digit = VIM_ISDIGIT(*p);
	    if (lower || digit || ASCII_ISUPPER(*p))
	    {
		if (p[1] == '-')
		{
		    // clear range of marks
		    from = *p;
		    to = p[2];
		    if (!(lower ? ASCII_ISLOWER(p[2])
				: (digit ? VIM_ISDIGIT(p[2])
				    : ASCII_ISUPPER(p[2])))
			    || to < from)
		    {
			semsg(_(e_invalid_argument_str), p);
			return;
		    }
		    p += 2;
		}
		else
		    // clear one lower case mark
		    from = to = *p;

		for (i = from; i <= to; ++i)
		{
		    if (lower)
			curbuf->b_namedm[i - 'a'].lnum = 0;
		    else
		    {
			if (digit)
			    n = i - '0' + NMARKS;
			else
			    n = i - 'A';
			namedfm[n].fmark.mark.lnum = 0;
			namedfm[n].fmark.fnum = 0;
			VIM_CLEAR(namedfm[n].fname);
#ifdef FEAT_VIMINFO
			namedfm[n].time_set = digit ? 0 : vim_time();
#endif
		    }
		}
	    }
	    else
		switch (*p)
		{
		    case '"': curbuf->b_last_cursor.lnum = 0; break;
		    case '^': curbuf->b_last_insert.lnum = 0; break;
		    case '.': curbuf->b_last_change.lnum = 0; break;
		    case '[': curbuf->b_op_start.lnum    = 0; break;
		    case ']': curbuf->b_op_end.lnum      = 0; break;
		    case '<': curbuf->b_visual.vi_start.lnum = 0; break;
		    case '>': curbuf->b_visual.vi_end.lnum   = 0; break;
		    case ' ': break;
		    default:  semsg(_(e_invalid_argument_str), p);
			      return;
		}
	}
    }
}
