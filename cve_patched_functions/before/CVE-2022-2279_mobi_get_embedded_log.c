MOBI_RET mobi_get_embedded_log(unsigned char **data, size_t *size, const MOBIData *m) {
    *data = NULL;
    *size = 0;
    if (m == NULL) {
        return MOBI_INIT_FAILED;
    }
    MOBIMobiHeader *header = m->mh;
    if (mobi_is_hybrid(m) && m->use_kf8 && m->next) {
        /* SRCS index is in KF7 header */
        header = m->next->mh;
    }
    if (header == NULL || header->srcs_index == NULL || header->srcs_count == NULL ||
        *header->srcs_index == MOBI_NOTSET || *header->srcs_count < 2) {
        return MOBI_SUCCESS;
    }
    uint32_t index = *header->srcs_index + 1;
    
    const MOBIPdbRecord *srcs_record = mobi_get_record_by_seqnumber(m, index);
    if (srcs_record == NULL) {
        return MOBI_SUCCESS;
    }
    const size_t log_offset = 12;
    if (srcs_record->size <= log_offset) {
        debug_print("Wrong size of CMET resource: %zu\n", srcs_record->size);
        return MOBI_DATA_CORRUPT;
    }
    MOBIBuffer *buf = mobi_buffer_init_null(srcs_record->data, srcs_record->size);
    if (buf == NULL) {
        return MOBI_MALLOC_FAILED;
    }
    if (mobi_buffer_match_magic(buf, CMET_MAGIC) == false) {
        debug_print("%s\n", "Wrong magic for CMET resource");
        mobi_buffer_free_null(buf);
        return MOBI_DATA_CORRUPT;
    }
    mobi_buffer_setpos(buf, 8);
    uint32_t log_length = mobi_buffer_get32(buf);
    unsigned char *log_data = mobi_buffer_getpointer(buf, log_length);
    if (buf->error != MOBI_SUCCESS) {
        debug_print("CMET resource too short: %zu (log size: %u)\n", srcs_record->size, log_length);
        mobi_buffer_free_null(buf);
        return MOBI_DATA_CORRUPT;
    }
    
    *data = log_data;
    *size = log_length;
    
    mobi_buffer_free_null(buf);
    return MOBI_SUCCESS;
}
