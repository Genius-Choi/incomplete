static struct ast_frame *ast_rtp_read(struct ast_rtp_instance *instance, int rtcp)
{
	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
	struct ast_srtp *srtp;
	RAII_VAR(struct ast_rtp_instance *, child, NULL, rtp_instance_unlock);
	struct ast_sockaddr addr;
	int res, hdrlen = 12, version, payloadtype;
	unsigned char *read_area = rtp->rawdata + AST_FRIENDLY_OFFSET;
	size_t read_area_size = sizeof(rtp->rawdata) - AST_FRIENDLY_OFFSET;
	unsigned int *rtpheader = (unsigned int*)(read_area), seqno, ssrc, timestamp, prev_seqno;
	struct ast_sockaddr remote_address = { {0,} };
	struct frame_list frames;
	struct ast_frame *frame;
	unsigned int bundled;

	/* If this is actually RTCP let's hop on over and handle it */
	if (rtcp) {
		if (rtp->rtcp && rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {
			return ast_rtcp_read(instance);
		}
		return &ast_null_frame;
	}

	/* Actually read in the data from the socket */
	if ((res = rtp_recvfrom(instance, read_area, read_area_size, 0,
				&addr)) < 0) {
		if (res == RTP_DTLS_ESTABLISHED) {
			rtp->f.frametype = AST_FRAME_CONTROL;
			rtp->f.subclass.integer = AST_CONTROL_SRCCHANGE;
			return &rtp->f;
		}

		ast_assert(errno != EBADF);
		if (errno != EAGAIN) {
			ast_log(LOG_WARNING, "RTP Read error: %s.  Hanging up.\n",
				(errno) ? strerror(errno) : "Unspecified");
			return NULL;
		}
		return &ast_null_frame;
	}

	/* If this was handled by the ICE session don't do anything */
	if (!res) {
		return &ast_null_frame;
	}

	/* This could be a multiplexed RTCP packet. If so, be sure to interpret it correctly */
	if (rtcp_mux(rtp, read_area)) {
		return ast_rtcp_interpret(instance, ast_rtp_instance_get_srtp(instance, 1), read_area, res, &addr);
	}

	/* Make sure the data that was read in is actually enough to make up an RTP packet */
	if (res < hdrlen) {
		/* If this is a keepalive containing only nulls, don't bother with a warning */
		int i;
		for (i = 0; i < res; ++i) {
			if (read_area[i] != '\0') {
				ast_log(LOG_WARNING, "RTP Read too short\n");
				return &ast_null_frame;
			}
		}
		return &ast_null_frame;
	}

	/* Get fields and verify this is an RTP packet */
	seqno = ntohl(rtpheader[0]);

	ast_rtp_instance_get_remote_address(instance, &remote_address);

	if (!(version = (seqno & 0xC0000000) >> 30)) {
		struct sockaddr_in addr_tmp;
		struct ast_sockaddr addr_v4;
		if (ast_sockaddr_is_ipv4(&addr)) {
			ast_sockaddr_to_sin(&addr, &addr_tmp);
		} else if (ast_sockaddr_ipv4_mapped(&addr, &addr_v4)) {
			ast_debug_stun(1, "(%p) STUN using IPv6 mapped address %s\n",
				instance, ast_sockaddr_stringify(&addr));
			ast_sockaddr_to_sin(&addr_v4, &addr_tmp);
		} else {
			ast_debug_stun(1, "(%p) STUN cannot do for non IPv4 address %s\n",
				instance, ast_sockaddr_stringify(&addr));
			return &ast_null_frame;
		}
		if ((ast_stun_handle_packet(rtp->s, &addr_tmp, read_area, res, NULL, NULL) == AST_STUN_ACCEPT) &&
		    ast_sockaddr_isnull(&remote_address)) {
			ast_sockaddr_from_sin(&addr, &addr_tmp);
			ast_rtp_instance_set_remote_address(instance, &addr);
		}
		return &ast_null_frame;
	}

	/* If the version is not what we expected by this point then just drop the packet */
	if (version != 2) {
		return &ast_null_frame;
	}

	/* We use the SSRC to determine what RTP instance this packet is actually for */
	ssrc = ntohl(rtpheader[2]);

	/* We use the SRTP data from the provided instance that it came in on, not the child */
	srtp = ast_rtp_instance_get_srtp(instance, 0);

	/* Determine the appropriate instance for this */
	child = rtp_find_instance_by_packet_source_ssrc(instance, rtp, ssrc);
	if (!child) {
		/* Neither the bundled parent nor any child has this SSRC */
		return &ast_null_frame;
	}
	if (child != instance) {
		/* It is safe to hold the child lock while holding the parent lock, we guarantee that the locking order
		 * is always parent->child or that the child lock is not held when acquiring the parent lock.
		 */
		ao2_lock(child);
		instance = child;
		rtp = ast_rtp_instance_get_data(instance);
	} else {
		/* The child is the parent! We don't need to unlock it. */
		child = NULL;
	}

	/* If strict RTP protection is enabled see if we need to learn the remote address or if we need to drop the packet */
	switch (rtp->strict_rtp_state) {
	case STRICT_RTP_LEARN:
		/*
		 * Scenario setup:
		 * PartyA -- Ast1 -- Ast2 -- PartyB
		 *
		 * The learning timeout is necessary for Ast1 to handle the above
		 * setup where PartyA calls PartyB and Ast2 initiates direct media
		 * between Ast1 and PartyB.  Ast1 may lock onto the Ast2 stream and
		 * never learn the PartyB stream when it starts.  The timeout makes
		 * Ast1 stay in the learning state long enough to see and learn the
		 * RTP stream from PartyB.
		 *
		 * To mitigate against attack, the learning state cannot switch
		 * streams while there are competing streams.  The competing streams
		 * interfere with each other's qualification.  Once we accept a
		 * stream and reach the timeout, an attacker cannot interfere
		 * anymore.
		 *
		 * Here are a few scenarios and each one assumes that the streams
		 * are continuous:
		 *
		 * 1) We already have a known stream source address and the known
		 * stream wants to change to a new source address.  An attacking
		 * stream will block learning the new stream source.  After the
		 * timeout we re-lock onto the original stream source address which
		 * likely went away.  The result is one way audio.
		 *
		 * 2) We already have a known stream source address and the known
		 * stream doesn't want to change source addresses.  An attacking
		 * stream will not be able to replace the known stream.  After the
		 * timeout we re-lock onto the known stream.  The call is not
		 * affected.
		 *
		 * 3) We don't have a known stream source address.  This presumably
		 * is the start of a call.  Competing streams will result in staying
		 * in learning mode until a stream becomes the victor and we reach
		 * the timeout.  We cannot exit learning if we have no known stream
		 * to lock onto.  The result is one way audio until there is a victor.
		 *
		 * If we learn a stream source address before the timeout we will be
		 * in scenario 1) or 2) when a competing stream starts.
		 */
		if (!ast_sockaddr_isnull(&rtp->strict_rtp_address)
			&& STRICT_RTP_LEARN_TIMEOUT < ast_tvdiff_ms(ast_tvnow(), rtp->rtp_source_learn.start)) {
			ast_verb(4, "%p -- Strict RTP learning complete - Locking on source address %s\n",
				rtp, ast_sockaddr_stringify(&rtp->strict_rtp_address));
			ast_test_suite_event_notify("STRICT_RTP_LEARN", "Source: %s",
				ast_sockaddr_stringify(&rtp->strict_rtp_address));
			rtp->strict_rtp_state = STRICT_RTP_CLOSED;
		} else {
			struct ast_sockaddr target_address;

			if (!ast_sockaddr_cmp(&rtp->strict_rtp_address, &addr)) {
				/*
				 * We are open to learning a new address but have received
				 * traffic from the current address, accept it and reset
				 * the learning counts for a new source.  When no more
				 * current source packets arrive a new source can take over
				 * once sufficient traffic is received.
				 */
				rtp_learning_seq_init(&rtp->rtp_source_learn, seqno);
				break;
			}

			/*
			 * We give preferential treatment to the requested target address
			 * (negotiated SDP address) where we are to send our RTP.  However,
			 * the other end has no obligation to send from that address even
			 * though it is practically a requirement when NAT is involved.
			 */
			ast_rtp_instance_get_requested_target_address(instance, &target_address);
			if (!ast_sockaddr_cmp(&target_address, &addr)) {
				/* Accept the negotiated target RTP stream as the source */
				ast_verb(4, "%p -- Strict RTP switching to RTP target address %s as source\n",
					rtp, ast_sockaddr_stringify(&addr));
				ast_sockaddr_copy(&rtp->strict_rtp_address, &addr);
				rtp_learning_seq_init(&rtp->rtp_source_learn, seqno);
				break;
			}

			/*
			 * Trying to learn a new address.  If we pass a probationary period
			 * with it, that means we've stopped getting RTP from the original
			 * source and we should switch to it.
			 */
			if (!ast_sockaddr_cmp(&rtp->rtp_source_learn.proposed_address, &addr)) {
				if (rtp->rtp_source_learn.stream_type == AST_MEDIA_TYPE_UNKNOWN) {
					struct ast_rtp_codecs *codecs;

					codecs = ast_rtp_instance_get_codecs(instance);
					rtp->rtp_source_learn.stream_type =
						ast_rtp_codecs_get_stream_type(codecs);
					ast_verb(4, "%p -- Strict RTP qualifying stream type: %s\n",
						rtp, ast_codec_media_type2str(rtp->rtp_source_learn.stream_type));
				}
				if (!rtp_learning_rtp_seq_update(&rtp->rtp_source_learn, seqno)) {
					/* Accept the new RTP stream */
					ast_verb(4, "%p -- Strict RTP switching source address to %s\n",
						rtp, ast_sockaddr_stringify(&addr));
					ast_sockaddr_copy(&rtp->strict_rtp_address, &addr);
					rtp_learning_seq_init(&rtp->rtp_source_learn, seqno);
					break;
				}
				/* Not ready to accept the RTP stream candidate */
				ast_debug_rtp(1, "(%p) RTP %p -- Received packet from %s, dropping due to strict RTP protection. Will switch to it in %d packets.\n",
					instance, rtp, ast_sockaddr_stringify(&addr), rtp->rtp_source_learn.packets);
			} else {
				/*
				 * This is either an attacking stream or
				 * the start of the expected new stream.
				 */
				ast_sockaddr_copy(&rtp->rtp_source_learn.proposed_address, &addr);
				rtp_learning_seq_init(&rtp->rtp_source_learn, seqno);
				ast_debug_rtp(1, "(%p) RTP %p -- Received packet from %s, dropping due to strict RTP protection. Qualifying new stream.\n",
					instance, rtp, ast_sockaddr_stringify(&addr));
			}
			return &ast_null_frame;
		}
		/* Fall through */
	case STRICT_RTP_CLOSED:
		/*
		 * We should not allow a stream address change if the SSRC matches
		 * once strictrtp learning is closed.  Any kind of address change
		 * like this should have happened while we were in the learning
		 * state.  We do not want to allow the possibility of an attacker
		 * interfering with the RTP stream after the learning period.
		 * An attacker could manage to get an RTCP packet redirected to
		 * them which can contain the SSRC value.
		 */
		if (!ast_sockaddr_cmp(&rtp->strict_rtp_address, &addr)) {
			break;
		}
		ast_debug_rtp(1, "(%p) RTP %p -- Received packet from %s, dropping due to strict RTP protection.\n",
			instance, rtp, ast_sockaddr_stringify(&addr));
#ifdef TEST_FRAMEWORK
	{
		static int strict_rtp_test_event = 1;
		if (strict_rtp_test_event) {
			ast_test_suite_event_notify("STRICT_RTP_CLOSED", "Source: %s",
				ast_sockaddr_stringify(&addr));
			strict_rtp_test_event = 0; /* Only run this event once to prevent possible spam */
		}
	}
#endif
		return &ast_null_frame;
	case STRICT_RTP_OPEN:
		break;
	}

	/* If symmetric RTP is enabled see if the remote side is not what we expected and change where we are sending audio */
	if (ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_NAT)) {
		if (ast_sockaddr_cmp(&remote_address, &addr)) {
			/* do not update the originally given address, but only the remote */
			ast_rtp_instance_set_incoming_source_address(instance, &addr);
			ast_sockaddr_copy(&remote_address, &addr);
			if (rtp->rtcp && rtp->rtcp->type == AST_RTP_INSTANCE_RTCP_STANDARD) {
				ast_sockaddr_copy(&rtp->rtcp->them, &addr);
				ast_sockaddr_set_port(&rtp->rtcp->them, ast_sockaddr_port(&addr) + 1);
			}
			ast_set_flag(rtp, FLAG_NAT_ACTIVE);
			if (ast_debug_rtp_packet_is_allowed)
				ast_debug(0, "(%p) RTP NAT: Got audio from other end. Now sending to address %s\n",
					instance, ast_sockaddr_stringify(&remote_address));
		}
	}

	/* Pull out the various other fields we will need */
	payloadtype = (seqno & 0x7f0000) >> 16;
	seqno &= 0xffff;
	timestamp = ntohl(rtpheader[1]);

#ifdef AST_DEVMODE
	if (should_drop_packets(&addr)) {
		ast_debug(0, "(%p) RTP: drop received packet from %s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6d)\n",
			instance, ast_sockaddr_stringify(&addr), payloadtype, seqno, timestamp, res - hdrlen);
		return &ast_null_frame;
	}
#endif

	if (rtp_debug_test_addr(&addr)) {
		ast_verbose("Got  RTP packet from    %s (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6d)\n",
			    ast_sockaddr_stringify(&addr),
			    payloadtype, seqno, timestamp, res - hdrlen);
	}

	AST_LIST_HEAD_INIT_NOLOCK(&frames);

	bundled = (child || AST_VECTOR_SIZE(&rtp->ssrc_mapping)) ? 1 : 0;

	prev_seqno = rtp->lastrxseqno;
	/* We need to save lastrxseqno for use by jitter before resetting it. */
	rtp->prevrxseqno = rtp->lastrxseqno;
	rtp->lastrxseqno = seqno;

	if (!rtp->recv_buffer) {
		/* If there is no receive buffer then we can pass back the frame directly */
		frame = ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled);
		AST_LIST_INSERT_TAIL(&frames, frame, frame_list);
		return AST_LIST_FIRST(&frames);
	} else if (rtp->expectedrxseqno == -1 || seqno == rtp->expectedrxseqno) {
		rtp->expectedrxseqno = seqno + 1;

		/* We've cycled over, so go back to 0 */
		if (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {
			rtp->expectedrxseqno = 0;
		}

		/* If there are no buffered packets that will be placed after this frame then we can
		 * return it directly without duplicating it.
		 */
		if (!ast_data_buffer_count(rtp->recv_buffer)) {
			frame = ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled);
			AST_LIST_INSERT_TAIL(&frames, frame, frame_list);
			return AST_LIST_FIRST(&frames);
		}

		if (!AST_VECTOR_REMOVE_CMP_ORDERED(&rtp->missing_seqno, seqno, find_by_value,
			AST_VECTOR_ELEM_CLEANUP_NOOP)) {
			ast_debug_rtp(2, "(%p) RTP Packet with sequence number '%d' on instance is no longer missing\n",
				instance, seqno);
		}

		/* If we don't have the next packet after this we can directly return the frame, as there is no
		 * chance it will be overwritten.
		 */
		if (!ast_data_buffer_get(rtp->recv_buffer, rtp->expectedrxseqno)) {
			frame = ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled);
			AST_LIST_INSERT_TAIL(&frames, frame, frame_list);
			return AST_LIST_FIRST(&frames);
		}

		/* Otherwise we need to dupe the frame so that the potential processing of frames placed after
		 * it do not overwrite the data. You may be thinking that we could just add the current packet
		 * to the head of the frames list and avoid having to duplicate it but this would result in out
		 * of order packet processing by libsrtp which we are trying to avoid.
		 */
		frame = ast_frdup(ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled));
		if (frame) {
			AST_LIST_INSERT_TAIL(&frames, frame, frame_list);
			prev_seqno = seqno;
		}

		/* Add any additional packets that we have buffered and that are available */
		while (ast_data_buffer_count(rtp->recv_buffer)) {
			struct ast_rtp_rtcp_nack_payload *payload;

			payload = (struct ast_rtp_rtcp_nack_payload *)ast_data_buffer_remove(rtp->recv_buffer, rtp->expectedrxseqno);
			if (!payload) {
				break;
			}

			frame = ast_frdup(ast_rtp_interpret(instance, srtp, &addr, payload->buf, payload->size, prev_seqno, bundled));
			ast_free(payload);

			if (!frame) {
				/* If this packet can't be interpreted due to being out of memory we return what we have and assume
				 * that we will determine it is a missing packet later and NACK for it.
				 */
				return AST_LIST_FIRST(&frames);
			}

			ast_debug_rtp(2, "(%p) RTP pulled buffered packet with sequence number '%d' to additionally return\n",
				instance, frame->seqno);
			AST_LIST_INSERT_TAIL(&frames, frame, frame_list);
			prev_seqno = rtp->expectedrxseqno;
			rtp->expectedrxseqno++;
			if (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {
				rtp->expectedrxseqno = 0;
			}
		}

		return AST_LIST_FIRST(&frames);
	} else if ((((seqno - rtp->expectedrxseqno) > 100) && timestamp > rtp->lastividtimestamp) ||
		ast_data_buffer_count(rtp->recv_buffer) == ast_data_buffer_max(rtp->recv_buffer)) {
		int inserted = 0;

		/* We have a large number of outstanding buffered packets or we've jumped far ahead in time.
		 * To compensate we dump what we have in the buffer and place the current packet in a logical
		 * spot. In the case of video we also require a full frame to give the decoding side a fighting
		 * chance.
		 */

		if (rtp->rtp_source_learn.stream_type == AST_MEDIA_TYPE_VIDEO) {
			ast_debug_rtp(2, "(%p) RTP source has wild gap or packet loss, sending FIR\n",
				instance);
			rtp_write_rtcp_fir(instance, rtp, &remote_address);
		}

		/* This works by going through the progression of the sequence number retrieving buffered packets
		 * or inserting the current received packet until we've run out of packets. This ensures that the
		 * packets are in the correct sequence number order.
		 */
		while (ast_data_buffer_count(rtp->recv_buffer)) {
			struct ast_rtp_rtcp_nack_payload *payload;

			/* If the packet we received is the one we are expecting at this point then add it in */
			if (rtp->expectedrxseqno == seqno) {
				frame = ast_frdup(ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled));
				if (frame) {
					AST_LIST_INSERT_TAIL(&frames, frame, frame_list);
					prev_seqno = seqno;
					ast_debug_rtp(2, "(%p) RTP inserted just received packet with sequence number '%d' in correct order\n",
						instance, seqno);
				}
				/* It is possible due to packet retransmission for this packet to also exist in the receive
				 * buffer so we explicitly remove it in case this occurs, otherwise the receive buffer will
				 * never be empty.
				 */
				payload = (struct ast_rtp_rtcp_nack_payload *)ast_data_buffer_remove(rtp->recv_buffer, seqno);
				if (payload) {
					ast_free(payload);
				}
				rtp->expectedrxseqno++;
				if (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {
					rtp->expectedrxseqno = 0;
				}
				inserted = 1;
				continue;
			}

			payload = (struct ast_rtp_rtcp_nack_payload *)ast_data_buffer_remove(rtp->recv_buffer, rtp->expectedrxseqno);
			if (payload) {
				frame = ast_frdup(ast_rtp_interpret(instance, srtp, &addr, payload->buf, payload->size, prev_seqno, bundled));
				if (frame) {
					AST_LIST_INSERT_TAIL(&frames, frame, frame_list);
					prev_seqno = rtp->expectedrxseqno;
					ast_debug_rtp(2, "(%p) RTP emptying queue and returning packet with sequence number '%d'\n",
						instance, frame->seqno);
				}
				ast_free(payload);
			}

			rtp->expectedrxseqno++;
			if (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {
				rtp->expectedrxseqno = 0;
			}
		}

		if (!inserted) {
			/* This current packet goes after them, and we assume that packets going forward will follow
			 * that new sequence number increment. It is okay for this to not be duplicated as it is guaranteed
			 * to be the last packet processed right now and it is also guaranteed that it will always return
			 * non-NULL.
			 */
			frame = ast_rtp_interpret(instance, srtp, &addr, read_area, res, prev_seqno, bundled);
			AST_LIST_INSERT_TAIL(&frames, frame, frame_list);
			rtp->expectedrxseqno = seqno + 1;
			if (rtp->expectedrxseqno == SEQNO_CYCLE_OVER) {
				rtp->expectedrxseqno = 0;
			}

			ast_debug_rtp(2, "(%p) RTP adding just received packet with sequence number '%d' to end of dumped queue\n",
				instance, seqno);
		}

		/* When we flush increase our chance for next time by growing the receive buffer when possible
		 * by how many packets we missed, to give ourselves a bit more breathing room.
		 */
		ast_data_buffer_resize(rtp->recv_buffer, MIN(MAXIMUM_RTP_RECV_BUFFER_SIZE,
			ast_data_buffer_max(rtp->recv_buffer) + AST_VECTOR_SIZE(&rtp->missing_seqno)));
		ast_debug_rtp(2, "(%p) RTP receive buffer is now at maximum of %zu\n", instance, ast_data_buffer_max(rtp->recv_buffer));

		/* As there is such a large gap we don't want to flood the order side with missing packets, so we
		 * give up and start anew.
		 */
		AST_VECTOR_RESET(&rtp->missing_seqno, AST_VECTOR_ELEM_CLEANUP_NOOP);

		return AST_LIST_FIRST(&frames);
	}

	/* We're finished with the frames list */
	ast_frame_free(AST_LIST_FIRST(&frames), 0);

	/* Determine if the received packet is from the last OLD_PACKET_COUNT (1000 by default) packets or not.
	 * For the case where the received sequence number exceeds that of the expected sequence number we calculate
	 * the past sequence number that would be 1000 sequence numbers ago. If the received sequence number
	 * exceeds or meets that then it is within OLD_PACKET_COUNT packets ago. For example if the expected
	 * sequence number is 100 and we receive 65530, then it would be considered old. This is because
	 * 65535 - 1000 + 100 = 64635 which gives us the sequence number at which we would consider the packets
	 * old. Since 65530 is above that, it would be considered old.
	 * For the case where the received sequence number is less than the expected sequence number we can do
	 * a simple subtraction to see if it is 1000 packets ago or not.
	 */
	if ((seqno < rtp->expectedrxseqno && ((rtp->expectedrxseqno - seqno) <= OLD_PACKET_COUNT)) ||
		(seqno > rtp->expectedrxseqno && (seqno >= (65535 - OLD_PACKET_COUNT + rtp->expectedrxseqno)))) {
		/* If this is a packet from the past then we have received a duplicate packet, so just drop it */
		ast_debug_rtp(2, "(%p) RTP received an old packet with sequence number '%d', dropping it\n",
			instance, seqno);
		return &ast_null_frame;
	} else if (ast_data_buffer_get(rtp->recv_buffer, seqno)) {
		/* If this is a packet we already have buffered then it is a duplicate, so just drop it */
		ast_debug_rtp(2, "(%p) RTP received a duplicate transmission of packet with sequence number '%d', dropping it\n",
			instance, seqno);
		return &ast_null_frame;
	} else {
		/* This is an out of order packet from the future */
		struct ast_rtp_rtcp_nack_payload *payload;
		int missing_seqno;
		int remove_failed;
		unsigned int missing_seqnos_added = 0;

		ast_debug_rtp(2, "(%p) RTP received an out of order packet with sequence number '%d' while expecting '%d' from the future\n",
			instance, seqno, rtp->expectedrxseqno);

		payload = ast_malloc(sizeof(*payload) + res);
		if (!payload) {
			/* If the payload can't be allocated then we can't defer this packet right now.
			 * Instead of dumping what we have we pretend we lost this packet. It will then
			 * get NACKed later or the existing buffer will be returned entirely. Well, we may
			 * try since we're seemingly out of memory. It's a bad situation all around and
			 * packets are likely to get lost anyway.
			 */
			return &ast_null_frame;
		}

		payload->size = res;
		memcpy(payload->buf, rtpheader, res);
		if (ast_data_buffer_put(rtp->recv_buffer, seqno, payload) == -1) {
			ast_free(payload);
		}

		/* If this sequence number is removed that means we had a gap and this packet has filled it in
		 * some. Since it was part of the gap we will have already added any other missing sequence numbers
		 * before it (and possibly after it) to the vector so we don't need to do that again. Note that
		 * remove_failed will be set to -1 if the sequence number isn't removed, and 0 if it is.
		 */
		remove_failed = AST_VECTOR_REMOVE_CMP_ORDERED(&rtp->missing_seqno, seqno, find_by_value,
			AST_VECTOR_ELEM_CLEANUP_NOOP);
		if (!remove_failed) {
			ast_debug_rtp(2, "(%p) RTP packet with sequence number '%d' is no longer missing\n",
				instance, seqno);
		}

		/* The missing sequence number code works by taking the sequence number of the
		 * packet we've just received and going backwards until we hit the sequence number
		 * of the last packet we've received. While doing so we check to make sure that the
		 * sequence number is not already missing and that it is not already buffered.
		 */
		missing_seqno = seqno;
		while (remove_failed) {
			missing_seqno -= 1;

			/* If we've cycled backwards then start back at the top */
			if (missing_seqno < 0) {
				missing_seqno = 65535;
			}

			/* We've gone backwards enough such that we've hit the previous sequence number */
			if (missing_seqno == prev_seqno) {
				break;
			}

			/* We don't want missing sequence number duplicates. If, for some reason,
			 * packets are really out of order, we could end up in this scenario:
			 *
			 * We are expecting sequence number 100
			 * We receive sequence number 105
			 * Sequence numbers 100 through 104 get added to the vector
			 * We receive sequence number 101 (this section is skipped)
			 * We receive sequence number 103
			 * Sequence number 102 is added to the vector
			 *
			 * This will prevent the duplicate from being added.
			 */
			if (AST_VECTOR_GET_CMP(&rtp->missing_seqno, missing_seqno,
						find_by_value)) {
				continue;
			}

			/* If this packet has been buffered already then don't count it amongst the
			 * missing.
			 */
			if (ast_data_buffer_get(rtp->recv_buffer, missing_seqno)) {
				continue;
			}

			ast_debug_rtp(2, "(%p) RTP added missing sequence number '%d'\n",
				instance, missing_seqno);
			AST_VECTOR_ADD_SORTED(&rtp->missing_seqno, missing_seqno,
					compare_by_value);
			missing_seqnos_added++;
		}

		/* When we add a large number of missing sequence numbers we assume there was a substantial
		 * gap in reception so we trigger an immediate NACK. When our data buffer is 1/4 full we
		 * assume that the packets aren't just out of order but have actually been lost. At 1/2
		 * full we get more aggressive and ask for retransmission when we get a new packet.
		 * To get them back we construct and send a NACK causing the sender to retransmit them.
		 */
		if (missing_seqnos_added >= MISSING_SEQNOS_ADDED_TRIGGER ||
			ast_data_buffer_count(rtp->recv_buffer) == ast_data_buffer_max(rtp->recv_buffer) / 4 ||
			ast_data_buffer_count(rtp->recv_buffer) >= ast_data_buffer_max(rtp->recv_buffer) / 2) {
			int packet_len = 0;
			int res = 0;
			int ice;
			int sr;
			size_t data_size = AST_UUID_STR_LEN + 128 + (AST_VECTOR_SIZE(&rtp->missing_seqno) * 4);
			RAII_VAR(unsigned char *, rtcpheader, NULL, ast_free_ptr);
			RAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report,
					ast_rtp_rtcp_report_alloc(rtp->themssrc_valid ? 1 : 0),
					ao2_cleanup);

			/* Sufficient space for RTCP headers and report, SDES with CNAME, NACK header,
			 * and worst case 4 bytes per missing sequence number.
			 */
			rtcpheader = ast_malloc(sizeof(*rtcpheader) + data_size);
			if (!rtcpheader) {
				ast_debug_rtcp(1, "(%p) RTCP failed to allocate memory for NACK\n", instance);
				return &ast_null_frame;
			}

			memset(rtcpheader, 0, data_size);

			res = ast_rtcp_generate_compound_prefix(instance, rtcpheader, rtcp_report, &sr);

			if (res == 0 || res == 1) {
				return &ast_null_frame;
			}

			packet_len += res;

			res = ast_rtcp_generate_nack(instance, rtcpheader + packet_len);

			if (res == 0) {
				ast_debug_rtcp(1, "(%p) RTCP failed to construct NACK, stopping here\n", instance);
				return &ast_null_frame;
			}

			packet_len += res;

			res = rtcp_sendto(instance, rtcpheader, packet_len, 0, &remote_address, &ice);
			if (res < 0) {
				ast_debug_rtcp(1, "(%p) RTCP failed to send NACK request out\n", instance);
			} else {
				ast_debug_rtcp(2, "(%p) RTCP sending a NACK request to get missing packets\n", instance);
				/* Update RTCP SR/RR statistics */
				ast_rtcp_calculate_sr_rr_statistics(instance, rtcp_report, remote_address, ice, sr);
			}
		}
	}

	return &ast_null_frame;
}
