static int handle_request_for_tables(char *tables, uint length)
{
  char *query, *end, options[100], message[100];
  uint query_length= 0;
  const char *op = 0;

  options[0] = 0;
  end = options;
  switch (what_to_do) {
  case DO_CHECK:
    op = "CHECK";
    if (opt_quick)              end = my_stpcpy(end, " QUICK");
    if (opt_fast)               end = my_stpcpy(end, " FAST");
    if (opt_medium_check)       end = my_stpcpy(end, " MEDIUM"); /* Default */
    if (opt_extended)           end = my_stpcpy(end, " EXTENDED");
    if (opt_check_only_changed) end = my_stpcpy(end, " CHANGED");
    if (opt_upgrade)            end = my_stpcpy(end, " FOR UPGRADE");
    break;
  case DO_REPAIR:
    op= (opt_write_binlog) ? "REPAIR" : "REPAIR NO_WRITE_TO_BINLOG";
    if (opt_quick)              end = my_stpcpy(end, " QUICK");
    if (opt_extended)           end = my_stpcpy(end, " EXTENDED");
    if (opt_frm)                end = my_stpcpy(end, " USE_FRM");
    break;
  case DO_ANALYZE:
    op= (opt_write_binlog) ? "ANALYZE" : "ANALYZE NO_WRITE_TO_BINLOG";
    break;
  case DO_OPTIMIZE:
    op= (opt_write_binlog) ? "OPTIMIZE" : "OPTIMIZE NO_WRITE_TO_BINLOG";
    break;
  case DO_UPGRADE:
    return fix_table_storage_name(tables);
  }

  if (!(query =(char *) my_malloc(PSI_NOT_INSTRUMENTED,
                                  (sizeof(char)*(length+110)), MYF(MY_WME))))
    return 1;
  if (opt_all_in_1)
  {
    /* No backticks here as we added them before */
    query_length= sprintf(query, "%s TABLE %s %s", op, tables, options);
  }
  else
  {
    char *ptr;

    ptr= my_stpcpy(my_stpcpy(query, op), " TABLE ");
    ptr= fix_table_name(ptr, tables);
    ptr= strxmov(ptr, " ", options, NullS);
    query_length= (uint) (ptr - query);
  }
  if (mysql_real_query(sock, query, query_length))
  {
    sprintf(message, "when executing '%s TABLE ... %s'", op, options);
    DBerror(sock, message);
    return 1;
  }
  print_result();
  my_free(query);
  return 0;
}
