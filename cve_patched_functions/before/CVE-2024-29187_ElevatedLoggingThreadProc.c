static DWORD WINAPI ElevatedLoggingThreadProc(
    __in LPVOID lpThreadParameter
    )
{
    HRESULT hr = S_OK;
    DWORD dwLastError = ERROR_SUCCESS;
    BURN_REDIRECTED_LOGGING_CONTEXT* pContext = static_cast<BURN_REDIRECTED_LOGGING_CONTEXT*>(lpThreadParameter);
    DWORD dwSignaledIndex = 0;
    LPSTR sczBuffer = NULL;
    BURN_PIPE_RESULT result = { };
    HANDLE rghEvents[2] =
    {
        pContext->hLogEvent,
        pContext->hFinishedEvent,
    };

    for (;;)
    {
        hr = AppWaitForMultipleObjects(countof(rghEvents), rghEvents, FALSE, INFINITE, &dwSignaledIndex);
        if (FAILED(hr))
        {
            LogRedirect(NULL, NULL); // reset logging so the next failure gets written locally.
            ExitOnFailure(hr, "Failed to wait for log thread events, signaled: %u.", dwSignaledIndex);
        }

        if (1 == dwSignaledIndex)
        {
            LogRedirect(NULL, NULL); // No more messages will be logged over the pipe.
        }

        dwLastError = ERROR_SUCCESS;

        ::EnterCriticalSection(&pContext->csBuffer);

        sczBuffer = pContext->sczBuffer;
        pContext->sczBuffer = NULL;

        if (0 == dwSignaledIndex && !::ResetEvent(rghEvents[0]))
        {
            dwLastError = ::GetLastError();
        }

        ::LeaveCriticalSection(&pContext->csBuffer);

        if (ERROR_SUCCESS != dwLastError)
        {
            LogRedirect(NULL, NULL); // reset logging so the next failure gets written locally.
            ExitOnWin32Error(dwLastError, hr, "Failed to reset log event.");
        }

        if (sczBuffer)
        {
            hr = LogStringOverPipe(sczBuffer, pContext->hPipe);
            if (FAILED(hr))
            {
                LogRedirect(NULL, NULL); // reset logging so the next failure gets written locally.
                ExitOnFailure(hr, "Failed to wait log message over pipe.");
            }

            ReleaseStr(sczBuffer);
        }

        if (1 == dwSignaledIndex)
        {
            break;
        }
    }

LExit:
    LogRedirect(NULL, NULL); // No more messages will be logged over the pipe.

    {
        HRESULT hrTerminate = PipeTerminateLoggingPipe(pContext->hPipe, hr);
        if (FAILED(hrTerminate))
        {
            TraceError(hrTerminate, "Failed to terminate logging pipe.");
        }
    }

    // Log the message locally if it failed to go over the pipe.
    if (sczBuffer)
    {
        LogStringWorkRaw(sczBuffer);

        ReleaseStr(sczBuffer);
    }

    // Log any remaining message locally.
    if (pContext->sczBuffer)
    {
        AssertSz(FAILED(hr), "Exiting logging thread on success even though there was a leftover message");
        LogStringWorkRaw(pContext->sczBuffer);

        ReleaseStr(pContext->sczBuffer);
    }

    return (DWORD)hr;
}
