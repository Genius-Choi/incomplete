Perl_regcurly(const char *s, const char *e, const char * result[5])
{
    /* This function matches a {m,n} quantifier.  When called with a NULL final
     * argument, it simply parses the input from 's' up through 'e-1', and
     * returns a boolean as to whether or not this input is syntactically a
     * {m,n} quantifier.
     *
     * When called with a non-NULL final parameter, and when the function
     * returns TRUE, it additionally stores information into the array
     * specified by that parameter about what it found in the parse.  The
     * parameter must be a pointer into a 5 element array of 'const char *'
     * elements.  The returned information is as follows:
     *   result[RBRACE]  points to the closing brace
     *   result[MIN_S]   points to the first byte of the lower bound
     *   result[MIN_E]   points to one beyond the final byte of the lower bound
     *   result[MAX_S]   points to the first byte of the upper bound
     *   result[MAX_E]   points to one beyond the final byte of the upper bound
     *
     * If the quantifier is of the form {m,} (meaning an infinite upper
     * bound), result[MAX_E] is set to result[MAX_S]; what they actually point
     * to is irrelevant, just that it's the same place
     *
     * If instead the quantifier is of the form {m} there is actually only
     * one bound, and both the upper and lower result[] elements are set to
     * point to it.
     *
     * This function checks only for syntactic validity; it leaves checking for
     * semantic validity and raising any diagnostics to the caller.  This
     * function is called in multiple places to check for syntax, but only from
     * one for semantics.  It makes it as simple as possible for the
     * syntax-only callers, while furnishing just enough information for the
     * semantic caller.
     */

    const char * min_start = NULL;
    const char * max_start = NULL;
    const char * min_end = NULL;
    const char * max_end = NULL;

    bool has_comma = FALSE;

    PERL_ARGS_ASSERT_REGCURLY;

    if (s >= e || *s++ != '{')
	return FALSE;

    while (s < e && isBLANK(*s)) {
        s++;
    }

    if isDIGIT(*s) {
        min_start = s;
        do {
            s++;
        } while (s < e && isDIGIT(*s));
        min_end = s;
    }

    while (s < e && isBLANK(*s)) {
        s++;
    }

    if (*s == ',') {
        has_comma = TRUE;
	s++;

        while (s < e && isBLANK(*s)) {
            s++;
        }

        if isDIGIT(*s) {
            max_start = s;
            do {
                s++;
            } while (s < e && isDIGIT(*s));
            max_end = s;
        }
    }

    while (s < e && isBLANK(*s)) {
        s++;
    }
                               /* Need at least one number */
    if (s >= e || *s != '}' || (! min_start && ! max_end)) {
        return FALSE;
    }

    if (result) {

        result[RBRACE] = s;

        result[MIN_S] = min_start;
        result[MIN_E] = min_end;
        if (has_comma) {
            if (max_start) {
                result[MAX_S] = max_start;
                result[MAX_E] = max_end;
            }
            else {
                /* Having no value after the comma is signalled by setting
                 * start and end to the same value.  What that value is isn't
                 * relevant; NULL is chosen simply because it will fail if the
                 * caller mistakenly uses it */
                result[MAX_S] = result[MAX_E] = NULL;
            }
        }
        else {  /* No comma means lower and upper bounds are the same */
            result[MAX_S] = min_start;
            result[MAX_E] = min_end;
        }
    }

    return TRUE;
}
