typedArrayPrototypeAt(void *, Runtime &runtime, NativeArgs args) {
  // 1. Let O be the this value.
  // 2. Perform ? ValidateTypedArray(O).
  if (LLVM_UNLIKELY(
          JSTypedArrayBase::validateTypedArray(
              runtime, args.getThisHandle(), true) ==
          ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  GCScope gcScope{runtime};

  auto O = args.vmcastThis<JSTypedArrayBase>();

  // 3. Let len be O.[[ArrayLength]].
  // The this object‚Äôs [[ArrayLength]] internal slot is accessed in place of
  // performing a [[Get]] of "length".
  double len = O->getLength();

  // 4. Let relativeIndex be ? ToIntegerOrInfinity(index).
  auto idx = args.getArgHandle(0);
  auto relativeIndexRes = toIntegerOrInfinity(runtime, idx);
  if (relativeIndexRes == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  const double relativeIndex = relativeIndexRes->getNumber();

  double k;
  // 5. If relativeIndex ‚â• 0, then
  if (relativeIndex >= 0) {
    // a. Let k be relativeIndex.
    k = relativeIndex;
  } else {
    // 6. Else,
    // a. Let k be len + relativeIndex.
    k = len + relativeIndex;
  }

  // 7. If k < 0 or k ‚â• len, return undefined.
  if (k < 0 || k >= len) {
    return HermesValue::encodeUndefinedValue();
  }

  // 8. Return ? Get(O, ! ToString(ùîΩ(k))).
  // Since we know we have a TypedArray, we can directly call JSTypedArray::at
  // rather than getComputed_RJS like the spec mandates.
#define TYPED_ARRAY(name, type)                                            \
  case CellKind::name##ArrayKind: {                                        \
    auto *arr = vmcast<JSTypedArray<type, CellKind::name##ArrayKind>>(*O); \
    if (!arr->attached(runtime)) {                                         \
      return runtime.raiseTypeError("Underlying ArrayBuffer detached");    \
    }                                                                      \
    return HermesValue::encodeNumberValue(arr->at(runtime, k));            \
  }
  switch (O->getKind()) {
#include "hermes/VM/TypedArrays.def"
    default:
      llvm_unreachable("Invalid TypedArray after ValidateTypedArray call");
  }
}
