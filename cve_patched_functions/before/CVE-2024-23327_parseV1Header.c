bool Filter::parseV1Header(const char* buf, size_t len) {
  std::string proxy_line;
  proxy_line.assign(buf, len);
  const auto trimmed_proxy_line = StringUtil::rtrim(proxy_line);

  // Parse proxy protocol line with format: PROXY TCP4/TCP6/UNKNOWN SOURCE_ADDRESS
  // DESTINATION_ADDRESS SOURCE_PORT DESTINATION_PORT.
  const auto line_parts = StringUtil::splitToken(trimmed_proxy_line, " ", true);
  if (line_parts.size() < 2 || line_parts[0] != "PROXY") {
    ENVOY_LOG(debug, "failed to read proxy protocol");
    return false;
  }

  // If the line starts with UNKNOWN we know it's a proxy protocol line, so we can remove it from
  // the socket and continue. According to spec "real connection's parameters" should be used, so
  // we should NOT restore the addresses in this case.
  if (line_parts[1] != "UNKNOWN") {
    // If protocol not UNKNOWN, src and dst addresses have to be present.
    if (line_parts.size() != 6) {
      ENVOY_LOG(debug, "failed to read proxy protocol");
      return false;
    }

    // TODO(gsagula): parseInternetAddressAndPortNoThrow() could be modified to take two string_view
    // arguments, so we can eliminate allocation here.
    if (line_parts[1] == "TCP4") {
      const Network::Address::InstanceConstSharedPtr remote_address =
          Network::Utility::parseInternetAddressAndPortNoThrow(std::string{line_parts[2]} + ":" +
                                                               std::string{line_parts[4]});
      const Network::Address::InstanceConstSharedPtr local_address =
          Network::Utility::parseInternetAddressAndPortNoThrow(std::string{line_parts[3]} + ":" +
                                                               std::string{line_parts[5]});

      if (remote_address == nullptr || local_address == nullptr) {
        return false;
      }
      proxy_protocol_header_.emplace(
          WireHeader{len, 0, 0, 0, Network::Address::IpVersion::v4, remote_address, local_address});
      return true;
    } else if (line_parts[1] == "TCP6") {
      const Network::Address::InstanceConstSharedPtr remote_address =
          Network::Utility::parseInternetAddressAndPortNoThrow("[" + std::string{line_parts[2]} +
                                                               "]:" + std::string{line_parts[4]});
      const Network::Address::InstanceConstSharedPtr local_address =
          Network::Utility::parseInternetAddressAndPortNoThrow("[" + std::string{line_parts[3]} +
                                                               "]:" + std::string{line_parts[5]});

      if (remote_address == nullptr || local_address == nullptr) {
        return false;
      }
      proxy_protocol_header_.emplace(
          WireHeader{len, 0, 0, 0, Network::Address::IpVersion::v6, remote_address, local_address});
      return true;
    } else {
      ENVOY_LOG(debug, "failed to read proxy protocol");
      return false;
    }
  }
  proxy_protocol_header_.emplace(WireHeader{len, 0, 0, 0});
  return true;
}
