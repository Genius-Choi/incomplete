syn_cache_add(struct sockaddr *src, struct sockaddr *dst, struct tcphdr *th,
    u_int iphlen, struct socket *so, struct mbuf *m, u_char *optp, int optlen,
    struct tcp_opt_info *oi, tcp_seq *issp)
{
	struct tcpcb tb, *tp;
	long win;
	struct syn_cache *sc;
	struct syn_cache_head *scp;
	struct mbuf *ipopts;

	tp = sototcpcb(so);

	/*
	 * RFC1122 4.2.3.10, p. 104: discard bcast/mcast SYN
	 *
	 * Note this check is performed in tcp_input() very early on.
	 */

	/*
	 * Initialize some local state.
	 */
	win = sbspace(so, &so->so_rcv);
	if (win > TCP_MAXWIN)
		win = TCP_MAXWIN;

	bzero(&tb, sizeof(tb));
#ifdef TCP_SIGNATURE
	if (optp || (tp->t_flags & TF_SIGNATURE)) {
#else
	if (optp) {
#endif
		tb.pf = tp->pf;
		tb.sack_enable = tp->sack_enable;
		tb.t_flags = tcp_do_rfc1323 ? (TF_REQ_SCALE|TF_REQ_TSTMP) : 0;
#ifdef TCP_SIGNATURE
		if (tp->t_flags & TF_SIGNATURE)
			tb.t_flags |= TF_SIGNATURE;
#endif
		tb.t_state = TCPS_LISTEN;
		if (tcp_dooptions(&tb, optp, optlen, th, m, iphlen, oi,
		    sotoinpcb(so)->inp_rtableid))
			return (-1);
	}

	switch (src->sa_family) {
	case AF_INET:
		/*
		 * Remember the IP options, if any.
		 */
		ipopts = ip_srcroute(m);
		break;
	default:
		ipopts = NULL;
	}

	/*
	 * See if we already have an entry for this connection.
	 * If we do, resend the SYN,ACK.  We do not count this
	 * as a retransmission (XXX though maybe we should).
	 */
	sc = syn_cache_lookup(src, dst, &scp, sotoinpcb(so)->inp_rtableid);
	if (sc != NULL) {
		tcpstat_inc(tcps_sc_dupesyn);
		if (ipopts) {
			/*
			 * If we were remembering a previous source route,
			 * forget it and use the new one we've been given.
			 */
			m_free(sc->sc_ipopts);
			sc->sc_ipopts = ipopts;
		}
		sc->sc_timestamp = tb.ts_recent;
		if (syn_cache_respond(sc, m) == 0) {
			tcpstat_inc(tcps_sndacks);
			tcpstat_inc(tcps_sndtotal);
		}
		return (0);
	}

	sc = pool_get(&syn_cache_pool, PR_NOWAIT|PR_ZERO);
	if (sc == NULL) {
		m_free(ipopts);
		return (-1);
	}

	/*
	 * Fill in the cache, and put the necessary IP and TCP
	 * options into the reply.
	 */
	memcpy(&sc->sc_src, src, src->sa_len);
	memcpy(&sc->sc_dst, dst, dst->sa_len);
	sc->sc_rtableid = sotoinpcb(so)->inp_rtableid;
	sc->sc_flags = 0;
	sc->sc_ipopts = ipopts;
	sc->sc_irs = th->th_seq;

	sc->sc_iss = issp ? *issp : arc4random();
	sc->sc_peermaxseg = oi->maxseg;
	sc->sc_ourmaxseg = tcp_mss_adv(m, sc->sc_src.sa.sa_family);
	sc->sc_win = win;
	sc->sc_timestamp = tb.ts_recent;
	if ((tb.t_flags & (TF_REQ_TSTMP|TF_RCVD_TSTMP)) ==
	    (TF_REQ_TSTMP|TF_RCVD_TSTMP)) {
		sc->sc_flags |= SCF_TIMESTAMP;
		sc->sc_modulate = arc4random();
	}
	if ((tb.t_flags & (TF_RCVD_SCALE|TF_REQ_SCALE)) ==
	    (TF_RCVD_SCALE|TF_REQ_SCALE)) {
		sc->sc_requested_s_scale = tb.requested_s_scale;
		sc->sc_request_r_scale = 0;
		/*
		 * Pick the smallest possible scaling factor that
		 * will still allow us to scale up to sb_max.
		 *
		 * We do this because there are broken firewalls that
		 * will corrupt the window scale option, leading to
		 * the other endpoint believing that our advertised
		 * window is unscaled.  At scale factors larger than
		 * 5 the unscaled window will drop below 1500 bytes,
		 * leading to serious problems when traversing these
		 * broken firewalls.
		 *
		 * With the default sbmax of 256K, a scale factor
		 * of 3 will be chosen by this algorithm.  Those who
		 * choose a larger sbmax should watch out
		 * for the compatiblity problems mentioned above.
		 *
		 * RFC1323: The Window field in a SYN (i.e., a <SYN>
		 * or <SYN,ACK>) segment itself is never scaled.
		 */
		while (sc->sc_request_r_scale < TCP_MAX_WINSHIFT &&
		    (TCP_MAXWIN << sc->sc_request_r_scale) < sb_max)
			sc->sc_request_r_scale++;
	} else {
		sc->sc_requested_s_scale = 15;
		sc->sc_request_r_scale = 15;
	}
#ifdef TCP_ECN
	/*
	 * if both ECE and CWR flag bits are set, peer is ECN capable.
	 */
	if (tcp_do_ecn &&
	    (th->th_flags & (TH_ECE|TH_CWR)) == (TH_ECE|TH_CWR))
		sc->sc_flags |= SCF_ECN_PERMIT;
#endif
	/*
	 * Set SCF_SACK_PERMIT if peer did send a SACK_PERMITTED option
	 * (i.e., if tcp_dooptions() did set TF_SACK_PERMIT).
	 */
	if (tb.sack_enable && (tb.t_flags & TF_SACK_PERMIT))
		sc->sc_flags |= SCF_SACK_PERMIT;
#ifdef TCP_SIGNATURE
	if (tb.t_flags & TF_SIGNATURE)
		sc->sc_flags |= SCF_SIGNATURE;
#endif
	sc->sc_tp = tp;
	if (syn_cache_respond(sc, m) == 0) {
		syn_cache_insert(sc, tp);
		tcpstat_inc(tcps_sndacks);
		tcpstat_inc(tcps_sndtotal);
	} else {
		syn_cache_put(sc);
		tcpstat_inc(tcps_sc_dropped);
	}

	return (0);
}
