static GF_Err dasher_initialize(GF_Filter *filter)
{
	GF_Err e;
	GF_DasherCtx *ctx = gf_filter_get_udta(filter);
	gf_filter_set_max_extra_input_pids(filter, -1);

	ctx->pids = gf_list_new();
	ctx->postponed_pids = gf_list_new();
	ctx->tpl_records = gf_list_new();
	if (!ctx->initext && (ctx->muxtype==DASHER_MUX_AUTO))
		ctx->muxtype = DASHER_MUX_ISOM;

	if ((ctx->segdur.num <= 0) || !ctx->segdur.den) {
		ctx->segdur.num = 1;
		ctx->segdur.den = 1;
		ctx->no_seg_dur = GF_TRUE;
	}
	if (ctx->dmode==GF_DASH_DYNAMIC_LAST+1) {
		ctx->dmode = GF_DASH_DYNAMIC;
		ctx->move_to_static = GF_TRUE;
	}

	e = dasher_setup_profile(ctx);
	if (e) return e;

	if (ctx->sfile && ctx->tpl)
		ctx->tpl = GF_FALSE;

	ctx->current_period = dasher_new_period();
	ctx->next_period = dasher_new_period();
	ctx->on_demand_done = GF_TRUE;

	if (ctx->state) {
		ctx->first_context_load = GF_TRUE;
	}
	if (ctx->subdur && !ctx->state) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[Dasher] subdur mode specified but no context set, will only dash %g seconds of media\n", ctx->subdur));
	}
	//we build manifest from input frag/seg, always use single frag
	if (ctx->sigfrag) {
		if (ctx->tpl) {
			ctx->sseg = GF_FALSE;
			ctx->sfile = GF_FALSE;
		} else {
			if (!ctx->sseg)
				ctx->sfile = GF_TRUE;
		}
		if (ctx->gencues) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[Dasher] `sigfrag` and `gencues` options cannot be used together, disabling gencies\n"));
			ctx->gencues = GF_FALSE;
		}
	}

	if (!ctx->sap || ctx->sigfrag || ctx->cues)
		ctx->sbound = DASHER_BOUNDS_OUT;

	if ((ctx->tsb>=0) && (ctx->dmode!=GF_DASH_STATIC))
		ctx->purge_segments = GF_TRUE;

	if (ctx->state && ctx->sreg) {
		u32 diff;
		u64 next_gen_ntp;
		GF_Err dash_state_check_timing(const char *dash_state, u64 *next_gen_ntp_ms, u32 *next_time_ms);

		e = dash_state_check_timing(ctx->state, &next_gen_ntp, &diff);
		if (e<0) return e;
		if (e==GF_EOS) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[Dasher] generation called too early by %d ms\n", (s32) diff));
			return e;
		}
	}


	dasher_init_utc(filter, ctx);

#ifdef GPAC_CONFIG_EMSCRIPTEN
	//we need to read the state file so we must run on main thread
	if (ctx->state)
		gf_filter_force_main_thread(filter, GF_TRUE);
#endif
	return GF_OK;
}
