void apc_load_impl_compressed
    (struct cache_info *info,
     int *int_lens, const char *int_keys, long long *int_values,
     int *char_lens, const char *char_keys, char *char_values,
     int *string_lens, const char *strings,
     int *object_lens, const char *objects,
     int *thrift_lens, const char *thrifts,
     int *other_lens, const char *others) {
  bool readOnly = apcExtension::EnableConstLoad && info && info->use_const;
  if (readOnly && info->a_name) Logger::FInfo("const archive {}", info->a_name);
  auto& s = apc_store();
  SnapshotBuilder* snap = apcExtension::PrimeLibraryUpgradeDest.empty() ?
    nullptr : &s_snapshotBuilder;
  {
    int count = int_lens[0];
    int len = int_lens[1];
    if (count) {
      std::vector<KeyValuePair> vars(count);
      char *keys = gzdecode(int_keys, len);
      if (keys == nullptr) throw Exception("bad compressed apc archive.");
      ScopedMem holder(keys);
      const char *k = keys;
      long long* v = int_values;
      for (int i = 0; i < count; i++) {
        auto& item = vars[i];
        item.key = k;
        item.readOnly = readOnly;
        s.constructPrime(*v++, item);
        if (UNLIKELY(snap != nullptr)) snap->addInt(v[-1], item);
        k += int_lens[i + 2] + 1; // skip \0
      }
      s.prime(std::move(vars));
      assertx((k - keys) == len);
    }
  }
  {
    int count = char_lens[0];
    int len = char_lens[1];
    if (count) {
      std::vector<KeyValuePair> vars(count);
      char *keys = gzdecode(char_keys, len);
      if (keys == nullptr) throw Exception("bad compressed apc archive.");
      ScopedMem holder(keys);
      const char *k = keys;
      char *v = char_values;
      for (int i = 0; i < count; i++) {
        auto& item = vars[i];
        item.key = k;
        item.readOnly = readOnly;
        switch (*v++) {
          case 0:
            s.constructPrime(false, item);
            if (UNLIKELY(snap != nullptr)) snap->addFalse(item);
            break;
          case 1:
            s.constructPrime(true, item);
            if (UNLIKELY(snap != nullptr)) snap->addTrue(item);
            break;
          case 2:
            s.constructPrime(uninit_null(), item);
            if (UNLIKELY(snap != nullptr)) snap->addNull(item);
            break;
        default:
          throw Exception("bad apc archive, unknown char type");
        }
        k += char_lens[i + 2] + 1; // skip \0
      }
      s.prime(std::move(vars));
      assertx((k - keys) == len);
    }
  }
  {
    int count = string_lens[0] / 2;
    int len = string_lens[1];
    if (count) {
      std::vector<KeyValuePair> vars(count);
      char *decoded = gzdecode(strings, len);
      if (decoded == nullptr) throw Exception("bad compressed apc archive.");
      ScopedMem holder(decoded);
      const char *p = decoded;
      for (int i = 0; i < count; i++) {
        auto& item = vars[i];
        item.key = p;
        item.readOnly = readOnly;
        p += string_lens[i + i + 2] + 1; // skip \0
        // Strings would be copied into APC anyway.
        String value(p, string_lens[i + i + 3], CopyString);
        // todo: t2539893: check if value is already a static string
        s.constructPrime(value, item, false);
        if (UNLIKELY(snap != nullptr)) snap->addString(value, item);
        p += string_lens[i + i + 3] + 1; // skip \0
      }
      s.prime(std::move(vars));
      assertx((p - decoded) == len);
    }
  }
  {
    int count = object_lens[0] / 2;
    int len = object_lens[1];
    if (count) {
      std::vector<KeyValuePair> vars(count);
      char *decoded = gzdecode(objects, len);
      if (decoded == nullptr) throw Exception("bad compressed APC archive.");
      ScopedMem holder(decoded);
      const char *p = decoded;
      for (int i = 0; i < count; i++) {
        auto& item = vars[i];
        item.key = p;
        item.readOnly = readOnly;
        p += object_lens[i + i + 2] + 1; // skip \0
        String value(p, object_lens[i + i + 3], CopyString);
        s.constructPrime(value, item, true);
        if (UNLIKELY(snap != nullptr)) snap->addObject(value, item);
        p += object_lens[i + i + 3] + 1; // skip \0
      }
      s.prime(std::move(vars));
      assertx((p - decoded) == len);
    }
  }
  {
    int count = thrift_lens[0] / 2;
    int len = thrift_lens[1];
    if (count) {
      std::vector<KeyValuePair> vars(count);
      char *decoded = gzdecode(thrifts, len);
      if (decoded == nullptr) throw Exception("bad compressed apc archive.");
      ScopedMem holder(decoded);
      const char *p = decoded;
      for (int i = 0; i < count; i++) {
        auto& item = vars[i];
        item.key = p;
        item.readOnly = readOnly;
        p += thrift_lens[i + i + 2] + 1; // skip \0
        String value(p, thrift_lens[i + i + 3], CopyString);
        bool success;
        Variant v = HHVM_FN(fb_unserialize)(value, success);
        if (success ==  false) {
          throw Exception("bad apc archive, fb_unserialize failed");
        }
        s.constructPrime(v, item);
        if (UNLIKELY(snap != nullptr)) snap->addThrift(value, item);
        p += thrift_lens[i + i + 3] + 1; // skip \0
      }
      s.prime(std::move(vars));
      assertx((p - decoded) == len);
    }
  }
  {
    int count = other_lens[0] / 2;
    int len = other_lens[1];
    if (count) {
      std::vector<KeyValuePair> vars(count);
      char *decoded = gzdecode(others, len);
      if (decoded == nullptr) throw Exception("bad compressed apc archive.");
      ScopedMem holder(decoded);
      const char *p = decoded;
      for (int i = 0; i < count; i++) {
        auto& item = vars[i];
        item.key = p;
        item.readOnly = readOnly;
        p += other_lens[i + i + 2] + 1; // skip \0
        String value(p, other_lens[i + i + 3], CopyString);
        Variant v =
          unserialize_from_string(value, VariableUnserializer::Type::Internal);
        if (same(v, false)) {
          // we can't possibly get here if it was a boolean "false" that's
          // supposed to be serialized as a char
          throw Exception("bad apc archive, unserialize_from_string failed");
        }
        s.constructPrime(v, item);
        if (UNLIKELY(snap != nullptr)) snap->addOther(value, item);
        p += other_lens[i + i + 3] + 1; // skip \0
      }
      s.prime(std::move(vars));
      assertx((p - decoded) == len);
    }
  }
}
