edit_buffers(
    mparm_T	*parmp,
    char_u	*cwd)			// current working dir
{
    int		arg_idx;		// index in argument list
    int		i;
    int		advance = TRUE;
    win_T	*win;
    char_u	*p_shm_save = NULL;

    /*
     * Don't execute Win/Buf Enter/Leave autocommands here
     */
    ++autocmd_no_enter;
    ++autocmd_no_leave;

    // When w_arg_idx is -1 remove the window (see create_windows()).
    if (curwin->w_arg_idx == -1)
    {
	win_close(curwin, TRUE);
	advance = FALSE;
    }

    arg_idx = 1;
    for (i = 1; i < parmp->window_count; ++i)
    {
	if (cwd != NULL)
	    mch_chdir((char *)cwd);
	// When w_arg_idx is -1 remove the window (see create_windows()).
	if (curwin->w_arg_idx == -1)
	{
	    ++arg_idx;
	    win_close(curwin, TRUE);
	    advance = FALSE;
	    continue;
	}

	if (advance)
	{
	    if (parmp->window_layout == WIN_TABS)
	    {
		if (curtab->tp_next == NULL)	// just checking
		    break;
		goto_tabpage(0);
		// Temporarily reset 'shm' option to not print fileinfo when
		// loading the other buffers. This would overwrite the already
		// existing fileinfo for the first tab.
		if (i == 1)
		{
		    char buf[100];

		    p_shm_save = vim_strsave(p_shm);
		    vim_snprintf(buf, 100, "F%s", p_shm);
		    set_option_value_give_err((char_u *)"shm",
							 0L, (char_u *)buf, 0);
		}
	    }
	    else
	    {
		if (curwin->w_next == NULL)	// just checking
		    break;
		win_enter(curwin->w_next, FALSE);
	    }
	}
	advance = TRUE;

	// Only open the file if there is no file in this window yet (that can
	// happen when .vimrc contains ":sall").
	if (curbuf == firstwin->w_buffer || curbuf->b_ffname == NULL)
	{
	    curwin->w_arg_idx = arg_idx;
	    // Edit file from arg list, if there is one.  When "Quit" selected
	    // at the ATTENTION prompt close the window.
	    swap_exists_did_quit = FALSE;
	    (void)do_ecmd(0, arg_idx < GARGCOUNT
			  ? alist_name(&GARGLIST[arg_idx]) : NULL,
			  NULL, NULL, ECMD_LASTL, ECMD_HIDE, curwin);
	    if (swap_exists_did_quit)
	    {
		// abort or quit selected
		if (got_int || only_one_window())
		{
		    // abort selected and only one window
		    did_emsg = FALSE;   // avoid hit-enter prompt
		    getout(1);
		}
		win_close(curwin, TRUE);
		advance = FALSE;
	    }
	    if (arg_idx == GARGCOUNT - 1)
		arg_had_last = TRUE;
	    ++arg_idx;
	}
	ui_breakcheck();
	if (got_int)
	{
	    (void)vgetc();	// only break the file loading, not the rest
	    break;
	}
    }

    if (p_shm_save != NULL)
    {
	set_option_value_give_err((char_u *)"shm", 0L, p_shm_save, 0);
	vim_free(p_shm_save);
    }

    if (parmp->window_layout == WIN_TABS)
	goto_tabpage(1);
    --autocmd_no_enter;

    // make the first window the current window
    win = firstwin;
#if defined(FEAT_QUICKFIX)
    // Avoid making a preview window the current window.
    while (win->w_p_pvw)
    {
	win = win->w_next;
	if (win == NULL)
	{
	    win = firstwin;
	    break;
	}
    }
#endif
    win_enter(win, FALSE);

    --autocmd_no_leave;
    TIME_MSG("editing files in windows");
    if (parmp->window_count > 1 && parmp->window_layout != WIN_TABS)
	win_equal(curwin, FALSE, 'b');	// adjust heights
}
