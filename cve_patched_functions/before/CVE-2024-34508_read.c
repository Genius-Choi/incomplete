OFCondition DcmElement::read(DcmInputStream &inStream,
                             const E_TransferSyntax ixfer,
                             const E_GrpLenEncoding /*glenc*/,
                             const Uint32 maxReadLength)
{
    /* if this element's transfer state shows ERW_notInitialized, this is an illegal call */
    if (getTransferState() == ERW_notInitialized)
        errorFlag = EC_IllegalCall;
    else
    {
        /* if this is not an illegal call, go ahead and create a DcmXfer */
        /* object based on the transfer syntax which was passed */
        DcmXfer inXfer(ixfer);

        /* determine the transfer syntax's byte ordering */
        if (getTag() == DCM_PixelData)
          fByteOrder = inXfer.getPixelDataByteOrder();
          else fByteOrder = inXfer.getByteOrder();

        /* check if the stream reported an error */
        errorFlag = inStream.status();
        /* if we encountered the end of the stream, set the error flag correspondingly */
        if (errorFlag.good() && inStream.eos())
        {
            errorFlag = EC_EndOfStream; // not handled as parsing error by caller
            /* Network can never report EOS at this point, so we are in a file
             * and no bytes are left for reading. This is only valid if
             * the announced length of the current value is 0 and we are in the
             * last element of the dataset (e.g. Pixel Data) otherwise it must be an error */
            if (getLengthField() > 0)
            {
                /* Return error code if we are are not ignoring parsing errors */
                if (!dcmIgnoreParsingErrors.get())
                    errorFlag = EC_StreamNotifyClient; // should we rather return EC_InvalidStream?
                /* In any case, make sure that calling the load value routine on this
                 * element will fail later. For that, create the stream factory that
                 * the load routine will use. Otherwise it would not realize
                 * that there is a problem */
                delete fLoadValue;
                fLoadValue = inStream.newFactory();
                /* Print an error message when too few bytes are available in the file in order to
                 * distinguish this problem from any other generic "InvalidStream" problem. */
                DCMDATA_ERROR("DcmElement: " << getTagName() << " " << getTag()
                    << " larger (" << getLengthField() << ") than remaining bytes in file");
            }
        }
        /* if we did not encounter the end of the stream and no error occurred so far, go ahead */
        else if (errorFlag.good())
        {
            /* if the transfer state is ERW_init, we need to prepare */
            /* the reading of this element's value from the stream */
            if (getTransferState() == ERW_init)
            {
                /* if the Length of this element's value is greater than the amount of bytes we */
                /* can read from the stream and if the stream has random access, we want to create */
                /* a DcmInputStreamFactory object that enables us to read this element's value later. */
                /* This new object will be stored (together with the position where we have to start */
                /* reading the value) in the member variable fLoadValue. */
                if (getLengthField() > maxReadLength)
                {
                    /* try to create a stream factory to read the value later */
                    delete fLoadValue;
                    fLoadValue = inStream.newFactory();

                    if (fLoadValue)
                    {
                        offile_off_t skipped = inStream.skip(getLengthField());
                        if (skipped < OFstatic_cast(offile_off_t, getLengthField()))
                        {
                            /* If desired, specific parser errors will be ignored */
                            if (dcmIgnoreParsingErrors.get())
                                errorFlag = EC_Normal;
                            else
                                errorFlag = EC_StreamNotifyClient;
                            /* Print an error message when too few bytes are available in the file in order to
                             * distinguish this problem from any other generic "InvalidStream" problem. */
                            DCMDATA_ERROR("DcmElement: " << getTagName() << " " << getTag()
                                << " larger (" << getLengthField() << ") than remaining bytes in file");
                        }
                    }
                }
                /* if there is already a value for this element, delete this value */
#if defined(HAVE_STD__NOTHROW) && defined(HAVE_NOTHROW_DELETE)
                // if created with the nothrow version it must also be deleted with
                // the nothrow version else memory error.
                operator delete[] (fValue, std::nothrow);
#else
                delete[] fValue;
#endif
                /* set the transfer state to ERW_inWork */
                setTransferState(ERW_inWork);
            }
            /* if the transfer state is ERW_inWork and we are not supposed */
            /* to read this element's value later, read the value now */
            if (getTransferState() == ERW_inWork && !fLoadValue)
                errorFlag = loadValue(&inStream);
            /* if the amount of transferred bytes equals the Length of this element */
            /* or the object which contains information to read the value of this */
            /* element later is existent, set the transfer state to ERW_ready */
            if (getTransferredBytes() == getLengthField() || fLoadValue)
                setTransferState(ERW_ready);
        }
    }

    /* return result value */
    return errorFlag;
}
