static connection_t *connection_add(
        ogs_sbi_client_t *client, ogs_sbi_client_cb_f client_cb,
        ogs_sbi_request_t *request, void *data)
{
    ogs_hash_index_t *hi;
    int i;
    connection_t *conn = NULL;
    CURLMcode rc;

    ogs_assert(client);
    ogs_assert(client_cb);
    ogs_assert(request);
    ogs_assert(request->h.method);

    ogs_pool_alloc(&connection_pool, &conn);
    ogs_expect_or_return_val(conn, NULL);
    memset(conn, 0, sizeof(connection_t));

    conn->client = client;
    conn->client_cb = client_cb;
    conn->data = data;

    conn->method = ogs_strdup(request->h.method);
    if (!conn->method) {
        ogs_error("conn->method is NULL");
        _connection_remove(conn);
        return NULL;
    }

    conn->num_of_header = ogs_hash_count(request->http.headers);
    if (conn->num_of_header) {
        conn->headers = ogs_calloc(conn->num_of_header, sizeof(char *));
        if (!conn->headers) {
            ogs_error("conn->headers is NULL");
            _connection_remove(conn);
            return NULL;
        }
        for (hi = ogs_hash_first(request->http.headers), i = 0;
                hi && i < conn->num_of_header; hi = ogs_hash_next(hi), i++) {
            const char *key = ogs_hash_this_key(hi);
            char *val = ogs_hash_this_val(hi);

            conn->headers[i] = ogs_msprintf("%s: %s", key, val);
            if (!conn->headers[i]) {
                ogs_error("conn->headers[i=%d] is NULL", i);
                _connection_remove(conn);
                return NULL;
            }
            conn->header_list = curl_slist_append(
                    conn->header_list, conn->headers[i]);
        }
    }

    conn->timer = ogs_timer_add(
            ogs_app()->timer_mgr, connection_timer_expired, conn);
    if (!conn->timer) {
        ogs_error("conn->timer is NULL");
        _connection_remove(conn);
        return NULL;
    }

    /* If http response is not received within deadline,
     * Open5GS will discard this request. */
    ogs_timer_start(conn->timer,
            ogs_app()->time.message.sbi.connection_deadline);

    conn->easy = curl_easy_init();
    if (!conn->easy) {
        ogs_error("conn->easy is NULL");
        _connection_remove(conn);
        return NULL;
    }

    if (ogs_hash_count(request->http.params)) {
        char *uri = add_params_to_uri(conn->easy,
                            request->h.uri, request->http.params);
        if (!uri) {
            ogs_error("add_params_to_uri() failed");
            _connection_remove(conn);
            return NULL;
        }

        request->h.uri = uri;
    }

    /* HTTP Method */
    if (strcmp(request->h.method, OGS_SBI_HTTP_METHOD_PUT) == 0 ||
        strcmp(request->h.method, OGS_SBI_HTTP_METHOD_PATCH) == 0 ||
        strcmp(request->h.method, OGS_SBI_HTTP_METHOD_DELETE) == 0 ||
        strcmp(request->h.method, OGS_SBI_HTTP_METHOD_POST) == 0) {

        curl_easy_setopt(conn->easy,
                CURLOPT_CUSTOMREQUEST, request->h.method);
        if (request->http.content) {
            conn->content = ogs_memdup(
                    request->http.content, request->http.content_length);
            if (!conn->content) {
                ogs_error("conn->content is NULL");
                _connection_remove(conn);
                return NULL;
            }
            curl_easy_setopt(conn->easy,
                    CURLOPT_POSTFIELDS, conn->content);
            curl_easy_setopt(conn->easy,
                CURLOPT_POSTFIELDSIZE, request->http.content_length);
#if 1 /* Disable HTTP/1.1 100 Continue : Use "Expect:" in libcurl */
            conn->header_list = curl_slist_append(
                    conn->header_list, "Expect:");
#else
            curl_easy_setopt(conn->easy, CURLOPT_EXPECT_100_TIMEOUT_MS, 0L);
#endif
            ogs_debug("SENDING...[%d]", (int)request->http.content_length);
            if (request->http.content_length)
                ogs_debug("%s", request->http.content);
        }
    }

    curl_easy_setopt(conn->easy, CURLOPT_HTTPHEADER, conn->header_list);

#if 1 /* Use HTTP2 */
    curl_easy_setopt(conn->easy,
            CURLOPT_HTTP_VERSION, CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE);
#endif

    ogs_list_add(&client->connection_list, conn);

    curl_easy_setopt(conn->easy, CURLOPT_URL, request->h.uri);

    curl_easy_setopt(conn->easy, CURLOPT_PRIVATE, conn);
    curl_easy_setopt(conn->easy, CURLOPT_WRITEFUNCTION, write_cb);
    curl_easy_setopt(conn->easy, CURLOPT_WRITEDATA, conn);
    curl_easy_setopt(conn->easy, CURLOPT_HEADERFUNCTION, header_cb);
    curl_easy_setopt(conn->easy, CURLOPT_HEADERDATA, conn);
    curl_easy_setopt(conn->easy, CURLOPT_ERRORBUFFER, conn->error);

    ogs_assert(client->multi);
    rc = curl_multi_add_handle(client->multi, conn->easy);
    mcode_or_die("connection_add: curl_multi_add_handle", rc);

    return conn;
}
