int ksmbd_sign_smb1_pdu(struct ksmbd_session *sess, struct kvec *iov, int n_vec,
			char *sig)
{
	struct ksmbd_crypto_ctx *ctx;
	int rc, i;

	ctx = ksmbd_crypto_ctx_find_md5();
	if (!ctx) {
		ksmbd_debug(AUTH, "could not crypto alloc md5\n");
		return -ENOMEM;
	}

	rc = crypto_shash_init(CRYPTO_MD5(ctx));
	if (rc) {
		ksmbd_debug(AUTH, "md5 init error %d\n", rc);
		goto out;
	}

	rc = crypto_shash_update(CRYPTO_MD5(ctx), sess->sess_key, 40);
	if (rc) {
		ksmbd_debug(AUTH, "md5 update error %d\n", rc);
		goto out;
	}

	for (i = 0; i < n_vec; i++) {
		rc = crypto_shash_update(CRYPTO_MD5(ctx),
					 iov[i].iov_base,
					 iov[i].iov_len);
		if (rc) {
			ksmbd_debug(AUTH, "md5 update error %d\n", rc);
			goto out;
		}
	}

	rc = crypto_shash_final(CRYPTO_MD5(ctx), sig);
	if (rc)
		ksmbd_debug(AUTH, "md5 generation error %d\n", rc);

out:
	ksmbd_release_crypto_ctx(ctx);
	return rc;
}
