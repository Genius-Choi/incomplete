static st32 parse_type(Context *ctx, const ut64 offset, RStrBuf *strbuf, ut64 *size, HtUP **visited) {
	r_return_val_if_fail (strbuf, -1);
	RBinDwarfDie *die = ht_up_find (ctx->die_map, offset, NULL);
	if (!die) {
		return -1;
	}
	bool root = false;

	if (!visited) {
		root = true;
		SetU *su = set_u_new ();
		visited = malloc (sizeof (void*));
		*visited = su;
	}
	if (visited && set_u_contains (*visited, offset)) {
		eprintf ("Warning: anal.dwarf.parse_type: infinite recursion detected.\n");
		return -1;
	}
	set_u_add (*visited, offset);

	st32 type_idx;
	st32 tag;
	char *name = NULL;
	// get size of first type DIE that has size
	if (size && *size == 0) {
		*size = get_die_size (die);
	}
	switch (die->tag) {
	// this should be recursive search for the type until you find base/user defined type
	case DW_TAG_pointer_type:
		type_idx = find_attr_idx (die, DW_AT_type);
		if (type_idx == -1) {
			r_strbuf_append (strbuf, "void");
			r_strbuf_append (strbuf, " *");
		} else {
			tag = parse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);
			if (tag == DW_TAG_subroutine_type) {
				strbuf_rev_prepend_char (strbuf, "(*)", '(');
			} else if (tag == DW_TAG_pointer_type) {
				if (!strbuf_rev_append_char (strbuf, "*", "(*")) {
					strbuf_rev_prepend_char (strbuf, "*", '*');
				}
			} else {
				r_strbuf_append (strbuf, " *");
			}
		}
		break;
	// We won't parse them as a complete type, because that will already be done
	// so just a name now
	case DW_TAG_typedef:
	case DW_TAG_base_type:
	case DW_TAG_structure_type:
	case DW_TAG_enumeration_type:
	case DW_TAG_union_type:
	case DW_TAG_class_type:
		name = get_die_name (die);
		if (name) {
			r_strbuf_append (strbuf, name);
			free (name);
		}
		break;
	case DW_TAG_subroutine_type:
		type_idx = find_attr_idx (die, DW_AT_type);
		if (type_idx == -1) {
			r_strbuf_append (strbuf, "void");
		} else {
			parse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);
		}
		r_strbuf_append (strbuf, " (");
		if (die->has_children) { // has parameters
		}
		r_strbuf_append (strbuf, ")");
		break;
	case DW_TAG_array_type:
		type_idx = find_attr_idx (die, DW_AT_type);
		if (type_idx != -1) {
			parse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);
		}
		parse_array_type (ctx, die - ctx->all_dies, strbuf);
		break;
	case DW_TAG_const_type:
		type_idx = find_attr_idx (die, DW_AT_type);
		if (type_idx != -1) {
			parse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);
		}
		r_strbuf_append (strbuf, " const");
		break;
	case DW_TAG_volatile_type:
		type_idx = find_attr_idx (die, DW_AT_type);
		if (type_idx != -1) {
			parse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);
		}
		r_strbuf_append (strbuf, " volatile");
		break;
	case DW_TAG_restrict_type:
		type_idx = find_attr_idx (die, DW_AT_type);
		if (type_idx != -1) {
			parse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);
		}
		r_strbuf_append (strbuf, " restrict");
		break;
	case DW_TAG_rvalue_reference_type:
		type_idx = find_attr_idx (die, DW_AT_type);
		if (type_idx != -1) {
			parse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);
		}
		r_strbuf_append (strbuf, " &&");
		break;
	case DW_TAG_reference_type:
		type_idx = find_attr_idx (die, DW_AT_type);
		if (type_idx != -1) {
			parse_type (ctx, die->attr_values[type_idx].reference, strbuf, size, visited);
		}
		r_strbuf_append (strbuf, " &");
		break;
	default:
		break;
	}
	if (root) {
		set_u_free (*visited);
	}
	return (st32)die->tag;
}
