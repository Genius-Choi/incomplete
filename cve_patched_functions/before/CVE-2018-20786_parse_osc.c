parse_osc(const char *command, size_t cmdlen, void *user)
{
    term_T	*term = (term_T *)user;
    js_read_T	reader;
    typval_T	tv;
    channel_T	*channel = term->tl_job == NULL ? NULL
						    : term->tl_job->jv_channel;

    /* We recognize only OSC 5 1 ; {command} */
    if (cmdlen < 3 || STRNCMP(command, "51;", 3) != 0)
	return 0; /* not handled */

    reader.js_buf = vim_strnsave((char_u *)command + 3, (int)(cmdlen - 3));
    if (reader.js_buf == NULL)
	return 1;
    reader.js_fill = NULL;
    reader.js_used = 0;
    if (json_decode(&reader, &tv, 0) == OK
	    && tv.v_type == VAR_LIST
	    && tv.vval.v_list != NULL)
    {
	listitem_T *item = tv.vval.v_list->lv_first;

	if (item == NULL)
	    ch_log(channel, "Missing command");
	else
	{
	    char_u	*cmd = tv_get_string(&item->li_tv);

	    /* Make sure an invoked command doesn't delete the buffer (and the
	     * terminal) under our fingers. */
	    ++term->tl_buffer->b_locked;

	    item = item->li_next;
	    if (item == NULL)
		ch_log(channel, "Missing argument for %s", cmd);
	    else if (STRCMP(cmd, "drop") == 0)
		handle_drop_command(item);
	    else if (STRCMP(cmd, "call") == 0)
		handle_call_command(term, channel, item);
	    else
		ch_log(channel, "Invalid command received: %s", cmd);
	    --term->tl_buffer->b_locked;
	}
    }
    else
	ch_log(channel, "Invalid JSON received");

    vim_free(reader.js_buf);
    clear_tv(&tv);
    return 1;
}
