void rcar_read_certificate(uint64_t cert, uint32_t *len, uintptr_t *dst)
{
	uint32_t seed, val, info_1, info_2;
	uintptr_t size, dsth, dstl;

	cert &= 0xFFFFFFFFU;

	seed = mmio_read_32(RCAR_BOOT_KEY_CERT_NEW);
	val = mmio_read_32(RCAR_BOOT_KEY_CERT_NEW + 0xC);
	info_1 = (val >> 18) & 0x3U;
	val = mmio_read_32(cert + 0xC);
	info_2 = (val >> 21) & 0x3;

	if (seed == RCAR_CERT_MAGIC_NUM) {
		if (info_1 != 1) {
			ERROR("BL2: Cert is invalid.\n");
			*dst = 0;
			*len = 0;
			return;
		}

		if (info_2 > 2) {
			ERROR("BL2: Cert is invalid.\n");
			*dst = 0;
			*len = 0;
			return;
		}

		switch (info_2) {
		case 2:
			size = cert + RCAR_CERT_INFO_SIZE_OFFSET2;
			dstl = cert + RCAR_CERT_INFO_DST_OFFSET2;
			break;
		case 1:
			size = cert + RCAR_CERT_INFO_SIZE_OFFSET1;
			dstl = cert + RCAR_CERT_INFO_DST_OFFSET1;
			break;
		case 0:
			size = cert + RCAR_CERT_INFO_SIZE_OFFSET;
			dstl = cert + RCAR_CERT_INFO_DST_OFFSET;
			break;
		}
		*len = mmio_read_32(size);
		if (*len > (UINT32_MAX / 4)) {
			ERROR("BL2: uint32 overflow!\n");
			*dst = 0;
			*len = 0;
			return;
		}

		*len = *len * 4U;
		dsth = dstl + 4U;
		*dst = ((uintptr_t) mmio_read_32(dsth) << 32) +
		    ((uintptr_t) mmio_read_32(dstl));
		return;
	}

	size = cert + RCAR_CERT_INFO_SIZE_OFFSET;
	*len = mmio_read_32(size) * 4U;
	dstl = cert + RCAR_CERT_INFO_DST_OFFSET;
	dsth = dstl + 4U;
	*dst = ((uintptr_t) mmio_read_32(dsth) << 32) +
	    ((uintptr_t) mmio_read_32(dstl));
}
