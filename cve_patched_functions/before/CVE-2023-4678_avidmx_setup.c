static void avidmx_setup(GF_Filter *filter, GF_AVIDmxCtx *ctx)
{
	u32 sync_id = 0;
	u32 codecid = 0;
	Bool unframed;
	u32 i, count, pfmt=0;
	GF_Fraction64 dur;
	char *comp;

	if (ctx->use_file_fps) {
		Double fps = AVI_frame_rate(ctx->avi);
		gf_media_get_video_timing(fps, &ctx->fps.num, &ctx->fps.den);
	}

	dur.den = ctx->fps.num;
	dur.num = (u64) (ctx->fps.den * AVI_video_frames(ctx->avi));

	unframed = GF_TRUE;
	comp = AVI_video_compressor(ctx->avi);
	if (!comp) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[AVIDmx] Cannot retrieve video compressor name, ignoring video stream\n"));
	}
	/*these are/should be OK*/
	else if (!stricmp(comp, "DIVX") || !stricmp(comp, "DX50")	/*DivX*/
		|| !stricmp(comp, "XVID") /*XviD*/
		|| !stricmp(comp, "3iv2") /*3ivX*/
		|| !stricmp(comp, "fvfw") /*ffmpeg*/
		|| !stricmp(comp, "NDIG") /*nero*/
		|| !stricmp(comp, "MP4V") /*!! not tested*/
		|| !stricmp(comp, "M4CC") /*Divio - not tested*/
		|| !stricmp(comp, "PVMM") /*PacketVideo - not tested*/
		|| !stricmp(comp, "SEDG") /*Samsung - not tested*/
		|| !stricmp(comp, "RMP4") /*Sigma - not tested*/
		|| !stricmp(comp, "MP43") /*not tested*/
		|| !stricmp(comp, "FMP4") /*not tested*/
		|| !stricmp(comp, "VP6F") /*not tested*/
	) {
		codecid = GF_CODECID_MPEG4_PART2;
	} else if ( !stricmp(comp, "H264") /*not tested*/
		|| !stricmp(comp, "X264") /*not tested*/
	) {
		codecid = GF_CODECID_AVC;
	} else if ( !stricmp(comp, "avc1") ) {
		codecid = GF_CODECID_AVC;
		unframed = GF_FALSE;
	} else if (!stricmp(comp, "DIV3") || !stricmp(comp, "DIV4")) {
//		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[AVIDmx] Video format %s not compliant with MPEG-4 Visual - please recompress the file first\n", comp));
		codecid = GF_CODECID_MSPEG4_V3;
		unframed = GF_FALSE;
	} else if (!comp[0]) {
		codecid = GF_CODECID_RAW;
		pfmt = GF_PIXEL_BGR;
	} else {
		GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[AVIDmx] Video format %s not natively supported, signaling as is\n", comp));
		codecid = gf_4cc_parse(comp);
		unframed = GF_FALSE;
	}

	ctx->v_in_use = GF_FALSE;
	if (codecid) {
		u32 w, h;
		if (!ctx->v_opid) {
			ctx->v_opid = gf_filter_pid_new(filter);
		}
		ctx->nb_frames = (u32) AVI_video_frames(ctx->avi);
		ctx->cur_frame = 0;
		sync_id = 1;
		ctx->v_in_use = GF_TRUE;

		gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_VISUAL) );
		gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_CODECID, &PROP_UINT(codecid) );
		gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->fps.num) );

		gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_ID, &PROP_UINT( sync_id) );
		gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT( sync_id ) );
		gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_FPS, &PROP_FRAC( ctx->fps ) );
		w = AVI_video_width(ctx->avi);
		h = AVI_video_height(ctx->avi);
		gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_WIDTH, &PROP_UINT( w ) );
		gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_HEIGHT, &PROP_UINT( h ) );
		gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_DURATION, &PROP_FRAC64( dur ) );

		gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );

		if (pfmt) {
			u32 stride=0;
			gf_pixel_get_size_info(pfmt, w, h, NULL, &stride, NULL, NULL, NULL);
			gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_STRIDE, &PROP_UINT( stride ) );
			gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_PIXFMT, &PROP_UINT( pfmt ) );
		} else if (unframed) {
			gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_UNFRAMED, &PROP_BOOL(GF_TRUE) );
			gf_filter_pid_set_property_str(ctx->v_opid, "nocts", &PROP_BOOL( GF_TRUE ) );
		} else if (ctx->avi->extradata_size && ctx->avi->extradata) {
			gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA(ctx->avi->extradata, ctx->avi->extradata_size) );
		}
		if (ctx->noreframe)
			gf_filter_pid_set_property(ctx->v_opid, GF_PROP_PID_UNFRAMED, NULL);
	}

	unframed = GF_FALSE;
	count = AVI_audio_tracks(ctx->avi);
	for (i=0; i<count; i++) {
		u32 a_fmt, afmt=0, nb_bits;
		AVI_set_audio_track(ctx->avi, i);

		codecid = 0;
		a_fmt = AVI_audio_format(ctx->avi);
		nb_bits = AVI_audio_bits(ctx->avi);
		switch (a_fmt) {
		case WAVE_FORMAT_PCM:
		case GF_4CC('P','C','M',' '):
			codecid = GF_CODECID_RAW;
			switch (nb_bits) {
			case 8:
				afmt = GF_AUDIO_FMT_U8;
				break;
			case 16:
				afmt = GF_AUDIO_FMT_S16;
				break;
			case 24:
				afmt = GF_AUDIO_FMT_S24;
				break;
			case 32:
				afmt = GF_AUDIO_FMT_S32;
				break;
			default:
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[AVIDmx] Audio bit depth %d not mapped, patch welcome\n", nb_bits));
				afmt = GF_AUDIO_FMT_S16;
				break;
			}
			break;
		case WAVE_FORMAT_ADPCM:
			codecid = GF_CODECID_ADPCM;
			break;
		case WAVE_FORMAT_IBM_CVSD:
			codecid = GF_CODECID_IBM_CVSD;
			break;
		case WAVE_FORMAT_ALAW:
			codecid = GF_CODECID_ALAW;
			break;
		case WAVE_FORMAT_MULAW:
			codecid = GF_CODECID_MULAW;
			break;
		case WAVE_FORMAT_OKI_ADPCM:
			codecid = GF_CODECID_OKI_ADPCM;
			break;
		case WAVE_FORMAT_DVI_ADPCM:
			codecid = GF_CODECID_DVI_ADPCM;
			break;
		case WAVE_FORMAT_DIGISTD:
			codecid = GF_CODECID_DIGISTD;
			break;
		case WAVE_FORMAT_YAMAHA_ADPCM:
			codecid = GF_CODECID_YAMAHA_ADPCM;
			break;
		case WAVE_FORMAT_DSP_TRUESPEECH:
			codecid = GF_CODECID_DSP_TRUESPEECH;
			break;
		case WAVE_FORMAT_GSM610:
			codecid = GF_CODECID_GSM610;
			break;
		case IBM_FORMAT_MULAW:
			codecid = GF_CODECID_IBM_MULAW;
			break;
		case IBM_FORMAT_ALAW:
			codecid = GF_CODECID_IBM_ALAW;
			break;
		case IBM_FORMAT_ADPCM:
			codecid = GF_CODECID_IBM_ADPCM;
			break;
		case WAVE_FORMAT_MP3:
			codecid = GF_CODECID_MPEG_AUDIO;
			unframed = GF_TRUE;
			break;
		case WAVE_FORMAT_AAC_ADTS:
			codecid = GF_CODECID_AAC_MPEG4;
			unframed = GF_TRUE;
			break;
		case WAVE_FORMAT_AAC:
			codecid = GF_CODECID_AAC_MPEG4;
			break;
		case WAVE_FORMAT_AC3:
			codecid = GF_CODECID_AC3;
			break;
		default:
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[AVIDmx] Audio format %d not supported, patch welcome\n", a_fmt));
			break;
		}

		if (codecid) {
			AVIAstream *st = NULL;
			u32 brate, j, c  = gf_list_count(ctx->audios);
			for (j=0; j<c; j++) {
				st = gf_list_get(ctx->audios, j);
				if (!st->in_use) break;
				st = NULL;
			}
			if (!st) {
				GF_SAFEALLOC(st, AVIAstream);
				if (!st) continue;
				st->opid = gf_filter_pid_new(filter);
				gf_list_add(ctx->audios, st);
			}
			st->in_use = GF_TRUE;
			st->stream_num = i;
			if (!sync_id) sync_id = 2 + st->stream_num;
			st->audio_done = GF_FALSE;

			if (codecid==GF_CODECID_MPEG_AUDIO) {
				u32 cid=0;
				char data[8];
				AVI_set_audio_track(ctx->avi, i);
				AVI_read_audio(ctx->avi, data, 8, (int*)&cid);
#ifndef GPAC_DISABLE_AV_PARSERS
				u32 hdr = GF_4CC(data[0], data[1], data[2], data[3]);
				cid = gf_mp3_object_type_indication(hdr);
#endif
				AVI_set_audio_position(ctx->avi, 0);
				if (cid) codecid = cid;
			}

			gf_filter_pid_set_property(st->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_AUDIO) );
			gf_filter_pid_set_property(st->opid, GF_PROP_PID_CODECID, &PROP_UINT( codecid) );
			st->freq = AVI_audio_rate(ctx->avi);
			gf_filter_pid_set_property(st->opid, GF_PROP_PID_SAMPLE_RATE, &PROP_UINT( st->freq ) );
			st->nb_channels = AVI_audio_channels(ctx->avi);
			gf_filter_pid_set_property(st->opid, GF_PROP_PID_NUM_CHANNELS, &PROP_UINT( st->nb_channels ) );
			brate = AVI_audio_mp3rate(ctx->avi);
			//for mp3 and aac
			if (brate && (unframed || (codecid == GF_CODECID_AAC_MPEG4)))
				gf_filter_pid_set_property(st->opid, GF_PROP_PID_BITRATE, &PROP_UINT( brate ) );
			gf_filter_pid_set_property(st->opid, GF_PROP_PID_ID, &PROP_UINT( 2 + st->stream_num) );
			gf_filter_pid_set_property(st->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT( sync_id ) );
			gf_filter_pid_set_property(st->opid, GF_PROP_PID_DURATION, &PROP_FRAC64( dur ) );

			gf_filter_pid_set_property(st->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );
			st->audio_bps = 0;
			if (unframed) {
				gf_filter_pid_set_property(st->opid, GF_PROP_PID_UNFRAMED, &PROP_BOOL( GF_TRUE ) );
				gf_filter_pid_set_property(st->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(st->freq) );
			} else {
				if (afmt) {
					gf_filter_pid_set_property(st->opid, GF_PROP_PID_AUDIO_FORMAT, &PROP_UINT(afmt) );
				}
				st->audio_bps = AVI_audio_bits(ctx->avi);
				gf_filter_pid_set_property(st->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(st->freq) );

				if (codecid == GF_CODECID_AAC_MPEG4) {
#ifndef GPAC_DISABLE_AV_PARSERS
					GF_M4ADecSpecInfo acfg;
					u8 *dsi=NULL;
					u32 dsi_len=0;
					memset(&acfg, 0, sizeof(GF_M4ADecSpecInfo));
					acfg.base_object_type = GF_M4A_AAC_LC;
					acfg.base_sr = st->freq;
					acfg.nb_chan = st->nb_channels;
					acfg.sbr_object_type = 0;
					acfg.audioPL = gf_m4a_get_profile(&acfg);
					gf_m4a_write_config(&acfg, &dsi, &dsi_len);
					gf_filter_pid_set_property(st->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_len) );
#endif
					st->audio_bps = 0;
					st->is_aac = GF_TRUE;
				}
			}

			if (ctx->noreframe)
				gf_filter_pid_set_property(st->opid, GF_PROP_PID_UNFRAMED, NULL);
		}
	}
}
