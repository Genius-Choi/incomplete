SWITCH_DECLARE(int) switch_rtp_write_frame(switch_rtp_t *rtp_session, switch_frame_t *frame)
{
	uint8_t fwd = 0;
	void *data = NULL;
	uint32_t len, ts = 0;
	switch_payload_t payload = 0;
	rtp_msg_t *send_msg = NULL;
	srtp_hdr_t local_header;
	int r = 0;
	switch_status_t status;

	if (!switch_rtp_ready(rtp_session) || !rtp_session->remote_addr) {
		return -1;
	}

	if (!rtp_write_ready(rtp_session, frame->datalen, __LINE__)) {
		return 0;
	}

	//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
	//	rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_READ]++;
	//	rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]++;
	//}


	if (switch_test_flag(frame, SFF_PROXY_PACKET) || switch_test_flag(frame, SFF_UDPTL_PACKET) ||
		rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {

		//if (rtp_session->flags[SWITCH_RTP_FLAG_PROXY_MEDIA] || rtp_session->flags[SWITCH_RTP_FLAG_UDPTL]) {
		switch_size_t bytes;
		//char bufa[50];

		/* Fast PASS! */
		if (!switch_test_flag(frame, SFF_PROXY_PACKET) && !switch_test_flag(frame, SFF_UDPTL_PACKET)) {
			return 0;
		}
		bytes = frame->packetlen;
		//tx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->remote_addr);

		send_msg = frame->packet;

		if (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] && !switch_test_flag(frame, SFF_UDPTL_PACKET)) {

			if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->payload > 0) {
				send_msg->header.pt = rtp_session->payload;
			}

			send_msg->header.ssrc = htonl(rtp_session->ssrc);
			send_msg->header.seq = htons(++rtp_session->seq);
		}

		if (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {
			const char *tx_host;
			const char *old_host;
			const char *my_host;

			char bufa[50], bufb[50], bufc[50];


			tx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtp_from_addr);
			old_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);
			my_host = switch_get_addr(bufc, sizeof(bufc), rtp_session->local_addr);

			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_CONSOLE,
							  "W %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u seq=%u m=%d\n",
							  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : "NoName",
							  (long) bytes,
							  my_host, switch_sockaddr_get_port(rtp_session->local_addr),
							  old_host, rtp_session->remote_port,
							  tx_host, switch_sockaddr_get_port(rtp_session->rtp_from_addr),
							  send_msg->header.pt, ntohl(send_msg->header.ts), ntohs(send_msg->header.seq), send_msg->header.m);

		}

		if ((status = switch_socket_sendto(rtp_session->sock_output, rtp_session->remote_addr, 0, frame->packet, &bytes)) != SWITCH_STATUS_SUCCESS) {
			if (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_ERROR, "bytes: %" SWITCH_SIZE_T_FMT ", status: %d", bytes, status);
			}

			return -1 * status;
		}


		rtp_session->stats.outbound.raw_bytes += bytes;
		rtp_session->stats.outbound.media_bytes += bytes;
		rtp_session->stats.outbound.media_packet_count++;
		rtp_session->stats.outbound.packet_count++;
		return (int) bytes;
	}

	fwd = (rtp_session->flags[SWITCH_RTP_FLAG_RAW_WRITE] &&
		   (switch_test_flag(frame, SFF_RAW_RTP) || switch_test_flag(frame, SFF_RAW_RTP_PARSE_FRAME))) ? 1 : 0;

	if (!fwd && !rtp_session->sending_dtmf && !rtp_session->queue_delay && !rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] &&
		rtp_session->flags[SWITCH_RTP_FLAG_RAW_WRITE] && (rtp_session->rtp_bugs & RTP_BUG_GEN_ONE_GEN_ALL)) {

		switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_WARNING, "Generating RTP locally but timestamp passthru is configured, disabling....\n");
		rtp_session->flags[SWITCH_RTP_FLAG_RAW_WRITE] = 0;
		rtp_session->flags[SWITCH_RTP_FLAG_RESET] = 1;
	}

	switch_assert(frame != NULL);

	if (switch_test_flag(frame, SFF_CNG)) {
		if (rtp_session->cng_pt != INVALID_PT) {
			payload = rtp_session->cng_pt;
		} else {
			return (int) frame->packetlen;
		}
	} else {
		payload = rtp_session->payload;
#if 0
		if (rtp_session->pmaps && *rtp_session->pmaps) {
			payload_map_t *pmap;
			for (pmap = *rtp_session->pmaps; pmap; pmap = pmap->next) {
				if (pmap->current) {
					payload = pmap->pt;
				}
			}
		}
#endif
	}


	if (switch_test_flag(frame, SFF_RTP_HEADER) || rtp_session->flags[SWITCH_RTP_FLAG_TEXT]) {
		switch_size_t wrote;

		wrote = switch_rtp_write_manual(rtp_session, frame->data, frame->datalen,
										frame->m, frame->payload, (uint32_t) (frame->timestamp), &frame->flags);

		rtp_session->stats.outbound.raw_bytes += wrote;
		rtp_session->stats.outbound.media_bytes += wrote;
		rtp_session->stats.outbound.media_packet_count++;
		rtp_session->stats.outbound.packet_count++;

		return wrote;
	}

	if (frame->pmap && rtp_session->pmaps && *rtp_session->pmaps) {
		payload_map_t *pmap;

		switch_mutex_lock(rtp_session->flag_mutex);
		for (pmap = *rtp_session->pmaps; pmap; pmap = pmap->next) {
			if (pmap->negotiated && pmap->hash == frame->pmap->hash) {
				payload = pmap->recv_pt;
				break;
			}
		}
		switch_mutex_unlock(rtp_session->flag_mutex);
	}

	if (fwd) {
		send_msg = frame->packet;
		local_header = send_msg->header;
		len = frame->packetlen;
		ts = 0;

		send_msg->header.pt = payload;

		if (switch_test_flag(frame, SFF_RAW_RTP_PARSE_FRAME)) {
			send_msg->header.version = 2;
			send_msg->header.m = frame->m;

			send_msg->header.ts = htonl(frame->timestamp);
			if (frame->ssrc) {
				send_msg->header.ssrc = htonl(frame->ssrc);
			} else {
				send_msg->header.ssrc = htonl(rtp_session->ssrc);
			}
		}

	} else {
		data = frame->data;
		len = frame->datalen;
		ts = rtp_session->flags[SWITCH_RTP_FLAG_RAW_WRITE] ? (uint32_t) frame->timestamp : 0;
	}

	/*
	  if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
	  send_msg->header.pt = rtp_session->payload;
	  }
	*/

	r = rtp_common_write(rtp_session, send_msg, data, len, payload, ts, &frame->flags);

	if (send_msg) {
		send_msg->header = local_header;
	}

	return r;

}
