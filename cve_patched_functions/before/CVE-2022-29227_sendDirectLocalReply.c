void FilterManager::sendDirectLocalReply(
    Code code, absl::string_view body,
    const std::function<void(ResponseHeaderMap&)>& modify_headers, bool is_head_request,
    const absl::optional<Grpc::Status::GrpcStatus> grpc_status) {
  // Make sure we won't end up with nested watermark calls from the body buffer.
  state_.encoder_filters_streaming_ = true;
  Http::Utility::sendLocalReply(
      state_.destroyed_,
      Utility::EncodeFunctions{
          [this, modify_headers](ResponseHeaderMap& headers) -> void {
            if (streamInfo().route() && streamInfo().route()->routeEntry()) {
              streamInfo().route()->routeEntry()->finalizeResponseHeaders(headers, streamInfo());
            }
            if (modify_headers) {
              modify_headers(headers);
            }
          },
          [&](ResponseHeaderMap& response_headers, Code& code, std::string& body,
              absl::string_view& content_type) -> void {
            local_reply_.rewrite(filter_manager_callbacks_.requestHeaders().ptr(), response_headers,
                                 stream_info_, code, body, content_type);
          },
          [&](ResponseHeaderMapPtr&& response_headers, bool end_stream) -> void {
            // Move the response headers into the FilterManager to make sure they're visible to
            // access logs.
            filter_manager_callbacks_.setResponseHeaders(std::move(response_headers));

            state_.non_100_response_headers_encoded_ = true;
            filter_manager_callbacks_.encodeHeaders(*filter_manager_callbacks_.responseHeaders(),
                                                    end_stream);
            if (state_.saw_downstream_reset_) {
              return;
            }
            maybeEndEncode(end_stream);
          },
          [&](Buffer::Instance& data, bool end_stream) -> void {
            filter_manager_callbacks_.encodeData(data, end_stream);
            if (state_.saw_downstream_reset_) {
              return;
            }
            maybeEndEncode(end_stream);
          }},
      Utility::LocalReplyData{state_.is_grpc_request_, code, body, grpc_status, is_head_request});
}
