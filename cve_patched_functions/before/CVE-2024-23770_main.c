int main(int argc, char **argv) {
    printf("%s, %s.\n", pkgname, copyright);
    parse_default_extension_map();
    parse_commandline(argc, argv);
    /* parse_commandline() might override parts of the extension map by
     * parsing a user-specified file.
     */
    sort_mime_map();
    xasprintf(&keep_alive_field, "Keep-Alive: timeout=%d\r\n", timeout_secs);
    if (want_server_id)
        xasprintf(&server_hdr, "Server: %s\r\n", pkgname);
    else
        server_hdr = xstrdup("");
    init_sockin();

    /* open logfile */
    if (logfile_name == NULL)
        logfile = stdout;
    else {
        logfile = fopen(logfile_name, "ab");
        if (logfile == NULL)
            err(1, "opening logfile: fopen(\"%s\")", logfile_name);
    }

    if (want_daemon)
        daemonize_start();

    /* signals */
    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
        err(1, "signal(ignore SIGPIPE)");
    if (signal(SIGINT, stop_running) == SIG_ERR)
        err(1, "signal(SIGINT)");
    if (signal(SIGTERM, stop_running) == SIG_ERR)
        err(1, "signal(SIGTERM)");

    /* security */
    if (want_chroot) {
        tzset(); /* read /etc/localtime before we chroot */
        if (chdir(wwwroot) == -1)
            err(1, "chdir(%s)", wwwroot);
        if (chroot(wwwroot) == -1)
            err(1, "chroot(%s)", wwwroot);
        printf("chrooted to `%s'\n", wwwroot);
        wwwroot[0] = '\0'; /* empty string */
    }
    if (drop_gid != INVALID_GID) {
        gid_t list[1];
        list[0] = drop_gid;
        if (setgroups(1, list) == -1)
            err(1, "setgroups([%d])", (int)drop_gid);
        if (setgid(drop_gid) == -1)
            err(1, "setgid(%d)", (int)drop_gid);
        printf("set gid to %d\n", (int)drop_gid);
    }
    if (drop_uid != INVALID_UID) {
        if (setuid(drop_uid) == -1)
            err(1, "setuid(%d)", (int)drop_uid);
        printf("set uid to %d\n", (int)drop_uid);
    }

    /* create pidfile */
    if (pidfile_name) pidfile_create();

    if (want_daemon) daemonize_finish();

    /* main loop */
    running = 1;
    while (running) httpd_poll();

    /* clean exit */
    xclose(sockin);
    if (logfile != NULL) fclose(logfile);
    if (pidfile_name) pidfile_remove();

    /* close and free connections */
    {
        struct connection *conn, *next;

        LIST_FOREACH_SAFE(conn, &connlist, entries, next) {
            LIST_REMOVE(conn, entries);
            free_connection(conn);
            free(conn);
        }
    }

    /* free the mallocs */
    {
        size_t i;
        for (i=0; i<mime_map_size; i++) {
            free(mime_map[i].extension);
            free(mime_map[i].mimetype);
        }
        free(mime_map);
        if (forward_map)
            free(forward_map);
        free(keep_alive_field);
        free(wwwroot);
        free(server_hdr);
        free(auth_key);
        free(custom_hdrs);
    }

    /* usage stats */
    {
        struct rusage r;

        getrusage(RUSAGE_SELF, &r);
        printf("CPU time used: %u.%02u user, %u.%02u system\n",
            (unsigned int)r.ru_utime.tv_sec,
                (unsigned int)(r.ru_utime.tv_usec/10000),
            (unsigned int)r.ru_stime.tv_sec,
                (unsigned int)(r.ru_stime.tv_usec/10000)
        );
        printf("Requests: %llu\n", llu(num_requests));
        printf("Bytes: %llu in, %llu out\n", llu(total_in), llu(total_out));
    }

    return 0;
}
