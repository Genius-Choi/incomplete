int tport_getaddrinfo(char const *node, char const *service,
		      su_addrinfo_t const *hints,
		      su_addrinfo_t **res)
{
  su_addrinfo_t const *h0;
  su_addrinfo_t *tbf, **prev;
  int error = EAI_SOCKTYPE;
  int i, N;
  su_addrinfo_t *all[TPORT_N + 1]; /* Lists for all supported transports */
  su_addrinfo_t *results[TPORT_N + 1];
  void *addr;
  int addrlen;

  *res = NULL;

  for (N = 0, h0 = hints; h0; h0 = h0->ai_next) {
    su_addrinfo_t h[1];

    *h = *h0, h->ai_next = NULL, h->ai_canonname = NULL;

    error = su_getaddrinfo(node, service, h, &all[N]);
    results[N] = all[N];
    if (error == EAI_SOCKTYPE) {
      SU_DEBUG_7(("%s(): su_getaddrinfo(%s, %s) for %s: %s\n",
		  __func__, node ? node : "\"\"", service,
		  h0->ai_canonname, su_gai_strerror(error)));
      continue;
    }

    if (error || !all[N])
      break;
    N++;
  }

  if (h0)
    for (i = 0; i < N; i++)
      su_freeaddrinfo(all[i]);
  if (error)
    return error;

  /* Combine all the valid addrinfo structures to a single list */
  prev = &tbf, tbf = NULL;

  for (;;) {
    su_addrinfo_t *ai = NULL, *ai0;

    for (i = 0, h0 = hints; i < N; i++, h0 = h0->ai_next) {
      if ((ai = get_next_addrinfo(&results[i])))
	break;
    }
    if (i == N)
      break;

    assert(ai);
    addr = SU_ADDR((su_sockaddr_t *)ai->ai_addr);
    addrlen = SU_ADDRLEN((su_sockaddr_t *)ai->ai_addr);

    /* Copy all the addrinfo structures with same address to the list */
    for (; i < N; i++, h0 = h0->ai_next) {
      while ((ai0 = get_next_addrinfo(&results[i]))) {
	void *a = SU_ADDR((su_sockaddr_t *)ai0->ai_addr);

	if (memcmp(addr, a, addrlen)) /* Different address */
	  break;

	results[i] = ai0->ai_next;

	ai = calloc(1, sizeof *ai + ai0->ai_addrlen);
	if (ai == NULL)
	  goto error;
	*prev = memcpy(ai, ai0, sizeof *ai); prev = &ai->ai_next; *prev = NULL;
	ai->ai_addr = memcpy(ai + 1, ai0->ai_addr, ai0->ai_addrlen);
	ai->ai_canonname = h0->ai_canonname;
      }
    }
  }

  for (i = 0; i < N; i++)
    su_freeaddrinfo(all[i]);

  *res = tbf;
  return 0;

 error:
  for (i = 0; i < N; i++)
    su_freeaddrinfo(all[i]);
  tport_freeaddrinfo(tbf);
  return EAI_MEMORY;
}
