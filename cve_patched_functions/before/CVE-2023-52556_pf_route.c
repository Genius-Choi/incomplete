pf_route(struct pf_pdesc *pd, struct pf_state *st)
{
	struct mbuf		*m0;
	struct mbuf_list	 ml;
	struct sockaddr_in	*dst, sin;
	struct rtentry		*rt = NULL;
	struct ip		*ip;
	struct ifnet		*ifp = NULL;
	unsigned int		 rtableid;

	if (pd->m->m_pkthdr.pf.routed++ > 3) {
		m_freem(pd->m);
		pd->m = NULL;
		return;
	}

	if (st->rt == PF_DUPTO) {
		if ((m0 = m_dup_pkt(pd->m, max_linkhdr, M_NOWAIT)) == NULL)
			return;
	} else {
		if ((st->rt == PF_REPLYTO) == (st->direction == pd->dir))
			return;
		m0 = pd->m;
		pd->m = NULL;
	}

	if (m0->m_len < sizeof(struct ip)) {
		DPFPRINTF(LOG_ERR,
		    "%s: m0->m_len < sizeof(struct ip)", __func__);
		goto bad;
	}

	ip = mtod(m0, struct ip *);

	if (pd->dir == PF_IN) {
		if (ip->ip_ttl <= IPTTLDEC) {
			if (st->rt != PF_DUPTO) {
				pf_send_icmp(m0, ICMP_TIMXCEED,
				    ICMP_TIMXCEED_INTRANS, 0,
				    pd->af, st->rule.ptr, pd->rdomain);
			}
			goto bad;
		}
		ip->ip_ttl -= IPTTLDEC;
	}

	memset(&sin, 0, sizeof(sin));
	dst = &sin;
	dst->sin_family = AF_INET;
	dst->sin_len = sizeof(*dst);
	dst->sin_addr = st->rt_addr.v4;
	rtableid = m0->m_pkthdr.ph_rtableid;

	rt = rtalloc_mpath(sintosa(dst), &ip->ip_src.s_addr, rtableid);
	if (!rtisvalid(rt)) {
		if (st->rt != PF_DUPTO) {
			pf_send_icmp(m0, ICMP_UNREACH, ICMP_UNREACH_HOST,
			    0, pd->af, st->rule.ptr, pd->rdomain);
		}
		ipstat_inc(ips_noroute);
		goto bad;
	}

	ifp = if_get(rt->rt_ifidx);
	if (ifp == NULL)
		goto bad;

	/* A locally generated packet may have invalid source address. */
	if ((ntohl(ip->ip_src.s_addr) >> IN_CLASSA_NSHIFT) == IN_LOOPBACKNET &&
	    (ifp->if_flags & IFF_LOOPBACK) == 0)
		ip->ip_src = ifatoia(rt->rt_ifa)->ia_addr.sin_addr;

	if (st->rt != PF_DUPTO && pd->dir == PF_IN) {
		if (pf_test(AF_INET, PF_OUT, ifp, &m0) != PF_PASS)
			goto bad;
		else if (m0 == NULL)
			goto done;
		if (m0->m_len < sizeof(struct ip)) {
			DPFPRINTF(LOG_ERR,
			    "%s: m0->m_len < sizeof(struct ip)", __func__);
			goto bad;
		}
		ip = mtod(m0, struct ip *);
	}

	if (if_output_tso(ifp, &m0, sintosa(dst), rt, ifp->if_mtu) ||
	    m0 == NULL)
		goto done;

	/*
	 * Too large for interface; fragment if possible.
	 * Must be able to put at least 8 bytes per fragment.
	 */
	if (ip->ip_off & htons(IP_DF)) {
		ipstat_inc(ips_cantfrag);
		if (st->rt != PF_DUPTO)
			pf_send_icmp(m0, ICMP_UNREACH, ICMP_UNREACH_NEEDFRAG,
			    ifp->if_mtu, pd->af, st->rule.ptr, pd->rdomain);
		goto bad;
	}

	if (ip_fragment(m0, &ml, ifp, ifp->if_mtu) ||
	    if_output_ml(ifp, &ml, sintosa(dst), rt))
		goto done;
	ipstat_inc(ips_fragmented);

done:
	if_put(ifp);
	rtfree(rt);
	return;

bad:
	m_freem(m0);
	goto done;
}
