int ecall_restart(struct ecall *ecall, enum icall_call_type call_type)
{
	enum econn_state state;
	int err = 0;
	bool muted;

	if (!ecall)
		return EINVAL;

	state = econn_current_state(ecall->econn);

	switch (state) {
	case ECONN_ANSWERED:
	case ECONN_DATACHAN_ESTABLISHED:
		break;

	default:
		warning("ecall(%p): restart: cannot restart in state: '%s'\n",
			ecall, econn_state_name(state));
		return EPROTO;
	}

	if (ecall->conv_type == ICALL_CONV_TYPE_CONFERENCE) {
		ICALL_CALL_CB(ecall->icall, closeh,
			      &ecall->icall,
			      EAGAIN,
			      NULL,
			      0,
			      NULL,
			      NULL, 
			      ecall->icall.arg);
			
		return 0;
	}

	ecall->call_type = call_type;
	ecall->update = true;
	tmr_cancel(&ecall->dc_tmr);
	ecall->conf_part = mem_deref(ecall->conf_part);
	muted = msystem_get_muted();

	ecall->dce = NULL;
	ecall->dce_ch = NULL;
	err = alloc_flow(ecall, ASYNC_OFFER, ecall->call_type, ecall->audio_cbr);
	msystem_set_muted(muted);
	if (err) {
		warning("ecall: re-start: alloc_flow failed: %m\n", err);
		goto out;
	}
	//if (ecall->conf_part)
	//	ecall->conf_part->data = ecall->flow;

	IFLOW_CALL(ecall->flow, set_remote_userclientid,
		econn_userid_remote(ecall->econn),
		econn_clientid_remote(ecall->econn));
	IFLOW_CALL(ecall->flow, set_video_state, ecall->vstate);

	ecall->sdp.async = ASYNC_NONE;
	err = generate_offer(ecall);
	if (err) {
		warning("ecall(%p): restart: generate_offer"
			" failed (%m)\n", ecall, err);
		goto out;
	}

 out:
	return err;
}
