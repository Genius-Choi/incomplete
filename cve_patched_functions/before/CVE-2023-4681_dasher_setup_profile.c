static GF_Err dasher_setup_profile(GF_DasherCtx *ctx)
{
	switch (ctx->profile) {
	case GF_DASH_PROFILE_AVC264_LIVE:
	case GF_DASH_PROFILE_AVC264_ONDEMAND:
	case GF_DASH_PROFILE_DASHIF_LL:
		if (ctx->cp == GF_DASH_CPMODE_REPRESENTATION) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[Dasher] ERROR! The selected DASH profile (DASH-IF IOP) requires the ContentProtection element to be present in the AdaptationSet element, updating.\n"));
			ctx->cp = GF_DASH_CPMODE_ADAPTATION_SET;
		}
	default:
		break;
	}
	if (ctx->muxtype==DASHER_MUX_TS) {
		switch (ctx->profile) {
		case GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE:
		case GF_DASH_PROFILE_AVC264_LIVE:
		case GF_DASH_PROFILE_DASHIF_LL:
			ctx->profile = GF_DASH_PROFILE_LIVE;
			break;
		case GF_DASH_PROFILE_ONDEMAND:
		case GF_DASH_PROFILE_AVC264_ONDEMAND:
			ctx->profile = GF_DASH_PROFILE_ONDEMAND;
			break;
		}
	}

	/*adjust params based on profiles*/
	switch (ctx->profile) {
	case GF_DASH_PROFILE_LIVE:
		ctx->sseg = ctx->sfile = GF_FALSE;
		ctx->tpl = ctx->align = ctx->sap = GF_TRUE;
		break;
	case GF_DASH_PROFILE_HBBTV_1_5_ISOBMF_LIVE:
		ctx->check_main_role = GF_TRUE;
		ctx->bs_switch = DASHER_BS_SWITCH_MULTI;
		//FALLTHROUGH
	case GF_DASH_PROFILE_AVC264_LIVE:
		ctx->sseg = ctx->sfile = GF_FALSE;
		ctx->no_fragments_defaults = ctx->align = ctx->tpl = ctx->sap = GF_TRUE;
		break;
	case GF_DASH_PROFILE_AVC264_ONDEMAND:
		ctx->tpl = GF_FALSE;
		ctx->no_fragments_defaults = ctx->align = ctx->sseg = ctx->sap = GF_TRUE;
		break;
	case GF_DASH_PROFILE_ONDEMAND:
		ctx->sseg = ctx->align = ctx->sap = ctx->sfile = GF_TRUE;
		ctx->tpl = GF_FALSE;

		if (ctx->muxtype==DASHER_MUX_TS) {
			ctx->sseg = GF_FALSE;
			ctx->tpl = GF_TRUE;
			ctx->profile = GF_DASH_PROFILE_MAIN;
		} else {
			if ((ctx->bs_switch != DASHER_BS_SWITCH_DEF) && (ctx->bs_switch != DASHER_BS_SWITCH_OFF)) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[Dasher] onDemand profile, bitstream switching mode cannot be used, defaulting to off.\n"));
			}
		}
		/*BS switching is meaningless in onDemand profile*/
		ctx->bs_switch = DASHER_BS_SWITCH_OFF;
		break;
	case GF_DASH_PROFILE_MAIN:
		ctx->align = ctx->sap = GF_TRUE;
		ctx->sseg = ctx->tpl = GF_FALSE;
		break;
	case GF_DASH_PROFILE_DASHIF_LL:
		ctx->sseg = ctx->sfile = GF_FALSE;
		ctx->no_fragments_defaults = ctx->align = ctx->tpl = ctx->sap = GF_TRUE;
		if (!ctx->utcs) {
			const char *default_utc_timing_server = "https://time.akamai.com/?iso&ms";
			GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[Dasher] DASH-IF LL requires UTCTiming but none specified, using %s \n", default_utc_timing_server));
			ctx->utcs = gf_strdup(default_utc_timing_server);
		}
		break;
	default:
		break;
	}

	if ((ctx->bs_switch == DASHER_BS_SWITCH_MULTI) && (ctx->pswitch == DASHER_PSWITCH_STSD)) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[Dasher] Cannot use `stsd` period switch with `multi` bitstream switching, disabling pswitch\n"));
		ctx->pswitch = DASHER_PSWITCH_SINGLE;
	}

	if (ctx->sseg)
		ctx->tpl = GF_FALSE;

	if (ctx->bs_switch == DASHER_BS_SWITCH_DEF) {
		ctx->bs_switch = DASHER_BS_SWITCH_ON;
	}

	if (ctx->cmaf) {
		ctx->align = GF_TRUE;
		ctx->sap = GF_TRUE;
	}

	if (! ctx->align) {
		if (ctx->profile != GF_DASH_PROFILE_FULL) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[Dasher] Segments are not time-aligned in each representation of each period\n\tswitching to FULL profile\n"));
			ctx->profile = GF_DASH_PROFILE_FULL;
		}
		//commented out, this does not seem correct since BS switching is orthogonal to segment alignment
		//one could have inband params working even in non time-aligned setup
#if 0
		if (ctx->bs_switch != DASHER_BS_SWITCH_OFF) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[Dasher] Segments are not time-aligned in each representation of each period\n\tdisabling bitstream switching\n"));
			ctx->bs_switch = DASHER_BS_SWITCH_OFF;
		}
#endif

	}

	//check we have a segment template
	if (!ctx->template) {
		if (!ctx->sigfrag) {
			ctx->template = gf_strdup( ctx->sfile ? "$File$$FS$_dash" : (ctx->stl ? "$File$_dash$FS$$Time$" : "$File$_dash$FS$$Number$") );
			GF_LOG(GF_LOG_INFO, GF_LOG_DASH, ("[Dasher] No template assigned, using %s\n", ctx->template));
			ctx->def_template = 1;
		}

		if (ctx->profile == GF_DASH_PROFILE_FULL) {
			ctx->sfile = GF_TRUE;
		}
	}
	//backward compatibility with old arch using %s
	else {
		char *sep = strstr(ctx->template, "%s");
		if (sep) {
			char *new_template = NULL;
			sep[0] = 0;
			gf_dynstrcat(&new_template, ctx->template, NULL);
			gf_dynstrcat(&new_template, "$File$", NULL);
			gf_dynstrcat(&new_template, sep+2, NULL);
			gf_free(ctx->template);
			ctx->template = new_template;
		}

	}
	return GF_OK;
}
