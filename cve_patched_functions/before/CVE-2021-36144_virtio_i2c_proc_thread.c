virtio_i2c_proc_thread(void *arg)
{
	struct virtio_i2c *vi2c = arg;
	struct virtio_vq_info *vq = &vi2c->vq;
	struct iovec iov[3];
	uint16_t idx, flags[3];
	struct virtio_i2c_hdr *hdr;
	struct i2c_msg msg;
	uint8_t *status;
	int n;

	for (;;) {
		pthread_mutex_lock(&vi2c->req_mtx);

		vi2c->in_process = 0;
		while (!vq_has_descs(vq) && !vi2c->closing)
			pthread_cond_wait(&vi2c->req_cond, &vi2c->req_mtx);

		if (vi2c->closing) {
			pthread_mutex_unlock(&vi2c->req_mtx);
			return NULL;
		}
		vi2c->in_process = 1;
		pthread_mutex_unlock(&vi2c->req_mtx);
		do {
			n = vq_getchain(vq, &idx, iov, 3, flags);
			if (n < 2 || n > 3) {
				WPRINTF("virtio_i2c_proc: failed to get iov from virtqueue\n");
				continue;
			}
			hdr = iov[0].iov_base;
			msg.addr = hdr->addr;
			msg.flags = hdr->flags;
			if (hdr->len) {
				msg.buf = iov[1].iov_base;
				msg.len = iov[1].iov_len;
				status = iov[2].iov_base;
			} else {
				msg.buf = NULL;
				msg.len = 0;
				status = iov[1].iov_base;
			}
			*status = native_adapter_proc(vi2c, &msg);
			vq_relchain(vq, idx, 1);
		} while (vq_has_descs(vq));
		vq_endchains(vq, 0);
	}
}
