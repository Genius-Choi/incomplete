do_set_option_numeric(
    int		opt_idx,
    int		opt_flags,
    char_u	**argp,
    int		nextchar,
    set_op_T	op,
    long_u	flags,
    int		cp_val,
    char_u	*varp,
    char	*errbuf,
    size_t	errbuflen)
{
    char_u		*arg = *argp;
    varnumber_T		value;
    int			i;
    char		*errmsg = NULL;

    if (opt_idx < 0 || varp == NULL)
	return NULL;  // "cannot happen"
		      //
    /*
     * Different ways to set a number option:
     * &	    set to default value
     * <	    set to global value
     * <xx>	    accept special key codes for 'wildchar'
     * c	    accept any non-digit for 'wildchar'
     * [-]0-9   set number
     * other    error
     */
    ++arg;
    if (nextchar == '&')
	value = (long)(long_i)options[opt_idx].def_val[
	    ((flags & P_VI_DEF) || cp_val) ? VI_DEFAULT : VIM_DEFAULT];
    else if (nextchar == '<')
    {
	if ((long *)varp == &curbuf->b_p_ul && opt_flags == OPT_LOCAL)
	    // for 'undolevels' NO_LOCAL_UNDOLEVEL means using the global value
	    value = NO_LOCAL_UNDOLEVEL;
	else if (opt_flags == OPT_LOCAL
		    && ((long *)varp == &curwin->w_p_siso
		     || (long *)varp == &curwin->w_p_so))
	    // for 'scrolloff'/'sidescrolloff' -1 means using the global value
	    value = -1;
	else
	    value = *(long *)get_varp_scope(&(options[opt_idx]), OPT_GLOBAL);
    }
    else if (((long *)varp == &p_wc || (long *)varp == &p_wcm)
	    && (*arg == '<'
		|| *arg == '^'
		|| (*arg != NUL
		    && (!arg[1] || VIM_ISWHITE(arg[1]))
		    && !VIM_ISDIGIT(*arg))))
    {
	value = string_to_key(arg, FALSE);
	if (value == 0 && (long *)varp != &p_wcm)
	{
	    errmsg = e_invalid_argument;
	    goto skip;
	}
    }
    else if (*arg == '-' || VIM_ISDIGIT(*arg))
    {
	// Allow negative (for 'undolevels'), octal and hex numbers.
	vim_str2nr(arg, NULL, &i, STR2NR_ALL, &value, NULL, 0, TRUE, NULL);
	if (i == 0 || (arg[i] != NUL && !VIM_ISWHITE(arg[i])))
	{
	    errmsg = e_number_required_after_equal;
	    goto skip;
	}
    }
    else
    {
	errmsg = e_number_required_after_equal;
	goto skip;
    }

    if (op == OP_ADDING)
	value = *(long *)varp + value;
    else if (op == OP_PREPENDING)
	value = *(long *)varp * value;
    else if (op == OP_REMOVING)
	value = *(long *)varp - value;

    errmsg = set_num_option(opt_idx, varp, value, errbuf, errbuflen,
								opt_flags);

skip:
    *argp = arg;
    return errmsg;
}
