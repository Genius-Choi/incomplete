ecma_proxy_object_own_property_keys (ecma_object_t *obj_p) /**< proxy object */
{
  JERRY_ASSERT (ECMA_OBJECT_IS_PROXY (obj_p));
  ECMA_CHECK_STACK_USAGE_RETURN (NULL);

  ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) obj_p;

  /* 1. */
  ecma_value_t handler = proxy_obj_p->handler;

  /* 2-5. */
  ecma_value_t trap = ecma_validate_proxy_object (handler, LIT_MAGIC_STRING_OWN_KEYS_UL);

  if (ECMA_IS_VALUE_ERROR (trap))
  {
    return NULL;
  }

  ecma_value_t target = proxy_obj_p->target;
  ecma_object_t *target_obj_p = ecma_get_object_from_value (target);

  /* 6. */
  if (ecma_is_value_undefined (trap))
  {
    ecma_collection_t *result = ecma_op_object_own_property_keys (target_obj_p, JERRY_PROPERTY_FILTER_ALL);
    JERRY_BLOCK_TAIL_CALL_OPTIMIZATION ();
    return result;
  }

  ecma_object_t *func_obj_p = ecma_get_object_from_value (trap);

  /* 7. */
  ecma_value_t trap_result_array = ecma_op_function_call (func_obj_p, handler, &target, 1);

  ecma_deref_object (func_obj_p);

  if (ECMA_IS_VALUE_ERROR (trap_result_array))
  {
    return NULL;
  }

  /* 8. */
  ecma_collection_t *trap_result = ecma_op_create_list_from_array_like (trap_result_array, true);

  ecma_free_value (trap_result_array);

  if (trap_result == NULL || (obj_p->u2.prototype_cp & JERRY_PROXY_SKIP_RESULT_VALIDATION))
  {
    return trap_result;
  }

  /* 9. */
  if (ecma_collection_check_duplicated_entries (trap_result))
  {
    ecma_collection_free (trap_result);
    ecma_raise_type_error (ECMA_ERR_TRAP_WITH_DUPLICATED_ENTRIES);
    return NULL;
  }

  /* 10. */
  ecma_value_t extensible_target = ecma_builtin_object_object_is_extensible (target_obj_p);

  if (ECMA_IS_VALUE_ERROR (extensible_target))
  {
    ecma_collection_free (trap_result);
    return NULL;
  }

  /* 11. */
  ecma_collection_t *target_keys = ecma_op_object_own_property_keys (target_obj_p, JERRY_PROPERTY_FILTER_ALL);

  if (target_keys == NULL)
  {
    ecma_collection_free (trap_result);
    return target_keys;
  }

  /* 14. */
  ecma_collection_t *target_configurable_keys = ecma_new_collection ();

  /* 15. */
  ecma_collection_t *target_non_configurable_keys = ecma_new_collection ();

  ecma_collection_t *ret_value = NULL;

  /* 16. */
  for (uint32_t i = 0; i < target_keys->item_count; i++)
  {
    ecma_property_descriptor_t target_desc;

    ecma_string_t *prop_name_p = ecma_get_prop_name_from_value (target_keys->buffer_p[i]);

    ecma_value_t status = ecma_op_object_get_own_property_descriptor (target_obj_p, prop_name_p, &target_desc);

    if (ECMA_IS_VALUE_ERROR (status))
    {
      ecma_collection_free (trap_result);
      goto free_target_collections;
    }

    ecma_value_t prop_value = ecma_make_prop_name_value (prop_name_p);

    if (ecma_is_value_true (status) && !(target_desc.flags & JERRY_PROP_IS_CONFIGURABLE))
    {
      ecma_collection_push_back (target_non_configurable_keys, prop_value);
    }
    else
    {
      ecma_collection_push_back (target_configurable_keys, prop_value);
    }

    if (ecma_is_value_true (status))
    {
      ecma_free_property_descriptor (&target_desc);
    }
  }

  /* 17. */
  if (ecma_is_value_true (extensible_target) && target_non_configurable_keys->item_count == 0)
  {
    ret_value = trap_result;
  }
  /* 18-22. */
  else if (ecma_proxy_check_invariants_for_own_prop_keys (trap_result,
                                                          target_non_configurable_keys,
                                                          target_configurable_keys,
                                                          extensible_target))
  {
    ret_value = trap_result;
  }
  else
  {
    JERRY_ASSERT (ret_value == NULL);
    ecma_collection_free (trap_result);
  }

free_target_collections:
  ecma_collection_destroy (target_keys);
  ecma_collection_free (target_configurable_keys);
  ecma_collection_free (target_non_configurable_keys);

  /* 23. */
  return ret_value;
} /* ecma_proxy_object_own_property_keys */
