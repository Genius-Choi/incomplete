static int rtp_common_write(switch_rtp_t *rtp_session,
							rtp_msg_t *send_msg, void *data, uint32_t datalen, switch_payload_t payload, uint32_t timestamp, switch_frame_flag_t *flags)
{
	switch_size_t bytes;
	uint8_t send = 1;
	uint32_t this_ts = 0;
	int ret;
	switch_time_t now;
	uint8_t m = 0;

	if (!switch_rtp_ready(rtp_session)) {
		return -1;
	}

	if (!rtp_write_ready(rtp_session, datalen, __LINE__)) {
		return 0;
	}

	WRITE_INC(rtp_session);
	
	if (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {
		//switch_core_timer_sync(&rtp_session->write_timer);
	}

	if (send_msg) {
		bytes = datalen;

		m = (uint8_t) send_msg->header.m;
		rtp_session->ts = ntohl(send_msg->header.ts);

		if (flags && *flags & SFF_RFC2833) {
			if (rtp_session->te == INVALID_PT) {
				ret = 0;
				goto end;
			}
			send_msg->header.pt = rtp_session->te;
		}
		data = send_msg->body;
		if (datalen > rtp_header_len) {
			datalen -= rtp_header_len;
		}
	} else {
		if (*flags & SFF_RFC2833) {
			if (rtp_session->te == INVALID_PT) {
				ret = 0;
				goto end;
			}
			payload = rtp_session->te;
		}

		send_msg = &rtp_session->send_msg;
		send_msg->header.pt = payload;

		m = get_next_write_ts(rtp_session, timestamp);

		rtp_session->send_msg.header.ts = htonl(rtp_session->ts);

		memcpy(send_msg->body, data, datalen);
		bytes = datalen + rtp_header_len;
	}

	if (!switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO)) {
		
		if ((rtp_session->rtp_bugs & RTP_BUG_NEVER_SEND_MARKER)) {
			m = 0;
		} else {
			int delta = rtp_session->ts - rtp_session->last_write_ts;

			if (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&
				((!rtp_session->flags[SWITCH_RTP_FLAG_RESET] && (abs(delta) > rtp_session->samples_per_interval * 10))
				|| rtp_session->ts == rtp_session->samples_per_interval)) {
				m++;
			}

			if (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {
				//switch_core_timer_sync(&rtp_session->write_timer);
			}

			if (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] &&
				(rtp_session->write_timer.samplecount - rtp_session->last_write_samplecount) > rtp_session->samples_per_interval * 10) {
				m++;
			}

			if (!rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] &&
				((unsigned) ((switch_micro_time_now() - rtp_session->last_write_timestamp))) > (rtp_session->ms_per_packet * 10)) {
				m++;
			}

			if (rtp_session->cn && payload != rtp_session->cng_pt) {
				rtp_session->cn = 0;
				m++;
			}

			if (rtp_session->need_mark && !rtp_session->sending_dtmf) {
				m++;
				rtp_session->need_mark = 0;
			}
		}

		if (m) {
			rtp_session->flags[SWITCH_RTP_FLAG_RESET] = 1;
			rtp_session->ts = 0;
		}

		/* If the marker was set, and the timestamp seems to have started over - set a new SSRC, to indicate this is a new stream */
		if (m && !switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_SECURE_SEND) && (rtp_session->rtp_bugs & RTP_BUG_CHANGE_SSRC_ON_MARKER) &&
			(rtp_session->flags[SWITCH_RTP_FLAG_RESET] || (rtp_session->ts <= rtp_session->last_write_ts && rtp_session->last_write_ts > 0))) {
			switch_rtp_set_ssrc(rtp_session, (uint32_t) ((intptr_t) rtp_session + (switch_time_t) switch_epoch_time_now(NULL)));
		}

		if (!switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO) && !switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_UDPTL)) {
			send_msg->header.m = (m && !(rtp_session->rtp_bugs & RTP_BUG_NEVER_SEND_MARKER)) ? 1 : 0;
		}
	}

	if (switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO)) {
		int external = (flags && *flags & SFF_EXTERNAL);
		/* Normalize the timestamps to our own base by generating a made up starting point then adding the measured deltas to that base
		   so if the timestamps and ssrc of the source change, it will not break the other end's jitter bufffer / decoder etc *cough* CHROME *cough*
		 */

		if (!rtp_session->ts_norm.ts) {
			rtp_session->ts_norm.ts = (uint32_t) rand() % 1000000 + 1;
		}

		if (!rtp_session->ts_norm.last_ssrc || send_msg->header.ssrc != rtp_session->ts_norm.last_ssrc || rtp_session->ts_norm.last_external != external) {
			switch_core_session_t *other_session;
			
			switch_core_session_request_video_refresh(rtp_session->session);
			switch_core_media_gen_key_frame(rtp_session->session);

			if (switch_core_session_get_partner(rtp_session->session, &other_session) == SWITCH_STATUS_SUCCESS) {
				switch_core_session_request_video_refresh(other_session);
				switch_core_media_gen_key_frame(other_session);
				switch_core_session_rwunlock(other_session);
			}

			if (rtp_session->ts_norm.last_ssrc) {
				rtp_session->ts_norm.delta_ttl = 0;
				rtp_session->ts_norm.ts++;
			}

			rtp_session->ts_norm.last_ssrc = send_msg->header.ssrc;
			rtp_session->ts_norm.last_frame = ntohl(send_msg->header.ts);
		}

		rtp_session->ts_norm.last_external = external;

		if (ntohl(send_msg->header.ts) != rtp_session->ts_norm.last_frame) {
			int32_t delta = ntohl(send_msg->header.ts) - rtp_session->ts_norm.last_frame;

			if (delta < 0 || delta > 90000) {
				switch_core_media_gen_key_frame(rtp_session->session);
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, 
								  "Timestamp shift detected last: %d this: %d delta: %d stick with prev delta: %d\n", 
								  rtp_session->ts_norm.last_frame, ntohl(send_msg->header.ts), delta, rtp_session->ts_norm.delta);
			} else {
				rtp_session->ts_norm.delta = delta;
			}

			rtp_session->ts_norm.ts += rtp_session->ts_norm.delta;

		}
		
		rtp_session->ts_norm.last_frame = ntohl(send_msg->header.ts);
		send_msg->header.ts = htonl(rtp_session->ts_norm.ts);
		this_ts = rtp_session->ts_norm.ts;
	}

	send_msg->header.ssrc = htonl(rtp_session->ssrc);

	if (rtp_session->flags[SWITCH_RTP_FLAG_GOOGLEHACK] && rtp_session->send_msg.header.pt == 97) {
		rtp_session->last_rtp_hdr.pt = 102;
	}

	if (rtp_session->flags[SWITCH_RTP_FLAG_VAD] &&
		rtp_session->last_rtp_hdr.pt == rtp_session->vad_data.read_codec->implementation->ianacode) {

		int16_t decoded[SWITCH_RECOMMENDED_BUFFER_SIZE / sizeof(int16_t)] = { 0 };
		uint32_t rate = 0;
		uint32_t codec_flags = 0;
		uint32_t len = sizeof(decoded);
		time_t now = switch_epoch_time_now(NULL);
		send = 0;

		if (rtp_session->vad_data.scan_freq && rtp_session->vad_data.next_scan <= now) {
			rtp_session->vad_data.bg_count = rtp_session->vad_data.bg_level = 0;
			rtp_session->vad_data.next_scan = now + rtp_session->vad_data.scan_freq;
		}

		if (switch_core_codec_decode(&rtp_session->vad_data.vad_codec,
									 rtp_session->vad_data.read_codec,
									 data,
									 datalen,
									 rtp_session->vad_data.read_codec->implementation->actual_samples_per_second,
									 decoded, &len, &rate, &codec_flags) == SWITCH_STATUS_SUCCESS) {

			uint32_t energy = 0;
			uint32_t x, y = 0, z = len / sizeof(int16_t);
			uint32_t score = 0;
			int divisor = 0;
			if (z) {

				if (!(divisor = rtp_session->vad_data.read_codec->implementation->actual_samples_per_second / 8000)) {
					divisor = 1;
				}

				for (x = 0; x < z; x++) {
					energy += abs(decoded[y]);
					y += rtp_session->vad_data.read_codec->implementation->number_of_channels;
				}

				if (++rtp_session->vad_data.start_count < rtp_session->vad_data.start) {
					send = 1;
				} else {
					score = (energy / (z / divisor));
					if (score && (rtp_session->vad_data.bg_count < rtp_session->vad_data.bg_len)) {
						rtp_session->vad_data.bg_level += score;
						if (++rtp_session->vad_data.bg_count == rtp_session->vad_data.bg_len) {
							rtp_session->vad_data.bg_level /= rtp_session->vad_data.bg_len;
						}
						send = 1;
					} else {
						if (score > rtp_session->vad_data.bg_level && !switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING)) {
							uint32_t diff = score - rtp_session->vad_data.bg_level;

							if (rtp_session->vad_data.hangover_hits) {
								rtp_session->vad_data.hangover_hits--;
							}

							if (diff >= rtp_session->vad_data.diff_level || ++rtp_session->vad_data.hangunder_hits >= rtp_session->vad_data.hangunder) {

								switch_set_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING);

								rtp_session->vad_data.start_talking = switch_micro_time_now();

								if (!(rtp_session->rtp_bugs & RTP_BUG_NEVER_SEND_MARKER)) {
									send_msg->header.m = 1;
								}
								rtp_session->vad_data.hangover_hits = rtp_session->vad_data.hangunder_hits = rtp_session->vad_data.cng_count = 0;
								if (switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_EVENTS_TALK)) {

									if ((rtp_session->vad_data.fire_events & VAD_FIRE_TALK)) {
										switch_event_t *event;
										if (switch_event_create(&event, SWITCH_EVENT_TALK) == SWITCH_STATUS_SUCCESS) {
											switch_channel_event_set_data(switch_core_session_get_channel(rtp_session->vad_data.session), event);
											switch_event_fire(&event);
										}
									}
								}
							}
						} else {
							if (rtp_session->vad_data.hangunder_hits) {
								rtp_session->vad_data.hangunder_hits--;
							}
							if (switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING)) {
								if (++rtp_session->vad_data.hangover_hits >= rtp_session->vad_data.hangover) {
									rtp_session->vad_data.stop_talking = switch_micro_time_now();
									rtp_session->vad_data.total_talk_time += (rtp_session->vad_data.stop_talking - rtp_session->vad_data.start_talking);

									switch_clear_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING);

									rtp_session->vad_data.hangover_hits = rtp_session->vad_data.hangunder_hits = rtp_session->vad_data.cng_count = 0;
									if (switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_EVENTS_NOTALK)) {

										if ((rtp_session->vad_data.fire_events & VAD_FIRE_NOT_TALK)) {
											switch_event_t *event;
											if (switch_event_create(&event, SWITCH_EVENT_NOTALK) == SWITCH_STATUS_SUCCESS) {
												switch_channel_event_set_data(switch_core_session_get_channel(rtp_session->vad_data.session), event);
												switch_event_fire(&event);
											}
										}
									}
								}
							}
						}
					}
				}

				if (switch_test_flag(&rtp_session->vad_data, SWITCH_VAD_FLAG_TALKING)) {
					send = 1;
				}
			}
		} else {
			ret = -1;
			goto end;
		}
	}

	if (!switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_VIDEO)) {
		uint32_t ts_delta;

		this_ts = ntohl(send_msg->header.ts);

		ts_delta = abs((int32_t)(this_ts - rtp_session->last_write_ts));

		if (ts_delta > rtp_session->samples_per_second * 2) {
			rtp_session->flags[SWITCH_RTP_FLAG_RESET] = 1;
		}
#ifdef DEBUG_TS_ROLLOVER
		switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "WRITE TS LAST:%u THIS:%u DELTA:%u\n", rtp_session->last_write_ts, this_ts, ts_delta);
#endif
		if ((!(flags && *flags & SFF_RFC2833) && ts_delta == 0) || !switch_rtp_ready(rtp_session) || rtp_session->sending_dtmf) {
			send = 0;
		}
	}

	if (rtp_session->flags[SWITCH_RTP_FLAG_PAUSE]) {
		send = 0;
	}

	if (send) {
		int delta = 1;

		if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && (*flags & SFF_EXTERNAL) && 
			rtp_session->stats.outbound.packet_count && rtp_session->flags[SWITCH_RTP_FLAG_PASSTHRU]) {
			int32_t x = rtp_session->last_write_seq;
			int32_t y = ntohs(send_msg->header.seq);

			if (!rtp_session->video_delta_mode) {
				rtp_session->video_delta_mode = 1;
			} else {
				if (x > UINT16_MAX / 2 && y < UINT16_MAX / 2) {
					x -= (int32_t)UINT16_MAX+1;
				}
			
				delta = y-x;
			}
			
			rtp_session->last_write_seq = y;
		}

		if (!rtp_session->flags[SWITCH_RTP_FLAG_PASSTHRU]) {
			rtp_session->video_delta_mode = 0;
		}

		rtp_session->seq += delta;

		send_msg->header.seq = htons(rtp_session->seq);
		
		if (rtp_session->flags[SWITCH_RTP_FLAG_BYTESWAP] && send_msg->header.pt == rtp_session->payload) {
			switch_swap_linear((int16_t *)send_msg->body, (int) datalen);
		}

#ifdef ENABLE_SRTP
		switch_mutex_lock(rtp_session->ice_mutex);
		if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND]) {
			int sbytes = (int) bytes;
			srtp_err_status_t stat;


			if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_RESET] || !rtp_session->send_ctx[rtp_session->srtp_idx_rtp]) {

				switch_rtp_clear_flag(rtp_session, SWITCH_RTP_FLAG_SECURE_SEND_RESET);
				srtp_dealloc(rtp_session->send_ctx[rtp_session->srtp_idx_rtp]);
				rtp_session->send_ctx[rtp_session->srtp_idx_rtp] = NULL;
				if (srtp_create(&rtp_session->send_ctx[rtp_session->srtp_idx_rtp],
										&rtp_session->send_policy[rtp_session->srtp_idx_rtp]) || !rtp_session->send_ctx[rtp_session->srtp_idx_rtp]) {
					switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR,
									  "Error! RE-Activating %s Secure RTP SEND\n", rtp_type(rtp_session));
					rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND] = 0;
					ret = -1;
					switch_mutex_unlock(rtp_session->ice_mutex);
					goto end;
				} else {
					switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_INFO,
									  "RE-Activating %s Secure RTP SEND\n", rtp_type(rtp_session));
				}
			}

			if (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI]) {
				stat = srtp_protect(rtp_session->send_ctx[rtp_session->srtp_idx_rtp], &send_msg->header, &sbytes);
			} else {
				stat = srtp_protect_mki(rtp_session->send_ctx[rtp_session->srtp_idx_rtp], &send_msg->header, &sbytes, 1, SWITCH_CRYPTO_MKI_INDEX);
			}

			if (stat) {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR,
								  "Error: %s SRTP protection failed with code %d\n", rtp_type(rtp_session), stat);
			}

			bytes = sbytes;
		}
		switch_mutex_unlock(rtp_session->ice_mutex);
#endif

		now = switch_micro_time_now();
#ifdef RTP_DEBUG_WRITE_DELTA
		{
			int delta = (int) (now - rtp_session->send_time) / 1000;
			switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_ERROR, "WRITE %d delta %d\n", (int) bytes, delta);
		}
#endif
		rtp_session->send_time = now;

		if (rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_WRITE]) {
			const char *tx_host;
			const char *old_host;
			const char *my_host;

			char bufa[50], bufb[50], bufc[50];


			tx_host = switch_get_addr(bufa, sizeof(bufa), rtp_session->rtp_from_addr);
			old_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->remote_addr);
			my_host = switch_get_addr(bufc, sizeof(bufc), rtp_session->local_addr);

			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG_CLEAN(rtp_session->session), SWITCH_LOG_CONSOLE,
							  "W %s b=%4ld %s:%u %s:%u %s:%u pt=%d ts=%u seq=%u m=%d\n",
							  rtp_session->session ? switch_channel_get_name(switch_core_session_get_channel(rtp_session->session)) : "NoName",
							  (long) bytes,
							  my_host, switch_sockaddr_get_port(rtp_session->local_addr),
							  old_host, rtp_session->remote_port,
							  tx_host, switch_sockaddr_get_port(rtp_session->rtp_from_addr),
							  send_msg->header.pt, ntohl(send_msg->header.ts), ntohs(send_msg->header.seq), send_msg->header.m);

		}

		if (rtp_session->flags[SWITCH_RTP_FLAG_NACK]) {
			switch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);

			if (!rtp_session->vbw) {
				int nack_size = 100;
				const char *var;
				
				if ((var = switch_channel_get_variable(channel, "rtp_nack_buffer_size"))) {
					int tmp = atoi(var);
					
					if (tmp > 0 && tmp < 500) {
						nack_size = tmp;
					}
				}

				switch_jb_create(&rtp_session->vbw, SJB_VIDEO, nack_size, nack_size, rtp_session->pool);

				if (rtp_session->vbw) {
					switch_jb_set_flag(rtp_session->vbw, SJB_QUEUE_ONLY);
					//switch_jb_debug_level(rtp_session->vbw, 10);
				}
			}
			switch_jb_put_packet(rtp_session->vbw, (switch_rtp_packet_t *)send_msg, bytes);
		}

#ifdef RTP_WRITE_PLOSS
		{
			int r = (rand() % 10000) + 1;

			if (r <= 200) {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ALERT,
								  "Simulate dropping packet ......... ts: %u seq: %u\n", ntohl(send_msg->header.ts), ntohs(send_msg->header.seq));
			} else {
				if (switch_socket_sendto(rtp_session->sock_output, rtp_session->remote_addr, 0, (void *) send_msg, &bytes) != SWITCH_STATUS_SUCCESS) {
					rtp_session->seq--;
					ret = -1;
					goto end;
				}
			}
		}
#else
		//if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
		//
		//	rtp_session->flags[SWITCH_RTP_FLAG_DEBUG_RTP_READ]++;
		//
		//	//switch_log_printf(SWITCH_CHANNEL_LOG, SWITCH_LOG_WARNING, "SEND %u\n", ntohs(send_msg->header.seq));
		//}
		if (switch_socket_sendto(rtp_session->sock_output, rtp_session->remote_addr, 0, (void *) send_msg, &bytes) != SWITCH_STATUS_SUCCESS) {
			rtp_session->seq -= delta;

			ret = -1;
			goto end;
		}
#endif
		rtp_session->last_write_ts = this_ts;
		rtp_session->flags[SWITCH_RTP_FLAG_RESET] = 0;

		if (rtp_session->queue_delay) {
			rtp_session->delay_samples = rtp_session->queue_delay;
			rtp_session->queue_delay = 0;
		}

		rtp_session->stats.outbound.raw_bytes += bytes;
		rtp_session->stats.outbound.packet_count++;

		if (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {
			rtp_session->stats.rtcp.sent_pkt_count++;
		}

		if (send_msg->header.pt == rtp_session->cng_pt) {
			rtp_session->stats.outbound.cng_packet_count++;
		} else {
			rtp_session->stats.outbound.media_packet_count++;
			rtp_session->stats.outbound.media_bytes += bytes;
		}

		if (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER]) {
			//switch_core_timer_sync(&rtp_session->write_timer);
			rtp_session->last_write_samplecount = rtp_session->write_timer.samplecount;
		}

		rtp_session->last_write_timestamp = switch_micro_time_now();
	}

	ret = (int) bytes;

 end:

	WRITE_DEC(rtp_session);

	return ret;
}
