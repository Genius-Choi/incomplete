long FS_FOpenFileRead( const char *filename, fileHandle_t *file, qboolean uniqueFILE ) {
	searchpath_t	*search;
	char			*netpath;
	pack_t			*pak;
	fileInPack_t	*pakFile;
	directory_t		*dir;
	long			hash;
	//unz_s			*zfi;
	//void			*temp;
	int				l;

	hash = 0;

	FS_AssertInitialised();

	if ( file == NULL ) {
		Com_Error( ERR_FATAL, "FS_FOpenFileRead: NULL 'file' parameter passed\n" );
	}

	if ( !filename ) {
		Com_Error( ERR_FATAL, "FS_FOpenFileRead: NULL 'filename' parameter passed\n" );
	}

	// qpaths are not supposed to have a leading slash
	if ( filename[0] == '/' || filename[0] == '\\' ) {
		filename++;
	}

	// make absolutely sure that it can't back up the path.
	// The searchpaths do guarantee that something will always
	// be prepended, so we don't need to worry about "c:" or "//limbo"
	if ( strstr( filename, ".." ) || strstr( filename, "::" ) ) {
		*file = 0;
		return -1;
	}

	// make sure the q3key file is only readable by the quake3.exe at initialization
	// any other time the key should only be accessed in memory using the provided functions
	if( com_fullyInitialized && strstr( filename, "q3key" ) ) {
		*file = 0;
		return -1;
	}

	//
	// search through the path, one element at a time
	//

	*file = FS_HandleForFile();
	fsh[*file].handleFiles.unique = uniqueFILE;

	// this new bool is in for an optimisation, if you (eg) opened a BSP file under fs_copyfiles==2,
	//	then it triggered a copy operation to update your local HD version, then this will re-open the
	//	file handle on your local version, not the net build. This uses a bit more CPU to re-do the loop
	//	logic, but should read faster than accessing the net version a second time.
	//
	qboolean bFasterToReOpenUsingNewLocalFile = qfalse;

	do
	{
		bFasterToReOpenUsingNewLocalFile = qfalse;

		for ( search = fs_searchpaths ; search ; search = search->next ) {
			//
			if ( search->pack ) {
				hash = FS_HashFileName(filename, search->pack->hashSize);
			}
			// is the element a pak file?
			if ( search->pack && search->pack->hashTable[hash] ) {
				// disregard if it doesn't match one of the allowed pure pak files
				if ( !FS_PakIsPure(search->pack) ) {
					continue;
				}

				// look through all the pak file elements
				pak = search->pack;
				pakFile = pak->hashTable[hash];
				do {
					// case and separator insensitive comparisons
					if ( !FS_FilenameCompare( pakFile->name, filename ) ) {
						// found it!

						// mark the pak as having been referenced and mark specifics on cgame and ui
						// shaders, txt, arena files  by themselves do not count as a reference as
						// these are loaded from all pk3s
						// from every pk3 file..

						// The x86.dll suffixes are needed in order for sv_pure to continue to
						// work on non-x86/windows systems...

						l = strlen( filename );
						if ( !(pak->referenced & FS_GENERAL_REF)) {
							if( !FS_IsExt(filename, ".shader", l) &&
							    !FS_IsExt(filename, ".txt", l) &&
							    !FS_IsExt(filename, ".str", l) &&
							    !FS_IsExt(filename, ".cfg", l) &&
							    !FS_IsExt(filename, ".config", l) &&
							    !FS_IsExt(filename, ".bot", l) &&
							    !FS_IsExt(filename, ".arena", l) &&
							    !FS_IsExt(filename, ".menu", l) &&
							    !FS_IsExt(filename, ".fcf", l) &&
							    Q_stricmp(filename, "jampgamex86.dll") != 0 &&
							    //Q_stricmp(filename, "vm/qagame.qvm") != 0 &&
							    !strstr(filename, "levelshots"))
							{
								pak->referenced |= FS_GENERAL_REF;
							}
						}

						if (!(pak->referenced & FS_CGAME_REF))
						{
							if ( Q_stricmp( filename, "cgame.qvm" ) == 0 ||
									Q_stricmp( filename, "cgamex86.dll" ) == 0 )
							{
								pak->referenced |= FS_CGAME_REF;
							}
						}

						if (!(pak->referenced & FS_UI_REF))
						{
							if ( Q_stricmp( filename, "ui.qvm" ) == 0 ||
									Q_stricmp( filename, "uix86.dll" ) == 0 )
							{
								pak->referenced |= FS_UI_REF;
							}
						}

						if ( uniqueFILE ) {
							// open a new file on the pakfile
							fsh[*file].handleFiles.file.z = unzOpen (pak->pakFilename);
							if (fsh[*file].handleFiles.file.z == NULL) {
								Com_Error (ERR_FATAL, "Couldn't open %s", pak->pakFilename);
							}
						} else {
							fsh[*file].handleFiles.file.z = pak->handle;
						}
						Q_strncpyz( fsh[*file].name, filename, sizeof( fsh[*file].name ) );
						fsh[*file].zipFile = qtrue;

						// set the file position in the zip file (also sets the current file info)
						unzSetOffset(fsh[*file].handleFiles.file.z, pakFile->pos);

						// open the file in the zip
						unzOpenCurrentFile(fsh[*file].handleFiles.file.z);

#if 0
						zfi = (unz_s *)fsh[*file].handleFiles.file.z;
						// in case the file was new
						temp = zfi->filestream;
						// set the file position in the zip file (also sets the current file info)
						unzSetOffset(pak->handle, pakFile->pos);
						// copy the file info into the unzip structure
						Com_Memcpy( zfi, pak->handle, sizeof(unz_s) );
						// we copy this back into the structure
						zfi->filestream = temp;
						// open the file in the zip
						unzOpenCurrentFile( fsh[*file].handleFiles.file.z );
#endif
						fsh[*file].zipFilePos = pakFile->pos;
						fsh[*file].zipFileLen = pakFile->len;

						if ( fs_debug->integer ) {
							Com_Printf( "FS_FOpenFileRead: %s (found in '%s')\n",
								filename, pak->pakFilename );
						}
	#ifndef DEDICATED
	#ifndef FINAL_BUILD
						// Check for unprecached files when in game but not in the menus
						if((cls.state == CA_ACTIVE) && !(Key_GetCatcher( ) & KEYCATCH_UI))
						{
							Com_Printf(S_COLOR_YELLOW "WARNING: File %s not precached\n", filename);
						}
	#endif
	#endif // DEDICATED
						return pakFile->len;
					}
					pakFile = pakFile->next;
				} while(pakFile != NULL);
			} else if ( search->dir ) {
				// check a file in the directory tree

				// if we are running restricted, the only files we
				// will allow to come from the directory are .cfg files
				l = strlen( filename );
		  // FIXME TTimo I'm not sure about the fs_numServerPaks test
		  // if you are using FS_ReadFile to find out if a file exists,
		  //   this test can make the search fail although the file is in the directory
		  // I had the problem on https://zerowing.idsoftware.com/bugzilla/show_bug.cgi?id=8
		  // turned out I used FS_FileExists instead
				if ( fs_numServerPaks ) {
					if ( !FS_IsExt( filename, ".cfg", l ) &&		// for config files
					    !FS_IsExt( filename, ".fcf", l ) &&		// force configuration files
					    !FS_IsExt( filename, ".menu", l ) &&		// menu files
					    !FS_IsExt( filename, ".game", l ) &&		// menu files
					    !FS_IsExt( filename, ".dat", l ) &&		// for journal files
					    !FS_IsDemoExt( filename, l ) ) {			// demos
						continue;
					}
				}

				dir = search->dir;

				netpath = FS_BuildOSPath( dir->path, dir->gamedir, filename );
				fsh[*file].handleFiles.file.o = fopen (netpath, "rb");
				if ( !fsh[*file].handleFiles.file.o ) {
					continue;
				}

				if ( !FS_IsExt( filename, ".cfg", l ) &&		// for config files
					!FS_IsExt( filename, ".fcf", l ) &&		// force configuration files
					!FS_IsExt( filename, ".menu", l ) &&		// menu files
					!FS_IsExt( filename, ".game", l ) &&		// menu files
					!FS_IsExt( filename, ".dat", l ) &&		// for journal files
					!FS_IsDemoExt( filename, l ) ) {			// demos
					fs_fakeChkSum = Q_flrand(0.0f, 1.0f);
				}
#ifdef _WIN32
				// if running with fs_copyfiles 2, and search path == local, then we need to fail to open
				//	if the time/date stamp != the network version (so it'll loop round again and use the network path,
				//	which comes later in the search order)
				//
				if ( fs_copyfiles->integer == 2 && fs_cdpath->string[0] && !Q_stricmp( dir->path, fs_basepath->string )
					&& FS_FileCacheable(filename) )
				{
					if ( Sys_FileOutOfDate( netpath, FS_BuildOSPath( fs_cdpath->string, dir->gamedir, filename ) ))
					{
						fclose(fsh[*file].handleFiles.file.o);
						fsh[*file].handleFiles.file.o = 0;
						continue;	//carry on to find the cdpath version.
					}
				}
#endif
				Q_strncpyz( fsh[*file].name, filename, sizeof( fsh[*file].name ) );
				fsh[*file].zipFile = qfalse;
				if ( fs_debug->integer ) {
					Com_Printf( "FS_FOpenFileRead: %s (found in '%s%c%s')\n", filename,
						dir->path, PATH_SEP, dir->gamedir );
				}

#ifdef _WIN32
				// if we are getting it from the cdpath, optionally copy it
				//  to the basepath
				if ( fs_copyfiles->integer && !Q_stricmp( dir->path, fs_cdpath->string ) ) {
					char	*copypath;

					copypath = FS_BuildOSPath( fs_basepath->string, dir->gamedir, filename );
					switch ( fs_copyfiles->integer )
					{
						default:
						case 1:
						{
							FS_CopyFile( netpath, copypath );
						}
						break;

						case 2:
						{

							if (FS_FileCacheable(filename) )
							{
								// maybe change this to Com_DPrintf?   On the other hand...
								//
								Com_Printf( "fs_copyfiles(2), Copying: %s to %s\n", netpath, copypath );

								FS_CreatePath( copypath );

								bool bOk = true;
								if (!CopyFile( netpath, copypath, FALSE ))
								{
									DWORD dwAttrs = GetFileAttributes(copypath);
									SetFileAttributes(copypath, dwAttrs & ~FILE_ATTRIBUTE_READONLY);
									bOk = !!CopyFile( netpath, copypath, FALSE );
								}

								if (bOk)
								{
									// clear this handle and setup for re-opening of the new local copy...
									//
									bFasterToReOpenUsingNewLocalFile = qtrue;
									fclose(fsh[*file].handleFiles.file.o);
									fsh[*file].handleFiles.file.o = NULL;
								}
							}
						}
						break;
					}
				}
#endif
				if (bFasterToReOpenUsingNewLocalFile)
				{
					break;	// and re-read the local copy, not the net version
				}

	#ifndef DEDICATED
	#ifndef FINAL_BUILD
				// Check for unprecached files when in game but not in the menus
				if((cls.state == CA_ACTIVE) && !(Key_GetCatcher( ) & KEYCATCH_UI))
				{
					Com_Printf(S_COLOR_YELLOW "WARNING: File %s not precached\n", filename);
				}
	#endif
	#endif // dedicated
				return FS_fplength(fsh[*file].handleFiles.file.o);
			}
		}
	}
	while ( bFasterToReOpenUsingNewLocalFile );

	Com_DPrintf ("Can't find %s\n", filename);
#ifdef FS_MISSING
	if (missingFiles) {
		fprintf(missingFiles, "%s\n", filename);
	}
#endif
	*file = 0;
	return -1;
}
