static Handle<HiddenClass> getHiddenClassForBuffer(
    Runtime &runtime,
    CodeBlock *curCodeBlock,
    unsigned numLiterals,
    unsigned keyBufferIndex) {
  RuntimeModule *runtimeModule = curCodeBlock->getRuntimeModule();
  if (auto clazzOpt = runtimeModule->findCachedLiteralHiddenClass(
          runtime, keyBufferIndex, numLiterals))
    return *clazzOpt;

  MutableHandle<> tmpHandleKey{runtime};
  MutableHandle<HiddenClass> clazz =
      runtime.makeMutableHandle(runtime.getHiddenClassForPrototypeRaw(
          vmcast<JSObject>(runtime.objectPrototype),
          JSObject::numOverlapSlots<JSObject>()));

  GCScopeMarkerRAII marker{runtime};
  auto keyGen =
      curCodeBlock->getObjectBufferKeyIter(keyBufferIndex, numLiterals);
  while (keyGen.hasNext()) {
    auto key = keyGen.get(runtime);
    SymbolID sym = [&] {
      if (key.isSymbol())
        return ID(key.getSymbol().unsafeGetIndex());

      assert(key.isNumber() && "Key must be symbol or number");
      tmpHandleKey = key;
      // Note that since this handle has been created, the associated symbol
      // will be automatically kept alive until we flush the marker.
      // valueToSymbolID cannot fail because the key is known to be uint32.
      Handle<SymbolID> symHandle = *valueToSymbolID(runtime, tmpHandleKey);
      return *symHandle;
    }();
    auto addResult = HiddenClass::addProperty(
        clazz, runtime, sym, PropertyFlags::defaultNewNamedPropertyFlags());
    clazz = addResult->first;
    marker.flush();
  }

  if (LLVM_LIKELY(!clazz->isDictionary())) {
    assert(
        numLiterals == clazz->getNumProperties() &&
        "numLiterals should match hidden class property count.");
    assert(
        clazz->getNumProperties() < 256 &&
        "cached hidden class should have property count less than 256");
    runtimeModule->tryCacheLiteralHiddenClass(runtime, keyBufferIndex, *clazz);
  }

  return {clazz};
}
