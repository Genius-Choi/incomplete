void Filter::maybeDoShadowing() {
  for (const auto& shadow_policy_wrapper : active_shadow_policies_) {
    const auto& shadow_policy = shadow_policy_wrapper.get();

    const absl::optional<absl::string_view> shadow_cluster_name =
        getShadowCluster(shadow_policy, *downstream_headers_);

    // The cluster name got from headers is empty.
    if (!shadow_cluster_name.has_value()) {
      continue;
    }

    Http::RequestMessagePtr request(new Http::RequestMessageImpl(
        Http::createHeaderMap<Http::RequestHeaderMapImpl>(*shadow_headers_)));
    if (callbacks_->decodingBuffer()) {
      request->body().add(*callbacks_->decodingBuffer());
    }
    if (shadow_trailers_) {
      request->trailers(Http::createHeaderMap<Http::RequestTrailerMapImpl>(*shadow_trailers_));
    }

    auto options = Http::AsyncClient::RequestOptions()
                       .setTimeout(timeout_.global_timeout_)
                       .setParentSpan(callbacks_->activeSpan())
                       .setChildSpanName("mirror")
                       .setSampled(shadow_policy.traceSampled())
                       .setIsShadow(true);
    options.setFilterConfig(config_);
    config_.shadowWriter().shadow(std::string(shadow_cluster_name.value()), std::move(request),
                                  options);
  }
}
