int get_ctty(pid_t pid, dev_t *ret_devnr, char **ret) {
        _cleanup_free_ char *fn = NULL, *b = NULL;
        dev_t devnr;
        int r;

        r = get_ctty_devnr(pid, &devnr);
        if (r < 0)
                return r;

        r = device_path_make_canonical(S_IFCHR, devnr, &fn);
        if (r < 0) {
                if (r != -ENOENT) /* No symlink for this in /dev/char/? */
                        return r;

                if (major(devnr) == 136) {
                        /* This is an ugly hack: PTY devices are not listed in /dev/char/, as they don't follow the
                         * Linux device model. This means we have no nice way to match them up against their actual
                         * device node. Let's hence do the check by the fixed, assigned major number. Normally we try
                         * to avoid such fixed major/minor matches, but there appears to nother nice way to handle
                         * this. */

                        if (asprintf(&b, "pts/%u", minor(devnr)) < 0)
                                return -ENOMEM;
                } else {
                        /* Probably something similar to the ptys which have no symlink in /dev/char/. Let's return
                         * something vaguely useful. */

                        r = device_path_make_major_minor(S_IFCHR, devnr, &fn);
                        if (r < 0)
                                return r;
                }
        }

        if (!b) {
                const char *w;

                w = path_startswith(fn, "/dev/");
                if (w) {
                        b = strdup(w);
                        if (!b)
                                return -ENOMEM;
                } else
                        b = TAKE_PTR(fn);
        }

        if (ret)
                *ret = TAKE_PTR(b);

        if (ret_devnr)
                *ret_devnr = devnr;

        return 0;
}
