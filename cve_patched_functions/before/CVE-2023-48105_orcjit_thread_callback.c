orcjit_thread_callback(void *arg)
{
    OrcJitThreadArg *thread_arg = (OrcJitThreadArg *)arg;
#if WASM_ENABLE_JIT != 0
    AOTCompContext *comp_ctx = thread_arg->comp_ctx;
#endif
    WASMModule *module = thread_arg->module;
    uint32 group_idx = thread_arg->group_idx;
    uint32 group_stride = WASM_ORC_JIT_BACKEND_THREAD_NUM;
    uint32 func_count = module->function_count;
    uint32 i;

#if WASM_ENABLE_FAST_JIT != 0
    /* Compile fast jit funcitons of this group */
    for (i = group_idx; i < func_count; i += group_stride) {
        if (!jit_compiler_compile(module, i + module->import_function_count)) {
            os_printf("failed to compile fast jit function %u\n", i);
            break;
        }

        if (module->orcjit_stop_compiling) {
            return NULL;
        }
    }
#if WASM_ENABLE_JIT != 0 && WASM_ENABLE_LAZY_JIT != 0
    os_mutex_lock(&module->tierup_wait_lock);
    module->fast_jit_ready_groups++;
    os_mutex_unlock(&module->tierup_wait_lock);
#endif
#endif

#if WASM_ENABLE_FAST_JIT != 0 && WASM_ENABLE_JIT != 0 \
    && WASM_ENABLE_LAZY_JIT != 0
    /* For JIT tier-up, set each llvm jit func to call_to_fast_jit */
    for (i = group_idx; i < func_count;
         i += group_stride * WASM_ORC_JIT_COMPILE_THREAD_NUM) {
        uint32 j;

        for (j = 0; j < WASM_ORC_JIT_COMPILE_THREAD_NUM; j++) {
            if (i + j * group_stride < func_count) {
                if (!jit_compiler_set_call_to_fast_jit(
                        module,
                        i + j * group_stride + module->import_function_count)) {
                    os_printf(
                        "failed to compile call_to_fast_jit for func %u\n",
                        i + j * group_stride + module->import_function_count);
                    module->orcjit_stop_compiling = true;
                    return NULL;
                }
            }
            if (module->orcjit_stop_compiling) {
                return NULL;
            }
        }
    }

    /* Wait until init_llvm_jit_functions_stage2 finishes and all
       fast jit functions are compiled */
    os_mutex_lock(&module->tierup_wait_lock);
    while (!(module->llvm_jit_inited && module->enable_llvm_jit_compilation
             && module->fast_jit_ready_groups >= group_stride)) {
        os_cond_reltimedwait(&module->tierup_wait_cond,
                             &module->tierup_wait_lock, 10000);
        if (module->orcjit_stop_compiling) {
            /* init_llvm_jit_functions_stage2 failed */
            os_mutex_unlock(&module->tierup_wait_lock);
            return NULL;
        }
    }
    os_mutex_unlock(&module->tierup_wait_lock);
#endif

#if WASM_ENABLE_JIT != 0
    /* Compile llvm jit functions of this group */
    for (i = group_idx; i < func_count;
         i += group_stride * WASM_ORC_JIT_COMPILE_THREAD_NUM) {
        LLVMOrcJITTargetAddress func_addr = 0;
        LLVMErrorRef error;
        char func_name[48];
        typedef void (*F)(void);
        union {
            F f;
            void *v;
        } u;
        uint32 j;

        snprintf(func_name, sizeof(func_name), "%s%d%s", AOT_FUNC_PREFIX, i,
                 "_wrapper");
        LOG_DEBUG("compile llvm jit func %s", func_name);
        error =
            LLVMOrcLLLazyJITLookup(comp_ctx->orc_jit, &func_addr, func_name);
        if (error != LLVMErrorSuccess) {
            char *err_msg = LLVMGetErrorMessage(error);
            os_printf("failed to compile llvm jit function %u: %s", i, err_msg);
            LLVMDisposeErrorMessage(err_msg);
            break;
        }

        /* Call the jit wrapper function to trigger its compilation, so as
           to compile the actual jit functions, since we add the latter to
           function list in the PartitionFunction callback */
        u.v = (void *)func_addr;
        u.f();

        for (j = 0; j < WASM_ORC_JIT_COMPILE_THREAD_NUM; j++) {
            if (i + j * group_stride < func_count) {
                module->func_ptrs_compiled[i + j * group_stride] = true;
#if WASM_ENABLE_FAST_JIT != 0 && WASM_ENABLE_LAZY_JIT != 0
                snprintf(func_name, sizeof(func_name), "%s%d", AOT_FUNC_PREFIX,
                         i + j * group_stride);
                error = LLVMOrcLLLazyJITLookup(comp_ctx->orc_jit, &func_addr,
                                               func_name);
                if (error != LLVMErrorSuccess) {
                    char *err_msg = LLVMGetErrorMessage(error);
                    os_printf("failed to compile llvm jit function %u: %s", i,
                              err_msg);
                    LLVMDisposeErrorMessage(err_msg);
                    /* Ignore current llvm jit func, as its func ptr is
                       previous set to call_to_fast_jit, which also works */
                    continue;
                }

                jit_compiler_set_llvm_jit_func_ptr(
                    module,
                    i + j * group_stride + module->import_function_count,
                    (void *)func_addr);

                /* Try to switch to call this llvm jit funtion instead of
                   fast jit function from fast jit jitted code */
                jit_compiler_set_call_to_llvm_jit(
                    module,
                    i + j * group_stride + module->import_function_count);
#endif
            }
        }

        if (module->orcjit_stop_compiling) {
            break;
        }
    }
#endif

    return NULL;
}
