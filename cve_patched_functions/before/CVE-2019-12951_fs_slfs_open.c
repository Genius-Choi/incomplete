int fs_slfs_open(const char *pathname, int flags, mode_t mode) {
  int fd;
  for (fd = 0; fd < MAX_OPEN_SLFS_FILES; fd++) {
    if (s_sl_fds[fd].fh <= 0) break;
  }
  if (fd >= MAX_OPEN_SLFS_FILES) return set_errno(ENOMEM);
  struct sl_fd_info *fi = &s_sl_fds[fd];

  /*
   * Apply path manipulations again, in case we got here directly
   * (via TI libc's "add_device").
   */
  pathname = drop_dir(pathname, NULL);

  _u32 am = 0;
  fi->size = (size_t) -1;
  int rw = (flags & 3);
  size_t new_size = 0;
  struct sl_file_open_info *foi =
      fs_slfs_find_foi(pathname, false /* create */);
  if (foi != NULL) {
    LOG(LL_DEBUG, ("FOI for %s: %d 0x%x %p", pathname, (int) foi->size,
                   (unsigned int) foi->flags, foi->token));
  }
  if (rw == O_RDONLY) {
    SlFsFileInfo_t sl_fi;
    _i32 r = sl_FsGetInfo((const _u8 *) pathname, 0, &sl_fi);
    if (r == SL_FS_OK) {
      fi->size = SL_FI_FILE_SIZE(sl_fi);
    }
    am = SL_FS_READ;
  } else {
    if (!(flags & O_TRUNC) || (flags & O_APPEND)) {
      // FailFS files cannot be opened for append and will be truncated
      // when opened for write.
      return set_errno(ENOTSUP);
    }
    if (flags & O_CREAT) {
      if (foi->size > 0) {
        new_size = foi->size;
      } else {
        new_size = FS_SLFS_MAX_FILE_SIZE;
      }
      am = FS_MODE_OPEN_CREATE(new_size, 0);
    } else {
      am = SL_FS_WRITE;
    }
#if SL_MAJOR_VERSION_NUM >= 2
    am |= SL_FS_OVERWRITE;
#endif
  }
  uint32_t *token = NULL;
  if (foi != NULL) {
    am |= foi->flags;
    token = foi->token;
  }
  fi->fh = slfs_open((_u8 *) pathname, am, token);
  LOG(LL_DEBUG, ("sl_FsOpen(%s, 0x%x, %p) sz %u = %d", pathname, (int) am,
                 token, (unsigned int) new_size, (int) fi->fh));
  int r;
  if (fi->fh >= 0) {
    fi->pos = 0;
    r = fd;
  } else {
    r = set_errno(sl_fs_to_errno(fi->fh));
  }
  return r;
}
