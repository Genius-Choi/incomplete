do_encrypt_fn (const RIJNDAEL_context *ctx, unsigned char *b,
               const unsigned char *a)
{
#define rk (ctx->keyschenc32)
  const byte *sbox = ((const byte *)encT) + 1;
  int rounds = ctx->rounds;
  int r;
  u32 sa[4];
  u32 sb[4];

  sb[0] = buf_get_le32(a + 0);
  sb[1] = buf_get_le32(a + 4);
  sb[2] = buf_get_le32(a + 8);
  sb[3] = buf_get_le32(a + 12);

  sa[0] = sb[0] ^ rk[0][0];
  sa[1] = sb[1] ^ rk[0][1];
  sa[2] = sb[2] ^ rk[0][2];
  sa[3] = sb[3] ^ rk[0][3];

  sb[0] = rol(encT[(byte)(sa[0] >> (0 * 8))], (0 * 8));
  sb[3] = rol(encT[(byte)(sa[0] >> (1 * 8))], (1 * 8));
  sb[2] = rol(encT[(byte)(sa[0] >> (2 * 8))], (2 * 8));
  sb[1] = rol(encT[(byte)(sa[0] >> (3 * 8))], (3 * 8));
  sa[0] = rk[1][0] ^ sb[0];

  sb[1] ^= rol(encT[(byte)(sa[1] >> (0 * 8))], (0 * 8));
  sa[0] ^= rol(encT[(byte)(sa[1] >> (1 * 8))], (1 * 8));
  sb[3] ^= rol(encT[(byte)(sa[1] >> (2 * 8))], (2 * 8));
  sb[2] ^= rol(encT[(byte)(sa[1] >> (3 * 8))], (3 * 8));
  sa[1] = rk[1][1] ^ sb[1];

  sb[2] ^= rol(encT[(byte)(sa[2] >> (0 * 8))], (0 * 8));
  sa[1] ^= rol(encT[(byte)(sa[2] >> (1 * 8))], (1 * 8));
  sa[0] ^= rol(encT[(byte)(sa[2] >> (2 * 8))], (2 * 8));
  sb[3] ^= rol(encT[(byte)(sa[2] >> (3 * 8))], (3 * 8));
  sa[2] = rk[1][2] ^ sb[2];

  sb[3] ^= rol(encT[(byte)(sa[3] >> (0 * 8))], (0 * 8));
  sa[2] ^= rol(encT[(byte)(sa[3] >> (1 * 8))], (1 * 8));
  sa[1] ^= rol(encT[(byte)(sa[3] >> (2 * 8))], (2 * 8));
  sa[0] ^= rol(encT[(byte)(sa[3] >> (3 * 8))], (3 * 8));
  sa[3] = rk[1][3] ^ sb[3];

  for (r = 2; r < rounds; r++)
    {
      sb[0] = rol(encT[(byte)(sa[0] >> (0 * 8))], (0 * 8));
      sb[3] = rol(encT[(byte)(sa[0] >> (1 * 8))], (1 * 8));
      sb[2] = rol(encT[(byte)(sa[0] >> (2 * 8))], (2 * 8));
      sb[1] = rol(encT[(byte)(sa[0] >> (3 * 8))], (3 * 8));
      sa[0] = rk[r][0] ^ sb[0];

      sb[1] ^= rol(encT[(byte)(sa[1] >> (0 * 8))], (0 * 8));
      sa[0] ^= rol(encT[(byte)(sa[1] >> (1 * 8))], (1 * 8));
      sb[3] ^= rol(encT[(byte)(sa[1] >> (2 * 8))], (2 * 8));
      sb[2] ^= rol(encT[(byte)(sa[1] >> (3 * 8))], (3 * 8));
      sa[1] = rk[r][1] ^ sb[1];

      sb[2] ^= rol(encT[(byte)(sa[2] >> (0 * 8))], (0 * 8));
      sa[1] ^= rol(encT[(byte)(sa[2] >> (1 * 8))], (1 * 8));
      sa[0] ^= rol(encT[(byte)(sa[2] >> (2 * 8))], (2 * 8));
      sb[3] ^= rol(encT[(byte)(sa[2] >> (3 * 8))], (3 * 8));
      sa[2] = rk[r][2] ^ sb[2];

      sb[3] ^= rol(encT[(byte)(sa[3] >> (0 * 8))], (0 * 8));
      sa[2] ^= rol(encT[(byte)(sa[3] >> (1 * 8))], (1 * 8));
      sa[1] ^= rol(encT[(byte)(sa[3] >> (2 * 8))], (2 * 8));
      sa[0] ^= rol(encT[(byte)(sa[3] >> (3 * 8))], (3 * 8));
      sa[3] = rk[r][3] ^ sb[3];

      r++;

      sb[0] = rol(encT[(byte)(sa[0] >> (0 * 8))], (0 * 8));
      sb[3] = rol(encT[(byte)(sa[0] >> (1 * 8))], (1 * 8));
      sb[2] = rol(encT[(byte)(sa[0] >> (2 * 8))], (2 * 8));
      sb[1] = rol(encT[(byte)(sa[0] >> (3 * 8))], (3 * 8));
      sa[0] = rk[r][0] ^ sb[0];

      sb[1] ^= rol(encT[(byte)(sa[1] >> (0 * 8))], (0 * 8));
      sa[0] ^= rol(encT[(byte)(sa[1] >> (1 * 8))], (1 * 8));
      sb[3] ^= rol(encT[(byte)(sa[1] >> (2 * 8))], (2 * 8));
      sb[2] ^= rol(encT[(byte)(sa[1] >> (3 * 8))], (3 * 8));
      sa[1] = rk[r][1] ^ sb[1];

      sb[2] ^= rol(encT[(byte)(sa[2] >> (0 * 8))], (0 * 8));
      sa[1] ^= rol(encT[(byte)(sa[2] >> (1 * 8))], (1 * 8));
      sa[0] ^= rol(encT[(byte)(sa[2] >> (2 * 8))], (2 * 8));
      sb[3] ^= rol(encT[(byte)(sa[2] >> (3 * 8))], (3 * 8));
      sa[2] = rk[r][2] ^ sb[2];

      sb[3] ^= rol(encT[(byte)(sa[3] >> (0 * 8))], (0 * 8));
      sa[2] ^= rol(encT[(byte)(sa[3] >> (1 * 8))], (1 * 8));
      sa[1] ^= rol(encT[(byte)(sa[3] >> (2 * 8))], (2 * 8));
      sa[0] ^= rol(encT[(byte)(sa[3] >> (3 * 8))], (3 * 8));
      sa[3] = rk[r][3] ^ sb[3];
    }

  /* Last round is special. */

  sb[0] = (sbox[(byte)(sa[0] >> (0 * 8)) * 4]) << (0 * 8);
  sb[3] = (sbox[(byte)(sa[0] >> (1 * 8)) * 4]) << (1 * 8);
  sb[2] = (sbox[(byte)(sa[0] >> (2 * 8)) * 4]) << (2 * 8);
  sb[1] = (sbox[(byte)(sa[0] >> (3 * 8)) * 4]) << (3 * 8);
  sa[0] = rk[r][0] ^ sb[0];

  sb[1] ^= (sbox[(byte)(sa[1] >> (0 * 8)) * 4]) << (0 * 8);
  sa[0] ^= (sbox[(byte)(sa[1] >> (1 * 8)) * 4]) << (1 * 8);
  sb[3] ^= (sbox[(byte)(sa[1] >> (2 * 8)) * 4]) << (2 * 8);
  sb[2] ^= (sbox[(byte)(sa[1] >> (3 * 8)) * 4]) << (3 * 8);
  sa[1] = rk[r][1] ^ sb[1];

  sb[2] ^= (sbox[(byte)(sa[2] >> (0 * 8)) * 4]) << (0 * 8);
  sa[1] ^= (sbox[(byte)(sa[2] >> (1 * 8)) * 4]) << (1 * 8);
  sa[0] ^= (sbox[(byte)(sa[2] >> (2 * 8)) * 4]) << (2 * 8);
  sb[3] ^= (sbox[(byte)(sa[2] >> (3 * 8)) * 4]) << (3 * 8);
  sa[2] = rk[r][2] ^ sb[2];

  sb[3] ^= (sbox[(byte)(sa[3] >> (0 * 8)) * 4]) << (0 * 8);
  sa[2] ^= (sbox[(byte)(sa[3] >> (1 * 8)) * 4]) << (1 * 8);
  sa[1] ^= (sbox[(byte)(sa[3] >> (2 * 8)) * 4]) << (2 * 8);
  sa[0] ^= (sbox[(byte)(sa[3] >> (3 * 8)) * 4]) << (3 * 8);
  sa[3] = rk[r][3] ^ sb[3];

  buf_put_le32(b + 0, sa[0]);
  buf_put_le32(b + 4, sa[1]);
  buf_put_le32(b + 8, sa[2]);
  buf_put_le32(b + 12, sa[3]);
#undef rk

  return (56 + 2*sizeof(int));
}
