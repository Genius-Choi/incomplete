translatePresentationContextList(LST_HEAD ** internalList,
                                 LST_HEAD ** SCUSCPRoleList,
                                 LST_HEAD ** userContextList)
{
    PRV_PRESENTATIONCONTEXTITEM
        * context;
    DUL_PRESENTATIONCONTEXT
        * userContext;
    DUL_SUBITEM
        * subItem;
    DUL_TRANSFERSYNTAX
        * transfer;
    PRV_SCUSCPROLE
        * scuscpRole;
    OFCondition cond = EC_Normal;

    context = (PRV_PRESENTATIONCONTEXTITEM*)LST_Head(internalList);
    (void) LST_Position(internalList, (LST_NODE*)context);
    while (context != NULL) {
        userContext = (DUL_PRESENTATIONCONTEXT*)malloc(sizeof(DUL_PRESENTATIONCONTEXT));
        if (userContext == NULL) return EC_MemoryExhausted;
        if ((userContext->proposedTransferSyntax = LST_Create()) == NULL) return EC_MemoryExhausted;

        userContext->acceptedTransferSyntax[0] = '\0';
        userContext->presentationContextID = context->contextID;
        OFStandard::strlcpy(userContext->abstractSyntax, context->abstractSyntax.data, sizeof(userContext->abstractSyntax));
        userContext->proposedSCRole = DUL_SC_ROLE_DEFAULT;
        userContext->acceptedSCRole = DUL_SC_ROLE_DEFAULT;

        scuscpRole = findSCUSCPRole(SCUSCPRoleList,
                                    userContext->abstractSyntax);
        if (scuscpRole != NULL) {
            if (scuscpRole->SCURole == scuscpRole->SCPRole) {
                userContext->proposedSCRole = DUL_SC_ROLE_SCUSCP;
                if (scuscpRole->SCURole == 0)
                    DCMNET_WARN("DULFSM: both role fields are 0 in SCP/SCU role selection sub-item");
            }
            else if (scuscpRole->SCURole == 1)
                userContext->proposedSCRole = DUL_SC_ROLE_SCU;
            else  // SCPRole == 1
                userContext->proposedSCRole = DUL_SC_ROLE_SCP;
        }
        subItem = (DUL_SUBITEM*)LST_Head(&context->transferSyntaxList);
        if (subItem == NULL)
        {
            char buf1[256];
            sprintf(buf1, "DUL Peer supplied illegal number of transfer syntaxes (%d)", 0);
            free(userContext);
            return makeDcmnetCondition(DULC_PEERILLEGALXFERSYNTAXCOUNT, OF_error, buf1);
        }
        (void) LST_Position(&context->transferSyntaxList, (LST_NODE*)subItem);
        while (subItem != NULL) {
            transfer = (DUL_TRANSFERSYNTAX*)malloc(sizeof(DUL_TRANSFERSYNTAX));
            if (transfer == NULL) return EC_MemoryExhausted;
            OFStandard::strlcpy(transfer->transferSyntax, subItem->data, sizeof(transfer->transferSyntax));

            LST_Enqueue(&userContext->proposedTransferSyntax, (LST_NODE*)transfer);
            subItem = (DUL_SUBITEM*)LST_Next(&context->transferSyntaxList);
        }
        LST_Enqueue(userContextList, (LST_NODE*)userContext);
        context = (PRV_PRESENTATIONCONTEXTITEM*)LST_Next(internalList);
    }
    return EC_Normal;
}
