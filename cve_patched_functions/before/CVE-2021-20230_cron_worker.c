NOEXPORT void cron_worker(void) {
    time_t now, then;
    int delay;
#if !defined(OPENSSL_NO_DH) && OPENSSL_VERSION_NUMBER>=0x0090800fL
    BN_GENCB *bn_gencb;
#endif

    s_log(LOG_DEBUG, "Cron thread initialized");
#if !defined(OPENSSL_NO_DH) && OPENSSL_VERSION_NUMBER>=0x0090800fL
    bn_gencb=cron_bn_gencb();
#endif
    time(&then);
    for(;;) {
        s_log(LOG_INFO, "Executing cron jobs");
#ifndef OPENSSL_NO_DH
#if OPENSSL_VERSION_NUMBER>=0x0090800fL
        cron_dh_param(bn_gencb);
#else /* OpenSSL older than 0.9.8 */
        cron_dh_param();
#endif /* OpenSSL 0.9.8 or later */
#endif /* OPENSSL_NO_DH */
        time(&now);
        s_log(LOG_INFO, "Cron jobs completed in %d seconds", (int)(now-then));
        then+=CRON_PERIOD;
        if(then>now) {
            delay=(int)(then-now);
        } else {
            s_log(LOG_NOTICE, "Cron backlog cleared (possible hibernation)");
            delay=CRON_PERIOD-(int)(now-then)%CRON_PERIOD;
            then=now+delay;
        }
        s_log(LOG_DEBUG, "Waiting %d seconds", delay);
        do { /* retry s_poll_sleep() if it was interrupted by a signal */
            s_poll_sleep(delay, 0);
            time(&now);
            delay=(int)(then-now);
        } while(delay>0);
        s_log(LOG_INFO, "Reopening log file");
        signal_post(SIGNAL_REOPEN_LOG);
    }
}
