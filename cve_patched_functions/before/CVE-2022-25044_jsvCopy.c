JsVar *jsvCopy(JsVar *src, bool copyChildren) {
  if (jsvIsFlatString(src)) {
    // Copy a Flat String into a non-flat string - it's just safer
    return jsvNewFromStringVar(src, 0, JSVAPPENDSTRINGVAR_MAXLENGTH);
  }
  JsVar *dst = jsvNewWithFlags(src->flags & JSV_VARIABLEINFOMASK);
  if (!dst) return 0; // out of memory
  if (!jsvIsStringExt(src)) {
      bool refsAsData = jsvIsBasicString(src)||jsvIsNativeString(src)||jsvIsFlashString(src)||jsvIsNativeFunction(src);
      memcpy(&dst->varData, &src->varData, refsAsData ? JSVAR_DATA_STRING_LEN : JSVAR_DATA_STRING_NAME_LEN);
      if (jsvIsNativeFunction(src)) {
        jsvSetFirstChild(dst,0);
      }
      if (!refsAsData) {
        assert(jsvGetPrevSibling(dst) == 0);
        assert(jsvGetNextSibling(dst) == 0);
        assert(jsvGetFirstChild(dst) == 0);
      }
      assert(jsvGetLastChild(dst) == 0);
  } else {
    // stringexts use the extra pointers after varData to store characters
    // see jsvGetMaxCharactersInVar
    memcpy(&dst->varData, &src->varData, JSVAR_DATA_STRING_MAX_LEN);
    assert(jsvGetLastChild(dst) == 0);
  }

  // Copy what names point to
  if (copyChildren && jsvIsName(src)) {
    if (jsvGetFirstChild(src)) {
      if (jsvIsNameWithValue(src)) {
        // name_int/etc don't need references
        jsvSetFirstChild(dst, jsvGetFirstChild(src));
      } else {
        JsVar *child = jsvLock(jsvGetFirstChild(src));
        JsVar *childCopy = jsvRef(jsvCopy(child, true));
        jsvUnLock(child);
        if (childCopy) { // could have been out of memory
          jsvSetFirstChild(dst, jsvGetRef(childCopy));
          jsvUnLock(childCopy);
        }
      }
    }
  }

  if (jsvHasStringExt(src)) {
    // copy extra bits of string if there were any
    src = jsvLockAgain(src);
    JsVar *dstChild = jsvLockAgain(dst);
    while (jsvGetLastChild(src)) {
      JsVar *child = jsvLock(jsvGetLastChild(src));
      if (jsvIsStringExt(child)) {
        JsVar *childCopy = jsvNewWithFlags(child->flags & JSV_VARIABLEINFOMASK);
        if (childCopy) {// could be out of memory
          memcpy(&childCopy->varData, &child->varData, JSVAR_DATA_STRING_MAX_LEN);
          jsvSetLastChild(dstChild, jsvGetRef(childCopy)); // no ref for stringext
        }
        jsvUnLock2(src,dstChild);
        src = child;
        dstChild = childCopy;
      } else {
        JsVar *childCopy = jsvCopy(child, true);
        if (childCopy) {// could be out of memory
          jsvSetLastChild(dstChild, jsvGetRef(childCopy)); // no ref for stringext
          jsvUnLock(childCopy);
        }
        jsvUnLock2(src, dstChild);
        return dst;
      }
    }
    jsvUnLock2(src,dstChild);
  } else if (jsvHasChildren(src)) {
    if (copyChildren) {
      // Copy children..
      JsVarRef vr;
      vr = jsvGetFirstChild(src);
      while (vr) {
        JsVar *name = jsvLock(vr);
        JsVar *child = jsvCopyNameOnly(name, true/*link children*/, true/*keep as name*/); // NO DEEP COPY!
        if (child) { // could have been out of memory
          jsvAddName(dst, child);
          jsvUnLock(child);
        }
        vr = jsvGetNextSibling(name);
        jsvUnLock(name);
      }
    }
  } else {
    assert(jsvIsBasic(src)); // in case we missed something!
  }

  return dst;
}
