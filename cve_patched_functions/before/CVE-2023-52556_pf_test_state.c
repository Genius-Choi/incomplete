pf_test_state(struct pf_pdesc *pd, struct pf_state **stp, u_short *reason)
{
	int			 copyback = 0;
	struct pf_state_peer	*src, *dst;
	int			 action;
	struct inpcb		*inp = pd->m->m_pkthdr.pf.inp;
	u_int8_t		 psrc, pdst;

	action = PF_PASS;
	if (pd->dir == (*stp)->direction) {
		src = &(*stp)->src;
		dst = &(*stp)->dst;
		psrc = PF_PEER_SRC;
		pdst = PF_PEER_DST;
	} else {
		src = &(*stp)->dst;
		dst = &(*stp)->src;
		psrc = PF_PEER_DST;
		pdst = PF_PEER_SRC;
	}

	switch (pd->virtual_proto) {
	case IPPROTO_TCP:
		if ((action = pf_synproxy(pd, stp, reason)) != PF_PASS)
			return (action);
		if ((pd->hdr.tcp.th_flags & (TH_SYN|TH_ACK)) == TH_SYN) {

			if (dst->state >= TCPS_FIN_WAIT_2 &&
			    src->state >= TCPS_FIN_WAIT_2) {
				if (pf_status.debug >= LOG_NOTICE) {
					log(LOG_NOTICE, "pf: state reuse ");
					pf_print_state(*stp);
					pf_print_flags(pd->hdr.tcp.th_flags);
					addlog("\n");
				}
				/* XXX make sure it's the same direction ?? */
				(*stp)->timeout = PFTM_PURGE;
				pf_state_unref(*stp);
				*stp = NULL;
				pf_mbuf_link_inpcb(pd->m, inp);
				return (PF_DROP);
			} else if (dst->state >= TCPS_ESTABLISHED &&
			    src->state >= TCPS_ESTABLISHED) {
				/*
				 * SYN matches existing state???
				 * Typically happens when sender boots up after
				 * sudden panic. Certain protocols (NFSv3) are
				 * always using same port numbers. Challenge
				 * ACK enables all parties (firewall and peers)
				 * to get in sync again.
				 */
				pf_send_challenge_ack(pd, *stp, src, dst);
				return (PF_DROP);
			}
		}

		if ((*stp)->state_flags & PFSTATE_SLOPPY) {
			if (pf_tcp_track_sloppy(pd, stp, reason) == PF_DROP)
				return (PF_DROP);
		} else {
			if (pf_tcp_track_full(pd, stp, reason, &copyback,
			    PF_REVERSED_KEY((*stp)->key, pd->af)) == PF_DROP)
				return (PF_DROP);
		}
		break;
	case IPPROTO_UDP:
		/* update states */
		if (src->state < PFUDPS_SINGLE)
			pf_set_protostate(*stp, psrc, PFUDPS_SINGLE);
		if (dst->state == PFUDPS_SINGLE)
			pf_set_protostate(*stp, pdst, PFUDPS_MULTIPLE);

		/* update expire time */
		(*stp)->expire = getuptime();
		if (src->state == PFUDPS_MULTIPLE &&
		    dst->state == PFUDPS_MULTIPLE)
			(*stp)->timeout = PFTM_UDP_MULTIPLE;
		else
			(*stp)->timeout = PFTM_UDP_SINGLE;
		break;
	default:
		/* update states */
		if (src->state < PFOTHERS_SINGLE)
			pf_set_protostate(*stp, psrc, PFOTHERS_SINGLE);
		if (dst->state == PFOTHERS_SINGLE)
			pf_set_protostate(*stp, pdst, PFOTHERS_MULTIPLE);

		/* update expire time */
		(*stp)->expire = getuptime();
		if (src->state == PFOTHERS_MULTIPLE &&
		    dst->state == PFOTHERS_MULTIPLE)
			(*stp)->timeout = PFTM_OTHER_MULTIPLE;
		else
			(*stp)->timeout = PFTM_OTHER_SINGLE;
		break;
	}

	/* translate source/destination address, if necessary */
	if ((*stp)->key[PF_SK_WIRE] != (*stp)->key[PF_SK_STACK]) {
		struct pf_state_key	*nk;
		int			 afto, sidx, didx;

		if (PF_REVERSED_KEY((*stp)->key, pd->af))
			nk = (*stp)->key[pd->sidx];
		else
			nk = (*stp)->key[pd->didx];

		afto = pd->af != nk->af;
		sidx = afto ? pd->didx : pd->sidx;
		didx = afto ? pd->sidx : pd->didx;

#ifdef INET6
		if (afto) {
			pf_addrcpy(&pd->nsaddr, &nk->addr[sidx], nk->af);
			pf_addrcpy(&pd->ndaddr, &nk->addr[didx], nk->af);
			pd->naf = nk->af;
			action = PF_AFRT;
		}
#endif /* INET6 */

		if (!afto)
			pf_translate_a(pd, pd->src, &nk->addr[sidx]);

		if (pd->sport != NULL)
			pf_patch_16(pd, pd->sport, nk->port[sidx]);

		if (afto || PF_ANEQ(pd->dst, &nk->addr[didx], pd->af) ||
		    pd->rdomain != nk->rdomain)
			pd->destchg = 1;

		if (!afto)
			pf_translate_a(pd, pd->dst, &nk->addr[didx]);

		if (pd->dport != NULL)
			pf_patch_16(pd, pd->dport, nk->port[didx]);

		pd->m->m_pkthdr.ph_rtableid = nk->rdomain;
		copyback = 1;
	}

	if (copyback && pd->hdrlen > 0) {
		m_copyback(pd->m, pd->off, pd->hdrlen, &pd->hdr, M_NOWAIT);
	}

	return (action);
}
