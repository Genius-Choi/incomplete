static ut64 get_import_addr(ELFOBJ *bin, int sym) {
	if ((!bin->shdr || !bin->strtab) && !bin->phdr) {
		return UT64_MAX;
	}

	if (!bin->rel_cache) {
		return UT64_MAX;
	}

	// lookup the right rel/rela entry
	RBinElfReloc *rel = ht_up_find (bin->rel_cache, sym, NULL);
	if (!rel) {
		return UT64_MAX;
	}

	switch (bin->ehdr.e_machine) {
	case EM_ARM:
	case EM_AARCH64:
		return get_import_addr_arm (bin, rel);
	case EM_MIPS: // MIPS32 BIG ENDIAN relocs
		return get_import_addr_mips (bin, rel);
	case EM_VAX:
		// as beautiful as riscv <3
		return get_import_addr_riscv (bin, rel);
	case EM_RISCV:
		return get_import_addr_riscv (bin, rel);
	case EM_SPARC:
	case EM_SPARCV9:
	case EM_SPARC32PLUS:
		return get_import_addr_sparc (bin, rel);
	case EM_PPC:
	case EM_PPC64:
		return get_import_addr_ppc (bin, rel);
	case EM_386:
	case EM_X86_64:
		return get_import_addr_x86 (bin, rel);
	case EM_LOONGARCH:
		return get_import_addr_loongarch(bin, rel);
	default:
		eprintf ("Unsupported relocs type %" PFMT64u " for arch %d\n",
				(ut64) rel->type, bin->ehdr.e_machine);
		return UT64_MAX;
	}
}
