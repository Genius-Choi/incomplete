uint32_t gssntlm_import_name_by_mech(uint32_t *minor_status,
                                     gss_const_OID mech_type,
                                     gss_buffer_t input_name_buffer,
                                     gss_OID input_name_type,
                                     gss_name_t *output_name)
{
    struct gssntlm_name *name = NULL;
    uint32_t retmaj;
    uint32_t retmin;

    /* TODO: check mech_type == gssntlm_oid */
    if (mech_type == GSS_C_NO_OID) {
        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_READ);
    }

    name = calloc(1, sizeof(struct gssntlm_name));
    if (!name) {
        set_GSSERR(ENOMEM);
        goto done;
    }

    /* treat null OID like NT_USER_NAME */
    if (input_name_type == GSS_C_NULL_OID) {
        input_name_type = GSS_C_NT_USER_NAME;
    }

    if (gss_oid_equal(input_name_type, GSS_C_NT_HOSTBASED_SERVICE) ||
        gss_oid_equal(input_name_type, GSS_C_NT_HOSTBASED_SERVICE_X)) {
        char *spn = NULL;
        char *p = NULL;

        name->type = GSSNTLM_NAME_SERVER;

        if (input_name_buffer->length > 0) {
            spn = strndup(input_name_buffer->value, input_name_buffer->length);
            if (!spn) {
                set_GSSERR(ENOMEM);
                goto done;
            }
            p = strchr(spn, '@');
            if (p && input_name_buffer->length == 1) {
                free(spn);
                spn = p = NULL;
            }
        }

        if (p) {
            /* Windows expects a SPN not a GSS Name */
            if (p != spn) {
                *p = '/';
                name->data.server.spn = spn;
                spn = NULL;
            }
            p += 1;
            name->data.server.name = strdup(p);
            if (!name->data.server.name) {
                free(spn);
                set_GSSERR(ENOMEM);
                goto done;
            }
        } else {
            char hostname[HOST_NAME_MAX + 1] = { 0 };
            size_t l, r;
            /* no seprator, assume only service is provided and try to
             * source the local host name */
            retmin = gethostname(hostname, HOST_NAME_MAX);
            if (retmin) {
                free(spn);
                set_GSSERR(retmin);
                goto done;
            }
            hostname[HOST_NAME_MAX] = '\0';
            if (spn != NULL) {
                /* spn = <service> + </> + <hostname> + <\0> */
                l = strlen(spn) + 1 + strlen(hostname) + 1;
                name->data.server.spn = malloc(l);
                if (!name->data.server.spn) {
                    free(spn);
                    set_GSSERR(ENOMEM);
                    goto done;
                }
                r = snprintf(name->data.server.spn, l, "%s/%s", spn, hostname);
                if (r != l - 1) {
                    free(spn);
                    set_GSSERR(ENOMEM);
                    goto done;
                }
            }
            name->data.server.name = strdup(hostname);
            if (!name->data.server.name) {
                free(spn);
                set_GSSERR(ENOMEM);
                goto done;
            }
        }
        free(spn);
        set_GSSERRS(0, GSS_S_COMPLETE);

    } else if (gss_oid_equal(input_name_type, GSS_C_NT_USER_NAME)) {

        name->type = GSSNTLM_NAME_USER;
        retmaj = parse_user_name(&retmin,
                                 input_name_buffer->value,
                                 input_name_buffer->length,
                                 &name->data.user.domain,
                                 &name->data.user.name);
    } else if (gss_oid_equal(input_name_type, GSS_C_NT_MACHINE_UID_NAME)) {
        uid_t uid;

        name->type = GSSNTLM_NAME_USER;
        name->data.user.domain = NULL;

        uid = *(uid_t *)input_name_buffer->value;
        retmaj = uid_to_name(&retmin, uid, &name->data.user.name);
    } else if (gss_oid_equal(input_name_type, GSS_C_NT_STRING_UID_NAME)) {
        char struid[12] = { 0 };
        uid_t uid;

        name->type = GSSNTLM_NAME_USER;
        name->data.user.domain = NULL;

        if (input_name_buffer->length > 12) {
            set_GSSERR(ERR_BADARG);
            goto done;
        }
        memcpy(struid, input_name_buffer->value, input_name_buffer->length);
        struid[11] = '\0';
        errno = 0;
        uid = strtol(struid, NULL, 10);
        if (errno) {
            set_GSSERR(ERR_BADARG);
            goto done;
        }
        retmaj = uid_to_name(&retmin, uid, &name->data.user.name);
    } else if (gss_oid_equal(input_name_type, GSS_C_NT_ANONYMOUS)) {
        name->type = GSSNTLM_NAME_ANON;
        set_GSSERRS(0, GSS_S_COMPLETE);
    } else if (gss_oid_equal(input_name_type, GSS_C_NT_EXPORT_NAME)) {
        /* TODO */
        set_GSSERRS(ERR_NOTSUPPORTED, GSS_S_BAD_NAMETYPE);
    } else {
        set_GSSERRS(ERR_BADARG, GSS_S_BAD_NAMETYPE);
    }

done:
    if (retmaj != GSS_S_COMPLETE) {
        uint32_t tmpmin;
        gssntlm_release_name(&tmpmin, (gss_name_t *)&name);
    } else {
        *output_name = (gss_name_t)name;
    }
    return GSSERR();
}
