static int ast_rtcp_write(const void *data)
{
	struct ast_rtp_instance *instance = (struct ast_rtp_instance *) data;
	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
	int res;
	int sr = 0;
	int packet_len = 0;
	int ice;
	struct ast_sockaddr remote_address = { { 0, } };
	unsigned char *rtcpheader;
	unsigned char bdata[AST_UUID_STR_LEN + 128] = ""; /* More than enough */
	RAII_VAR(struct ast_rtp_rtcp_report *, rtcp_report, NULL, ao2_cleanup);

	if (!rtp || !rtp->rtcp || rtp->rtcp->schedid == -1) {
		ao2_ref(instance, -1);
		return 0;
	}

	ao2_lock(instance);
	rtcpheader = bdata;
	rtcp_report = ast_rtp_rtcp_report_alloc(rtp->themssrc_valid ? 1 : 0);
	res = ast_rtcp_generate_compound_prefix(instance, rtcpheader, rtcp_report, &sr);

	if (res == 0 || res == 1) {
		goto cleanup;
	}

	packet_len += res;

	if (rtp->bundled) {
		ast_rtp_instance_get_remote_address(instance, &remote_address);
	} else {
		ast_sockaddr_copy(&remote_address, &rtp->rtcp->them);
	}

	res = rtcp_sendto(instance, (unsigned int *)rtcpheader, packet_len, 0, &remote_address, &ice);
	if (res < 0) {
		ast_log(LOG_ERROR, "RTCP %s transmission error to %s, rtcp halted %s\n",
				sr ? "SR" : "RR",
				ast_sockaddr_stringify(&rtp->rtcp->them),
				strerror(errno));
		res = 0;
	} else {
		ast_rtcp_calculate_sr_rr_statistics(instance, rtcp_report, remote_address, ice, sr);
	}

cleanup:
	ao2_unlock(instance);

	if (!res) {
		/*
		 * Not being rescheduled.
		 */
		rtp->rtcp->schedid = -1;
		ao2_ref(instance, -1);
	}

	return res;
}
