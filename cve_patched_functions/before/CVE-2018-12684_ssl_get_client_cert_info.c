ssl_get_client_cert_info(struct mg_connection *conn)
{
	X509 *cert = SSL_get_peer_certificate(conn->ssl);
	if (cert) {
		char str_subject[1024];
		char str_issuer[1024];
		char str_finger[1024];
		unsigned char buf[256];
		char *str_serial = NULL;
		unsigned int ulen;
		int ilen;
		unsigned char *tmp_buf;
		unsigned char *tmp_p;

		/* Handle to algorithm used for fingerprint */
		const EVP_MD *digest = EVP_get_digestbyname("sha1");

		/* Get Subject and issuer */
		X509_NAME *subj = X509_get_subject_name(cert);
		X509_NAME *iss = X509_get_issuer_name(cert);

		/* Get serial number */
		ASN1_INTEGER *serial = X509_get_serialNumber(cert);

		/* Translate serial number to a hex string */
		BIGNUM *serial_bn = ASN1_INTEGER_to_BN(serial, NULL);
		str_serial = BN_bn2hex(serial_bn);
		BN_free(serial_bn);

		/* Translate subject and issuer to a string */
		(void)X509_NAME_oneline(subj, str_subject, (int)sizeof(str_subject));
		(void)X509_NAME_oneline(iss, str_issuer, (int)sizeof(str_issuer));

		/* Calculate SHA1 fingerprint and store as a hex string */
		ulen = 0;

		/* ASN1_digest is deprecated. Do the calculation manually,
		 * using EVP_Digest. */
		ilen = i2d_X509(cert, NULL);
		tmp_buf = (ilen > 0)
		              ? (unsigned char *)mg_malloc_ctx((unsigned)ilen + 1,
		                                               conn->phys_ctx)
		              : NULL;
		if (tmp_buf) {
			tmp_p = tmp_buf;
			(void)i2d_X509(cert, &tmp_p);
			if (!EVP_Digest(
			        tmp_buf, (unsigned)ilen, buf, &ulen, digest, NULL)) {
				ulen = 0;
			}
			mg_free(tmp_buf);
		}

		if (!hexdump2string(
		        buf, (int)ulen, str_finger, (int)sizeof(str_finger))) {
			*str_finger = 0;
		}

		conn->request_info.client_cert = (struct mg_client_cert *)
		    mg_malloc_ctx(sizeof(struct mg_client_cert), conn->phys_ctx);
		if (conn->request_info.client_cert) {
			conn->request_info.client_cert->peer_cert = (void *)cert;
			conn->request_info.client_cert->subject =
			    mg_strdup_ctx(str_subject, conn->phys_ctx);
			conn->request_info.client_cert->issuer =
			    mg_strdup_ctx(str_issuer, conn->phys_ctx);
			conn->request_info.client_cert->serial =
			    mg_strdup_ctx(str_serial, conn->phys_ctx);
			conn->request_info.client_cert->finger =
			    mg_strdup_ctx(str_finger, conn->phys_ctx);
		} else {
			mg_cry_internal(conn,
			                "%s",
			                "Out of memory: Cannot allocate memory for client "
			                "certificate");
		}

		/* Strings returned from bn_bn2hex must be freed using OPENSSL_free,
		 * see https://linux.die.net/man/3/bn_bn2hex */
		OPENSSL_free(str_serial);
	}
}
