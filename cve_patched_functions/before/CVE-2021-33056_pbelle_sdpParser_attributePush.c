pbelle_sdpParser_attributePush(pbelle_sdpParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sdpParser_attribute_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sdpParser_attributeStack->size(ctx->pbelle_sdpParser_attributeStack) > ctx->pbelle_sdpParser_attributeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sdpParser_attribute_SCOPE)ctx->pbelle_sdpParser_attributeStack->get(ctx->pbelle_sdpParser_attributeStack, ctx->pbelle_sdpParser_attributeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sdpParser_attribute_SCOPE) ANTLR3_MALLOC(sizeof(belle_sdpParser_attribute_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sdpParser_attributeStack->push(ctx->pbelle_sdpParser_attributeStack, newAttributes, (void (*)(void *))attributeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sdpParser_attributeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}
