void ssl_setup_session_resumption(SSL_CTX **contexts, size_t num_contexts, struct st_h2o_quic_resumption_args_t *quic_args,
                                  h2o_barrier_t *startup_barrier)
{
    if (conf.cache.setup != NULL)
        conf.cache.setup(contexts, num_contexts);

    if (quic_args != NULL) {
        assert(num_contexts != 0);
        if (conf.ticket.update_thread == NULL)
            h2o_fatal("ticket-based encryption MUST be enabled when running QUIC");
        quic_is_clustered = quic_args->is_clustered;
    }

#if H2O_USE_SESSION_TICKETS
    if (num_contexts == 0)
        return;

    if (startup_barrier != NULL) {
        h2o_barrier_add(startup_barrier, 1);
        session_tickets.barrier = startup_barrier;
    }

    if (conf.ticket.update_thread != NULL) {
        /* start session ticket updater thread */
        pthread_t tid;
        pthread_attr_t attr;
        pthread_attr_init(&attr);
        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
        h2o_multithread_create_thread(&tid, &attr, conf.ticket.update_thread, NULL);
        pthread_attr_destroy(&attr);
        size_t i;
        for (i = 0; i != num_contexts; ++i) {
            SSL_CTX *ctx = contexts[i];
            SSL_CTX_set_tlsext_ticket_key_cb(ctx, ticket_key_callback_ossl);
            /* accompanying ptls context is initialized in ssl_setup_session_resumption_ptls */
        }
    } else {
        size_t i;
        for (i = 0; i != num_contexts; ++i)
            SSL_CTX_set_options(contexts[i], SSL_CTX_get_options(contexts[i]) | SSL_OP_NO_TICKET);
    }
#endif
}
