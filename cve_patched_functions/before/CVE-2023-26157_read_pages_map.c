read_pages_map (Bit_Chain *dat, int64_t size_comp, int64_t size_uncomp,
                int64_t correction)
{
  r2007_page *pages = NULL, *last_page = NULL, *page;
  int64_t offset = 0x480; // dat->byte;
  Bit_Chain sdat = { 0 };
  // int64_t index;

  if (!read_system_page (&sdat, dat, size_comp, size_uncomp, correction))
    {
      LOG_ERROR ("Failed to read system page")
      return NULL;
    }
  LOG_TRACE ("\n=== System Section (Pages Map) ===\n")
  while (sdat.byte < (size_t)size_uncomp)
    {
      page = (r2007_page *)malloc (sizeof (r2007_page));
      if (page == NULL)
        {
          LOG_ERROR ("Out of memory")
          bit_chain_free (&sdat);
          pages_destroy (pages);
          return NULL;
        }
      if (sdat.byte + 16 > sdat.size)
        {
          LOG_ERROR ("Page out of bounds")
          bit_chain_free (&sdat);
          pages_destroy (pages);
          return NULL;
        }
      page->size = bit_read_RLL (&sdat);
      page->id = (int64_t)bit_read_RLL (&sdat);
      page->offset = offset;
      offset += page->size;

      // index = page->id > 0 ? page->id : -page->id;
      LOG_TRACE ("Page [%3" PRId64 "]: ", page->id)
      LOG_TRACE ("size: %6" PRIu64 " ", page->size)
      LOG_TRACE ("offset: 0x%" PRIx64 " \n", page->offset)

      page->next = NULL;

      if (pages == NULL)
        pages = last_page = page;
      else
        {
          last_page->next = page;
          last_page = page;
        }
    }
  bit_chain_free (&sdat);
  return pages;
}
