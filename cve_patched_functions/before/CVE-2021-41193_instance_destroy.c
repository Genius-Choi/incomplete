static void instance_destroy(struct calling_instance *inst)
{
	struct le *le;

	if (inst->thread_run) {
		inst->thread_run = false;

		debug("wcall: joining thread..\n");

		pthread_join(inst->tid, NULL);
		pthread_detach(inst->tid);
		inst->tid = 0;
	}

	uintptr_t vuser = inst->wuser;
	msystem_unregister_listener((void*)vuser);
	tmr_cancel(&inst->tmr_roam);

	/* Dont call list_flush as we expect a valid list
	   in the wcall destructor */
	le = inst->wcalls.head;
	while(le) {
		if (le->data) {
			mem_deref(le->data);
			le = inst->wcalls.head;
		}
		else {
			le = le->next;
		}
	}
	list_flush(&inst->ctxl);

	lock_write_get(inst->lock);
	list_unlink(&inst->le);
	list_flush(&inst->ecalls);

	inst->userid = mem_deref(inst->userid);
	inst->clientid = mem_deref(inst->clientid);
	inst->mm = mem_deref(inst->mm);
	inst->msys = mem_deref(inst->msys);
	inst->cfg = mem_deref(inst->cfg);
	inst->media_laddr = mem_deref(inst->media_laddr);

	inst->readyh = NULL;
	inst->sendh = NULL;
	inst->incomingh = NULL;
	inst->estabh = NULL;
	inst->closeh = NULL;
	inst->vstateh = NULL;
	inst->acbrh = NULL;
	inst->cfg_reqh = NULL;
	inst->arg = NULL;

	lock_rel(inst->lock);

	inst->lock = mem_deref(inst->lock);
	inst->netprobe = mem_deref(inst->netprobe);

	{
		struct inst_dtor_entry *ide;
		ide = mem_zalloc(sizeof(*ide), ide_destructor);
		if (!ide)
			return;
		
		ide->inst = inst;
		ide->marshal = inst->marshal;

		if (!inst->shuth)
			ide_handler(ide);
		else {
			tmr_init(&ide->tmr);
			ide->shuth = inst->shuth;
			ide->shuth_arg = inst->shuth_arg;
			tmr_start(&ide->tmr, 0, ide_handler, ide);
		}
	}
}
