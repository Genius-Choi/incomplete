static void mg_tun_client_handler(struct mg_connection *nc, int ev,
                                  void *ev_data MG_UD_ARG(void *user_data)) {
#if !MG_ENABLE_CALLBACK_USERDATA
  void *user_data = nc->user_data;
#else
  (void) nc;
#endif
  struct mg_tun_client *client = (struct mg_tun_client *) user_data;

  switch (ev) {
    case MG_EV_CONNECT: {
      int err = *(int *) ev_data;

      if (err) {
        LOG(LL_ERROR, ("Cannot connect to the tunnel dispatcher: %d", err));
      } else {
        LOG(LL_INFO, ("Connected to the tunnel dispatcher"));
      }
      break;
    }
    case MG_EV_HTTP_REPLY: {
      struct http_message *hm = (struct http_message *) ev_data;

      if (hm->resp_code != 200) {
        LOG(LL_ERROR,
            ("Tunnel dispatcher reply non-OK status code %d", hm->resp_code));
      }
      break;
    }
    case MG_EV_WEBSOCKET_HANDSHAKE_DONE: {
      LOG(LL_INFO, ("Tunnel dispatcher handshake done"));
      break;
    }
    case MG_EV_WEBSOCKET_FRAME: {
      struct websocket_message *wm = (struct websocket_message *) ev_data;
      struct mg_connection *tc;
      struct mg_tun_frame frame;

      if (mg_tun_parse_frame(wm->data, wm->size, &frame) == -1) {
        LOG(LL_ERROR, ("Got invalid tun frame dropping", wm->size));
        break;
      }

      mg_tun_log_frame(&frame);

      tc = mg_tun_if_find_conn(client, frame.stream_id);
      if (tc == NULL) {
        if (frame.body.len > 0) {
          LOG(LL_DEBUG, ("Got frame after receiving end has been closed"));
        }
        break;
      }
      if (frame.body.len > 0) {
        mg_if_recv_tcp_cb(tc, (void *) frame.body.p, frame.body.len,
                          0 /* own */);
      }
      if (frame.flags & MG_TUN_F_END_STREAM) {
        LOG(LL_DEBUG, ("Closing tunneled connection because got end of stream "
                       "from other end"));
        tc->flags |= MG_F_CLOSE_IMMEDIATELY;
        mg_close_conn(tc);
      }
      break;
    }
    case MG_EV_CLOSE: {
      LOG(LL_DEBUG, ("Closing all tunneled connections"));
      /*
       * The client might have been already freed when the listening socket is
       * closed.
       */
      if (client != NULL) {
        mg_tun_close_all(client);
        client->disp = NULL;
        LOG(LL_INFO, ("Dispatcher connection is no more, reconnecting"));
        /* TODO(mkm): implement exp back off */
        mg_tun_reconnect(client, MG_TUN_RECONNECT_INTERVAL);
      }
      break;
    }
    default:
      break;
  }
}
