xrdp_sec_process_logon_info(struct xrdp_sec *self, struct stream *s)
{
    int flags = 0;
    unsigned int len_domain = 0;
    unsigned int len_user = 0;
    unsigned int len_password = 0;
    unsigned int len_program = 0;
    unsigned int len_directory = 0;
    unsigned int len_clnt_addr = 0;
    unsigned int len_clnt_dir = 0;
    const char *sep;

    if (!s_check_rem_and_log(s, 8, "Parsing [MS-RDPBCGR] TS_INFO_PACKET"))
    {
        return 1;
    }
    in_uint8s(s, 4);
    in_uint32_le(s, flags);
    LOG_DEVEL(LOG_LEVEL_TRACE, "Parsing [MS-RDPBCGR] TS_INFO_PACKET");

    /* this is the first test that the decrypt is working */
    if ((flags & RDP_LOGON_NORMAL) != RDP_LOGON_NORMAL) /* 0x33 */
    {
        /* must be or error */
        LOG(LOG_LEVEL_ERROR, "received wrong flags, likely decrypt not working");
        return 1;
    }

    if (flags & RDP_LOGON_LEAVE_AUDIO)
    {
        self->rdp_layer->client_info.sound_code = 1;
        LOG_DEVEL(LOG_LEVEL_DEBUG, "[MS-RDPBCGR] TS_INFO_PACKET flag INFO_REMOTECONSOLEAUDIO found");
        LOG(LOG_LEVEL_DEBUG,
            "Client requested that audio on the server be played on the server.");
    }

    if (flags & RDP_LOGON_RAIL)
    {
        self->rdp_layer->client_info.rail_enable = 1;
        LOG_DEVEL(LOG_LEVEL_DEBUG, "[MS-RDPBCGR] TS_INFO_PACKET flag INFO_RAIL found");
        LOG(LOG_LEVEL_DEBUG,
            "Client requested Remote Application Integrated Locally (RAIL).");
    }

    if (flags & RDP_LOGON_AUTO)
    {
        LOG_DEVEL(LOG_LEVEL_DEBUG, "[MS-RDPBCGR] TS_INFO_PACKET flag INFO_AUTOLOGON found");
        /* todo, for now not allowing autologon and mce both */
        if (!self->rdp_layer->client_info.is_mce)
        {
            self->rdp_layer->client_info.rdp_autologin = 1;
            LOG(LOG_LEVEL_DEBUG, "Client requested auto logon.");
        }
        else
        {
            LOG(LOG_LEVEL_WARNING, "Auto logon is not supported with MCE");
        }
    }

    if (flags & RDP_COMPRESSION)
    {
        LOG_DEVEL(LOG_LEVEL_DEBUG, "[MS-RDPBCGR] TS_INFO_PACKET flag INFO_COMPRESSION found, "
                  "CompressionType 0x%1.1x", (flags & 0x00001E00) >> 9);
        /* TODO: check the client's supported compression type vs the server
           compression used */
        if (self->rdp_layer->client_info.use_bulk_comp)
        {

            self->rdp_layer->client_info.rdp_compression = 1;
            LOG(LOG_LEVEL_DEBUG, "Client requested compression enabled.");
        }
        else
        {
            LOG(LOG_LEVEL_DEBUG, "Client requested compression, but server "
                "compression is disabled.");
        }
    }

    if (!s_check_rem_and_log(s, 2, "Parsing [MS-RDPBCGR] TS_INFO_PACKET cbDomain"))
    {
        return 1;
    }
    in_uint16_le(s, len_domain);

    if (len_domain >= INFO_CLIENT_MAX_CB_LEN)
    {
        LOG(LOG_LEVEL_ERROR,
            "Client supplied domain is too long. Max length %d, domain length %d",
            INFO_CLIENT_MAX_CB_LEN, len_domain);
        return 1;
    }

    if (!s_check_rem_and_log(s, 2, "Parsing [MS-RDPBCGR] TS_INFO_PACKET cbUserName"))
    {
        return 1;
    }
    in_uint16_le(s, len_user);

    /*
     * Microsoft's itap client running on Mac OS/Android
     * always sends autologon credentials, even when user has not
     * configured any
     */
    if (len_user == 0 && self->rdp_layer->client_info.rdp_autologin)
    {
        LOG(LOG_LEVEL_DEBUG, "Client supplied user name is empty, disabling autologin");
        self->rdp_layer->client_info.rdp_autologin = 0;
    }

    if (len_user >= INFO_CLIENT_MAX_CB_LEN)
    {
        LOG(LOG_LEVEL_ERROR,
            "Client supplied user name is too long. Max length %d, user name length %d",
            INFO_CLIENT_MAX_CB_LEN, len_user);
        return 1;
    }

    if (!s_check_rem_and_log(s, 2, "Parsing [MS-RDPBCGR] TS_INFO_PACKET cbPassword"))
    {
        return 1;
    }
    in_uint16_le(s, len_password);

    /*
     * Ignore autologin requests if the password is empty. System managers
     * who really want to allow empty passwords can do this with a
     * special session type */
    if (len_password == 0 && self->rdp_layer->client_info.rdp_autologin)
    {
        LOG(LOG_LEVEL_DEBUG,
            "Client supplied password is empty, disabling autologin");
        self->rdp_layer->client_info.rdp_autologin = 0;
    }

    if (len_password >= INFO_CLIENT_MAX_CB_LEN)
    {
        LOG(LOG_LEVEL_ERROR,
            "Client supplied password is too long. Max length %d, password length %d",
            INFO_CLIENT_MAX_CB_LEN, len_password);
        return 1;
    }

    if (!s_check_rem_and_log(s, 2, "Parsing [MS-RDPBCGR] TS_INFO_PACKET cbAlternateShell"))
    {
        return 1;
    }
    in_uint16_le(s, len_program);

    if (len_program >= INFO_CLIENT_MAX_CB_LEN)
    {
        LOG(LOG_LEVEL_ERROR,
            "Client supplied program name is too long. Max length %d, program name length %d",
            INFO_CLIENT_MAX_CB_LEN, len_program);
        return 1;
    }

    if (!s_check_rem_and_log(s, 2, "Parsing [MS-RDPBCGR] TS_INFO_PACKET cbWorkingDir"))
    {
        return 1;
    }
    in_uint16_le(s, len_directory);

    if (len_directory >= INFO_CLIENT_MAX_CB_LEN)
    {
        LOG(LOG_LEVEL_ERROR,
            "Client supplied directory name is too long. Max length %d, directory name length %d",
            INFO_CLIENT_MAX_CB_LEN, len_directory);
        return 1;
    }

    if (ts_info_utf16_in(s, len_domain, self->rdp_layer->client_info.domain, sizeof(self->rdp_layer->client_info.domain)) != 0)
    {
        LOG(LOG_LEVEL_ERROR, "ERROR reading domain");
        return 1;
    }

    if (ts_info_utf16_in(s, len_user, self->rdp_layer->client_info.username, sizeof(self->rdp_layer->client_info.username)) != 0)
    {
        LOG(LOG_LEVEL_ERROR, "ERROR reading user name");
        return 1;
    }

    if (flags & RDP_LOGON_AUTO)
    {
        if (ts_info_utf16_in(s, len_password, self->rdp_layer->client_info.password, sizeof(self->rdp_layer->client_info.password)) != 0)
        {
            LOG(LOG_LEVEL_ERROR, "ERROR reading password");
            return 1;
        }
    }
    else if (self->rdp_layer->client_info.enable_token_login
             && len_user > 0
             && len_password == 0
             && (sep = g_strchr(self->rdp_layer->client_info.username, '\x1f')) != NULL)
    {
        LOG(LOG_LEVEL_DEBUG, "Client supplied a Logon token. Overwriting password with logon token.");
        g_strncpy(self->rdp_layer->client_info.password, sep + 1,
                  sizeof(self->rdp_layer->client_info.password) - 1);
        self->rdp_layer->client_info.username[sep - self->rdp_layer->client_info.username] = '\0';
        self->rdp_layer->client_info.rdp_autologin = 1;
    }
    else
    {
        if (!s_check_rem_and_log(s, len_password + 2, "Parsing [MS-RDPBCGR] TS_INFO_PACKET Password"))
        {
            return 1;
        }
        in_uint8s(s, len_password + 2);
        if (self->rdp_layer->client_info.require_credentials)
        {
            LOG(LOG_LEVEL_ERROR, "Server is configured to require that the "
                "client enable auto logon with credentials, but the client did "
                "not request auto logon.");
            return 1; /* credentials on cmd line is mandatory */
        }
    }
    if (self->rdp_layer->client_info.domain_user_separator[0] != '\0'
            && self->rdp_layer->client_info.domain[0] != '\0')
    {
        LOG(LOG_LEVEL_DEBUG, "Client supplied domain with user name. Overwriting user name with user name parsed from domain.");
        int size = sizeof(self->rdp_layer->client_info.username);
        g_strncat(self->rdp_layer->client_info.username, self->rdp_layer->client_info.domain_user_separator, size - 1 - g_strlen(self->rdp_layer->client_info.domain_user_separator));
        g_strncat(self->rdp_layer->client_info.username, self->rdp_layer->client_info.domain, size - 1 - g_strlen(self->rdp_layer->client_info.domain));
    }

    if (ts_info_utf16_in(s, len_program, self->rdp_layer->client_info.program, sizeof(self->rdp_layer->client_info.program)) != 0)
    {
        LOG(LOG_LEVEL_ERROR, "ERROR reading program");
        return 1;
    }

    if (ts_info_utf16_in(s, len_directory, self->rdp_layer->client_info.directory, sizeof(self->rdp_layer->client_info.directory)) != 0)
    {
        LOG(LOG_LEVEL_ERROR, "ERROR reading directory");
        return 1;
    }

    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_INFO_PACKET "
              "CodePage (ignored), flags 0x%8.8x, cbDomain %d, cbUserName %d, "
              "cbPassword %d, cbAlternateShell %d, cbWorkingDir %d, Domain %s, "
              "UserName %s, Password (omitted from log), AlternateShell %s, "
              "WorkingDir %s", flags, len_domain,
              len_user, len_password, len_program, len_directory,
              self->rdp_layer->client_info.domain,
              self->rdp_layer->client_info.username,
              self->rdp_layer->client_info.program,
              self->rdp_layer->client_info.directory);
    LOG(LOG_LEVEL_DEBUG, "Client supplied domain: %s", self->rdp_layer->client_info.domain);
    LOG(LOG_LEVEL_DEBUG, "Client supplied username: %s", self->rdp_layer->client_info.username);
    LOG(LOG_LEVEL_DEBUG, "Client supplied password: <omitted from log>");
    LOG(LOG_LEVEL_DEBUG, "Client supplied program: %s", self->rdp_layer->client_info.program);
    LOG(LOG_LEVEL_DEBUG, "Client supplied directory: %s", self->rdp_layer->client_info.directory);

    /* TODO: explain why the windows key flag is used to determine if the
       TS_EXTENDED_INFO_PACKET should be parsed */
    if (flags & RDP_LOGON_BLOB) /* INFO_ENABLEWINDOWSKEY */
    {
        if (!s_check_rem_and_log(s, 4, "Parsing [MS-RDPBCGR] TS_EXTENDED_INFO_PACKET "
                                 "clientAddressFamily and cbClientAddress"))
        {
            return 1;
        }
        /* TS_EXTENDED_INFO_PACKET required fields */
        in_uint8s(s, 2);         /* clientAddressFamily */
        in_uint16_le(s, len_clnt_addr);
        if (len_clnt_addr > EXTENDED_INFO_MAX_CLIENT_ADDR_LENGTH ||
                !s_check_rem(s, len_clnt_addr))
        {
            LOG(LOG_LEVEL_ERROR, "clientAddress is too long (%u bytes)",
                len_clnt_addr);
            return 1;
        }
        // The clientAddress is currently unused. [MS-RDPBCGR] requires
        // a mandatory null terminator, but some clients set
        // len_clnt_addr == 0 if this field is missing. Allow for this
        // in any future implementation.
        in_uint8s(s, len_clnt_addr); // Skip Unicode clientAddress

        if (!s_check_rem_and_log(s, 2, "Parsing [MS-RDPBCGR] TS_EXTENDED_INFO_PACKET clientDir"))
        {
            return 1;
        }
        in_uint16_le(s, len_clnt_dir);
        if (len_clnt_dir > INFO_CLIENT_MAX_CB_LEN ||
                !s_check_rem(s, len_clnt_dir))
        {
            LOG(LOG_LEVEL_ERROR, "clientDir is too long (%u bytes)", len_clnt_dir);
            return 1;
        }
        in_uint8s(s, len_clnt_dir); // Skip Unicode clientDir

        LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_EXTENDED_INFO_PACKET "
                  "<Required Fields> clientAddressFamily (ignored), "
                  "cbClientAddress (ignored), clientAddress (ignored), "
                  "cbClientDir (ignored), clientDir (ignored)");

        /* TODO: MS-BCGR 2.2.1.11.1.1.1 says that all fields after the
           client directory are optional. */
        if (!s_check_rem_and_log(s, 4 + 64 + 20 + 64 + 20 + 4 + 4,
                                 "Parsing [MS-RDPBCGR] TS_EXTENDED_INFO_PACKET "
                                 "clientTimeZone, clientSessionId, and performanceFlags"))
        {
            return 1;
        }
        /* TS_TIME_ZONE_INFORMATION */
        in_uint8s(s, 4);   /* Bias (4) */
        in_uint8s(s, 64);  /* StandardName (64) */
        in_uint8s(s, 20);  /* StandardDate (16), StandardBias (4) */
        in_uint8s(s, 64);  /* DaylightName (64) */
        in_uint8s(s, 20);  /* DaylightDate (16), DaylightBias (4) */
        in_uint8s(s, 4);   /* TS_EXTENDED_INFO_PACKET clientSessionId (4) */

        /* TS_EXTENDED_INFO_PACKET optional fields */
        in_uint32_le(s, self->rdp_layer->client_info.rdp5_performanceflags);

        LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_EXTENDED_INFO_PACKET "
                  "<Optional Fields> clientTimeZone (ignored), "
                  "clientSessionId (ignored), performanceFlags 0x%8.8x, "
                  "cbAutoReconnectCookie (ignored), autoReconnectCookie (ignored), "
                  "reserved1 (ignored), reserved2 (ignored), "
                  "cbDynamicDSTTimeZoneKeyName (ignored), "
                  "dynamicDSTTimeZoneKeyName (ignored), "
                  "dynamicDaylightTimeDisabled (ignored)",
                  self->rdp_layer->client_info.rdp5_performanceflags);
    }

    return 0;
}
