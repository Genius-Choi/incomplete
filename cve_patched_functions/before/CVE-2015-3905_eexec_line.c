eexec_line(unsigned char *line, int line_len)
{
    int cs_start_len = strlen(cs_start);
    int pos;
    int first_space;
    int digits;
    int cut_newline = 0;

    /* append this data to the end of `save' if necessary */
    if (save_len) {
	append_save(line, line_len);
	line = save;
	line_len = save_len;
        save_len = 0;
    }

    if (!line_len)
	return 0;

    /* Look for charstring start */

    /* skip first word */
    for (pos = 0; pos < line_len && isspace(line[pos]); pos++)
	;
    while (pos < line_len && !isspace(line[pos]))
	pos++;
    if (pos >= line_len)
	goto not_charstring;

    /* skip spaces */
    first_space = pos;
    while (pos < line_len && isspace(line[pos]))
	pos++;
    if (pos >= line_len || !isdigit(line[pos]))
	goto not_charstring;

    /* skip number */
    digits = pos;
    while (pos < line_len && isdigit(line[pos]))
	pos++;

    /* check for subr (another number) */
    if (pos < line_len - 1 && isspace(line[pos]) && isdigit(line[pos+1])) {
	first_space = pos;
	digits = pos + 1;
	for (pos = digits; pos < line_len && isdigit(line[pos]); pos++)
	    ;
    }

    /* check for charstring start */
    if (pos + 2 + cs_start_len < line_len
	&& pos > digits
	&& line[pos] == ' '
	&& strncmp((const char *)(line + pos + 1), cs_start, cs_start_len) == 0
	&& line[pos + 1 + cs_start_len] == ' ') {
	/* check if charstring is long enough */
	int cs_len = atoi((const char *)(line + digits));
	if (pos + 2 + cs_start_len + cs_len < line_len) {
	    /* long enough! */
	    if (line[line_len - 1] == '\r') {
		line[line_len - 1] = '\n';
		cut_newline = 1;
	    }
	    fprintf(ofp, "%.*s {\n", first_space, line);
	    decrypt_charstring(line + pos + 2 + cs_start_len, cs_len);
	    pos += 2 + cs_start_len + cs_len;
	    fprintf(ofp, "\t}%.*s", line_len - pos, line + pos);
	    return cut_newline;
	} else {
	    /* not long enough! */
            append_save(line, line_len);
	    return 0;
	}
    }

    /* otherwise, just output the line */
  not_charstring:
    /* 6.Oct.2003 - Werner Lemberg reports a stupid Omega font that behaves
       badly: a charstring definition follows "/Charstrings ... begin", ON THE
       SAME LINE. */
    {
	const char *CharStrings = (const char *)
	    oog_memstr(line, line_len, "/CharStrings ", 13);
	int crap, n;
	char should_be_slash = 0;
	if (CharStrings
	    && sscanf(CharStrings + 12, " %d dict dup begin %c%n", &crap, &should_be_slash, &n) >= 2
	    && should_be_slash == '/') {
	    int len = (CharStrings + 12 + n - 1) - (char *) line;
	    fprintf(ofp, "%.*s\n", len, line);
	    return eexec_line((unsigned char *) (CharStrings + 12 + n - 1), line_len - len);
	}
    }

    if (line[line_len - 1] == '\r') {
	line[line_len - 1] = '\n';
	cut_newline = 1;
    }
    set_lenIV((char *)line);
    set_cs_start((char *)line);
    fprintf(ofp, "%.*s", line_len, line);

    /* look for `currentfile closefile' to see if we should stop decrypting */
    if (oog_memstr(line, line_len, "currentfile closefile", 21) != 0)
	in_eexec = -1;

    return cut_newline;
}
