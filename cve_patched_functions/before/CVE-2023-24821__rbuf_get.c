static int _rbuf_get(const void *src, size_t src_len,
                     const void *dst, size_t dst_len,
                     size_t size, uint16_t tag,
                     unsigned page)
{
    gnrc_sixlowpan_frag_rb_t *res = NULL, *oldest = NULL;
    uint32_t now_usec = xtimer_now_usec();

    for (unsigned int i = 0; i < CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_SIZE; i++) {
        /* check first if entry already available */
        if ((rbuf[i].pkt != NULL) && (rbuf[i].super.tag == tag) &&
            ((IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&
              /* not all SFR fragments carry the datagram size, so make 0 a
               * legal value to not compare datagram size */
              ((size == 0) || (rbuf[i].super.datagram_size == size))) ||
             (!IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) &&
              (rbuf[i].super.datagram_size == size))) &&
            (rbuf[i].super.src_len == src_len) &&
            (rbuf[i].super.dst_len == dst_len) &&
            (memcmp(rbuf[i].super.src, src, src_len) == 0) &&
            (memcmp(rbuf[i].super.dst, dst, dst_len) == 0)) {
            DEBUG("6lo rfrag: entry %p (%s, ", (void *)(&rbuf[i]),
                  gnrc_netif_addr_to_str(rbuf[i].super.src,
                                         rbuf[i].super.src_len,
                                         l2addr_str));
            DEBUG("%s, %u, %u) found\n",
                  gnrc_netif_addr_to_str(rbuf[i].super.dst,
                                         rbuf[i].super.dst_len,
                                         l2addr_str),
                  (unsigned)rbuf[i].super.datagram_size, rbuf[i].super.tag);
#if CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_DEL_TIMER > 0
            if (rbuf[i].super.current_size == 0) {
                /* ensure that only empty reassembly buffer entries and entries
                 * scheduled for deletion have `current_size == 0` */
                DEBUG("6lo rfrag: scheduled for deletion, don't add fragment\n");
                return -1;
            }
#endif
            rbuf[i].super.arrival = now_usec;
            _set_rbuf_timeout();
            return i;
        }

        /* if there is a free spot: remember it */
        if ((res == NULL) && gnrc_sixlowpan_frag_rb_entry_empty(&rbuf[i])) {
            res = &(rbuf[i]);
        }

        /* remember oldest slot */
        /* note that xtimer_now will overflow in ~1.2 hours */
        if ((oldest == NULL) ||
            (oldest->super.arrival - rbuf[i].super.arrival < UINT32_MAX / 2)) {
            oldest = &(rbuf[i]);
        }
    }

    /* entry not in buffer and no empty spot found */
    if (res == NULL) {
        assert(oldest != NULL);
        /* if oldest is not empty, res must not be NULL (because otherwise
         * oldest could have been picked as res) */
        assert(!gnrc_sixlowpan_frag_rb_entry_empty(oldest));
        if (!IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_DO_NOT_OVERRIDE) ||
            ((now_usec - oldest->super.arrival) >
            CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_TIMEOUT_US)) {
            DEBUG("6lo rfrag: reassembly buffer full, remove oldest entry\n");
            gnrc_pktbuf_release(oldest->pkt);
            gnrc_sixlowpan_frag_rb_remove(oldest);
            res = oldest;
#if !IS_ACTIVE(CONFIG_GNRC_SIXLOWPAN_FRAG_RBUF_DO_NOT_OVERRIDE) && \
    IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_STATS)
            gnrc_sixlowpan_frag_stats_get()->rbuf_full++;
#endif
        }
        else {
#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_STATS
            gnrc_sixlowpan_frag_stats_get()->rbuf_full++;
#endif
            return -1;
        }
    }

    /* now we have an empty spot */

    gnrc_nettype_t reass_type;
    switch (page) {
        /* use switch(page) to be extendable */
#ifdef MODULE_GNRC_IPV6
        case 0U:
            reass_type = GNRC_NETTYPE_IPV6;
            break;
#endif
        default:
            reass_type = GNRC_NETTYPE_UNDEF;
    }
    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_VRB)) {
        if (IS_USED(MODULE_GNRC_SIXLOWPAN_IPHC)) {
            /* only allocate enough space to decompress IPv6 header
             * for forwarding information */
            res->pkt = gnrc_pktbuf_add(NULL, NULL, sizeof(ipv6_hdr_t),
                                       reass_type);
        }
        else {
            /* try fragment forwarding without IPHC. Since `res->pkt == NULL`
             * is not a valid value for a reassembly buffer entry, we need to
             * set it to at least a packet snip for now */
            res->pkt = gnrc_pktbuf_add(NULL, NULL, 0, reass_type);
        }
    }
    else {
        /* reassemble whole datagram without direct fragment forwarding */
        res->pkt = gnrc_pktbuf_add(NULL, NULL, size, reass_type);
    }
    if (res->pkt == NULL) {
        DEBUG("6lo rfrag: can not allocate reassembly buffer space.\n");
        return -1;
    }

    if (res->pkt->data) {
        /* clean first few bytes for later look-ups */
        memset(res->pkt->data, 0, sizeof(uint64_t));
    }
    res->super.datagram_size = size;
    res->super.arrival = now_usec;
    memcpy(res->super.src, src, src_len);
    memcpy(res->super.dst, dst, dst_len);
    res->super.src_len = src_len;
    res->super.dst_len = dst_len;
    res->super.tag = tag;
    res->super.current_size = 0;
#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR)
    res->offset_diff = 0U;
    memset(res->received, 0U, sizeof(res->received));
#endif  /* IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_SFR) */

    DEBUG("6lo rfrag: entry %p (%s, ", (void *)res,
          gnrc_netif_addr_to_str(res->super.src, res->super.src_len,
                                 l2addr_str));
    DEBUG("%s, %u, %u) created\n",
          gnrc_netif_addr_to_str(res->super.dst, res->super.dst_len,
                                 l2addr_str), res->super.datagram_size,
          res->super.tag);

    _set_rbuf_timeout();

    return res - &(rbuf[0]);
}
