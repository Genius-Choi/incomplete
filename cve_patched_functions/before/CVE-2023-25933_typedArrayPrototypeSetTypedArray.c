CallResult<HermesValue> typedArrayPrototypeSetTypedArray(
    Runtime &runtime,
    Handle<JSTypedArrayBase> self,
    Handle<JSTypedArrayBase> src,
    double offset) {
  if (!src->attached(runtime)) {
    return runtime.raiseTypeError(
        "The src TypedArray must be attached in order to use set()");
  }
  const JSTypedArrayBase::size_type srcLength = src->getLength();
  if (static_cast<double>(srcLength) + offset > self->getLength()) {
    return runtime.raiseRangeError(
        "The sum of the length of the given TypedArray "
        "and the offset cannot be greater than the length "
        "of this TypedArray");
  }
  // Since `src` is immutable, put the rest of the function into a continuation
  // to be called with a different `src` parameter.
  if (self->getBuffer(runtime)->getDataBlock(runtime) !=
      src->getBuffer(runtime)->getDataBlock(runtime)) {
    if (JSTypedArrayBase::setToCopyOfTypedArray(
            runtime, self, offset, src, 0, srcLength) ==
        ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
    return HermesValue::encodeUndefinedValue();
  }
  // 23. If SameValue(srcBuffer, targetBuffer) is true, then
  // a. Let srcBuffer be ? CloneArrayBuffer(targetBuffer, srcByteOffset,
  // %ArrayBuffer%).
  // If the two arrays have overlapping storage, make a copy of the source
  // array.
  // TODO: This could be implemented via a directional copy which either
  // copies forwards or backwards depending on how the regions overlap.
  auto possibleTA = src->allocate(runtime, srcLength);
  if (possibleTA == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto newSrc = possibleTA.getValue();
  if (JSTypedArrayBase::setToCopyOfBuffer(
          runtime,
          newSrc,
          0,
          runtime.makeHandle(src->getBuffer(runtime)),
          src->getByteOffset(),
          src->getByteLength()) == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  // Now copy from newSrc into self.
  if (JSTypedArrayBase::setToCopyOfTypedArray(
          runtime, self, offset, newSrc, 0, srcLength) ==
      ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  return HermesValue::encodeUndefinedValue();
}
