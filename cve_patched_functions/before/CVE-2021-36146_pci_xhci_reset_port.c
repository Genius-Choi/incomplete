pci_xhci_reset_port(struct pci_xhci_vdev *xdev, int portn, int warm)
{
	struct pci_xhci_portregs *port;
	struct xhci_trb evtrb;
	struct usb_native_devinfo *di;
	struct pci_xhci_dev_emu  *dev;
	int speed;
	int index;
	int rc = 0;

	UPRINTF(LINF, "reset port %d\r\n", portn);

	port = XHCI_PORTREG_PTR(xdev, portn);
	index = pci_xhci_get_native_port_index_by_vport(xdev, portn);
	if (index < 0) {
		UPRINTF(LWRN, "fail to reset port %d\r\n", portn);
		return;
	}
	di = &xdev->native_ports[index].info;
	dev = xdev->devices[portn];
	if (dev && dev->dev_ue->ue_reset != NULL)
		rc = dev->dev_ue->ue_reset(dev->dev_instance);

	port->portsc &= ~(XHCI_PS_PR | XHCI_PS_PLS_MASK);
	/*
	 * From xHCI spec 4.19.5 USB2 protocol ports never fail the bus
	 * reset seqence.
	 */
	if (rc != 0 && di->bcd >= 0x300) {
		port->portsc |= XHCI_PS_PLS_SET(UPS_PORT_LS_RX_DET)
				| XHCI_PS_SPEED_SET(USB_SPEED_VARIABLE);
		port->portsc &= ~XHCI_PS_CCS;
	} else {
		speed = pci_xhci_convert_speed(di->speed);
		port->portsc |= XHCI_PS_PED | XHCI_PS_SPEED_SET(speed)
				| XHCI_PS_PLS_SET(UPS_PORT_LS_U0);
	}
	if (warm && di->bcd >= 0x300)
		port->portsc |= XHCI_PS_WRC;

	if ((port->portsc & XHCI_PS_PRC) == 0) {
		port->portsc |= XHCI_PS_PRC;

		pci_xhci_set_evtrb(&evtrb, portn,
			XHCI_TRB_ERROR_SUCCESS,
			XHCI_TRB_EVENT_PORT_STS_CHANGE);
	if (pci_xhci_insert_event(xdev, &evtrb, 1) != 0)
		UPRINTF(LFTL, "Failed to inject reset port event!\n");
	}
}
