sendAssociationRJTCP(PRIVATE_NETWORKKEY ** /*network*/,
         DUL_ABORTITEMS * abortItems, PRIVATE_ASSOCIATIONKEY ** association)
{

    DUL_REJECTRELEASEABORTPDU
        pdu;
    unsigned char
        buffer[64],
       *b;
    unsigned long
        length;
    int
        nbytes;


    OFCondition cond = constructAssociateRejectPDU((unsigned char) abortItems->result,
        (unsigned char) abortItems->source, (unsigned char) abortItems->reason, &pdu);
    if (pdu.length + 6 <= sizeof(buffer))
        b = buffer;
    else {
        b = (unsigned char*)malloc(size_t(pdu.length + 6));
        if (b == NULL)  return EC_MemoryExhausted;
    }
    cond = streamRejectReleaseAbortPDU(&pdu, b, pdu.length + 6, &length);

    if ((*association)->associatePDUFlag)
    {
      // copy A-ASSOCIATE-RJ PDU
      (*association)->associatePDU = new char[length];
      if ((*association)->associatePDU)
      {
        memcpy((*association)->associatePDU, b, (size_t) length);
        (*association)->associatePDULength = length;
      }
    }

    if (cond.good())
    {
        do {
          nbytes = (*association)->connection ? (*association)->connection->write((char*)b, size_t(pdu.length + 6)) : 0;
        } while (nbytes == -1 && OFStandard::getLastNetworkErrorCode().value() == DCMNET_EINTR);
        if ((unsigned long) nbytes != pdu.length + 6)
        {
          OFString msg = "TCP I/O Error (";
          msg += OFStandard::getLastNetworkErrorCode().message();
          msg += ") occurred in routine: sendAssociationRJTCP";
          return makeDcmnetCondition(DULC_TCPIOERROR, OF_error, msg.c_str());
        }
    }
    if (b != buffer) free(b);
    return cond;
}
