static int readLine(HTTP_HANDLE_DATA* http_instance, char* buf, const size_t maxBufSize)
{
    int resultLineSize;

    if ((http_instance == NULL) || (buf == NULL) || (maxBufSize == 0))
    {
        LogError("%s", ((http_instance == NULL) ? "Invalid HTTP instance" : "Invalid HTTP buffer"));
        resultLineSize = -1;
    }
    else
    {
        char* destByte = buf;
        /*Codes_SRS_HTTPAPI_COMPACT_21_081: [ The HTTPAPI_ExecuteRequest shall try to read the message with the response up to 20 seconds. ]*/
        int countRetry = MAX_RECEIVE_RETRY;
        bool endOfSearch = false;
        resultLineSize = -1;
        while (!endOfSearch)
        {
            xio_dowork(http_instance->xio_handle);

            /* if any error was detected while receiving then simply break and report it */
            if (http_instance->is_io_error != 0)
            {
                LogError("xio reported error on dowork");
                endOfSearch = true;
            }
            else
            {
                unsigned char* receivedByte = http_instance->received_bytes;
                while (receivedByte < (http_instance->received_bytes + http_instance->received_bytes_count))
                {
                    if ((*receivedByte) != '\r')
                    {
                        (*destByte) = (*receivedByte);
                        destByte++;
                        receivedByte++;

                        if (destByte >= (buf + maxBufSize - 1))
                        {
                            LogError("Received message is bigger than the http buffer");
                            receivedByte = http_instance->received_bytes + http_instance->received_bytes_count;
                            endOfSearch = true;
                            break;
                        }
                    }
                    else
                    {
                        receivedByte++;
                        if ((receivedByte < (http_instance->received_bytes + http_instance->received_bytes_count)) && ((*receivedByte) == '\n'))
                        {
                            receivedByte++;
                        }
                        (*destByte) = '\0';
                        resultLineSize = (int)(destByte - buf);
                        endOfSearch = true;
                        break;
                    }
                }

                http_instance->received_bytes_count -= (receivedByte - http_instance->received_bytes);
                if (http_instance->received_bytes_count != 0)
                {
                    (void)memmove(http_instance->received_bytes, receivedByte, http_instance->received_bytes_count);
                }
                else
                {
                    conn_receive_discard_buffer(http_instance);
                }
            }

            if (!endOfSearch)
            {
                if ((countRetry--) > 0)
                {
                    /*Codes_SRS_HTTPAPI_COMPACT_21_083: [ The HTTPAPI_ExecuteRequest shall wait, at least, 100 milliseconds between retries. ]*/
                    ThreadAPI_Sleep(RETRY_INTERVAL_IN_MS);
                }
                else
                {
                    /*Codes_SRS_HTTPAPI_COMPACT_21_082: [ If the HTTPAPI_ExecuteRequest retries 20 seconds to receive the message without success, it shall fail and return HTTPAPI_READ_DATA_FAILED. ]*/
                    LogError("Receive timeout. The HTTP request is incomplete");
                    endOfSearch = true;
                }
            }
        }
    }

    return resultLineSize;
}
