bool downloadFile(std::string url, const std::filesystem::path &output) {
  auto temporaryPath = std::filesystem::temp_directory_path() /
                       hash(std::format("{}-{}", url, output.generic_string()));
  LOG.info(std::format("Downloading URL {} to {} (Temp: {})", url,
                       output.generic_string(),
                       temporaryPath.generic_string()));
  auto *curl = curl_easy_init();
  if (curl == nullptr) {
    LOG.error("Unable to create CURL* using curl_easy_init");
    return false;
  }
  FILE *filep = fopen(temporaryPath.c_str(), MODE);
  curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
  curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, NULL);
  curl_easy_setopt(curl, CURLOPT_WRITEDATA, filep);
  curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);
  // Less than 100kB/s in the last 10s => Timeout
  curl_easy_setopt(curl, CURLOPT_LOW_SPEED_TIME, 10L);
  curl_easy_setopt(curl, CURLOPT_CONNECTTIMEOUT, 15L);
  curl_easy_setopt(curl, CURLOPT_LOW_SPEED_LIMIT, 100000L);
  auto res = curl_easy_perform(curl);
  long httpCode = 0;
  curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &httpCode);
  LOG.info(std::format("curl_easy_perform: {} {}", curl_easy_strerror(res),
                       httpCode));
  auto goodFTP = url.starts_with("ftp://") && httpCode == FTP_OK;
  auto goodHTTP = httpCode == HTTP_OK;
  auto successful = res == CURLE_OK && (goodFTP || goodHTTP);
  curl_easy_cleanup(curl);
  (void)fclose(filep);
  if (!successful) {
    (void)std::filesystem::remove(temporaryPath);
  } else {
    try {
      std::filesystem::create_directories(output.parent_path());
      std::filesystem::copy_file(
          temporaryPath, output,
          std::filesystem::copy_options::overwrite_existing);
      std::filesystem::remove(temporaryPath);
    } catch (const std::filesystem::filesystem_error &e) {
      LOG.error(std::format("Failed to move the file: {}", e.what()));
      return false;
    }
  }
  return successful;
}
