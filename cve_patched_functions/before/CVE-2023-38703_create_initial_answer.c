static pj_status_t create_initial_answer(struct transport_ice *tp_ice,
                                         pj_pool_t *sdp_pool,
                                         pjmedia_sdp_session *loc_sdp,
                                         const pjmedia_sdp_session *rem_sdp,
                                         unsigned media_index)
{
    const pjmedia_sdp_media *rem_m = rem_sdp->media[media_index];
    pj_bool_t with_trickle;
    pj_status_t status;

    /* Check if media is removed (just in case) */
    if (rem_m->desc.port == 0) {
        return PJ_SUCCESS;
    }

    /* Verify the offer */
    status = verify_ice_sdp(tp_ice, sdp_pool, rem_sdp, media_index, 
                            PJ_ICE_SESS_ROLE_CONTROLLED, 
                            &tp_ice->rem_offer_state);
    if (status != PJ_SUCCESS) {
        set_no_ice(tp_ice, "Invalid SDP offer", status);
        return status;
    }

    /* Does remote support ICE? */
    if (tp_ice->rem_offer_state.match_comp_cnt==0) {
        set_no_ice(tp_ice, "No ICE found in SDP offer", PJ_SUCCESS);
        encode_no_ice_in_sdp(tp_ice, sdp_pool, loc_sdp, rem_sdp,
                             media_index);
        return PJ_SUCCESS;
    }

    /* ICE ice_mismatch? */
    if (tp_ice->rem_offer_state.ice_mismatch) {
        set_no_ice(tp_ice, "ICE ice_mismatch in remote offer", PJ_SUCCESS);
        encode_ice_mismatch(sdp_pool, loc_sdp, media_index);
        return PJ_SUCCESS;
    }

    /* Encode ICE in SDP */
    with_trickle = tp_ice->rem_offer_state.has_trickle &&
                   tp_ice->trickle_ice != PJ_ICE_SESS_TRICKLE_DISABLED;
    status = encode_session_in_sdp(tp_ice, sdp_pool, loc_sdp, media_index, 
                                   tp_ice->rem_offer_state.match_comp_cnt,
                                   PJ_FALSE, tp_ice->use_rtcp_mux,
                                   with_trickle);
    if (status != PJ_SUCCESS) {
        set_no_ice(tp_ice, "Error encoding SDP answer", status);
        return status;
    }

    return PJ_SUCCESS;
}
