scrollup(
    long	line_count,
    int		byfold UNUSED)	// TRUE: count a closed fold as one line
{
    int		do_sms = curwin->w_p_wrap && curwin->w_p_sms;

    if (do_sms
# ifdef FEAT_FOLDING
	    || (byfold && hasAnyFolding(curwin))
# endif
# ifdef FEAT_DIFF
	    || (curwin->w_p_diff && !curwin->w_p_wrap)
# endif
       )
    {
	int	    width1 = curwin->w_width - curwin_col_off();
	int	    width2 = width1 + curwin_col_off2();
	int	    size = 0;
	colnr_T	    prev_skipcol = curwin->w_skipcol;

	if (do_sms)
	    size = linetabsize(curwin, curwin->w_topline);

	// diff mode: first consume "topfill"
	// 'smoothscroll': increase "w_skipcol" until it goes over the end of
	// the line, then advance to the next line.
	// folding: count each sequence of folded lines as one logical line.
	for (int todo = line_count; todo > 0; --todo)
	{
# ifdef FEAT_DIFF
	    if (curwin->w_topfill > 0)
		--curwin->w_topfill;
	    else
# endif
	    {
		linenr_T lnum = curwin->w_topline;

# ifdef FEAT_FOLDING
		if (byfold)
		    // for a closed fold: go to the last line in the fold
		    (void)hasFolding(lnum, NULL, &lnum);
# endif
		if (lnum == curwin->w_topline && do_sms)
		{
		    // 'smoothscroll': increase "w_skipcol" until it goes over
		    // the end of the line, then advance to the next line.
		    int add = curwin->w_skipcol > 0 ? width2 : width1;
		    curwin->w_skipcol += add;
		    if (curwin->w_skipcol >= size)
		    {
			if (lnum == curbuf->b_ml.ml_line_count)
			{
			    // at the last screen line, can't scroll further
			    curwin->w_skipcol -= add;
			    break;
			}
			++lnum;
		    }
		}
		else
		{
		    if (lnum >= curbuf->b_ml.ml_line_count)
			break;
		    ++lnum;
		}

		if (lnum > curwin->w_topline)
		{
		    // approximate w_botline
		    curwin->w_botline += lnum - curwin->w_topline;
		    curwin->w_topline = lnum;
# ifdef FEAT_DIFF
		    curwin->w_topfill = diff_check_fill(curwin, lnum);
# endif
		    curwin->w_skipcol = 0;
		    if (todo > 1 && do_sms)
			size = linetabsize(curwin, curwin->w_topline);
		}
	    }
	}

	if (prev_skipcol > 0 || curwin->w_skipcol > 0)
	    // need to redraw more, because wl_size of the (new) topline may
	    // now be invalid
	    redraw_later(UPD_NOT_VALID);
    }
    else
    {
	curwin->w_topline += line_count;
	curwin->w_botline += line_count;	// approximate w_botline
    }

    if (curwin->w_topline > curbuf->b_ml.ml_line_count)
	curwin->w_topline = curbuf->b_ml.ml_line_count;
    if (curwin->w_botline > curbuf->b_ml.ml_line_count + 1)
	curwin->w_botline = curbuf->b_ml.ml_line_count + 1;

#ifdef FEAT_DIFF
    check_topfill(curwin, FALSE);
#endif

#ifdef FEAT_FOLDING
    if (hasAnyFolding(curwin))
	// Make sure w_topline is at the first of a sequence of folded lines.
	(void)hasFolding(curwin->w_topline, &curwin->w_topline, NULL);
#endif

    curwin->w_valid &= ~(VALID_WROW|VALID_CROW|VALID_BOTLINE);
    if (curwin->w_cursor.lnum < curwin->w_topline)
    {
	curwin->w_cursor.lnum = curwin->w_topline;
	curwin->w_valid &=
	      ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);
	coladvance(curwin->w_curswant);
    }
    if (curwin->w_cursor.lnum == curwin->w_topline
					    && do_sms && curwin->w_skipcol > 0)
    {
	int	col_off = curwin_col_off();
	int	col_off2 = curwin_col_off2();

	int	width1 = curwin->w_width - col_off;
	int	width2 = width1 + col_off2;
	int	extra2 = col_off - col_off2;
	long	so = get_scrolloff_value();
	int	scrolloff_cols = so == 0 ? 0 : width1 + (so - 1) * width2;
	int	space_cols = (curwin->w_height - 1) * width2;

	// If we have non-zero scrolloff, just ignore the marker as we are
	// going past it anyway.
	int overlap = scrolloff_cols != 0 ? 0
					  : sms_marker_overlap(curwin, extra2);

	// Make sure the cursor is in a visible part of the line, taking
	// 'scrolloff' into account, but using screen lines.
	// If there are not enough screen lines put the cursor in the middle.
	if (scrolloff_cols > space_cols / 2)
	    scrolloff_cols = space_cols / 2;
	validate_virtcol();
	if (curwin->w_virtcol < curwin->w_skipcol + overlap + scrolloff_cols)
	{
	    colnr_T col = curwin->w_virtcol;

	    if (col < width1)
		col += width1;
	    while (col < curwin->w_skipcol + overlap + scrolloff_cols)
		col += width2;
	    curwin->w_curswant = col;
	    coladvance(curwin->w_curswant);

	    // validate_virtcol() marked various things as valid, but after
	    // moving the cursor they need to be recomputed
	    curwin->w_valid &=
	       ~(VALID_WROW|VALID_WCOL|VALID_CHEIGHT|VALID_CROW|VALID_VIRTCOL);
	}
    }
}
