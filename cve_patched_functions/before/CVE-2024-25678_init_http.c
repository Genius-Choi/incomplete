init_http (struct ietf_full_conn *conn)
{
    unsigned max_risked_streams, dyn_table_size;

    fiu_return_on("full_conn_ietf/init_http", -1);
    lsquic_qeh_init(&conn->ifc_qeh, &conn->ifc_conn);
    if (conn->ifc_settings->es_qpack_experiment)
    {
        conn->ifc_qeh.qeh_exp_rec = lsquic_qpack_exp_new();
        if (conn->ifc_qeh.qeh_exp_rec)
        {
            conn->ifc_qeh.qeh_exp_rec->qer_flags |= QER_SERVER & conn->ifc_flags;
            conn->ifc_qeh.qeh_exp_rec->qer_flags |= QER_ENCODER;
        }
    }
    if (0 == avail_streams_count(conn, conn->ifc_flags & IFC_SERVER,
                                                                SD_UNI))
    {
        ABORT_QUIETLY(1, HEC_GENERAL_PROTOCOL_ERROR, "cannot create "
                            "control stream due to peer-imposed limit");
        conn->ifc_error = CONN_ERR(1, HEC_GENERAL_PROTOCOL_ERROR);
        return -1;
    }
    if (0 != create_ctl_stream_out(conn))
    {
        ABORT_WARN("cannot create outgoing control stream");
        return -1;
    }
    dyn_table_size = conn->ifc_settings->es_qpack_dec_max_size;
    max_risked_streams = conn->ifc_settings->es_qpack_dec_max_blocked;
    if (conn->ifc_settings->es_qpack_experiment == 2)
        randomize_qpack_settings(conn, "decoder", &dyn_table_size,
                                                    &max_risked_streams);
    if (0 != lsquic_hcso_write_settings(&conn->ifc_hcso,
                conn->ifc_settings->es_max_header_list_size, dyn_table_size,
                max_risked_streams, conn->ifc_flags & IFC_SERVER))
    {
        ABORT_WARN("cannot write SETTINGS");
        return -1;
    }
    if (!(conn->ifc_flags & IFC_SERVER)
        && (conn->ifc_u.cli.ifcli_flags & IFCLI_PUSH_ENABLED)
        && 0 != lsquic_hcso_write_max_push_id(&conn->ifc_hcso,
                                        conn->ifc_u.cli.ifcli_max_push_id))
    {
        ABORT_WARN("cannot write MAX_PUSH_ID");
        return -1;
    }
    if (0 != lsquic_qdh_init(&conn->ifc_qdh, &conn->ifc_conn,
                            conn->ifc_flags & IFC_SERVER, conn->ifc_enpub,
                            dyn_table_size, max_risked_streams))
    {
        ABORT_WARN("cannot initialize QPACK decoder");
        return -1;
    }
    if (avail_streams_count(conn, conn->ifc_flags & IFC_SERVER, SD_UNI) > 0)
    {
        if (0 != create_qdec_stream_out(conn))
        {
            ABORT_WARN("cannot create outgoing QPACK decoder stream");
            return -1;
        }
    }
    else
    {
        queue_streams_blocked_frame(conn, SD_UNI);
        LSQ_DEBUG("cannot create outgoing QPACK decoder stream due to "
            "unidir limits");
    }
    conn->ifc_flags |= IFC_HTTP_INITED;
    return 0;
}
