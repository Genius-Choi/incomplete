void DoPrefs(void) {
    GRect pos;
    GWindow gw;
    GWindowAttrs wattrs;
    GGadgetCreateData *pgcd, gcd[5], sgcd[45], mgcd[3], mfgcd[9], msgcd[9];
    GGadgetCreateData mfboxes[3], *mfarray[14];
    GGadgetCreateData mpboxes[3], *mparray[14];
    GGadgetCreateData sboxes[2], *sarray[50];
    GGadgetCreateData mboxes[3], *varray[5], *harray[8];
    GTextInfo *plabel, **list, label[5], slabel[45], *plabels[TOPICS+5], mflabels[9], mslabels[9];
    GTabInfo aspects[TOPICS+5], subaspects[3];
    GGadgetCreateData **hvarray, boxes[2*TOPICS];
    struct pref_data p;
    int i, gc, sgc, j, k, line, line_max, y, y2, ii, si;
    int32 llen;
    char buf[20];
    int gcnt[20];
    static unichar_t nullstr[] = { 0 };
    struct prefs_list *pl;
    char *tempstr;
    FontRequest rq;
    GFont *font;

    PrefsInit();

    MfArgsInit();
    for ( k=line_max=0; visible_prefs_list[k].tab_name!=0; ++k ) {
	for ( i=line=gcnt[k]=0; visible_prefs_list[k].pl[i].name!=NULL; ++i ) {
	    if ( visible_prefs_list[k].pl[i].dontdisplay )
	continue;
	    gcnt[k] += 2;
	    if ( visible_prefs_list[k].pl[i].type==pr_bool ) ++gcnt[k];
	    else if ( visible_prefs_list[k].pl[i].type==pr_file ) ++gcnt[k];
	    else if ( visible_prefs_list[k].pl[i].type==pr_angle ) ++gcnt[k];
	    ++line;
	}
	if ( visible_prefs_list[k].pl == args_list ) {
	    gcnt[k] += 6;
	    line += 6;
	}
	if ( line>line_max ) line_max = line;
    }

    prefs_oldval_cvEditHandleSize = prefs_cvEditHandleSize;
    prefs_oldval_cvInactiveHandleAlpha = prefs_cvInactiveHandleAlpha;

    memset(&p,'\0',sizeof(p));
    memset(&wattrs,0,sizeof(wattrs));
    wattrs.mask = wam_events|wam_cursor|wam_utf8_wtitle|wam_undercursor|wam_restrict|wam_isdlg;
    wattrs.event_masks = ~(1<<et_charup);
    wattrs.restrict_input_to_me = 1;
    wattrs.is_dlg = 1;
    wattrs.undercursor = 1;
    wattrs.cursor = ct_pointer;
    wattrs.utf8_window_title = _("Preferences");
    pos.x = pos.y = 0;
    pos.width = GGadgetScale(GDrawPointsToPixels(NULL,350));
    pos.height = GDrawPointsToPixels(NULL,line_max*26+69);
    gw = GDrawCreateTopWindow(NULL,&pos,e_h,&p,&wattrs);

    memset(sgcd,0,sizeof(sgcd));
    memset(slabel,0,sizeof(slabel));
    memset(&mfgcd,0,sizeof(mfgcd));
    memset(&msgcd,0,sizeof(msgcd));
    memset(&mflabels,0,sizeof(mflabels));
    memset(&mslabels,0,sizeof(mslabels));
    memset(&mfboxes,0,sizeof(mfboxes));
    memset(&mpboxes,0,sizeof(mpboxes));
    memset(&sboxes,0,sizeof(sboxes));
    memset(&boxes,0,sizeof(boxes));

    GCDFillMacFeat(mfgcd,mflabels,250,default_mac_feature_map, true, mfboxes, mfarray);

    sgc = 0;

    msgcd[sgc].gd.pos.x = 6; msgcd[sgc].gd.pos.y = 6;
    msgcd[sgc].gd.pos.width = 250; msgcd[sgc].gd.pos.height = 16*12+10;
    msgcd[sgc].gd.flags = gg_visible | gg_enabled | gg_list_alphabetic | gg_list_multiplesel;
    msgcd[sgc].gd.cid = CID_Mapping;
    msgcd[sgc].gd.u.list = Pref_MappingList(true);
    msgcd[sgc].gd.handle_controlevent = Pref_MappingSel;
    msgcd[sgc++].creator = GListCreate;
    mparray[0] = &msgcd[sgc-1];

    msgcd[sgc].gd.pos.x = 6; msgcd[sgc].gd.pos.y = msgcd[sgc-1].gd.pos.y+msgcd[sgc-1].gd.pos.height+10;
    msgcd[sgc].gd.flags = gg_visible | gg_enabled;
    mslabels[sgc].text = (unichar_t *) S_("MacMap|_New...");
    mslabels[sgc].text_is_1byte = true;
    mslabels[sgc].text_in_resource = true;
    msgcd[sgc].gd.label = &mslabels[sgc];
    msgcd[sgc].gd.handle_controlevent = Pref_NewMapping;
    msgcd[sgc++].creator = GButtonCreate;
    mparray[4] = GCD_Glue; mparray[5] = &msgcd[sgc-1];

    msgcd[sgc].gd.pos.x = msgcd[sgc-1].gd.pos.x+10+GIntGetResource(_NUM_Buttonsize)*100/GIntGetResource(_NUM_ScaleFactor);
    msgcd[sgc].gd.pos.y = msgcd[sgc-1].gd.pos.y;
    msgcd[sgc].gd.flags = gg_visible ;
    mslabels[sgc].text = (unichar_t *) _("_Delete");
    mslabels[sgc].text_is_1byte = true;
    mslabels[sgc].text_in_resource = true;
    msgcd[sgc].gd.label = &mslabels[sgc];
    msgcd[sgc].gd.cid = CID_MappingDel;
    msgcd[sgc].gd.handle_controlevent = Pref_DelMapping;
    msgcd[sgc++].creator = GButtonCreate;
    mparray[5] = GCD_Glue; mparray[6] = &msgcd[sgc-1];

    msgcd[sgc].gd.pos.x = msgcd[sgc-1].gd.pos.x+10+GIntGetResource(_NUM_Buttonsize)*100/GIntGetResource(_NUM_ScaleFactor);
    msgcd[sgc].gd.pos.y = msgcd[sgc-1].gd.pos.y;
    msgcd[sgc].gd.flags = gg_visible ;
    mslabels[sgc].text = (unichar_t *) _("_Edit...");
    mslabels[sgc].text_is_1byte = true;
    mslabels[sgc].text_in_resource = true;
    msgcd[sgc].gd.label = &mslabels[sgc];
    msgcd[sgc].gd.cid = CID_MappingEdit;
    msgcd[sgc].gd.handle_controlevent = Pref_EditMapping;
    msgcd[sgc++].creator = GButtonCreate;
    mparray[7] = GCD_Glue; mparray[8] = &msgcd[sgc-1];

    msgcd[sgc].gd.pos.x = msgcd[sgc-1].gd.pos.x+10+GIntGetResource(_NUM_Buttonsize)*100/GIntGetResource(_NUM_ScaleFactor);
    msgcd[sgc].gd.pos.y = msgcd[sgc-1].gd.pos.y;
    msgcd[sgc].gd.flags = gg_visible | gg_enabled;
    mslabels[sgc].text = (unichar_t *) S_("MacMapping|Default");
    mslabels[sgc].text_is_1byte = true;
    mslabels[sgc].text_in_resource = true;
    msgcd[sgc].gd.label = &mslabels[sgc];
    msgcd[sgc].gd.handle_controlevent = Pref_DefaultMapping;
    msgcd[sgc++].creator = GButtonCreate;
    mparray[9] = GCD_Glue; mparray[10] = &msgcd[sgc-1];
    mparray[11] = GCD_Glue; mparray[12] = NULL;

    mpboxes[2].gd.flags = gg_enabled|gg_visible;
    mpboxes[2].gd.u.boxelements = mparray+4;
    mpboxes[2].creator = GHBoxCreate;
    mparray[1] = GCD_Glue;
    mparray[2] = &mpboxes[2];
    mparray[3] = NULL;

    mpboxes[0].gd.flags = gg_enabled|gg_visible;
    mpboxes[0].gd.u.boxelements = mparray;
    mpboxes[0].creator = GVBoxCreate;

    sgc = 0;
    y2=5;
    si = 0;

    slabel[sgc].text = (unichar_t *) _("Menu Name");
    slabel[sgc].text_is_1byte = true;
    sgcd[sgc].gd.label = &slabel[sgc];
    sgcd[sgc].gd.popup_msg = (unichar_t *) _("You may create a script menu containing up to 10 frequently used scripts.\nEach entry in the menu needs both a name to display in the menu and\na script file to execute. The menu name may contain any unicode characters.\nThe button labeled \"...\" will allow you to browse for a script file.");
    sgcd[sgc].gd.pos.x = 8;
    sgcd[sgc].gd.pos.y = y2;
    sgcd[sgc].gd.flags = gg_visible | gg_enabled | gg_utf8_popup;
    sgcd[sgc++].creator = GLabelCreate;
    sarray[si++] = &sgcd[sgc-1];

    slabel[sgc].text = (unichar_t *) _("Script File");
    slabel[sgc].text_is_1byte = true;
    sgcd[sgc].gd.label = &slabel[sgc];
    sgcd[sgc].gd.popup_msg = (unichar_t *) _("You may create a script menu containing up to 10 frequently used scripts\nEach entry in the menu needs both a name to display in the menu and\na script file to execute. The menu name may contain any unicode characters.\nThe button labeled \"...\" will allow you to browse for a script file.");
    sgcd[sgc].gd.pos.x = 110;
    sgcd[sgc].gd.pos.y = y2;
    sgcd[sgc].gd.flags = gg_visible | gg_enabled | gg_utf8_popup;
    sgcd[sgc++].creator = GLabelCreate;
    sarray[si++] = &sgcd[sgc-1];
    sarray[si++] = GCD_Glue;
    sarray[si++] = NULL;

    y2 += 14;

    for ( i=0; i<SCRIPT_MENU_MAX; ++i ) {
	sgcd[sgc].gd.pos.x = 8; sgcd[sgc].gd.pos.y = y2;
	sgcd[sgc].gd.flags = gg_visible | gg_enabled | gg_text_xim;
	slabel[sgc].text = script_menu_names[i]==NULL?nullstr:script_menu_names[i];
	sgcd[sgc].gd.label = &slabel[sgc];
	sgcd[sgc].gd.cid = i+CID_ScriptMNameBase;
	sgcd[sgc++].creator = GTextFieldCreate;
	sarray[si++] = &sgcd[sgc-1];

	sgcd[sgc].gd.pos.x = 110; sgcd[sgc].gd.pos.y = y2;
	sgcd[sgc].gd.flags = gg_visible | gg_enabled;
	slabel[sgc].text = (unichar_t *) (script_filenames[i]==NULL?"":script_filenames[i]);
	slabel[sgc].text_is_1byte = true;
	sgcd[sgc].gd.label = &slabel[sgc];
	sgcd[sgc].gd.cid = i+CID_ScriptMFileBase;
	sgcd[sgc++].creator = GTextFieldCreate;
	sarray[si++] = &sgcd[sgc-1];

	sgcd[sgc].gd.pos.x = 210; sgcd[sgc].gd.pos.y = y2;
	sgcd[sgc].gd.flags = gg_visible | gg_enabled;
	slabel[sgc].text = (unichar_t *) _("...");
	slabel[sgc].text_is_1byte = true;
	sgcd[sgc].gd.label = &slabel[sgc];
	sgcd[sgc].gd.cid = i+CID_ScriptMBrowseBase;
	sgcd[sgc].gd.handle_controlevent = Prefs_ScriptBrowse;
	sgcd[sgc++].creator = GButtonCreate;
	sarray[si++] = &sgcd[sgc-1];
	sarray[si++] = NULL;

	y2 += 26;
    }
    sarray[si++] = GCD_Glue; sarray[si++] = GCD_Glue; sarray[si++] = GCD_Glue;
    sarray[si++] = NULL;
    sarray[si++] = NULL;

    sboxes[0].gd.flags = gg_enabled|gg_visible;
    sboxes[0].gd.u.boxelements = sarray;
    sboxes[0].creator = GHVBoxCreate;

    memset(&mgcd,0,sizeof(mgcd));
    memset(&mgcd,0,sizeof(mgcd));
    memset(&subaspects,'\0',sizeof(subaspects));
    memset(&label,0,sizeof(label));
    memset(&gcd,0,sizeof(gcd));
    memset(&aspects,'\0',sizeof(aspects));
    aspects[0].selected = true;

    for ( k=0; visible_prefs_list[k].tab_name!=0; ++k ) {
	pgcd = calloc(gcnt[k]+4,sizeof(GGadgetCreateData));
	plabel = calloc(gcnt[k]+4,sizeof(GTextInfo));
	hvarray = calloc((gcnt[k]+6)*5+2,sizeof(GGadgetCreateData *));

	aspects[k].text = (unichar_t *) visible_prefs_list[k].tab_name;
	aspects[k].text_is_1byte = true;
	aspects[k].gcd = &boxes[2*k];
	aspects[k].nesting = visible_prefs_list[k].nest;
	plabels[k] = plabel;

	gc = si = 0;
	for ( i=line=0, y=5; visible_prefs_list[k].pl[i].name!=NULL; ++i ) {
	    pl = &visible_prefs_list[k].pl[i];
	    if ( pl->dontdisplay )
	continue;
	    plabel[gc].text = (unichar_t *) _(pl->name);
	    plabel[gc].text_is_1byte = true;
	    pgcd[gc].gd.label = &plabel[gc];
	    pgcd[gc].gd.mnemonic = '\0';
	    pgcd[gc].gd.popup_msg = (unichar_t *) _(pl->popup);
	    pgcd[gc].gd.pos.x = 8;
	    pgcd[gc].gd.pos.y = y + 6;
	    pgcd[gc].gd.flags = gg_visible | gg_enabled | gg_utf8_popup;
	    pgcd[gc++].creator = GLabelCreate;
	    hvarray[si++] = &pgcd[gc-1];

	    plabel[gc].text_is_1byte = true;
	    pgcd[gc].gd.label = &plabel[gc];
	    pgcd[gc].gd.mnemonic = '\0';
	    pgcd[gc].gd.popup_msg = (unichar_t *) _(pl->popup);
	    pgcd[gc].gd.pos.x = 110;
	    pgcd[gc].gd.pos.y = y;
	    pgcd[gc].gd.flags = gg_visible | gg_enabled | gg_utf8_popup;
	    pgcd[gc].data = pl;
	    pgcd[gc].gd.cid = k*CID_PrefsOffset+CID_PrefsBase+i;
	    switch ( pl->type ) {
	      case pr_bool:
		plabel[gc].text = (unichar_t *) _("On");
		pgcd[gc].gd.pos.y += 3;
		pgcd[gc++].creator = GRadioCreate;
		hvarray[si++] = &pgcd[gc-1];
		pgcd[gc] = pgcd[gc-1];
		pgcd[gc].gd.pos.x += 50;
		pgcd[gc].gd.cid = 0;
		pgcd[gc].gd.label = &plabel[gc];
		plabel[gc].text = (unichar_t *) _("Off");
		plabel[gc].text_is_1byte = true;
		hvarray[si++] = &pgcd[gc];
		hvarray[si++] = GCD_Glue;
		if ( *((int *) pl->val))
		    pgcd[gc-1].gd.flags |= gg_cb_on;
		else
		    pgcd[gc].gd.flags |= gg_cb_on;
		++gc;
		y += 22;
	      break;
	      case pr_int:
		sprintf(buf,"%d", *((int *) pl->val));
		plabel[gc].text = (unichar_t *) copy( buf );
		pgcd[gc++].creator = GTextFieldCreate;
		hvarray[si++] = &pgcd[gc-1];
		hvarray[si++] = GCD_Glue; hvarray[si++] = GCD_Glue;
		y += 26;
	      break;
	      case pr_unicode:
		/*sprintf(buf,"U+%04x", *((int *) pl->val));*/
		{ char *pt; pt=buf; pt=utf8_idpb(pt,*((int *)pl->val),UTF8IDPB_NOZERO); *pt='\0'; }
		plabel[gc].text = (unichar_t *) copy( buf );
		pgcd[gc++].creator = GTextFieldCreate;
		hvarray[si++] = &pgcd[gc-1];
		hvarray[si++] = GCD_Glue; hvarray[si++] = GCD_Glue;
		y += 26;
	      break;
	      case pr_real:
		sprintf(buf,"%g", *((float *) pl->val));
		plabel[gc].text = (unichar_t *) copy( buf );
		pgcd[gc++].creator = GTextFieldCreate;
		hvarray[si++] = &pgcd[gc-1];
		hvarray[si++] = GCD_Glue; hvarray[si++] = GCD_Glue;
		y += 26;
	      break;
	      case pr_encoding:
		pgcd[gc].gd.u.list = GetEncodingTypes();
		pgcd[gc].gd.label = EncodingTypesFindEnc(pgcd[gc].gd.u.list,
			*(Encoding **) pl->val);
		for ( ii=0; pgcd[gc].gd.u.list[ii].text!=NULL ||pgcd[gc].gd.u.list[ii].line; ++ii )
		    if ( pgcd[gc].gd.u.list[ii].userdata!=NULL &&
			    (strcmp(pgcd[gc].gd.u.list[ii].userdata,"Compacted")==0 ||
			     strcmp(pgcd[gc].gd.u.list[ii].userdata,"Original")==0 ))
			pgcd[gc].gd.u.list[ii].disabled = true;
		pgcd[gc].creator = GListFieldCreate;
		pgcd[gc].gd.pos.width = 160;
		if ( pgcd[gc].gd.label==NULL ) pgcd[gc].gd.label = &encodingtypes[0];
		++gc;
		hvarray[si++] = &pgcd[gc-1];
		hvarray[si++] = GCD_ColSpan; hvarray[si++] = GCD_ColSpan;
		y += 28;
	      break;
	      case pr_namelist:
	        { char **nlnames = AllNamelistNames();
		int cnt;
		GTextInfo *namelistnames;
		for ( cnt=0; nlnames[cnt]!=NULL; ++cnt);
		namelistnames = calloc(cnt+1,sizeof(GTextInfo));
		for ( cnt=0; nlnames[cnt]!=NULL; ++cnt) {
		    namelistnames[cnt].text = (unichar_t *) nlnames[cnt];
		    namelistnames[cnt].text_is_1byte = true;
		    if ( strcmp(_((*(NameList **) (pl->val))->title),nlnames[cnt])==0 ) {
			namelistnames[cnt].selected = true;
			pgcd[gc].gd.label = &namelistnames[cnt];
		    }
		}
		pgcd[gc].gd.u.list = namelistnames;
		pgcd[gc].creator = GListButtonCreate;
		pgcd[gc].gd.pos.width = 160;
		++gc;
		hvarray[si++] = &pgcd[gc-1];
		hvarray[si++] = GCD_ColSpan; hvarray[si++] = GCD_ColSpan;
		y += 28;
	      } break;
	      case pr_string: case pr_file:
		if ( pl->set==SetAutoTraceArgs || ((char **) pl->val)==&mf_args )
		    pgcd[gc].gd.pos.width = 160;
		if ( pl->val!=NULL )
		    tempstr = *((char **) (pl->val));
		else
		    tempstr = (char *) ((pl->get)());
		if ( tempstr!=NULL )
		    plabel[gc].text = /* def2u_*/ uc_copy( tempstr );
		else if ( ((char **) pl->val)==&BDFFoundry )
		    plabel[gc].text = /* def2u_*/ uc_copy( "FontForge" );
		else
		    plabel[gc].text = /* def2u_*/ uc_copy( "" );
		plabel[gc].text_is_1byte = false;
		pgcd[gc++].creator = GTextFieldCreate;
		hvarray[si++] = &pgcd[gc-1];
		if ( pl->type==pr_file ) {
		    pgcd[gc] = pgcd[gc-1];
		    pgcd[gc-1].gd.pos.width = 140;
		    hvarray[si++] = GCD_ColSpan;
		    pgcd[gc].gd.pos.x += 145;
		    pgcd[gc].gd.cid += CID_PrefsBrowseOffset;
		    pgcd[gc].gd.label = &plabel[gc];
		    plabel[gc].text = (unichar_t *) "...";
		    plabel[gc].text_is_1byte = true;
		    pgcd[gc].gd.handle_controlevent = Prefs_BrowseFile;
		    pgcd[gc++].creator = GButtonCreate;
		    hvarray[si++] = &pgcd[gc-1];
		} else if ( pl->set==SetAutoTraceArgs || ((char **) pl->val)==&mf_args ) {
		    hvarray[si++] = GCD_ColSpan;
		    hvarray[si++] = GCD_Glue;
		} else {
		    hvarray[si++] = GCD_Glue;
		    hvarray[si++] = GCD_Glue;
		}
		y += 26;
		if ( pl->val==NULL )
		    free(tempstr);
	      break;
	      case pr_angle:
		sprintf(buf,"%g", *((float *) pl->val) * RAD2DEG);
		plabel[gc].text = (unichar_t *) copy( buf );
		pgcd[gc++].creator = GTextFieldCreate;
		hvarray[si++] = &pgcd[gc-1];
		plabel[gc].text = (unichar_t *) U_("°");
		plabel[gc].text_is_1byte = true;
		pgcd[gc].gd.label = &plabel[gc];
		pgcd[gc].gd.pos.x = pgcd[gc-1].gd.pos.x+gcd[gc-1].gd.pos.width+2; pgcd[gc].gd.pos.y = pgcd[gc-1].gd.pos.y;
		pgcd[gc].gd.flags = gg_enabled|gg_visible;
		pgcd[gc++].creator = GLabelCreate;
		hvarray[si++] = &pgcd[gc-1];
		hvarray[si++] = GCD_Glue;
		y += 26;
	      break;
	    }
	    ++line;
	    hvarray[si++] = NULL;
	}
	if ( visible_prefs_list[k].pl == args_list ) {
	    static char *text[] = {
/* GT: See the long comment at "Property|New" */
/* GT: This and the next few strings show a limitation of my widget set which */
/* GT: cannot handle multi-line text labels. These strings should be concatenated */
/* GT: (after striping off "Prefs_App|") together, translated, and then broken up */
/* GT: to fit the dialog. There is an extra blank line, not used in English, */
/* GT: into which your text may extend if needed. */
		N_("Prefs_App|Normally FontForge will find applications by searching for"),
		N_("Prefs_App|them in your PATH environment variable, if you want"),
		N_("Prefs_App|to alter that behavior you may set an environment"),
		N_("Prefs_App|variable giving the full path spec of the application."),
		N_("Prefs_App|FontForge recognizes BROWSER, MF and AUTOTRACE."),
		N_("Prefs_App| "), /* A blank line */
		NULL };
	    y += 8;
	    for ( i=0; text[i]!=0; ++i ) {
		plabel[gc].text = (unichar_t *) S_(text[i]);
		plabel[gc].text_is_1byte = true;
		pgcd[gc].gd.label = &plabel[gc];
		pgcd[gc].gd.pos.x = 8;
		pgcd[gc].gd.pos.y = y;
		pgcd[gc].gd.flags = gg_visible | gg_enabled;
		pgcd[gc++].creator = GLabelCreate;
		hvarray[si++] = &pgcd[gc-1];
		hvarray[si++] = GCD_ColSpan; hvarray[si++] = GCD_ColSpan;
		hvarray[si++] = NULL;
		y += 12;
	    }
	}
	if ( y>y2 ) y2 = y;
	hvarray[si++] = GCD_Glue; hvarray[si++] = GCD_Glue;
	hvarray[si++] = GCD_Glue; hvarray[si++] = GCD_Glue;
	hvarray[si++] = NULL;
	hvarray[si++] = NULL;
	boxes[2*k].gd.flags = gg_enabled|gg_visible;
	boxes[2*k].gd.u.boxelements = hvarray;
	boxes[2*k].creator = GHVBoxCreate;
    }

    aspects[k].text = (unichar_t *) _("Script Menu");
    aspects[k].text_is_1byte = true;
    aspects[k++].gcd = sboxes;

    subaspects[0].text = (unichar_t *) _("Features");
    subaspects[0].text_is_1byte = true;
    subaspects[0].gcd = mfboxes;

    subaspects[1].text = (unichar_t *) _("Mapping");
    subaspects[1].text_is_1byte = true;
    subaspects[1].gcd = mpboxes;

    mgcd[0].gd.pos.x = 4; gcd[0].gd.pos.y = 6;
    mgcd[0].gd.pos.width = GDrawPixelsToPoints(NULL,pos.width)-20;
    mgcd[0].gd.pos.height = y2;
    mgcd[0].gd.u.tabs = subaspects;
    mgcd[0].gd.flags = gg_visible | gg_enabled;
    mgcd[0].creator = GTabSetCreate;

    aspects[k].text = (unichar_t *) _("Mac");
    aspects[k].text_is_1byte = true;
    aspects[k++].gcd = mgcd;

    gc = 0;

    gcd[gc].gd.pos.x = gcd[gc].gd.pos.y = 2;
    gcd[gc].gd.pos.width = pos.width-4; gcd[gc].gd.pos.height = pos.height-2;
    gcd[gc].gd.flags = gg_enabled | gg_visible | gg_pos_in_pixels;
    gcd[gc++].creator = GGroupCreate;

    gcd[gc].gd.pos.x = 4; gcd[gc].gd.pos.y = 6;
    gcd[gc].gd.pos.width = GDrawPixelsToPoints(NULL,pos.width)-8;
    gcd[gc].gd.pos.height = y2+20+18+4;
    gcd[gc].gd.u.tabs = aspects;
    gcd[gc].gd.flags = gg_visible | gg_enabled | gg_tabset_vert;
    gcd[gc++].creator = GTabSetCreate;
    varray[0] = &gcd[gc-1]; varray[1] = NULL;

    y = gcd[gc-1].gd.pos.y+gcd[gc-1].gd.pos.height;

    gcd[gc].gd.pos.x = 30-3; gcd[gc].gd.pos.y = y+5-3;
    gcd[gc].gd.pos.width = -1; gcd[gc].gd.pos.height = 0;
    gcd[gc].gd.flags = gg_visible | gg_enabled | gg_but_default;
    label[gc].text = (unichar_t *) _("_OK");
    label[gc].text_is_1byte = true;
    label[gc].text_in_resource = true;
    gcd[gc].gd.mnemonic = 'O';
    gcd[gc].gd.label = &label[gc];
    gcd[gc].gd.handle_controlevent = Prefs_Ok;
    gcd[gc++].creator = GButtonCreate;
    harray[0] = GCD_Glue; harray[1] = &gcd[gc-1]; harray[2] = GCD_Glue; harray[3] = GCD_Glue;

    gcd[gc].gd.pos.x = -30; gcd[gc].gd.pos.y = gcd[gc-1].gd.pos.y+3;
    gcd[gc].gd.pos.width = -1; gcd[gc].gd.pos.height = 0;
    gcd[gc].gd.flags = gg_visible | gg_enabled | gg_but_cancel;
    label[gc].text = (unichar_t *) _("_Cancel");
    label[gc].text_is_1byte = true;
    label[gc].text_in_resource = true;
    gcd[gc].gd.label = &label[gc];
    gcd[gc].gd.mnemonic = 'C';
    gcd[gc].gd.handle_controlevent = Prefs_Cancel;
    gcd[gc++].creator = GButtonCreate;
    harray[4] = GCD_Glue; harray[5] = &gcd[gc-1]; harray[6] = GCD_Glue; harray[7] = NULL;

    memset(mboxes,0,sizeof(mboxes));
    mboxes[2].gd.flags = gg_enabled|gg_visible;
    mboxes[2].gd.u.boxelements = harray;
    mboxes[2].creator = GHBoxCreate;
    varray[2] = &mboxes[2];
    varray[3] = NULL;
    varray[4] = NULL;

    mboxes[0].gd.pos.x = mboxes[0].gd.pos.y = 2;
    mboxes[0].gd.flags = gg_enabled|gg_visible;
    mboxes[0].gd.u.boxelements = varray;
    mboxes[0].creator = GHVGroupCreate;

    y = GDrawPointsToPixels(NULL,y+37);
    gcd[0].gd.pos.height = y-4;

    GGadgetsCreate(gw,mboxes);
    GTextInfoListFree(mfgcd[0].gd.u.list);
    GTextInfoListFree(msgcd[0].gd.u.list);

    GHVBoxSetExpandableRow(mboxes[0].ret,0);
    GHVBoxSetExpandableCol(mboxes[2].ret,gb_expandgluesame);
    GHVBoxSetExpandableRow(mfboxes[0].ret,0);
    GHVBoxSetExpandableCol(mfboxes[2].ret,gb_expandgluesame);
    GHVBoxSetExpandableRow(mpboxes[0].ret,0);
    GHVBoxSetExpandableCol(mpboxes[2].ret,gb_expandgluesame);
    GHVBoxSetExpandableRow(sboxes[0].ret,gb_expandglue);
    for ( k=0; k<TOPICS; ++k )
	GHVBoxSetExpandableRow(boxes[2*k].ret,gb_expandglue);

    memset(&rq,0,sizeof(rq));
    rq.utf8_family_name = MONO_UI_FAMILIES;
    rq.point_size = 12;
    rq.weight = 400;
    font = GDrawInstanciateFont(gw,&rq);
    GGadgetSetFont(mfgcd[0].ret,font);
    GGadgetSetFont(msgcd[0].ret,font);
    GHVBoxFitWindow(mboxes[0].ret);

    for ( k=0; visible_prefs_list[k].tab_name!=0; ++k ) for ( gc=0,i=0; visible_prefs_list[k].pl[i].name!=NULL; ++i ) {
	GGadgetCreateData *gcd = aspects[k].gcd[0].gd.u.boxelements[0];
	pl = &visible_prefs_list[k].pl[i];
	if ( pl->dontdisplay )
    continue;
	switch ( pl->type ) {
	  case pr_bool:
	    ++gc;
	  break;
	  case pr_encoding: {
	    GGadget *g = gcd[gc+1].ret;
	    list = GGadgetGetList(g,&llen);
	    for ( j=0; j<llen ; ++j ) {
		if ( list[j]->text!=NULL &&
			(void *) (intpt) ( *((int *) pl->val)) == list[j]->userdata )
		    list[j]->selected = true;
		else
		    list[j]->selected = false;
	    }
	    if ( gcd[gc+1].gd.u.list!=encodingtypes )
		GTextInfoListFree(gcd[gc+1].gd.u.list);
	  } break;
	  case pr_namelist:
	    free(gcd[gc+1].gd.u.list);
	  break;
	  case pr_string: case pr_file: case pr_int: case pr_real: case pr_unicode: case pr_angle:
	    free(plabels[k][gc+1].text);
	    if ( pl->type==pr_file || pl->type==pr_angle )
		++gc;
	  break;
	}
	gc += 2;
    }

    for ( k=0; visible_prefs_list[k].tab_name!=0; ++k ) {
	free(aspects[k].gcd->gd.u.boxelements[0]);
	free(aspects[k].gcd->gd.u.boxelements);
	free(plabels[k]);
    }

    GWidgetHidePalettes();
    GDrawSetVisible(gw,true);
    while ( !p.done )
	GDrawProcessOneEvent(NULL);
    GDrawDestroyWindow(gw);
}
