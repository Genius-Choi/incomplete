static void disasm_until_optype(RCore *core, ut64 addr, char type_print, int optype, int limit) {
	int p = 0;
	const bool show_color = core->print->flags & R_PRINT_FLAGS_COLOR;
	int i;
	for (i = 0; i < limit; i++) {
		RAnalOp *op = r_core_anal_op (core, addr, R_ARCH_OP_MASK_BASIC | R_ARCH_OP_MASK_DISASM);
		if (op) {
			char *mnem = op->mnemonic;
			char *m = malloc ((strlen (mnem) * 2) + 32);
			strcpy (m, mnem);
			//r_parse_parse (core->parser, op->mnemonic, m);
			if (type_print == 'q') {
				r_cons_printf ("%s\n", m);
			} else {
				if (show_color) {
					const char *offsetColor = r_cons_singleton ()->context->pal.offset; // TODO etooslow. must cache
					r_cons_printf ("%s0x%08"PFMT64x Color_RESET"  %10s %s\n",
							offsetColor, addr + p, "", m);
				} else {
					r_cons_printf ("0x%08"PFMT64x"  %10s %s\n", addr + p, "", m);
				}
			}
			if ((op->type & 0xfffff) == optype) {
				goto beach;
			}
			if (op->type == R_ANAL_OP_TYPE_JMP) {
				addr = op->jump;
			} else {
				addr += op->size;
			}
		} else {
			R_LOG_ERROR ("[pdp] Cannot get op at 0x%08"PFMT64x, addr + p);
			r_anal_op_free (op);
			break;
		}
		//r_io_read_at (core->io, n, rbuf, 512);
		r_anal_op_free (op);
	}
beach:
	return;
}
