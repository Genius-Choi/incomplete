static int check_rtcp_and_ice(switch_rtp_t *rtp_session)
{
	int ret = 0;
	int rtcp_ok = 0, rtcp_cyclic = 0, rtcp_fb = 0, force_send_rr = 0;
	switch_time_t now = switch_micro_time_now();
	int rate = 0, nack_ttl = 0, nack_dup = 0; 
	uint32_t cur_nack[MAX_NACK] = { 0 };
	uint16_t seq = 0;

	if (!rtp_session->flags[SWITCH_RTP_FLAG_UDPTL] &&
		rtp_session->flags[SWITCH_RTP_FLAG_AUTO_CNG] &&
		rtp_session->send_msg.header.ts &&
		rtp_session->cng_pt != INVALID_PT &&
		(rtp_session->write_timer.samplecount - rtp_session->last_write_samplecount >= rtp_session->samples_per_interval * 60)) {
		uint8_t data[10] = { 0 };
		switch_frame_flag_t frame_flags = SFF_NONE;
		data[0] = 65;
		rtp_session->cn++;

		get_next_write_ts(rtp_session, 0);
		rtp_session->send_msg.header.ts = htonl(rtp_session->ts);

		switch_rtp_write_manual(rtp_session, (void *) data, 2, 0, rtp_session->cng_pt, ntohl(rtp_session->send_msg.header.ts), &frame_flags);

		if (switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_USE_TIMER)) {
			rtp_session->last_write_samplecount = rtp_session->write_timer.samplecount;
		}
	}

	rate = rtp_session->rtcp_interval;

	if (rtp_session->flags[SWITCH_RTP_FLAG_NACK] && rtp_session->vb) {
		int n;
		for (n = 0; n < MAX_NACK; n++) {
			uint32_t nack = switch_jb_pop_nack(rtp_session->vb);

			if (!nack) break;

			seq = ntohs(nack & 0xFFFF);

			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, "%s Got NACK [%u][0x%x] for seq %u\n",
					switch_core_session_get_name(rtp_session->session), nack, nack, seq);

			cur_nack[nack_ttl++] = nack;
		}
		if (nack_ttl) {
			rtcp_ok = 1;
			rtcp_fb = 1;
		}
	}



	if (rtp_session->rtcp_sent_packets < 4) {
		rate = 4000;
	} else  {
		if (rtp_session->pli_count || rtp_session->fir_count || rtp_session->tmmbr || rtp_session->tmmbn) {
			//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "MARK BW/FIR ETC %d %d\n", rtp_session->pli_count, rtp_session->fir_count);
			rtcp_ok = 1;
			rtcp_fb = 1;
		}
	}

	if (rtp_session->send_rr) {
		rtp_session->send_rr = 0;
		rtcp_ok = 1;
		force_send_rr = 1;
	}

	//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "TIME CHECK %d > %d\n", (int)((now - rtp_session->rtcp_last_sent) / 1000), rate);

	if (!rtcp_ok && (!rtp_session->rtcp_last_sent || (int)((now - rtp_session->rtcp_last_sent) / 1000) > rate)) {
		//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "TIME UP\n");
		rtcp_cyclic = 1;
		rtcp_ok = 1;
	}

	if (rtcp_ok && using_ice(rtp_session)) {
		if (rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {
			if (!rtp_session->ice.rready) {
				rtcp_ok = 0;
			}
		} else {
			if (!rtp_session->rtcp_ice.rready) {
				rtcp_ok = 0;
			}
		}
	}

	//switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "WTF %d %d %d %d\n", rate, rtp_session->rtcp_sent_packets, rtcp_ok, nack_ttl);

	if (rtp_session->rtcp_sock_output && rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP] && !rtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU] && rtcp_ok) {
		switch_rtcp_numbers_t * stats = &rtp_session->stats.rtcp;
		struct switch_rtcp_receiver_report *rr;
		struct switch_rtcp_sender_report *sr;
		struct switch_rtcp_report_block *rtcp_report_block = NULL;
		switch_size_t rtcp_bytes = sizeof(struct switch_rtcp_hdr_s)+sizeof(uint32_t); /* add size of the packet header and the ssrc */
		switch_rtcp_hdr_t *sdes;
		uint8_t *p;
		switch_size_t sdes_bytes = sizeof(struct switch_rtcp_hdr_s);
		uint32_t *ssrc;
		switch_rtcp_sdes_unit_t *unit;
		switch_bool_t is_only_receiver = FALSE;

		if (!rtcp_fb) {
			rtp_session->rtcp_last_sent = now;
			rtp_session->rtcp_sent_packets++;
		}

		if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && 
				rtp_session->vb && rtcp_cyclic) {
				nack_dup = rtp_session->prev_nacks_inflight;
				rtp_session->prev_nacks_inflight = 0;
		}

		rtp_session->rtcp_send_msg.header.version = 2;
		rtp_session->rtcp_send_msg.header.p = 0;

		if ((switch_core_session_media_flow(rtp_session->session, SWITCH_MEDIA_TYPE_AUDIO) == SWITCH_MEDIA_FLOW_RECVONLY) ||
				switch_core_session_media_flow(rtp_session->session, SWITCH_MEDIA_TYPE_VIDEO) == SWITCH_MEDIA_FLOW_RECVONLY) {
			is_only_receiver = TRUE;
		}
		if (!rtp_session->stats.rtcp.sent_pkt_count || is_only_receiver || force_send_rr) {
			rtp_session->rtcp_send_msg.header.type = _RTCP_PT_RR; /* Receiver report */
			rr=(struct switch_rtcp_receiver_report*) rtp_session->rtcp_send_msg.body;
			rr->ssrc = htonl(rtp_session->ssrc);
			rtcp_report_block = &rr->report_block;
			rtcp_bytes += sizeof(struct switch_rtcp_report_block);
			rtcp_generate_report_block(rtp_session, rtcp_report_block, nack_dup);
			rtp_session->rtcp_send_msg.header.count = 1; /* reception report block count */
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, "Sending RTCP RR (ssrc=%u)\n", rtp_session->ssrc);
		} else {
			struct switch_rtcp_sender_info *rtcp_sender_info;
			rtp_session->rtcp_send_msg.header.type = _RTCP_PT_SR; /* Sender report */
			sr = (struct switch_rtcp_sender_report*) rtp_session->rtcp_send_msg.body;
			sr->ssrc = htonl(rtp_session->ssrc);
			rtcp_sender_info = &sr->sender_info;
			rtcp_generate_sender_info(rtp_session, rtcp_sender_info);
			rtcp_bytes += sizeof(struct switch_rtcp_sender_info);
			if (!rtcp_cyclic && rtcp_fb) {
				 /* rtcp-fb only, don't send receive report block */
				rtp_session->rtcp_send_msg.header.count = 0;
			} else {
				rtcp_report_block = &sr->report_block;
				rtcp_bytes += sizeof(struct switch_rtcp_report_block);
				rtcp_generate_report_block(rtp_session, rtcp_report_block, nack_dup);
				rtp_session->rtcp_send_msg.header.count = 1; /* reception report block count */
				stats->sent_pkt_count = 0;
				if ((!rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->flags[SWITCH_RTP_FLAG_AUDIO_FIRE_SEND_RTCP_EVENT]) ||
					(rtp_session->flags[SWITCH_RTP_FLAG_VIDEO] && rtp_session->flags[SWITCH_RTP_FLAG_VIDEO_FIRE_SEND_RTCP_EVENT])) {
 					switch_send_rtcp_event(rtp_session, sr, rtcp_report_block);
				}
			}
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, "Sending RTCP SR (ssrc=%u)\n", rtp_session->ssrc);
		}

		rtp_session->rtcp_send_msg.header.length = htons((uint16_t)(rtcp_bytes / 4) - 1);

		if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
			if (rtp_session->pli_count) {
				switch_rtcp_ext_hdr_t *ext_hdr;

				p = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;
				ext_hdr = (switch_rtcp_ext_hdr_t *) p;

				ext_hdr->version = 2;
				ext_hdr->p = 0;
				ext_hdr->fmt = _RTCP_PSFB_PLI;
				ext_hdr->pt = _RTCP_PT_PSFB;

				ext_hdr->send_ssrc = htonl(rtp_session->ssrc);
				ext_hdr->recv_ssrc = htonl(rtp_session->remote_ssrc);
				rtp_session->rtcp_vstats.video_in.pli_count++;
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG1, "Sending RTCP PLI %u %u [%u]\n",
								  rtp_session->ssrc, rtp_session->remote_ssrc, rtp_session->rtcp_vstats.video_in.pli_count);

				ext_hdr->length = htons((uint8_t)(sizeof(switch_rtcp_ext_hdr_t) / 4) - 1);
				rtcp_bytes += sizeof(switch_rtcp_ext_hdr_t);
				rtp_session->pli_count = 0;
			}

			if (rtp_session->flags[SWITCH_RTP_FLAG_NACK] && nack_ttl > 0) {
				int n = 0;

				rtp_session->rtcp_vstats.video_in.nack_count++;
				for (n = 0; n < nack_ttl; n++) {
					switch_rtcp_ext_hdr_t *ext_hdr;
					uint32_t *nack;
					p = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;
					ext_hdr = (switch_rtcp_ext_hdr_t *) p;

					ext_hdr->version = 2;
					ext_hdr->p = 0;
					ext_hdr->fmt = _RTCP_RTPFB_NACK;
					ext_hdr->pt = _RTCP_PT_RTPFB;
					ext_hdr->send_ssrc = htonl(rtp_session->ssrc);
					ext_hdr->recv_ssrc = htonl(rtp_session->remote_ssrc);
					ext_hdr->length = htons(3);
					p += sizeof(switch_rtcp_ext_hdr_t);
					nack = (uint32_t *) p;
					*nack = cur_nack[n];

					switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, "Sending RTCP NACK %u [%d]\n",
									  ntohs(*nack & 0xFFFF), rtp_session->rtcp_vstats.video_in.nack_count);

					rtcp_bytes += sizeof(switch_rtcp_ext_hdr_t) + sizeof(cur_nack[n]);
					cur_nack[n] = 0;
				}
				rtp_session->prev_nacks_inflight = n;
			}

			if (rtp_session->fir_count) {
				switch_rtcp_ext_hdr_t *ext_hdr;
				rtcp_fir_t *fir;

				if (switch_rtp_test_flag(rtp_session, SWITCH_RTP_FLAG_OLD_FIR)) {
					p = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;
					ext_hdr = (switch_rtcp_ext_hdr_t *) p;

					ext_hdr->version = 2;
					ext_hdr->pt = _RTCP_PT_FIR;
					rtcp_bytes += sizeof(switch_rtcp_ext_hdr_t);
				}


				p = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;
				ext_hdr = (switch_rtcp_ext_hdr_t *) p;

				p += sizeof(switch_rtcp_ext_hdr_t);
				fir = (rtcp_fir_t *) p;

				ext_hdr->version = 2;
				ext_hdr->p = 0;
				ext_hdr->fmt = _RTCP_PSFB_FIR;
				ext_hdr->pt = _RTCP_PT_PSFB;

				ext_hdr->send_ssrc = htonl(rtp_session->ssrc);
				ext_hdr->recv_ssrc = htonl(rtp_session->remote_ssrc);

				fir->ssrc = htonl(rtp_session->remote_ssrc);
				fir->seq = rtp_session->fir_seq;
				fir->r1 = fir->r2 = fir->r3 = 0;

				rtp_session->rtcp_vstats.video_in.fir_count++;
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, "Sending RTCP FIR SEQ %d [%u]\n", rtp_session->fir_seq, rtp_session->rtcp_vstats.video_in.fir_count);

				rtp_session->fir_seq++;

				ext_hdr->length = htons((uint8_t)((sizeof(switch_rtcp_ext_hdr_t) + sizeof(rtcp_fir_t)) / 4) - 1);
				rtcp_bytes += sizeof(switch_rtcp_ext_hdr_t) + sizeof(rtcp_fir_t);
				rtp_session->fir_count = 0;
			}

			//if (!rtp_session->tmmbr && rtp_session->cur_tmmbr) {
			//	rtp_session->tmmbr = rtp_session->cur_tmmbr;
			//}

			while (rtp_session->tmmbr || rtp_session->tmmbn) {
				switch_rtcp_ext_hdr_t *ext_hdr;
				rtcp_tmmbx_t *tmmbx;
				uint32_t bps = 0;
				p = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;
				ext_hdr = (switch_rtcp_ext_hdr_t *) p;

				p += sizeof(switch_rtcp_ext_hdr_t);
				tmmbx = (rtcp_tmmbx_t *) p;

				ext_hdr->version = 2;
				ext_hdr->p = 0;
				ext_hdr->pt = _RTCP_PT_RTPFB;
				ext_hdr->send_ssrc = htonl(rtp_session->ssrc);
				ext_hdr->recv_ssrc = 0;

				if (rtp_session->tmmbr) {
					switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, "Sending RTCP TMMBR %u\n", rtp_session->tmmbr);
					ext_hdr->fmt = _RTCP_RTPFB_TMMBR;
					bps = rtp_session->tmmbr;
					rtp_session->tmmbr = 0;
				} else {
					switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG2, "Sending RTCP TMMBN %u\n", rtp_session->tmmbr);
					ext_hdr->fmt = _RTCP_RTPFB_TMMBN;
					bps = rtp_session->tmmbn;
					rtp_session->tmmbn = 0;
				}

				tmmbx->ssrc = htonl(rtp_session->remote_ssrc);
				calc_bw_exp(bps, 17, tmmbx);

				ext_hdr->length = htons((uint8_t)((sizeof(switch_rtcp_ext_hdr_t) + sizeof(rtcp_tmmbx_t)) / 4) - 1);
				rtcp_bytes += sizeof(switch_rtcp_ext_hdr_t) + sizeof(rtcp_tmmbx_t);
			}

		}

		//SDES + CNAME
		p = (uint8_t *) (&rtp_session->rtcp_send_msg) + rtcp_bytes;
		sdes = (switch_rtcp_hdr_t *) p;
		sdes->version = 2;
		sdes->type = _RTCP_PT_SDES;
		sdes->count = 1;
		sdes->p = 0;
		p = (uint8_t *) (sdes) + sdes_bytes;
		ssrc = (uint32_t *) p;
		*ssrc = htonl(rtp_session->ssrc);
		sdes_bytes += sizeof(uint32_t);


		p = (uint8_t *) (sdes) + sdes_bytes;
		unit = (switch_rtcp_sdes_unit_t *) p;
		unit->type = _RTCP_SDES_CNAME;
		snprintf((char *)unit->value, 80, "%x", rtp_session->ssrc);
		unit->length = strlen((char *)unit->value);
		sdes_bytes += sizeof(switch_rtcp_sdes_unit_t) + unit->length;


		p += sizeof(switch_rtcp_sdes_unit_t) + unit->length;
		unit = (switch_rtcp_sdes_unit_t *) p;
		unit->type = _RTCP_SDES_NOTE;
		snprintf((char *)unit->value, 80, "FreeSWITCH.org -- Come to ClueCon.com");
		unit->length = strlen((char *)unit->value);
		sdes_bytes += sizeof(switch_rtcp_sdes_unit_t) + unit->length;

		sdes_bytes ++;//END

		sdes_bytes += 4 - (sdes_bytes % 4);

		sdes->length = htons((uint16_t)(sdes_bytes / 4) - 1);
		rtcp_bytes += sdes_bytes;

		/* Prepare next report */
		if (rtp_session->rtcp_send_msg.header.count) {
			stats->last_rpt_cycle = stats->cycle;
			stats->last_rpt_ext_seq = stats->high_ext_seq_recv;
			stats->last_rpt_ts = rtp_session->write_timer.samplecount;
			stats->period_pkt_count = 0;
		}



#ifdef ENABLE_SRTP
		switch_mutex_lock(rtp_session->ice_mutex);
		if (rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND]) {
			int stat = 0;
			int sbytes = (int) rtcp_bytes;

			if (!rtp_session->flags[SWITCH_RTP_FLAG_SECURE_SEND_MKI]) {
				stat = srtp_protect_rtcp(rtp_session->send_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_send_msg.header, &sbytes);
			} else {
				stat = srtp_protect_rtcp_mki(rtp_session->send_ctx[rtp_session->srtp_idx_rtcp], &rtp_session->rtcp_send_msg.header, &sbytes, 1, SWITCH_CRYPTO_MKI_INDEX);
			}

			if (stat) {
				switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_ERROR, "Error: SRTP RTCP protection failed with code %d\n", stat);
				switch_mutex_unlock(rtp_session->ice_mutex);
				goto end;
			} else {
				rtcp_bytes = sbytes;
			}
		}
		switch_mutex_unlock(rtp_session->ice_mutex);
#endif

		//#define DEBUG_EXTRA
#ifdef DEBUG_EXTRA
		{
			const char *old_host;
			char bufb[50];
			old_host = switch_get_addr(bufb, sizeof(bufb), rtp_session->rtcp_remote_addr);
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_CRIT, "%s SEND %s RTCP %s:%d %ld\n",
							  rtp_session_name(rtp_session),
							  rtp_type(rtp_session),
							  old_host,
							  switch_sockaddr_get_port(rtp_session->rtcp_remote_addr),
							  rtcp_bytes);
		}
#endif
		if (switch_socket_sendto(rtp_session->rtcp_sock_output, rtp_session->rtcp_remote_addr, 0, (void *)&rtp_session->rtcp_send_msg, &rtcp_bytes ) != SWITCH_STATUS_SUCCESS) {
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(rtp_session->session), SWITCH_LOG_DEBUG,"RTCP packet not written\n");
		} else {
			rtp_session->stats.inbound.period_packet_count = 0;
		}
	}

	if (rtp_session->ice.ice_user) {
		if (ice_out(rtp_session, &rtp_session->ice, SWITCH_FALSE) == SWITCH_STATUS_GENERR) {
			ret = -1;
			goto end;
		}
	}

	if (!rtp_session->flags[SWITCH_RTP_FLAG_RTCP_MUX]) {
		if (rtp_session->rtcp_ice.ice_user) {
			if (ice_out(rtp_session, &rtp_session->rtcp_ice, SWITCH_FALSE) == SWITCH_STATUS_GENERR) {
				ret = -1;
				goto end;
			}
		}
	}

 end:

	return ret;
}
