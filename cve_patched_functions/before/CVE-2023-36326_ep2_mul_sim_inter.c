void ep2_mul_sim_inter(ep2_t r, const ep2_t p, const bn_t k, const ep2_t q,
		const bn_t m) {
	int flag = 0;
	bn_t n, _k, _m;

	if (bn_is_zero(k) || ep2_is_infty(p)) {
		ep2_mul(r, q, m);
		return;
	}
	if (bn_is_zero(m) || ep2_is_infty(q)) {
		ep2_mul(r, p, k);
		return;
	}

	bn_null(n);
	bn_null(_k);
	bn_null(_m);

	RLC_TRY {
		bn_new(n);
		bn_new(_k);
		bn_new(_m);

		/* Handle this here to reduce complexity of static functions. */
		ep2_curve_get_ord(n);
		bn_mod(_k, k, n);
		bn_mod(_m, m, n);

#if defined(EP_ENDOM)
		if (ep_curve_is_endom()) {
			ep2_mul_sim_endom(r, p, _k, q, _m);
			flag = 1;
		}
#endif

#if defined(EP_PLAIN) || defined(EP_SUPER)
		if (!flag) {
			ep2_mul_sim_plain(r, p, _k, q, _m, NULL);
		}
#endif
		(void)flag;
	} RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	}
	RLC_FINALLY {
		bn_free(n);
		bn_free(_k);
		bn_free(_m);
	}
}
