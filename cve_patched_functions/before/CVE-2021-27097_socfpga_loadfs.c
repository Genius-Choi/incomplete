int socfpga_loadfs(fpga_fs_info *fpga_fsinfo, const void *buf, size_t bsize,
			u32 offset)
{
	struct fpga_loadfs_info fpga_loadfs;
	struct udevice *dev;
	int status, ret, size;
	u32 buffer = (uintptr_t)buf;
	size_t buffer_sizebytes = bsize;
	size_t buffer_sizebytes_ori = bsize;
	size_t total_sizeof_image = 0;
	ofnode node;
	const fdt32_t *phandle_p;
	u32 phandle;

	node = get_fpga_mgr_ofnode(ofnode_null());

	if (ofnode_valid(node)) {
		phandle_p = ofnode_get_property(node, "firmware-loader", &size);
		if (!phandle_p) {
			node = ofnode_path("/chosen");
			if (!ofnode_valid(node)) {
				debug("FPGA: /chosen node was not found.\n");
				return -ENOENT;
			}

			phandle_p = ofnode_get_property(node, "firmware-loader",
						       &size);
			if (!phandle_p) {
				debug("FPGA: firmware-loader property was not");
				debug(" found.\n");
				return -ENOENT;
			}
		}
	} else {
		debug("FPGA: FPGA manager node was not found.\n");
		return -ENOENT;
	}

	phandle = fdt32_to_cpu(*phandle_p);
	ret = uclass_get_device_by_phandle_id(UCLASS_FS_FIRMWARE_LOADER,
					     phandle, &dev);
	if (ret)
		return ret;

	memset(&fpga_loadfs, 0, sizeof(fpga_loadfs));

	fpga_loadfs.fpga_fsinfo = fpga_fsinfo;
	fpga_loadfs.offset = offset;

	printf("FPGA: Checking FPGA configuration setting ...\n");

	/*
	 * Note: Both buffer and buffer_sizebytes values can be altered by
	 * function below.
	 */
	ret = first_loading_rbf_to_buffer(dev, &fpga_loadfs, &buffer,
					   &buffer_sizebytes);
	if (ret == 1) {
		printf("FPGA: Skipping configuration ...\n");
		return 0;
	} else if (ret) {
		return ret;
	}

	if (fpga_loadfs.rbfinfo.section == core_section &&
		!(is_fpgamgr_early_user_mode() && !is_fpgamgr_user_mode())) {
		debug("FPGA : Must be in Early Release mode to program ");
		debug("core bitstream.\n");
		return -EPERM;
	}

	/* Disable all signals from HPS peripheral controller to FPGA */
	writel(0, socfpga_get_sysmgr_addr() + SYSMGR_A10_FPGAINTF_EN_GLOBAL);

	/* Disable all axi bridges (hps2fpga, lwhps2fpga & fpga2hps) */
	socfpga_bridges_reset();

	if (fpga_loadfs.rbfinfo.section == periph_section) {
		/* Initialize the FPGA Manager */
		status = fpgamgr_program_init((u32 *)buffer, buffer_sizebytes);
		if (status) {
			debug("FPGA: Init with peripheral bitstream failed.\n");
			return -EPERM;
		}
	}

	/* Transfer bitstream to FPGA Manager */
	fpgamgr_program_write((void *)buffer, buffer_sizebytes);

	total_sizeof_image += buffer_sizebytes;

	while (fpga_loadfs.remaining) {
		ret = subsequent_loading_rbf_to_buffer(dev,
							&fpga_loadfs,
							&buffer,
							&buffer_sizebytes_ori);

		if (ret)
			return ret;

		/* Transfer data to FPGA Manager */
		fpgamgr_program_write((void *)buffer,
					buffer_sizebytes_ori);

		total_sizeof_image += buffer_sizebytes_ori;

		WATCHDOG_RESET();
	}

	if (fpga_loadfs.rbfinfo.section == periph_section) {
		if (fpgamgr_wait_early_user_mode() != -ETIMEDOUT) {
			config_pins(gd->fdt_blob, "shared");
			puts("FPGA: Early Release Succeeded.\n");
		} else {
			debug("FPGA: Failed to see Early Release.\n");
			return -EIO;
		}

		/* For monolithic bitstream */
		if (is_fpgamgr_user_mode()) {
			/* Ensure the FPGA entering config done */
			status = fpgamgr_program_finish();
			if (status)
				return status;

			config_pins(gd->fdt_blob, "fpga");
			puts("FPGA: Enter user mode.\n");
		}
	} else if (fpga_loadfs.rbfinfo.section == core_section) {
		/* Ensure the FPGA entering config done */
		status = fpgamgr_program_finish();
		if (status)
			return status;

		config_pins(gd->fdt_blob, "fpga");
		puts("FPGA: Enter user mode.\n");
	} else {
		debug("FPGA: Config Error: Unsupported bitstream type.\n");
		return -ENOEXEC;
	}

	return (int)total_sizeof_image;
}
