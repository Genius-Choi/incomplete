static void msg_att_handler(struct mailimap_msg_att * msg_att, void * context)
{
    clistiter * item_iter;
    uint32_t uid;
    IMAPMessage * msg;
    bool hasHeader;
    bool hasBody;
    bool hasFlags;
    bool hasGmailLabels;
    bool hasGmailMessageID;
    bool hasGmailThreadID;
    struct msg_att_handler_data * msg_att_context;
    bool fetchByUID;
    Array * result;
    IMAPMessagesRequestKind requestKind;
    uint32_t mLastFetchedSequenceNumber;
    HashMap * mapping;
    bool needsHeader;
    bool needsBody;
    bool needsFlags;
    bool needsGmailLabels;
    bool needsGmailMessageID;
    bool needsGmailThreadID;
    IndexSet * uidsFilter;
    IndexSet * numbersFilter;
    
    msg_att_context = (struct msg_att_handler_data *) context;
    uidsFilter = msg_att_context->uidsFilter;
    numbersFilter = msg_att_context->numbersFilter;
    fetchByUID = msg_att_context->fetchByUID;
    result = msg_att_context->result;
    requestKind = msg_att_context->requestKind;
    mapping = msg_att_context->mapping;
    needsHeader = msg_att_context->needsHeader;
    needsBody = msg_att_context->needsBody;
    needsFlags = msg_att_context->needsFlags;
    needsGmailLabels = msg_att_context->needsGmailLabels;
    needsGmailMessageID = msg_att_context->needsGmailMessageID;
    needsGmailThreadID = msg_att_context->needsGmailThreadID;

    hasHeader = false;
    hasBody = false;
    hasFlags = false;
    hasGmailLabels = false;
    hasGmailMessageID = false;
    hasGmailThreadID = false;
    
    if (numbersFilter != NULL) {
        if (!numbersFilter->containsIndex((uint64_t) msg_att->att_number)) {
            return;
        }
    }

    msg = new IMAPMessage();
    
    uid = 0;
    mLastFetchedSequenceNumber = msg_att->att_number;
    if (mapping != NULL) {
        uid = (uint32_t) ((Value *) mapping->objectForKey(Value::valueWithUnsignedLongValue(msg_att->att_number)))->longLongValue();
    }

    msg->setSequenceNumber(msg_att->att_number);
    for(item_iter = clist_begin(msg_att->att_list) ; item_iter != NULL ; item_iter = clist_next(item_iter)) {
        struct mailimap_msg_att_item * att_item;
        
        att_item = (struct mailimap_msg_att_item *) clist_content(item_iter);
        if (att_item->att_type == MAILIMAP_MSG_ATT_ITEM_DYNAMIC) {
            MessageFlag flags;
            
            flags = flags_from_lep_att_dynamic(att_item->att_data.att_dyn);
            msg->setFlags(flags);
            msg->setOriginalFlags(flags);
            hasFlags = true;
            
            Array * customFlags;
            customFlags = custom_flags_from_lep_att_dynamic(att_item->att_data.att_dyn);
            msg->setCustomFlags(customFlags);
        }
        else if (att_item->att_type == MAILIMAP_MSG_ATT_ITEM_STATIC) {
            struct mailimap_msg_att_static * att_static;
            
            att_static = att_item->att_data.att_static;
            if (att_static->att_type == MAILIMAP_MSG_ATT_UID) {
                uid = att_static->att_data.att_uid;
            }
            else if (att_static->att_type == MAILIMAP_MSG_ATT_ENVELOPE) {
                struct mailimap_envelope * env;
                
                MCLog("parse envelope %lu", (unsigned long) uid);
                env = att_static->att_data.att_env;
                if ((requestKind & IMAPMessagesRequestKindMessageId) != 0) {
                    msg->header()->importPartialIMAPEnvelope(env);
                } else {
                    msg->header()->importIMAPEnvelope(env);
                }
                hasHeader = true;
            }
            else if (att_static->att_type == MAILIMAP_MSG_ATT_BODY_SECTION) {
                if ((requestKind & IMAPMessagesRequestKindFullHeaders) != 0 ||
                    (requestKind & IMAPMessagesRequestKindExtraHeaders) != 0) {
                    char * bytes;
                    size_t length;
                    
                    bytes = att_static->att_data.att_body_section->sec_body_part;
                    length = att_static->att_data.att_body_section->sec_length;
                    
                    msg->header()->importHeadersData(Data::dataWithBytes(bytes, (unsigned int) length));
                    hasHeader = true;
                }
                else {
                    char * references;
                    size_t ref_size;
                    
                    // references
                    references = att_static->att_data.att_body_section->sec_body_part;
                    ref_size = att_static->att_data.att_body_section->sec_length;
                    
                    msg->header()->importIMAPReferences(Data::dataWithBytes(references, (unsigned int) ref_size));
                }
            }
            else if (att_static->att_type == MAILIMAP_MSG_ATT_BODYSTRUCTURE) {
                AbstractPart * mainPart;
                
                // bodystructure
                mainPart = IMAPPart::attachmentWithIMAPBody(att_static->att_data.att_body);
                msg->setMainPart(mainPart);
                hasBody = true;
            }
        }
        else if (att_item->att_type == MAILIMAP_MSG_ATT_ITEM_EXTENSION) {
            struct mailimap_extension_data * ext_data;
            
            ext_data = att_item->att_data.att_extension_data;
            if (ext_data->ext_extension == &mailimap_extension_condstore) {
                struct mailimap_condstore_fetch_mod_resp * fetch_data;
                
                fetch_data = (struct mailimap_condstore_fetch_mod_resp *) ext_data->ext_data;
                msg->setModSeqValue(fetch_data->cs_modseq_value);
            }
            else if (ext_data->ext_extension == &mailimap_extension_xgmlabels) {
                struct mailimap_msg_att_xgmlabels * cLabels;
                Array * labels;
                clistiter * cur;
                
                labels = new Array();
                hasGmailLabels = true;
                cLabels = (struct mailimap_msg_att_xgmlabels *) ext_data->ext_data;
                for(cur = clist_begin(cLabels->att_labels) ; cur != NULL ; cur = clist_next(cur)) {
                    char * cLabel;
                    String * label;
                    
                    cLabel = (char *) clist_content(cur);
                    label = String::stringWithUTF8Characters(cLabel);
                    labels->addObject(label);
                }
                if (labels->count() > 0) {
                    msg->setGmailLabels(labels);
                }
                labels->release();
            }
            else if (ext_data->ext_extension == &mailimap_extension_xgmthrid) {
                uint64_t * threadID;
                
                threadID = (uint64_t *) ext_data->ext_data;
                msg->setGmailThreadID(*threadID);
                hasGmailThreadID = true;
            }
            else if (ext_data->ext_extension == &mailimap_extension_xgmmsgid) {
                uint64_t * msgID;
                
                msgID = (uint64_t *) ext_data->ext_data;
                msg->setGmailMessageID(*msgID);
                hasGmailMessageID = true;
            }
        }
    }
    for(item_iter = clist_begin(msg_att->att_list) ; item_iter != NULL ; item_iter = clist_next(item_iter)) {
        struct mailimap_msg_att_item * att_item;
        
        att_item = (struct mailimap_msg_att_item *) clist_content(item_iter);
        if (att_item->att_type == MAILIMAP_MSG_ATT_ITEM_STATIC) {
            struct mailimap_msg_att_static * att_static;
            
            att_static = att_item->att_data.att_static;
            if (att_static->att_type == MAILIMAP_MSG_ATT_INTERNALDATE) {
                msg->header()->importIMAPInternalDate(att_static->att_data.att_internal_date);
            } else if (att_static->att_type == MAILIMAP_MSG_ATT_RFC822_SIZE) {
                msg->setSize(att_static->att_data.att_rfc822_size);
            }
        }
    }
    
    if (needsBody && !hasBody) {
        msg->release();
        return;
    }
    if (needsHeader && !hasHeader) {
        msg->release();
        return;
    }
    if (needsFlags && !hasFlags) {
        msg->release();
        return;
    }
    if (needsGmailThreadID && !hasGmailThreadID) {
        msg->release();
        return;
    }
    if (needsGmailMessageID && !hasGmailMessageID) {
        msg->release();
        return;
    }
    if (needsGmailLabels && !hasGmailLabels) {
        msg->release();
        return;
    }
    if (uid != 0) {
        msg->setUid(uid);
    }
    else {
        msg->release();
        return;
    }

    if (uidsFilter != NULL) {
        if (!uidsFilter->containsIndex((uint64_t) uid)) {
            msg->release();
            return;
        }
    }
    
    result->addObject(msg);
    msg->release();
    
    msg_att_context->mLastFetchedSequenceNumber = mLastFetchedSequenceNumber;
}
