char *gf_svg_dump_attribute(GF_Node *elt, GF_FieldInfo *info)
{
	char tmp[1024];
	u8 intVal;

	if (!info->far_ptr) return gf_strdup("");
	intVal = *(u8 *)info->far_ptr;

	switch (info->fieldType) {
	case SVG_Boolean_datatype:
		return gf_strdup( *(SVG_Boolean *)info->far_ptr ? "true" : "false");

	case SVG_Color_datatype:
		return svg_dump_color((SVG_Color *)info->far_ptr);

	case SVG_Paint_datatype:
	{
		SVG_Paint *paint = (SVG_Paint *)info->far_ptr;
		if (paint->type == SVG_PAINT_NONE) return gf_strdup("none");
		else if (paint->type == SVG_PAINT_INHERIT) return gf_strdup("inherit");
		else if (paint->type == SVG_PAINT_URI) {
			char *iritmp = svg_dump_iri(&paint->iri);
			char *res = gf_malloc(sizeof(char)*(strlen(iritmp)+6));
			sprintf(res, "url(%s)", iritmp);
			gf_free(iritmp);
			return res;
		} else {
			return svg_dump_color(&paint->color);
		}
	}
	break;

	/* beginning of keyword type parsing */
	case SVG_FillRule_datatype:
		if (intVal == SVG_FILLRULE_INHERIT) return gf_strdup("inherit");
		else if (intVal == SVG_FILLRULE_NONZERO) return gf_strdup("nonzero");
		else return gf_strdup("evenodd");
		break;

	case SVG_StrokeLineJoin_datatype:
		if (intVal==SVG_STROKELINEJOIN_INHERIT) return gf_strdup("inherit");
		else if (intVal==SVG_STROKELINEJOIN_MITER) return gf_strdup("miter");
		else if (intVal==SVG_STROKELINEJOIN_ROUND) return gf_strdup("round");
		else if (intVal==SVG_STROKELINEJOIN_BEVEL) return gf_strdup("bevel");
		break;
	case SVG_StrokeLineCap_datatype:
		if (intVal==SVG_STROKELINECAP_INHERIT) return gf_strdup("inherit");
		else if (intVal==SVG_STROKELINECAP_BUTT) return gf_strdup("butt");
		else if (intVal==SVG_STROKELINECAP_ROUND) return gf_strdup("round");
		else if (intVal==SVG_STROKELINECAP_SQUARE) return gf_strdup("square");
		break;
	case SVG_FontStyle_datatype:
		if (intVal==SVG_FONTSTYLE_INHERIT) return gf_strdup("inherit");
		else if (intVal==SVG_FONTSTYLE_NORMAL) return gf_strdup("normal");
		else if (intVal==SVG_FONTSTYLE_ITALIC) return gf_strdup("italic");
		else if (intVal==SVG_FONTSTYLE_OBLIQUE) return gf_strdup("oblique");
		break;
	case SVG_FontWeight_datatype:
		if (intVal==SVG_FONTWEIGHT_INHERIT) return gf_strdup("inherit");
		else if (intVal==SVG_FONTWEIGHT_NORMAL) return gf_strdup("normal");
		else if (intVal==SVG_FONTWEIGHT_BOLD) return gf_strdup("bold");
		else if (intVal==SVG_FONTWEIGHT_BOLDER) return gf_strdup("bolder");
		else if (intVal==SVG_FONTWEIGHT_LIGHTER) return gf_strdup("lighter");
		else if (intVal==SVG_FONTWEIGHT_100) return gf_strdup("100");
		else if (intVal==SVG_FONTWEIGHT_200) return gf_strdup("200");
		else if (intVal==SVG_FONTWEIGHT_300) return gf_strdup("300");
		else if (intVal==SVG_FONTWEIGHT_400) return gf_strdup("400");
		else if (intVal==SVG_FONTWEIGHT_500) return gf_strdup("500");
		else if (intVal==SVG_FONTWEIGHT_600) return gf_strdup("600");
		else if (intVal==SVG_FONTWEIGHT_700) return gf_strdup("700");
		else if (intVal==SVG_FONTWEIGHT_800) return gf_strdup("800");
		else if (intVal==SVG_FONTWEIGHT_900) return gf_strdup("900");
		break;
	case SVG_FontVariant_datatype:
		if (intVal==SVG_FONTVARIANT_INHERIT) return gf_strdup("inherit");
		else if (intVal==SVG_FONTVARIANT_NORMAL) return gf_strdup("normal");
		else if (intVal==SVG_FONTVARIANT_SMALLCAPS) return gf_strdup("small-caps");
		break;
	case SVG_TextAnchor_datatype:
		if (intVal==SVG_TEXTANCHOR_INHERIT) return gf_strdup("inherit");
		else if (intVal==SVG_TEXTANCHOR_START) return gf_strdup("start");
		else if (intVal==SVG_TEXTANCHOR_MIDDLE) return gf_strdup("middle");
		else if (intVal==SVG_TEXTANCHOR_END) return gf_strdup("end");
		break;
	case SVG_Display_datatype:
		if (intVal==SVG_DISPLAY_INHERIT) return gf_strdup("inherit");
		else if (intVal==SVG_DISPLAY_NONE) return gf_strdup("none");
		else if (intVal==SVG_DISPLAY_INLINE) return gf_strdup("inline");
		else if (intVal==SVG_DISPLAY_BLOCK) return gf_strdup("block");
		else if (intVal==SVG_DISPLAY_LIST_ITEM) return gf_strdup("list-item");
		else if (intVal==SVG_DISPLAY_RUN_IN) return gf_strdup("run-in");
		else if (intVal==SVG_DISPLAY_COMPACT) return gf_strdup("compact");
		else if (intVal==SVG_DISPLAY_MARKER) return gf_strdup("marker");
		else if (intVal==SVG_DISPLAY_TABLE) return gf_strdup("table");
		else if (intVal==SVG_DISPLAY_INLINE_TABLE) return gf_strdup("inline-table");
		else if (intVal==SVG_DISPLAY_TABLE_ROW_GROUP) return gf_strdup("table-row-group");
		else if (intVal==SVG_DISPLAY_TABLE_HEADER_GROUP) return gf_strdup("table-header-group");
		else if (intVal==SVG_DISPLAY_TABLE_FOOTER_GROUP) return gf_strdup("table-footer-group");
		else if (intVal==SVG_DISPLAY_TABLE_ROW) return gf_strdup("table-row");
		else if (intVal==SVG_DISPLAY_TABLE_COLUMN_GROUP) return gf_strdup("table-column-group");
		else if (intVal==SVG_DISPLAY_TABLE_COLUMN) return gf_strdup("table-column");
		else if (intVal==SVG_DISPLAY_TABLE_CELL) return gf_strdup("table-cell");
		else if (intVal==SVG_DISPLAY_TABLE_CAPTION) return gf_strdup("table-caption");
		break;
	case SVG_Visibility_datatype:
		if (intVal==SVG_VISIBILITY_INHERIT) return gf_strdup("inherit");
		else if (intVal==SVG_VISIBILITY_VISIBLE) return gf_strdup("visible");
		else if (intVal==SVG_VISIBILITY_HIDDEN) return gf_strdup("hidden");
		else if (intVal==SVG_VISIBILITY_COLLAPSE) return gf_strdup("collapse");
		break;
	case SVG_Overflow_datatype:
		if (intVal==SVG_OVERFLOW_INHERIT) return gf_strdup("inherit");
		else if (intVal==SVG_OVERFLOW_VISIBLE) return gf_strdup("visible");
		else if (intVal==SVG_OVERFLOW_HIDDEN) return gf_strdup("hidden");
		else if (intVal==SVG_OVERFLOW_SCROLL) return gf_strdup("scroll");
		else if (intVal==SVG_OVERFLOW_AUTO) return gf_strdup("auto");
		break;
	case SVG_ZoomAndPan_datatype:
		if (intVal==SVG_ZOOMANDPAN_DISABLE) return gf_strdup("disable");
		else return gf_strdup("magnify");
		break;
	case SVG_DisplayAlign_datatype:
		if (intVal==SVG_DISPLAYALIGN_INHERIT) return gf_strdup("inherit");
		else if (intVal==SVG_DISPLAYALIGN_AUTO) return gf_strdup("auto");
		else if (intVal==SVG_DISPLAYALIGN_BEFORE) return gf_strdup("before");
		else if (intVal==SVG_DISPLAYALIGN_CENTER) return gf_strdup("center");
		else if (intVal==SVG_DISPLAYALIGN_AFTER) return gf_strdup("after");
		break;
	case SVG_TextAlign_datatype:
		if (intVal==SVG_TEXTALIGN_INHERIT) return gf_strdup("inherit");
		else if (intVal==SVG_TEXTALIGN_START) return gf_strdup("start");
		else if (intVal==SVG_TEXTALIGN_CENTER) return gf_strdup("center");
		else if (intVal==SVG_TEXTALIGN_END) return gf_strdup("end");
		break;
	case SVG_PointerEvents_datatype:
		if (intVal==SVG_POINTEREVENTS_INHERIT) return gf_strdup("inherit");
		else if (intVal==SVG_POINTEREVENTS_VISIBLEPAINTED) return gf_strdup("visiblePainted");
		else if (intVal==SVG_POINTEREVENTS_VISIBLEFILL) return gf_strdup("visibleFill");
		else if (intVal==SVG_POINTEREVENTS_VISIBLESTROKE) return gf_strdup("visibleStroke");
		else if (intVal==SVG_POINTEREVENTS_VISIBLE) return gf_strdup("visible");
		else if (intVal==SVG_POINTEREVENTS_PAINTED) return gf_strdup("painted");
		else if (intVal==SVG_POINTEREVENTS_FILL) return gf_strdup("fill");
		else if (intVal==SVG_POINTEREVENTS_STROKE) return gf_strdup("stroke");
		else if (intVal==SVG_POINTEREVENTS_ALL) return gf_strdup("all");
		else if (intVal==SVG_POINTEREVENTS_NONE) return gf_strdup("none");
		else if (intVal==SVG_POINTEREVENTS_BOUNDINGBOX) return gf_strdup("boundingBox");
		break;
	case SVG_RenderingHint_datatype:
		if (intVal==SVG_RENDERINGHINT_INHERIT) return gf_strdup("inherit");
		else if (intVal==SVG_RENDERINGHINT_AUTO) return gf_strdup("auto");
		else if (intVal==SVG_RENDERINGHINT_OPTIMIZEQUALITY) return gf_strdup("optimizeQuality");
		else if (intVal==SVG_RENDERINGHINT_OPTIMIZESPEED) return gf_strdup("optimizeSpeed");
		else if (intVal==SVG_RENDERINGHINT_OPTIMIZELEGIBILITY) return gf_strdup("optimizeLegibility");
		else if (intVal==SVG_RENDERINGHINT_CRISPEDGES) return gf_strdup("crispEdges");
		else if (intVal==SVG_RENDERINGHINT_GEOMETRICPRECISION) return gf_strdup("geometricPrecision");
		break;
	case SVG_VectorEffect_datatype:
		if (intVal==SVG_VECTOREFFECT_INHERIT) return gf_strdup("inherit");
		else if (intVal==SVG_VECTOREFFECT_NONE) return gf_strdup("none");
		else if (intVal==SVG_VECTOREFFECT_NONSCALINGSTROKE) return gf_strdup("non-scaling-stroke");
		break;
	case SVG_PlaybackOrder_datatype:
		if (intVal== SVG_PLAYBACKORDER_FORWARDONLY) return gf_strdup("forwardOnly");
		else if (intVal== SVG_PLAYBACKORDER_ALL) return gf_strdup("all");
		break;
	case SVG_TimelineBegin_datatype:
		if (intVal== SVG_TIMELINEBEGIN_ONSTART) return gf_strdup("onStart");
		else if (intVal== SVG_TIMELINEBEGIN_ONLOAD) return gf_strdup("onLoad");
		break;
	case XML_Space_datatype:
		if (intVal==XML_SPACE_DEFAULT) return gf_strdup("default");
		else if (intVal==XML_SPACE_PRESERVE) return gf_strdup("preserve");
		break;
	case XMLEV_Propagate_datatype:
		if (intVal==XMLEVENT_PROPAGATE_CONTINUE) return gf_strdup("continue");
		else if (intVal==XMLEVENT_PROPAGATE_STOP) return gf_strdup("stop");
		break;
	case XMLEV_DefaultAction_datatype:
		if (intVal==XMLEVENT_DEFAULTACTION_CANCEL) return gf_strdup("cancel");
		else if (intVal==XMLEVENT_DEFAULTACTION_PERFORM) return gf_strdup("perform");
		break;
	case XMLEV_Phase_datatype:
		if (intVal==XMLEVENT_PHASE_DEFAULT) return gf_strdup("default");
		else if (intVal==XMLEVENT_PHASE_CAPTURE) return gf_strdup("capture");
		break;
	case SMIL_SyncBehavior_datatype:
		if (intVal==SMIL_SYNCBEHAVIOR_INHERIT) return gf_strdup("inherit");
		else if (intVal==SMIL_SYNCBEHAVIOR_DEFAULT) return gf_strdup("default");
		else if (intVal==SMIL_SYNCBEHAVIOR_LOCKED) return gf_strdup("locked");
		else if (intVal==SMIL_SYNCBEHAVIOR_CANSLIP) return gf_strdup("canSlip");
		else if (intVal==SMIL_SYNCBEHAVIOR_INDEPENDENT) return gf_strdup("independent");
		break;
	case SMIL_SyncTolerance_datatype:
		if (((SMIL_SyncTolerance*)info->far_ptr)->type==SMIL_SYNCTOLERANCE_INHERIT) return gf_strdup("inherit");
		else if (((SMIL_SyncTolerance*)info->far_ptr)->type==SMIL_SYNCTOLERANCE_DEFAULT) return gf_strdup("default");
		else if (((SMIL_SyncTolerance*)info->far_ptr)->type==SMIL_SYNCBEHAVIOR_LOCKED) {
			sprintf(tmp, "%g", ((SMIL_SyncTolerance*)info->far_ptr)->value);
			return gf_strdup(tmp);
		}
		break;
	case SMIL_AttributeType_datatype:
		if (intVal==SMIL_ATTRIBUTETYPE_AUTO) return gf_strdup("auto");
		else if (intVal==SMIL_ATTRIBUTETYPE_XML) return gf_strdup("XML");
		else if (intVal==SMIL_ATTRIBUTETYPE_CSS) return gf_strdup("CSS");
		break;
	case SMIL_CalcMode_datatype:
		if (intVal==SMIL_CALCMODE_DISCRETE) return gf_strdup("discrete");
		else if (intVal==SMIL_CALCMODE_LINEAR) return gf_strdup("linear");
		else if (intVal==SMIL_CALCMODE_PACED) return gf_strdup("paced");
		else if (intVal==SMIL_CALCMODE_SPLINE) return gf_strdup("spline");
		break;
	case SMIL_Additive_datatype:
		if (intVal==SMIL_ADDITIVE_REPLACE) return gf_strdup("replace");
		else if (intVal==SMIL_ADDITIVE_SUM) return gf_strdup("sum");
		break;
	case SMIL_Accumulate_datatype:
		if (intVal==SMIL_ACCUMULATE_NONE) return gf_strdup("none");
		else if (intVal==SMIL_ACCUMULATE_SUM) return gf_strdup("sum");
		break;
	case SMIL_Restart_datatype:
		if (intVal==SMIL_RESTART_ALWAYS) return gf_strdup("always");
		else if (intVal==SMIL_RESTART_WHENNOTACTIVE) return gf_strdup("whenNotActive");
		else if (intVal==SMIL_RESTART_NEVER) return gf_strdup("never");
		break;
	case SMIL_Fill_datatype:
		if (intVal==SMIL_FILL_FREEZE) return gf_strdup("freeze");
		else if (intVal==SMIL_FILL_REMOVE) return gf_strdup("remove");
		break;

	case SVG_GradientUnit_datatype:
		if (intVal==SVG_GRADIENTUNITS_USER) return gf_strdup("userSpaceOnUse");
		else if (intVal==SVG_GRADIENTUNITS_OBJECT) return gf_strdup("objectBoundingBox");
		break;
	case SVG_InitialVisibility_datatype:
		if (intVal==SVG_INITIALVISIBILTY_WHENSTARTED) return gf_strdup("whenStarted");
		else if (intVal==SVG_INITIALVISIBILTY_ALWAYS) return gf_strdup("always");
		break;
	case SVG_FocusHighlight_datatype:
		if (intVal==SVG_FOCUSHIGHLIGHT_AUTO) return gf_strdup("auto");
		else if (intVal==SVG_FOCUSHIGHLIGHT_NONE) return gf_strdup("none");
		break;
	case SVG_Overlay_datatype:
		if (intVal==SVG_OVERLAY_NONE) return gf_strdup("none");
		else if (intVal==SVG_OVERLAY_TOP) return gf_strdup("top");
		break;
	case SVG_TransformBehavior_datatype:
		if (intVal==SVG_TRANSFORMBEHAVIOR_GEOMETRIC) return gf_strdup("geometric");
		else if (intVal==SVG_TRANSFORMBEHAVIOR_PINNED) return gf_strdup("pinned");
		else if (intVal==SVG_TRANSFORMBEHAVIOR_PINNED90) return gf_strdup("pinned90");
		else if (intVal==SVG_TRANSFORMBEHAVIOR_PINNED180) return gf_strdup("pinned180");
		else if (intVal==SVG_TRANSFORMBEHAVIOR_PINNED270) return gf_strdup("pinned270");
		break;
	case SVG_SpreadMethod_datatype:
		if (intVal==SVG_SPREAD_REFLECT) return gf_strdup("reflect");
		else if (intVal==SVG_SPREAD_REPEAT) return gf_strdup("repeat");
		else return gf_strdup("pad");
		break;

	case SVG_Filter_TransferType_datatype:
		if (intVal==SVG_FILTER_TRANSFER_TABLE) return gf_strdup("table");
		else if (intVal==SVG_FILTER_TRANSFER_DISCRETE) return gf_strdup("discrete");
		else if (intVal==SVG_FILTER_TRANSFER_LINEAR) return gf_strdup("linear");
		else if (intVal==SVG_FILTER_TRANSFER_GAMMA) return gf_strdup("gamma");
		else return gf_strdup("identity");
		break;

	case LASeR_Choice_datatype:
		if (intVal==LASeR_CHOICE_ALL) return gf_strdup("all");
		else if (intVal==LASeR_CHOICE_NONE) return gf_strdup("none");
		else if (intVal==LASeR_CHOICE_N) {
			sprintf(tmp, "%d", ((LASeR_Choice *)info->far_ptr)->choice_index);
			return gf_strdup(tmp);
		}
		break;
	case LASeR_Size_datatype:
		sprintf(tmp, "%g %g", _FIX2FLT(((LASeR_Size *)info->far_ptr)->width), _FIX2FLT(((LASeR_Size *)info->far_ptr)->height));
		return gf_strdup(tmp);
	/* end of keyword type parsing */

	/* inheritable floats */
	case SVG_FontSize_datatype:
	case SVG_Length_datatype:
	case SVG_Coordinate_datatype:
	case SVG_Rotate_datatype:
	case SVG_Number_datatype:
#if DUMP_COORDINATES
		return svg_dump_number((SVG_Number *)info->far_ptr);
#endif

	case XMLRI_datatype:
		return svg_dump_iri((XMLRI*)info->far_ptr);
	case XML_IDREF_datatype:
		return svg_dump_idref((XMLRI*)info->far_ptr);
	case XMLRI_List_datatype:
	{
		GF_List *l = *(GF_List **)info->far_ptr;
		u32 i, count = gf_list_count(l);
		char *attVal = gf_malloc(sizeof(char));
		attVal[0] = 0;
		for (i=0; i<count; i++) {
			u32 len;
			char *szT;
			XMLRI *iri = (XMLRI *)gf_list_get(l, i);
			szT = svg_dump_iri(iri);
			len = (u32) strlen(szT);
			if (len) {
				attVal = gf_realloc(attVal, sizeof(char)*(len+strlen(attVal)+ (i ? 2 : 1) ));
				if (i) strcat(attVal, " ");
				strcat(attVal, szT);
			}
			gf_free(szT);
		}
		return attVal;
	}
	break;

	case SVG_PathData_datatype:
#if DUMP_COORDINATES
		return svg_dump_path((SVG_PathData *)info->far_ptr);
#endif
		break;
	case SVG_Points_datatype:
	{
#if DUMP_COORDINATES
		GF_List *l = *(GF_List **) info->far_ptr;
		u32 i = 0;
		u32 count = gf_list_count(l);
		char *attVal = gf_malloc(sizeof(char));
		attVal[0] = 0;
		for (i=0; i<count; i++) {
			char szT[200];
			SVG_Point *p = (SVG_Point *)gf_list_get(l, i);
			sprintf(szT, "%g %g", _FIX2FLT(p->x), _FIX2FLT(p->y));
			attVal = gf_realloc(attVal, sizeof(char)*(strlen(szT)+strlen(attVal)+ (i ? 2 : 1) ));
			if (i) strcat(attVal, " ");
			strcat(attVal, szT);
		}
		return attVal;
#endif
	}
	break;
	case SMIL_KeyTimes_datatype:
	case SMIL_KeyPoints_datatype:
	case SMIL_KeySplines_datatype:
	{
		GF_List *l = *(GF_List **) info->far_ptr;
		u32 i = 0;
		u32 count = gf_list_count(l);
		char *attVal = gf_malloc(sizeof(char));
		attVal[0] = 0;
		for (i=0; i<count; i++) {
			char szT[1000];
			Fixed *p = (Fixed *)gf_list_get(l, i);
			sprintf(szT, "%g", _FIX2FLT(*p));
			attVal = gf_realloc(attVal, sizeof(char)*(strlen(szT)+strlen(attVal)+ (i ? 2 : 1) ));
			if (i) strcat(attVal, " ");
			strcat(attVal, szT);
		}
		return attVal;
	}
	break;
	case SVG_Coordinates_datatype:
	{
#if DUMP_COORDINATES
		GF_List *l = *(GF_List **) info->far_ptr;
		u32 i = 0;
		u32 count = gf_list_count(l);
		char *attVal = gf_malloc(sizeof(char));
		attVal[0]=0;
		for (i=0; i<count; i++) {
			char *szT;
			SVG_Coordinate *p = (SVG_Coordinate *)gf_list_get(l, i);
			szT = svg_dump_number((SVG_Length *)p);
			attVal = gf_realloc(attVal, sizeof(char)*(strlen(szT)+strlen(attVal)+ (i ? 2 : 1) ));
			if (i) strcat(attVal, " ");
			strcat(attVal, szT);
			gf_free(szT);
		}
		return attVal;
#endif
	}
	break;
	case SVG_ViewBox_datatype:
	{
		SVG_ViewBox *v = (SVG_ViewBox *)info->far_ptr;
		if (v->is_set) {
			sprintf(tmp, "%g %g %g %g", _FIX2FLT(v->x), _FIX2FLT(v->y), _FIX2FLT(v->width), _FIX2FLT(v->height) );
			return gf_strdup(tmp);
		} else
			return gf_strdup("none");
	}
	break;
	case SVG_StrokeDashArray_datatype:
	{
		SVG_StrokeDashArray *p = (SVG_StrokeDashArray *)info->far_ptr;
		if (p->type==SVG_STROKEDASHARRAY_NONE) return gf_strdup("none");
		else if (p->type==SVG_STROKEDASHARRAY_INHERIT) return gf_strdup("inherit");
		else if (p->type==SVG_STROKEDASHARRAY_ARRAY) {
			u32 i = 0;
			char *attVal = gf_malloc(sizeof(char));
			attVal[0] = 0;
			for (i=0; i<p->array.count; i++) {
				char *szT;
				SVG_Length l;
				l.type = p->array.units[i];
				l.value = p->array.vals[i];
				szT = svg_dump_number(&l);
				attVal = gf_realloc(attVal, sizeof(char)*(strlen(szT)+strlen(attVal)+ (i ? 2 : 1) ));
				if (i) strcat(attVal, " ");
				strcat(attVal, szT);
				gf_free(szT);
			}
			return attVal;
		}
	}
	break;
	case SVG_FontFamily_datatype:
	{
		SVG_FontFamily *f = (SVG_FontFamily *)info->far_ptr;
		return gf_strdup( (!f->value || (f->type==SVG_FONTFAMILY_INHERIT)) ? "inherit" : (const char *) f->value);
	}

	case SVG_PreserveAspectRatio_datatype:
	{
		SVG_PreserveAspectRatio *par = (SVG_PreserveAspectRatio *)info->far_ptr;
		tmp[0] = 0;
		if (par->defer) strcat(tmp, "defer ");
		if (par->align == SVG_PRESERVEASPECTRATIO_NONE) strcat(tmp, "none");
		else if (par->align == SVG_PRESERVEASPECTRATIO_XMINYMIN) strcat(tmp, "xMinYMin");
		else if (par->align == SVG_PRESERVEASPECTRATIO_XMIDYMIN) strcat(tmp, "xMidYMin");
		else if (par->align == SVG_PRESERVEASPECTRATIO_XMAXYMIN) strcat(tmp, "xMaxYMin");
		else if (par->align == SVG_PRESERVEASPECTRATIO_XMINYMID) strcat(tmp, "xMinYMid");
		else if (par->align == SVG_PRESERVEASPECTRATIO_XMIDYMID) strcat(tmp, "xMidYMid");
		else if (par->align == SVG_PRESERVEASPECTRATIO_XMAXYMID) strcat(tmp, "xMaxYMid");
		else if (par->align == SVG_PRESERVEASPECTRATIO_XMINYMAX) strcat(tmp, "xMinYMax");
		else if (par->align == SVG_PRESERVEASPECTRATIO_XMIDYMAX) strcat(tmp, "xMidYMax");
		else if (par->align == SVG_PRESERVEASPECTRATIO_XMAXYMAX) strcat(tmp, "xMaxYMax");
		if (par->meetOrSlice== SVG_MEETORSLICE_SLICE) strcat(tmp, " slice");

		return gf_strdup(tmp);
	}

	case SVG_Clock_datatype:
		sprintf(tmp, "%g", * (SVG_Clock *)info->far_ptr );
		return gf_strdup(tmp);

	case SVG_ID_datatype:
	case SVG_LanguageID_datatype:
	case SVG_GradientOffset_datatype:
	case DOM_String_datatype:
	case SVG_ContentType_datatype:
		if (*(SVG_String *)info->far_ptr)
			return gf_strdup( *(SVG_String *)info->far_ptr );
		break;

	case SVG_Focus_datatype:
	{
		SVG_Focus *foc = (SVG_Focus *)info->far_ptr;
		if (foc->type==SVG_FOCUS_SELF) return gf_strdup("self");
		else if (foc->type==SVG_FOCUS_AUTO) return gf_strdup("auto");
		else {
			sprintf(tmp, "#%s", foc->target.string);
			return gf_strdup(tmp);
		}
	}
	case SVG_ClipPath_datatype:
	{
		SVG_ClipPath *cp = (SVG_ClipPath *)info->far_ptr;
		sprintf(tmp, "url(#%s)", cp->target.string);
		return gf_strdup(tmp);
	}
	break;
	case SVG_Focusable_datatype:
	{
		SVG_Focusable *f = (SVG_Focusable *)info->far_ptr;
		if (*f == SVG_FOCUSABLE_TRUE) return gf_strdup("true");
		else if (*f == SVG_FOCUSABLE_FALSE) return gf_strdup("false");
		else return gf_strdup("auto");
	}

	case DOM_StringList_datatype:
	{
		GF_List *l1 = *(GF_List **) info->far_ptr;
		u32 i = 0;
		u32 count = gf_list_count(l1);
		char *attVal = gf_malloc(sizeof(char));
		attVal[0] =  0;
		for (i=0; i<count; i++) {
			char *p1 = (char *)gf_list_get(l1, i);
			attVal = gf_realloc(attVal, sizeof(char)*(strlen(p1)+strlen(attVal)+ (i ? 2 : 1) ));
			if (i) strcat(attVal, " ");
			strcat(attVal, p1);
		}
		return attVal;
	}

	case SVG_Numbers_datatype:
	{
#if DUMP_COORDINATES
		GF_List *l1 = *(GF_List **) info->far_ptr;
		u32 i = 0;
		u32 count = gf_list_count(l1);
		char *attVal = gf_malloc(sizeof(char));
		attVal[0]=0;
		for (i=0; i<count; i++) {
			char *szT;
			SVG_Number *p = (SVG_Number *)gf_list_get(l1, i);
			szT = svg_dump_number(p);
			attVal = gf_realloc(attVal, sizeof(char)*(strlen(szT)+strlen(attVal)+ (i ? 2 : 1) ));
			if (i) strcat(attVal, " ");
			strcat(attVal, szT);
			gf_free(szT);
		}
		return attVal;
#endif
	}
	break;

	case SVG_Motion_datatype:
	{
#if DUMP_COORDINATES
		GF_Matrix2D *m = (GF_Matrix2D *)info->far_ptr;
		sprintf(tmp, "%g %g", _FIX2FLT(m->m[2]), _FIX2FLT(m->m[5]));
		return gf_strdup(tmp);
#endif
	}
	break;

	case SVG_Transform_datatype:
	{
		SVG_Transform *t= (SVG_Transform *)info->far_ptr;
		if (t->is_ref) {
			sprintf(tmp, "ref(svg,%g,%g)", _FIX2FLT(t->mat.m[2]), _FIX2FLT(t->mat.m[5]) );
			return gf_strdup(tmp);
		} else {
			return gf_svg_dump_matrix(&t->mat);
		}
	}
	break;

	case SVG_Transform_Translate_datatype:
	{
		SVG_Point *pt = (SVG_Point *)info->far_ptr;
#if DUMP_COORDINATES
		sprintf(tmp, "%g %g", _FIX2FLT(pt->x), _FIX2FLT(pt->y) );
		return gf_strdup(tmp);
#endif
	}
	break;

	case SVG_Transform_Scale_datatype:
	{
		SVG_Point *pt = (SVG_Point *)info->far_ptr;
#if DUMP_COORDINATES
		if (pt->x == pt->y) {
			sprintf(tmp, "%g", _FIX2FLT(pt->x));
		} else {
			sprintf(tmp, "%g %g", _FIX2FLT(pt->x), _FIX2FLT(pt->y) );
		}
		return gf_strdup(tmp);
#endif
	}
	break;

	case SVG_Transform_SkewX_datatype:
	case SVG_Transform_SkewY_datatype:
	{
		Fixed *f = (Fixed *)info->far_ptr;
#if DUMP_COORDINATES
		sprintf(tmp, "%g", _FIX2FLT( 180 * gf_divfix(*f, GF_PI) ));
		return gf_strdup(tmp);
#endif
	}
	break;

	case SVG_Transform_Rotate_datatype:
	{
		SVG_Point_Angle *pt = (SVG_Point_Angle *)info->far_ptr;
#if DUMP_COORDINATES
		if (pt->x || pt->y) {
			sprintf(tmp, "%g %g %g", _FIX2FLT( 180 * gf_divfix(pt->angle, GF_PI) ), _FIX2FLT(pt->x), _FIX2FLT(pt->y) );
		} else {
			sprintf(tmp, "%g", _FIX2FLT(gf_divfix(180 * pt->angle, GF_PI) ));
		}
		return gf_strdup(tmp);
#endif
	}
	break;

	case SMIL_AttributeName_datatype:
	{
		SMIL_AttributeName *att_name = (SMIL_AttributeName *) info->far_ptr;
		if (att_name->name)
			return gf_strdup(att_name->name);

		if (att_name->tag) {
			char *att_name_val = (char *)gf_svg_get_attribute_name(elt, att_name->tag);
			if (!att_name_val) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[SVG] unknown attribute name for tag %d\n", att_name->tag));
				return NULL;
			}
			return gf_strdup(att_name_val );
		}
	}
	break;

	case SMIL_Times_datatype:
	{
		u32 i, count;
		GF_Node *par = gf_node_get_parent((GF_Node *)elt, 0);
		GF_List *l = *(GF_List **) info->far_ptr;
		char *attVal = gf_malloc(sizeof(char));
		attVal[0] = 0;
		count = gf_list_count(l);
		for (i=0; i<count; i++) {
			char szBuf[1000];
			SMIL_Time *t = (SMIL_Time *)gf_list_get(l, i);
			szBuf[0] = 0;
			if (t->type == GF_SMIL_TIME_CLOCK) {
				sprintf(szBuf, "%gs", t->clock);
			} else if (t->type==GF_SMIL_TIME_INDEFINITE) {
				strcpy(szBuf, "indefinite");
			} else if (t->type==GF_SMIL_TIME_WALLCLOCK) {
				u32 h, m, s;
				/*TODO - day month and year*/
				h = (u32) t->clock * 3600;
				m = (u32) (t->clock * 60 - 60*h);
				s = (u32) (t->clock - 3600*h - 60*m);
				sprintf(szBuf, "wallclock(%d:%d:%d)", h, m, s);
			}
			else if (t->type==GF_SMIL_TIME_EVENT) {
				if (t->event.type == GF_EVENT_KEYDOWN) {
					svg_dump_access_key(&t->event, szBuf);
				} else {
					if (t->element_id) {
						strcpy(szBuf, t->element_id);
						strcat(szBuf, ".");
					} else if (t->element && (t->element!=par) && gf_node_get_id(t->element) ) {
						const char *name = gf_node_get_name(t->element);
						if (name) {
							strcpy(szBuf, name);
						} else {
							sprintf(szBuf, "N%d", gf_node_get_id(t->element)-1 );
						}
						strcat(szBuf, ".");
					}
					strcat(szBuf, gf_dom_event_get_name(t->event.type));
				}
				if (t->clock) {
					char szCk[40];
					sprintf(szCk, "+%gs", t->clock);
					strcat(szBuf, szCk);
				}
			}
			if (szBuf[0]) {
				attVal = gf_realloc(attVal, sizeof(char)*(strlen(attVal)+strlen(szBuf)+ (i ? 2 : 1) ));
				if ( strlen(attVal) ) strcat(attVal, ";");
				strcat(attVal, szBuf);
			}
		}
		return attVal;
	}
	break;
	case SMIL_Duration_datatype:
	{
		SMIL_Duration *dur = (SMIL_Duration *)info->far_ptr;
		if (dur->type == SMIL_DURATION_INDEFINITE) return gf_strdup("indefinite");
		else if (dur->type == SMIL_DURATION_MEDIA) return gf_strdup("media");
		else if (dur->type == SMIL_DURATION_DEFINED) {
			sprintf(tmp, "%gs", dur->clock_value);
			return gf_strdup(tmp);
		} else {
			GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[SVG Dumping] smil duration not assigned\n"));
		}
	}
	break;
	case SMIL_RepeatCount_datatype:
	{
		SMIL_RepeatCount *rep = (SMIL_RepeatCount *)info->far_ptr;
		if (rep->type == SMIL_REPEATCOUNT_INDEFINITE) return gf_strdup("indefinite");
		else if (rep->type == SMIL_REPEATCOUNT_DEFINED) {
			sprintf(tmp, "%g", _FIX2FLT(rep->count) );
			return gf_strdup(tmp);
		}
		else {
			GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[SVG Dumping] smil repeat count not assigned\n"));
		}
	}
	break;
	case SVG_TransformType_datatype:
	{
		SVG_TransformType tr = *(SVG_TransformType *)info->far_ptr;
		if (tr == SVG_TRANSFORM_MATRIX) return gf_strdup("matrix");
		else if (tr == SVG_TRANSFORM_SCALE) return gf_strdup("scale");
		else if (tr == SVG_TRANSFORM_ROTATE) return gf_strdup("rotate");
		else if (tr == SVG_TRANSFORM_TRANSLATE) return gf_strdup("translate");
		else if (tr == SVG_TRANSFORM_SKEWX) return gf_strdup("skewX");
		else if (tr == SVG_TRANSFORM_SKEWY) return gf_strdup("skewY");
	}
	break;

	case SMIL_AnimateValue_datatype:
	{
		GF_FieldInfo a_fi;
		SMIL_AnimateValue*av = (SMIL_AnimateValue*)info->far_ptr;
		a_fi.fieldIndex = 0;
		a_fi.fieldType = av->type;
		a_fi.name = info->name;
		a_fi.far_ptr = av->value;
		return gf_svg_dump_attribute(elt, &a_fi);
	}
	break;
	case SMIL_AnimateValues_datatype:
	{
		GF_FieldInfo a_fi;
		u32 i, count;
		SMIL_AnimateValues *av = (SMIL_AnimateValues*)info->far_ptr;
		char *attVal = gf_malloc(sizeof(char));
		attVal[0] = 0;
		if (av->type) {
			count = gf_list_count(av->values);
			a_fi.fieldIndex = 0;
			a_fi.fieldType = av->type;
			a_fi.name = info->name;
			for (i=0; i<count; i++) {
				char *szBuf;
				a_fi.far_ptr = gf_list_get(av->values, i);
				szBuf = gf_svg_dump_attribute(elt, &a_fi);

				attVal = gf_realloc(attVal, sizeof(char)*(strlen(attVal)+strlen(szBuf)+ (i ? 2 : 1) ));
				if (i) strcat(attVal, ";");
				strcat(attVal, szBuf);
				gf_free(szBuf);
			}
		}
		return attVal;
	}

	case XMLEV_Event_datatype:
	{
		XMLEV_Event *d = (XMLEV_Event *)info->far_ptr;
		if (d->parameter) {
			svg_dump_access_key(d, tmp);
		} else {
			strcpy(tmp, gf_dom_event_get_name(d->type));
		}
		return gf_strdup(tmp);
	}
	default:
		GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[SVG Dumping] field %s of type %s not supported\n", info->name, gf_svg_attribute_type_to_string(info->fieldType)));
		break;
	}
	return gf_strdup("");
}
