void FilterManager::sendLocalReply(
    Code code, absl::string_view body,
    const std::function<void(ResponseHeaderMap& headers)>& modify_headers,
    const absl::optional<Grpc::Status::GrpcStatus> grpc_status, absl::string_view details) {
  ASSERT(!state_.under_on_local_reply_);
  const bool is_head_request = state_.is_head_request_;
  const bool is_grpc_request = state_.is_grpc_request_;

  // Stop filter chain iteration if local reply was sent while filter decoding or encoding callbacks
  // are running.
  if (state_.filter_call_state_ & (FilterCallState::DecodeHeaders | FilterCallState::DecodeData |
                                   FilterCallState::DecodeTrailers)) {
    state_.decoder_filter_chain_aborted_ = true;
  } else if (state_.filter_call_state_ &
             (FilterCallState::EncodeHeaders | FilterCallState::EncodeData |
              FilterCallState::EncodeTrailers)) {
    state_.encoder_filter_chain_aborted_ = true;
  }

  stream_info_.setResponseCodeDetails(details);
  StreamFilterBase::LocalReplyData data{code, details, false};
  FilterManager::onLocalReply(data);
  if (data.reset_imminent_) {
    ENVOY_STREAM_LOG(debug, "Resetting stream due to {}. onLocalReply requested reset.", *this,
                     details);
    filter_manager_callbacks_.resetStream();
    return;
  }

  if (!filter_manager_callbacks_.responseHeaders().has_value()) {
    // If the response has not started at all, send the response through the filter chain.
    sendLocalReplyViaFilterChain(is_grpc_request, code, body, modify_headers, is_head_request,
                                 grpc_status, details);
  } else if (!state_.non_100_response_headers_encoded_) {
    ENVOY_STREAM_LOG(debug, "Sending local reply with details {} directly to the encoder", *this,
                     details);
    // In this case, at least the header and possibly the body has started
    // processing through the filter chain, but no non-informational headers
    // have been sent downstream. To ensure that filters don't get their
    // state machine screwed up, bypass the filter chain and send the local
    // reply directly to the codec.
    //
    sendDirectLocalReply(code, body, modify_headers, state_.is_head_request_, grpc_status);
  } else {
    // If we land in this branch, response headers have already been sent to the client.
    // All we can do at this point is reset the stream.
    ENVOY_STREAM_LOG(debug, "Resetting stream due to {}. Prior headers have already been sent",
                     *this, details);
    // TODO(snowp): This means we increment the tx_reset stat which we weren't doing previously.
    // Intended?
    filter_manager_callbacks_.resetStream();
  }
}
