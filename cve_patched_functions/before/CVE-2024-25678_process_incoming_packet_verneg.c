process_incoming_packet_verneg (struct ietf_full_conn *conn,
                                        struct lsquic_packet_in *packet_in)
{
    int s;
    struct ver_iter vi;
    lsquic_ver_tag_t ver_tag;
    enum lsquic_version version;
    unsigned versions;

    if (lsquic_packet_in_is_verneg(packet_in))
    {
        LSQ_DEBUG("Processing version-negotiation packet");

        if (conn->ifc_u.cli.ifcli_ver_neg.vn_state != VN_START)
        {
            LSQ_DEBUG("ignore a likely duplicate version negotiation packet");
            return 0;
        }

        if (!(LSQUIC_CIDS_EQ(&conn->ifc_conn.cn_cid, &packet_in->pi_dcid)
            && CUR_DCID(conn)->len == packet_in->pi_scid_len
            && 0 == memcmp(CUR_DCID(conn)->idbuf, packet_in->pi_data
                            + packet_in->pi_scid_off, packet_in->pi_scid_len)))
        {
            LSQ_DEBUG("SCID and DCID in verneg packet don't match what we "
                        "sent: ignore");
            return 0;
        }

        versions = 0;
        for (s = lsquic_packet_in_ver_first(packet_in, &vi, &ver_tag); s;
                         s = lsquic_packet_in_ver_next(&vi, &ver_tag))
        {
            version = lsquic_tag2ver(ver_tag);
            if (version < N_LSQVER)
            {
                versions |= 1 << version;
                LSQ_DEBUG("server supports version %s", lsquic_ver2str[version]);
                EV_LOG_VER_NEG(LSQUIC_LOG_CONN_ID,
                                            "supports", lsquic_ver2str[version]);
            }
        }

        /* [draft-ietf-quic-transport-28] Section 6.2:
         " A client MUST discard a Version Negotiation packet that lists the
         " QUIC version selected by the client.
         */
        if (versions & (1 << conn->ifc_u.cli.ifcli_ver_neg.vn_ver))
        {
            LSQ_DEBUG("server replied with version we sent, %s, ignore",
                        lsquic_ver2str[conn->ifc_u.cli.ifcli_ver_neg.vn_ver]);
            return 0;
        }

        /* [draft-ietf-quic-transport-28] Section 6.2:
         " A client that supports only this version of QUIC MUST abandon the
         " current connection attempt if it receives a Version Negotiation
         " packet [...]
         */
        if (!verneg_ok(conn))
        {
            ABORT_WITH_FLAG(conn, LSQ_LOG_NOTICE, IFC_ERROR|IFC_HSK_FAILED,
                "version negotiation not permitted in this version of QUIC");
            return -1;
        }

        versions &= conn->ifc_u.cli.ifcli_ver_neg.vn_supp;
        if (0 == versions)
        {
            ABORT_WITH_FLAG(conn, LSQ_LOG_NOTICE, IFC_ERROR|IFC_HSK_FAILED,
                "client does not support any of the server-specified versions");
            return -1;
        }

        set_versions(conn, versions, NULL);
        conn->ifc_u.cli.ifcli_ver_neg.vn_state = VN_IN_PROGRESS;
        lsquic_send_ctl_expire_all(&conn->ifc_send_ctl);
        return 0;
    }

    if (packet_in->pi_version != conn->ifc_u.cli.ifcli_ver_neg.vn_ver)
    {
        if (!((1 << packet_in->pi_version)
              & conn->ifc_u.cli.ifcli_ver_neg.vn_supp))
        {
            LSQ_DEBUG("server version doesn't match versions "
                        "supported: ignore");
            return 0;
        }
        LSQ_DEBUG("version negociation: server switched version from %s to %s",
        lsquic_ver2str[conn->ifc_u.cli.ifcli_ver_neg.vn_ver],
        lsquic_ver2str[packet_in->pi_version]);
        switch_version(conn, packet_in->pi_version);
    }
    else
        conn->ifc_conn.cn_version = conn->ifc_u.cli.ifcli_ver_neg.vn_ver;
    assert(conn->ifc_u.cli.ifcli_ver_neg.vn_tag);
    assert(conn->ifc_u.cli.ifcli_ver_neg.vn_state != VN_END);
    conn->ifc_u.cli.ifcli_ver_neg.vn_state = VN_END;
    conn->ifc_u.cli.ifcli_ver_neg.vn_tag = NULL;
    conn->ifc_conn.cn_flags |= LSCONN_VER_SET;
    LSQ_DEBUG("end of version negotiation: agreed upon %s",
                    lsquic_ver2str[conn->ifc_conn.cn_version]);
    EV_LOG_VER_NEG(LSQUIC_LOG_CONN_ID,
            "agreed", lsquic_ver2str[conn->ifc_conn.cn_version]);
    conn->ifc_process_incoming_packet = process_regular_packet;

    if (process_regular_packet(conn, packet_in) == 0)
    {
        enable_ping_alarm_for_handshake(conn);
        return 0;
    }
    return -1;
}
