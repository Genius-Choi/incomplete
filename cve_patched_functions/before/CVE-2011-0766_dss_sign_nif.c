static ERL_NIF_TERM dss_sign_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{/* (DigesType, Data, Key=[P,Q,G,PrivKey]) */
    ErlNifBinary data_bin, ret_bin;
    ERL_NIF_TERM head, tail;
    unsigned char hmacbuf[SHA_DIGEST_LENGTH];
    unsigned int dsa_s_len;
    DSA* dsa = DSA_new();
    int i;

    dsa->pub_key  = NULL;
    if (!enif_get_list_cell(env, argv[2], &head, &tail)
	|| !get_bn_from_mpint(env, head, &dsa->p)
	|| !enif_get_list_cell(env, tail, &head, &tail)
	|| !get_bn_from_mpint(env, head, &dsa->q)
	|| !enif_get_list_cell(env, tail, &head, &tail)
	|| !get_bn_from_mpint(env, head, &dsa->g)
	|| !enif_get_list_cell(env, tail, &head, &tail)
	|| !get_bn_from_mpint(env, head, &dsa->priv_key)
	|| !enif_is_empty_list(env,tail)) {
	goto badarg;	
    }
    if (argv[0] == atom_sha && inspect_mpint(env, argv[1], &data_bin)) {
	SHA1(data_bin.data+4, data_bin.size-4, hmacbuf);
    }
    else if (argv[0] == atom_none && enif_inspect_binary(env,argv[1],&data_bin) 
	     && data_bin.size == SHA_DIGEST_LENGTH) {
	memcpy(hmacbuf, data_bin.data, SHA_DIGEST_LENGTH);
    }
    else {
    badarg:
	DSA_free(dsa);
	return enif_make_badarg(env);
    }

    enif_alloc_binary(DSA_size(dsa), &ret_bin);
    i =  DSA_sign(NID_sha1, hmacbuf, SHA_DIGEST_LENGTH,
		  ret_bin.data, &dsa_s_len, dsa);
    DSA_free(dsa);
    if (i) {
	if (dsa_s_len != ret_bin.size) {
	    enif_realloc_binary(&ret_bin, dsa_s_len);
	}
	return enif_make_binary(env, &ret_bin);
    }
    else {
	return atom_error;
    }
}
