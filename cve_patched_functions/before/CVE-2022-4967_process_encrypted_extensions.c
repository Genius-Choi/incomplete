static status_t process_encrypted_extensions(private_tls_peer_t *this,
											 bio_reader_t *reader)
{
	chunk_t ext = chunk_empty;
	uint16_t extension_type;

	this->crypto->append_handshake(this->crypto, TLS_ENCRYPTED_EXTENSIONS,
								   reader->peek(reader));

	if (!reader->read_data16(reader, &ext))
	{
		DBG1(DBG_TLS, "received invalid EncryptedExtensions");
		this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
		return NEED_MORE;
	}
	if (ext.len)
	{
		bio_reader_t *extensions = bio_reader_create(ext);

		while (extensions->remaining(extensions))
		{
			chunk_t extension_data = chunk_empty;

			if (!extensions->read_uint16(extensions, &extension_type) ||
				!extensions->read_data16(extensions, &extension_data))
			{
				DBG1(DBG_TLS, "invalid extension in EncryptedExtensions");
				this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
				extensions->destroy(extensions);
				return NEED_MORE;
			}
			switch (extension_type)
			{
				case TLS_EXT_SERVER_NAME:
				case TLS_EXT_MAX_FRAGMENT_LENGTH:
				case TLS_EXT_SUPPORTED_GROUPS:
				case TLS_EXT_USE_SRTP:
				case TLS_EXT_HEARTBEAT:
				case TLS_EXT_APPLICATION_LAYER_PROTOCOL_NEGOTIATION:
				case TLS_SERVER_CERTIFICATE_TYPE:
					/* not supported so far */
					DBG2(DBG_TLS, "ignoring unsupported %N EncryptedExtension",
						 tls_extension_names, extension_type);
					break;
				default:
					DBG1(DBG_TLS, "received forbidden EncryptedExtension (%d)",
						 extension_type);
					this->alert->add(this->alert, TLS_FATAL,
									 TLS_ILLEGAL_PARAMETER);
					extensions->destroy(extensions);
					return NEED_MORE;
			}
		}
		extensions->destroy(extensions);
	}
	this->state = STATE_ENCRYPTED_EXTENSIONS_RECEIVED;
	return NEED_MORE;
}
