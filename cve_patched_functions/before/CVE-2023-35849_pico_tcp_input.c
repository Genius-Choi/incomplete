int pico_tcp_input(struct pico_socket *s, struct pico_frame *f)
{
    struct pico_tcp_hdr *hdr = (struct pico_tcp_hdr *) (f->transport_hdr);
    int ret = 0;
    uint8_t flags = hdr->flags;
    const struct tcp_action_entry *action = &tcp_fsm[s->state >> 8];

    f->payload = (f->transport_hdr + ((hdr->len & 0xf0u) >> 2u));
    f->payload_len = (uint16_t)(f->transport_len - ((hdr->len & 0xf0u) >> 2u));

    tcp_dbg("[sam] TCP> [tcp input] t_len: %u\n", f->transport_len);
    tcp_dbg("[sam] TCP> flags = 0x%02x\n", hdr->flags);
    tcp_dbg("[sam] TCP> s->state >> 8 = %u\n", s->state >> 8);
    tcp_dbg("[sam] TCP> [tcp input] socket: %p state: %d <-- local port:%u remote port: %u seq: 0x%08x ack: 0x%08x flags: 0x%02x t_len: %u, hdr: %u payload: %d\n", s, s->state >> 8, short_be(hdr->trans.dport), short_be(hdr->trans.sport), SEQN(f), ACKN(f), hdr->flags, f->transport_len, (hdr->len & 0xf0) >> 2, f->payload_len );

    if ((f->payload + f->payload_len) > (f->buffer + f->buffer_len)) {
        tcp_dbg("TCP> Invalid payload len %04x\n", f->payload_len);
        pico_frame_discard(f);
        return -1;
    }

    /* This copy of the frame has the current socket as owner */
    f->sock = s;
    s->timestamp = TCP_TIME;
    /* Those are not supported at this time. */
    /* flags &= (uint8_t) ~(PICO_TCP_CWR | PICO_TCP_URG | PICO_TCP_ECN); */
    if(invalid_flags(s, flags)) {
        pico_tcp_reply_rst(s->stack, f);
    }
    else if (flags == PICO_TCP_SYN) {
        tcp_action_call(action->syn, s, f);
    } else if (flags == (PICO_TCP_SYN | PICO_TCP_ACK)) {
        tcp_action_call(action->synack, s, f);
    } else {
        ret = tcp_action_by_flags(action, s, f, flags);
    }

    if (s->ev_pending)
        tcp_wakeup_pending(s, s->ev_pending);

/* discard: */
    pico_frame_discard(f);
    return ret;
}
