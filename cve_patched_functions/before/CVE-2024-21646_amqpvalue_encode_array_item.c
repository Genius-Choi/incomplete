static int amqpvalue_encode_array_item(AMQP_VALUE item, bool first_element, AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
{
    int result;

    if ((item == NULL) ||
        (encoder_output == NULL))
    {
        LogError("Bad arguments: item = %p, encoder_output = %p", item, encoder_output);
        result = MU_FAILURE;
    }
    else
    {
        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)item;

        switch (value_data->type)
        {
            default:
                LogError("Unsupported array type: %d", (int)value_data->type);
                result = MU_FAILURE;
                break;

            case AMQP_TYPE_NULL:
                if ((first_element) && (encode_null_constructor(encoder_output, context) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_null_value(encoder_output, context);
                break;

            case AMQP_TYPE_BOOL:
                if ((first_element) && (encode_boolean_constructor(encoder_output, context) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_boolean_value(encoder_output, context, value_data->value.bool_value);
                break;

            case AMQP_TYPE_UBYTE:
                if ((first_element) && (encode_ubyte_constructor(encoder_output, context) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_ubyte_value(encoder_output, context, value_data->value.ubyte_value);
                break;

            case AMQP_TYPE_USHORT:
                if ((first_element) && (encode_ushort_constructor(encoder_output, context) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_ushort_value(encoder_output, context, value_data->value.ushort_value);
                break;

            case AMQP_TYPE_UINT:
                if ((first_element) && (encode_uint_constructor(encoder_output, context, false) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_uint_value(encoder_output, context, value_data->value.uint_value, false);
                break;

            case AMQP_TYPE_ULONG:
                if ((first_element) && (encode_ulong_constructor(encoder_output, context, false) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_ulong_value(encoder_output, context, value_data->value.ulong_value, false);
                break;

            case AMQP_TYPE_BYTE:
                if ((first_element) && (encode_byte_constructor(encoder_output, context) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_byte_value(encoder_output, context, value_data->value.byte_value);
                break;

            case AMQP_TYPE_SHORT:
                if ((first_element) && (encode_short_constructor(encoder_output, context) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_short_value(encoder_output, context, value_data->value.short_value);
                break;

            case AMQP_TYPE_INT:
                if ((first_element) && (encode_int_constructor(encoder_output, context, false) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_int_value(encoder_output, context, value_data->value.int_value, false);
                break;

            case AMQP_TYPE_LONG:
                if ((first_element) && (encode_long_constructor(encoder_output, context, false) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_long_value(encoder_output, context, value_data->value.long_value, false);
                break;

            case AMQP_TYPE_FLOAT:
                if ((first_element) && (encode_float_constructor(encoder_output, context) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_float_value(encoder_output, context, value_data->value.float_value);
                break;

            case AMQP_TYPE_DOUBLE:
                if ((first_element) && (encode_double_constructor(encoder_output, context) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_double_value(encoder_output, context, value_data->value.double_value);
                break;

            case AMQP_TYPE_TIMESTAMP:
                if ((first_element) && (encode_timestamp_constructor(encoder_output, context) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_timestamp_value(encoder_output, context, value_data->value.timestamp_value);
                break;

            case AMQP_TYPE_UUID:
                if ((first_element) && (encode_uuid_constructor(encoder_output, context) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_uuid_value(encoder_output, context, value_data->value.uuid_value);
                break;

            case AMQP_TYPE_BINARY:
                if ((first_element) && (encode_binary_constructor(encoder_output, context, false) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_binary_value(encoder_output, context, (const unsigned char*)value_data->value.binary_value.bytes, value_data->value.binary_value.length, false);
                break;

            case AMQP_TYPE_STRING:
                if ((first_element) && (encode_string_constructor(encoder_output, context, false) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_string_value(encoder_output, context, value_data->value.string_value.chars, strlen(value_data->value.string_value.chars), false);
                break;

            case AMQP_TYPE_SYMBOL:
                if ((first_element) && (encode_symbol_constructor(encoder_output, context, false) != 0))
                {
                    result = MU_FAILURE;
                    break;
                }
                result = encode_symbol_value(encoder_output, context, value_data->value.symbol_value.chars, strlen(value_data->value.symbol_value.chars), false);
                break;

            case AMQP_TYPE_LIST:
            {
                uint32_t list_size;

                if ((first_element) && (encode_list_constructor(encoder_output, context, false) != 0))
                {
                    result = MU_FAILURE;
                }
                else if (amqpvalue_get_encoded_list_size(value_data->value.list_value.items, value_data->value.list_value.count, &list_size) != 0)
                {
                    result = MU_FAILURE;
                }
                else
                {
                    result = encode_list_value(encoder_output, context, value_data->value.list_value.count, list_size, value_data->value.list_value.items, false);
                }
                break;
            }

            case AMQP_TYPE_MAP:
            {
                uint32_t map_size;

                if ((first_element) && (encode_map_constructor(encoder_output, context, false) != 0))
                {
                    result = MU_FAILURE;
                }
                else if (amqpvalue_get_encoded_map_size(value_data->value.map_value.pairs, value_data->value.map_value.pair_count, &map_size) != 0)
                {
                    result = MU_FAILURE;
                }
                else
                {
                    result = encode_map_value(encoder_output, context, value_data->value.map_value.pair_count, map_size, value_data->value.map_value.pairs, false);
                }
                break;
            }

            case AMQP_TYPE_ARRAY:
            {
                uint32_t array_size;

                if ((first_element) && (encode_array_constructor(encoder_output, context, false) != 0))
                {
                    result = MU_FAILURE;
                }
                else if (amqpvalue_get_encoded_array_size(value_data->value.array_value.items, value_data->value.array_value.count, &array_size) != 0)
                {
                    result = MU_FAILURE;
                }
                else
                {
                    result = encode_array_value(encoder_output, context, value_data->value.array_value.count, array_size, value_data->value.array_value.items, false);
                }
                break;
            }
        }
    }
    return result;
}
