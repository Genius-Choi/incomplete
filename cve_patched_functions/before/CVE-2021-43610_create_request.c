static belle_sip_request_t *create_request(belle_sip_dialog_t *obj, const char *method, int full){
	belle_sip_request_t *req;
	char* from_tag=NULL, *to_tag=NULL;

	if (!obj->remote_target){
		belle_sip_error("dialog [%p]: no remote_target set, unable to create request.", obj);
		return NULL;
	}

	if (!belle_sip_parameters_has_parameter(BELLE_SIP_PARAMETERS(obj->local_party), "tag")) {
		/*special case for dialog created by server transaction*/
		from_tag = obj->local_tag;
	}
	if (!belle_sip_parameters_has_parameter(BELLE_SIP_PARAMETERS(obj->remote_party), "tag")) {
		/*special case for dialog created by server transaction*/
		to_tag = obj->remote_tag;
	}

	req=belle_sip_request_create(belle_sip_header_address_get_uri(obj->remote_target),
	                                                method,
	                                                obj->call_id,
	                                                belle_sip_header_cseq_create(obj->local_cseq,method),
	                                                belle_sip_header_from_create(obj->local_party,from_tag),
	                                                belle_sip_header_to_create(obj->remote_party,to_tag),
	                                                belle_sip_header_via_new(),
	                                                0);

	if (full && obj->route_set) {
		belle_sip_message_add_headers((belle_sip_message_t*)req,obj->route_set);
	}
	if (obj->privacy) {
		/*repeat the last privacy set in new request. I could not find any requirement for this, but this might be safer
		 * as proxies don't store information about dialogs*/
		belle_sip_message_add_header((belle_sip_message_t*)req,BELLE_SIP_HEADER(obj->privacy));
	}
	belle_sip_request_set_dialog(req,obj);
	return req;
}
