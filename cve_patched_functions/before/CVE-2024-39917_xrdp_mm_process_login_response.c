xrdp_mm_process_login_response(struct xrdp_mm *self)
{
    enum scp_login_status login_result;
    int rv;
    int server_closed;

    self->mmcs_expecting_msg = 0;

    rv = scp_get_login_response(self->sesman_trans, &login_result,
                                &server_closed, &self->uid);
    if (rv == 0)
    {
        if (login_result != E_SCP_LOGIN_OK)
        {
            char buff[128];
            scp_login_status_to_str(login_result, buff, sizeof(buff));
            xrdp_wm_log_msg(self->wm, LOG_LEVEL_INFO, "%s", buff);

            if (login_result == E_SCP_LOGIN_NOT_AUTHENTICATED &&
                    self->wm->pamerrortxt[0] != '\0')
            {
                xrdp_wm_log_msg(self->wm, LOG_LEVEL_INFO, "%s",
                                self->wm->pamerrortxt);
            }

            if (server_closed)
            {
                if (login_result == E_SCP_LOGIN_NOT_AUTHENTICATED)
                {
                    xrdp_wm_log_msg(self->wm, LOG_LEVEL_INFO, "%s",
                                    "Login retry limit reached");
                }
                xrdp_wm_log_msg(self->wm, LOG_LEVEL_INFO, "%s",
                                "Close the log window to exit.");
                self->wm->fatal_error_in_log_window = 1;
                /* Transport can be deleted now */
                self->delete_sesman_trans = 1;
            }
            /* If the server hasn't closed, inform the window manager
             * of the fail, but leave the sesman connection open for
             * further login attempts */
            xrdp_wm_mod_connect_done(self->wm, 1);
        }
        else
        {
            /* login successful */
            xrdp_mm_connect_sm(self);
        }
    }

    return rv;
}
