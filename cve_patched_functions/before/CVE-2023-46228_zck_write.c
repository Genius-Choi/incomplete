ssize_t ZCK_PUBLIC_API zck_write(zckCtx *zck, const char *src, const size_t src_size) {
    VALIDATE_WRITE_INT(zck);

    if(src_size == 0)
        return 0;

    if(!zck->comp.started && !comp_init(zck))
        return -1;

    const char *loc = src;
    size_t loc_size = src_size;
    size_t loc_written = 0;
    uint32_t buzhash_res;

    if(zck->manual_chunk) {
        while(zck->comp.dc_data_size + loc_size > zck->chunk_max_size) {
            loc_written = zck->chunk_max_size - zck->comp.dc_data_size;
            if(comp_write(zck, loc, loc_written) != loc_written)
                return -1;
            loc_size -= loc_written;
            loc += loc_written;
            zck_log(ZCK_LOG_DDEBUG,
                    "Chunk has reached maximum size, forcing a new chunk");
            if(zck_end_chunk(zck) < 0)
                return -1;
        }
        if(comp_write(zck, loc, loc_size) != loc_size)
            return -1;
        else
            return src_size;
    } else {
        for(size_t i=0; i<loc_size; ) {
            if (!buzhash_update(&(zck->buzhash), loc+i, zck->buzhash_width, &buzhash_res)) {
                zck_log(ZCK_LOG_ERROR, "OOM in buzhash_update");
                return -1;
            }

            if((buzhash_res & zck->buzhash_bitmask) == 0 ||
               zck->comp.dc_data_size + i >= zck->chunk_auto_max) {
                if(comp_write(zck, loc, i) != i)
                    return -1;
                loc += i;
                loc_size -= i;
                i = 0;
                if(zck->comp.dc_data_size >= zck->chunk_max_size)
                    zck_log(ZCK_LOG_DDEBUG,
                            "Chunk has reached maximum size, forcing a new "
                            "chunk");
                else
                    zck_log(ZCK_LOG_DDEBUG, "Automatically ending chunk");
                if(zck->comp.dc_data_size < zck->chunk_auto_min) {
                    zck_log(ZCK_LOG_DDEBUG,
                            "Chunk too small, refusing to end chunk");
                    continue;
                }
                if(zck_end_chunk(zck) < 0)
                    return -1;
            } else {
                i++;
            }
        }
        if(loc_size > 0 && comp_write(zck, loc, loc_size) != loc_size)
            return -1;
        return src_size;
    }
}
