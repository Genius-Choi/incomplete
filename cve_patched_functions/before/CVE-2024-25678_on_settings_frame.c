on_settings_frame (void *ctx)
{
    struct ietf_full_conn *const conn = ctx;
    unsigned dyn_table_size, max_risked_streams;

    LSQ_DEBUG("SETTINGS frame");
    if (conn->ifc_flags & IFC_HAVE_PEER_SET)
    {
        ABORT_QUIETLY(1, HEC_FRAME_UNEXPECTED,
            "second incoming SETTING frame on HTTP control stream");
        return;
    }

    conn->ifc_flags |= IFC_HAVE_PEER_SET;
    dyn_table_size = MIN(conn->ifc_settings->es_qpack_enc_max_size,
                                conn->ifc_peer_hq_settings.header_table_size);
    max_risked_streams = MIN(conn->ifc_settings->es_qpack_enc_max_blocked,
                            conn->ifc_peer_hq_settings.qpack_blocked_streams);
    if (conn->ifc_settings->es_qpack_experiment == 2)
        randomize_qpack_settings(conn, "encoder", &dyn_table_size,
                                                        &max_risked_streams);
    if (conn->ifc_qeh.qeh_exp_rec)
    {
        conn->ifc_qeh.qeh_exp_rec->qer_peer_max_size
                        = conn->ifc_peer_hq_settings.header_table_size;
        conn->ifc_qeh.qeh_exp_rec->qer_used_max_size = dyn_table_size;
        conn->ifc_qeh.qeh_exp_rec->qer_peer_max_blocked
                        = conn->ifc_peer_hq_settings.qpack_blocked_streams;
        conn->ifc_qeh.qeh_exp_rec->qer_used_max_blocked = max_risked_streams;
    }
    if (0 != lsquic_qeh_settings(&conn->ifc_qeh,
            conn->ifc_peer_hq_settings.header_table_size,
            dyn_table_size, max_risked_streams, conn->ifc_flags & IFC_SERVER))
        ABORT_WARN("could not initialize QPACK encoder handler");
    if (avail_streams_count(conn, conn->ifc_flags & IFC_SERVER, SD_UNI) > 0)
    {
        if (0 != create_qenc_stream_out(conn))
            ABORT_WARN("cannot create outgoing QPACK encoder stream");
    }
    else
    {
        queue_streams_blocked_frame(conn, SD_UNI);
        LSQ_DEBUG("cannot create QPACK encoder stream due to unidir limit");
    }
    maybe_create_delayed_streams(conn);
}
