GF_Err avidmx_process(GF_Filter *filter)
{
	GF_AVIDmxCtx *ctx = gf_filter_get_udta(filter);
	u32 i, count, nb_done, nb_active=0;
	Bool start, end;
	u32 a_pc=0;

	if (!ctx->avi) {
		GF_FilterPacket *pck = gf_filter_pid_get_packet(ctx->ipid);
		if (!pck) {
			return GF_OK;
		}
		gf_filter_pck_get_framing(pck, &start, &end);
		gf_filter_pid_drop_packet(ctx->ipid);

		if (!end) {
			return GF_OK;
		}
		ctx->avi = AVI_open_input_file((char *)ctx->src_url, 1);
		if (!ctx->avi) {
			GF_Err e = GF_NON_COMPLIANT_BITSTREAM;
			if (! gf_file_exists(ctx->src_url)) e = GF_URL_ERROR;
			gf_filter_setup_failure(filter, e);
			return GF_NOT_SUPPORTED;
		}
		FILE *fp = gf_fopen(ctx->src_url, "r");
		if (fp) {
			ctx->file_size = gf_fsize(fp);
			gf_fclose(fp);
		}

		avidmx_setup(filter, ctx);
		return GF_OK;
	}

	if (ctx->v_in_use && ctx->v_playing && (ctx->cur_frame < ctx->nb_frames) && !gf_filter_pid_would_block(ctx->v_opid) ) {
		u32 key;
		u64 file_offset, cts;
		u8 *pck_data;
		s32 size = AVI_frame_size(ctx->avi, ctx->cur_frame);
		if (!size) {
			AVI_read_frame(ctx->avi, NULL, &key);
			ctx->dummy++;
		}
		//remove dummy frames
		else {
			file_offset = (u64) AVI_get_video_position(ctx->avi, ctx->cur_frame);
			cts = ctx->nb_frame_sent * ctx->fps.den;

			if (size > 4) {
				GF_FilterPacket *dst_pck = gf_filter_pck_new_alloc(ctx->v_opid, size, &pck_data);
				if (!dst_pck) return GF_OUT_OF_MEM;
				AVI_read_frame(ctx->avi, pck_data, &key);
				gf_filter_pck_set_byte_offset(dst_pck, file_offset);
				gf_filter_pck_set_cts(dst_pck, cts);
				gf_filter_pck_set_duration(dst_pck, ctx->fps.den);
				gf_filter_pck_set_framing(dst_pck, GF_TRUE, GF_TRUE);
				if (key) gf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);
				gf_filter_pck_send(dst_pck);
				ctx->nb_frame_sent++;
			} else {
				AVI_read_frame(ctx->avi, NULL, &key);
				ctx->nvops++;
			}
		}
		nb_active++;

		ctx->cur_frame++;
		if (ctx->cur_frame < ctx->nb_frames)
			gf_filter_post_process_task(filter);
		else if (!ctx->video_done) {
			ctx->video_done = GF_TRUE;
			gf_filter_pid_set_eos(ctx->v_opid);
		}
	} else if (!ctx->v_in_use || (ctx->cur_frame >= ctx->nb_frames)) {
		if (!ctx->video_done) {
			if (ctx->v_in_use) {
				gf_filter_pid_set_eos(ctx->v_opid);
			}
			ctx->video_done = GF_TRUE;
		}
	}
	
	nb_done = 0;
	count = gf_list_count(ctx->audios);
	for (i=0; i<count; i++) {
		s32 size;
		u32 pc=0;
		AVIAstream *st = gf_list_get(ctx->audios, i);
		if (st->audio_done || !st->in_use) {
			nb_done++;
			continue;
		}
		if (!ctx->v_playing)
			ctx->video_done = GF_TRUE;

		if (!st->playing || gf_filter_pid_would_block(st->opid) )
			continue;
		AVI_set_audio_track(ctx->avi, st->stream_num);
		nb_active++;

restart:
		size = AVI_audio_size(ctx->avi, st->aud_frame);

		if (st->seek_to_ts && size) {
			if (st->seek_to_ts > st->audio_ts) {
				st->aud_frame ++;
				if (st->audio_bps) {
					u32 nb_samples = (8*size) / (st->audio_bps * st->nb_channels);
					st->audio_ts += nb_samples;
				} else if (st->is_aac) {
					st->audio_ts += 1024;
				} else {
					st->audio_ts ++;
				}
				goto restart;
			}
			else
				st->seek_to_ts = 0;
		}

		if (size>0) {
			int continuous;
			u8 *pck_data;
			u64 file_offset;
			GF_FilterPacket *dst_pck = gf_filter_pck_new_alloc(st->opid, size, &pck_data);
			if (!dst_pck) return GF_OUT_OF_MEM;
			
			file_offset = gf_ftell(ctx->avi->fdes);
			AVI_read_audio(ctx->avi, pck_data, size, (int*)&continuous);

			if (ctx->file_size) {
				pc = (u32) ( file_offset * 100  / ctx->file_size);
			}

			if (st->audio_bps) {
				u32 nb_samples = (8*size) / (st->audio_bps * st->nb_channels);
				gf_filter_pck_set_cts(dst_pck, st->audio_ts);
				gf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);
				st->audio_ts += nb_samples;
			} else if (st->is_aac) {
				gf_filter_pck_set_cts(dst_pck, st->audio_ts);
				gf_filter_pck_set_sap(dst_pck, GF_FILTER_SAP_1);
				st->audio_ts += 1024;
			}

			if (continuous)
				gf_filter_pck_set_byte_offset(dst_pck, file_offset);

			gf_filter_pck_send(dst_pck);

			st->aud_frame ++;
		} else {
			st->audio_done = GF_TRUE;
			gf_filter_pid_set_eos(st->opid);
			nb_done++;
			pc = 100;
		}
		if (!a_pc || (pc<a_pc)) a_pc = pc;
	}
	if (gf_filter_reporting_enabled(filter)) {
		char szStatus[1024];
		u32 v_pc=0;
		if (ctx->v_in_use) {
			v_pc = ctx->cur_frame * 100;
			v_pc /= ctx->nb_frames;
		}

		if (ctx->video_done && (nb_done==count) ) {
			sprintf(szStatus, "100 %%");
			v_pc=100;
		}
		else if (count && ctx->v_in_use) {
			sprintf(szStatus, "V %d %% A %d %%", v_pc, a_pc);
			if (v_pc>a_pc) v_pc=a_pc;
		} else if (count) {
			sprintf(szStatus, "A %d %%", a_pc);
			v_pc = a_pc;
		} else {
			sprintf(szStatus, "V %d %%", v_pc);
		}
		gf_filter_update_status(filter, v_pc, szStatus);
	}
	if (ctx->video_done && (nb_done==count) ) {
		return GF_EOS;
	}
	if (!nb_active)
		return GF_OK;
	gf_filter_post_process_task(filter);
	return GF_OK;
}
