load_table(const uint8 **p_buf, const uint8 *buf_end, WASMTable *table,
           char *error_buf, uint32 error_buf_size)
{
    const uint8 *p = *p_buf, *p_end = buf_end, *p_org;

    CHECK_BUF(p, p_end, 1);
    /* 0x70 or 0x6F */
    table->elem_type = read_uint8(p);
    if (VALUE_TYPE_FUNCREF != table->elem_type
#if WASM_ENABLE_REF_TYPES != 0
        && VALUE_TYPE_EXTERNREF != table->elem_type
#endif
    ) {
        set_error_buf(error_buf, error_buf_size, "incompatible import type");
        return false;
    }

    p_org = p;
    read_leb_uint32(p, p_end, table->flags);
#if WASM_ENABLE_SHARED_MEMORY == 0
    if (p - p_org > 1) {
        set_error_buf(error_buf, error_buf_size,
                      "integer representation too long");
        return false;
    }
    if (table->flags > 1) {
        set_error_buf(error_buf, error_buf_size, "integer too large");
        return false;
    }
#else
    if (p - p_org > 1) {
        set_error_buf(error_buf, error_buf_size, "invalid limits flags");
        return false;
    }
    if (table->flags == 2) {
        set_error_buf(error_buf, error_buf_size, "tables cannot be shared");
        return false;
    }
    if (table->flags > 1) {
        set_error_buf(error_buf, error_buf_size, "invalid limits flags");
        return false;
    }
#endif

    read_leb_uint32(p, p_end, table->init_size);

    if (table->flags) {
        read_leb_uint32(p, p_end, table->max_size);
        if (!check_table_max_size(table->init_size, table->max_size, error_buf,
                                  error_buf_size))
            return false;
    }

    adjust_table_max_size(table->init_size, table->flags, &table->max_size);

    *p_buf = p;
    return true;
fail:
    return false;
}
