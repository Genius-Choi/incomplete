static int tcp_send_rst(struct pico_socket *s, struct pico_frame *fr)
{
    struct pico_socket_tcp *t = (struct pico_socket_tcp *) s;
    struct pico_tcp_hdr *hdr_rcv;
    int ret;

    if (fr && ((s->state & PICO_SOCKET_STATE_TCP) > PICO_SOCKET_STATE_TCP_SYN_RECV)) {
        /* in synchronized state: send RST with seq = ack from previous segment */
        hdr_rcv = (struct pico_tcp_hdr *) fr->transport_hdr;
        ret = tcp_do_send_rst(s, hdr_rcv->ack);
    } else {
        /* non-synchronized state */
        /* go to CLOSED here to prevent timer callback to go on after timeout */
        (t->sock).state &= 0x00FFU;
        (t->sock).state |= PICO_SOCKET_STATE_TCP_CLOSED;
        ret = tcp_do_send_rst(s, long_be(t->snd_nxt));

        /* Set generic socket state to CLOSED, too */
        (t->sock).state &= 0xFF00U;
        (t->sock).state |= PICO_SOCKET_STATE_CLOSED;

        /* call EV_FIN wakeup before deleting */
        if ((t->sock).wakeup)
            (t->sock).wakeup(PICO_SOCK_EV_FIN, &(t->sock));

        /* delete socket */
        pico_socket_del(&t->sock);
    }

    return ret;
}
