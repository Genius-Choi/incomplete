optional<MaskedIP> Condition::as_network(const string& s) {
  MaskedIP m;
  if (s.empty()) {
    return none;
  }

  m.v6 = s.find(':');
  auto slash = s.find('/');
  if (slash == string::npos) {
    m.prefix = m.v6 ? 128 : 32;
  } else {
    char* end = 0;
    m.prefix = strtoul(s.data() + slash + 1, &end, 10);
    if (*end != 0 || (m.v6 && m.prefix > 128) ||
	(!m.v6 && m.prefix > 32)) {
      return none;
    }
  }

  string t;
  auto p = &s;

  if (slash != string::npos) {
    t.assign(s, 0, slash);
    p = &t;
  }

  if (m.v6) {
    struct sockaddr_in6 a;
    if (inet_pton(AF_INET6, p->c_str(), static_cast<void*>(&a)) != 1) {
      return none;
    }

    m.addr |= Address(a.sin6_addr.s6_addr[0]) << 0;
    m.addr |= Address(a.sin6_addr.s6_addr[1]) << 8;
    m.addr |= Address(a.sin6_addr.s6_addr[2]) << 16;
    m.addr |= Address(a.sin6_addr.s6_addr[3]) << 24;
    m.addr |= Address(a.sin6_addr.s6_addr[4]) << 32;
    m.addr |= Address(a.sin6_addr.s6_addr[5]) << 40;
    m.addr |= Address(a.sin6_addr.s6_addr[6]) << 48;
    m.addr |= Address(a.sin6_addr.s6_addr[7]) << 56;
    m.addr |= Address(a.sin6_addr.s6_addr[8]) << 64;
    m.addr |= Address(a.sin6_addr.s6_addr[9]) << 72;
    m.addr |= Address(a.sin6_addr.s6_addr[10]) << 80;
    m.addr |= Address(a.sin6_addr.s6_addr[11]) << 88;
    m.addr |= Address(a.sin6_addr.s6_addr[12]) << 96;
    m.addr |= Address(a.sin6_addr.s6_addr[13]) << 104;
    m.addr |= Address(a.sin6_addr.s6_addr[14]) << 112;
    m.addr |= Address(a.sin6_addr.s6_addr[15]) << 120;
  } else {
    struct sockaddr_in a;
    if (inet_pton(AF_INET, p->c_str(), static_cast<void*>(&a)) != 1) {
      return none;
    }
    m.addr = ntohl(a.sin_addr.s_addr);
  }

  return none;
}
