mesh_serve_expired_lookup(struct module_qstate* qstate,
	struct query_info* lookup_qinfo)
{
	hashvalue_type h;
	struct lruhash_entry* e;
	struct dns_msg* msg;
	struct reply_info* data;
	struct msgreply_entry* key;
	time_t timenow = *qstate->env->now;
	int must_validate = (!(qstate->query_flags&BIT_CD)
		|| qstate->env->cfg->ignore_cd) && qstate->env->need_to_validate;
	/* Lookup cache */
	h = query_info_hash(lookup_qinfo, qstate->query_flags);
	e = slabhash_lookup(qstate->env->msg_cache, h, lookup_qinfo, 0);
	if(!e) return NULL;

	key = (struct msgreply_entry*)e->key;
	data = (struct reply_info*)e->data;
	msg = tomsg(qstate->env, &key->key, data, qstate->region, timenow,
		qstate->env->cfg->serve_expired, qstate->env->scratch);
	if(!msg)
		goto bail_out;

	/* Check CNAME chain (if any)
	 * This is part of tomsg above; no need to check now. */

	/* Check security status of the cached answer.
	 * tomsg above has a subset of these checks, so we are leaving
	 * these as is.
	 * In case of bogus or revalidation we don't care to reply here. */
	if(must_validate && (msg->rep->security == sec_status_bogus ||
		msg->rep->security == sec_status_secure_sentinel_fail)) {
		verbose(VERB_ALGO, "Serve expired: bogus answer found in cache");
		goto bail_out;
	} else if(msg->rep->security == sec_status_unchecked && must_validate) {
		verbose(VERB_ALGO, "Serve expired: unchecked entry needs "
			"validation");
		goto bail_out; /* need to validate cache entry first */
	} else if(msg->rep->security == sec_status_secure &&
		!reply_all_rrsets_secure(msg->rep) && must_validate) {
			verbose(VERB_ALGO, "Serve expired: secure entry"
				" changed status");
			goto bail_out; /* rrset changed, re-verify */
	}

	lock_rw_unlock(&e->lock);
	return msg;

bail_out:
	lock_rw_unlock(&e->lock);
	return NULL;
}
