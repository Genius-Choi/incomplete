main_loop(
    int		cmdwin,	    // TRUE when working in the command-line window
    int		noexmode)   // TRUE when return on entering Ex mode
{
    oparg_T	oa;		// operator arguments
    oparg_T	*prev_oap;	// operator arguments
    volatile int previous_got_int = FALSE;	// "got_int" was TRUE
#ifdef FEAT_CONCEAL
    // these are static to avoid a compiler warning
    static linenr_T	conceal_old_cursor_line = 0;
    static linenr_T	conceal_new_cursor_line = 0;
    static int		conceal_update_lines = FALSE;
#endif

    prev_oap = current_oap;
    current_oap = &oa;

#if defined(FEAT_X11) && defined(FEAT_XCLIPBOARD)
    // Setup to catch a terminating error from the X server.  Just ignore
    // it, restore the state and continue.  This might not always work
    // properly, but at least we don't exit unexpectedly when the X server
    // exits while Vim is running in a console.
    if (!cmdwin && !noexmode && SETJMP(x_jump_env))
    {
	State = MODE_NORMAL;
	VIsual_active = FALSE;
	got_int = TRUE;
	need_wait_return = FALSE;
	global_busy = FALSE;
	exmode_active = 0;
	skip_redraw = FALSE;
	RedrawingDisabled = 0;
	no_wait_return = 0;
	vgetc_busy = 0;
# ifdef FEAT_EVAL
	emsg_skip = 0;
# endif
	emsg_off = 0;
	setmouse();
	settmode(TMODE_RAW);
	starttermcap();
	scroll_start();
	redraw_later_clear();
    }
#endif

    clear_oparg(&oa);
    while (!cmdwin || cmdwin_result == 0)
    {
	if (stuff_empty())
	{
	    did_check_timestamps = FALSE;
	    if (need_check_timestamps)
		check_timestamps(FALSE);
	    if (need_wait_return)	// if wait_return() still needed ...
		wait_return(FALSE);	// ... call it now
	    if (need_start_insertmode && goto_im() && !VIsual_active)
	    {
		need_start_insertmode = FALSE;
		stuffReadbuff((char_u *)"i");	// start insert mode next
		// skip the fileinfo message now, because it would be shown
		// after insert mode finishes!
		need_fileinfo = FALSE;
	    }
	}

	// Reset "got_int" now that we got back to the main loop.  Except when
	// inside a ":g/pat/cmd" command, then the "got_int" needs to abort
	// the ":g" command.
	// For ":g/pat/vi" we reset "got_int" when used once.  When used
	// a second time we go back to Ex mode and abort the ":g" command.
	if (got_int)
	{
	    if (noexmode && global_busy && !exmode_active && previous_got_int)
	    {
		// Typed two CTRL-C in a row: go back to ex mode as if "Q" was
		// used and keep "got_int" set, so that it aborts ":g".
		exmode_active = EXMODE_NORMAL;
		State = MODE_NORMAL;
	    }
	    else if (!global_busy || !exmode_active)
	    {
		if (!quit_more)
		    (void)vgetc();		// flush all buffers
		got_int = FALSE;
	    }
	    previous_got_int = TRUE;
	}
	else
	    previous_got_int = FALSE;

#ifdef FEAT_EVAL
	// At the toplevel there is no exception handling.  Discard any that
	// may be hanging around (e.g. from "interrupt" at the debug prompt).
	if (did_throw && !ex_normal_busy)
	    discard_current_exception();
#endif

	if (!exmode_active)
	    msg_scroll = FALSE;
	quit_more = FALSE;

	// it's not safe unless may_trigger_safestate_main() is called
	was_safe = FALSE;

	/*
	 * If skip redraw is set (for ":" in wait_return()), don't redraw now.
	 * If there is nothing in the stuff_buffer or do_redraw is TRUE,
	 * update cursor and redraw.
	 */
	if (skip_redraw || exmode_active)
	{
	    skip_redraw = FALSE;
	    setcursor();
	    cursor_on();
	}
	else if (do_redraw || stuff_empty())
	{
#ifdef FEAT_GUI
	    // If ui_breakcheck() was used a resize may have been postponed.
	    gui_may_resize_shell();
#endif
#ifdef HAVE_DROP_FILE
	    // If files were dropped while text was locked or the curbuf was
	    // locked, this would be a good time to handle the drop.
	    handle_any_postponed_drop();
#endif
#ifdef FEAT_CONCEAL
	    if (curwin->w_p_cole == 0)
		conceal_update_lines = FALSE;
#endif

	    // Trigger CursorMoved if the cursor moved.
	    if (!finish_op && (has_cursormoved()
#ifdef FEAT_PROP_POPUP
				|| popup_visible
#endif
#ifdef FEAT_CONCEAL
				|| curwin->w_p_cole > 0
#endif
			      )
		    && !EQUAL_POS(last_cursormoved, curwin->w_cursor))
	    {
		if (has_cursormoved())
		    apply_autocmds(EVENT_CURSORMOVED, NULL, NULL,
							       FALSE, curbuf);
#ifdef FEAT_PROP_POPUP
		if (popup_visible)
		    popup_check_cursor_pos();
#endif
#ifdef FEAT_CONCEAL
		if (curwin->w_p_cole > 0)
		{
		    conceal_old_cursor_line = last_cursormoved.lnum;
		    conceal_new_cursor_line = curwin->w_cursor.lnum;
		    conceal_update_lines = TRUE;
		}
#endif
		last_cursormoved = curwin->w_cursor;
	    }

#if defined(FEAT_CONCEAL)
	    if (conceal_update_lines
		    && (conceal_old_cursor_line != conceal_new_cursor_line
			|| conceal_cursor_line(curwin)
			|| need_cursor_line_redraw))
	    {
		if (conceal_old_cursor_line != conceal_new_cursor_line
			&& conceal_old_cursor_line != 0
			&& conceal_old_cursor_line
						<= curbuf->b_ml.ml_line_count)
		    redrawWinline(curwin, conceal_old_cursor_line);
		redrawWinline(curwin, conceal_new_cursor_line);
		curwin->w_valid &= ~VALID_CROW;
		need_cursor_line_redraw = FALSE;
	    }
#endif

	    // Trigger TextChanged if b:changedtick differs.
	    if (!finish_op && has_textchanged()
		    && curbuf->b_last_changedtick != CHANGEDTICK(curbuf))
	    {
		apply_autocmds(EVENT_TEXTCHANGED, NULL, NULL, FALSE, curbuf);
		curbuf->b_last_changedtick = CHANGEDTICK(curbuf);
	    }

	    // Ensure curwin->w_topline and curwin->w_leftcol are up to date
	    // before triggering a WinScrolled autocommand.
	    update_topline();
	    validate_cursor();

	    if (!finish_op)
		may_trigger_win_scrolled_resized();

	    // If nothing is pending and we are going to wait for the user to
	    // type a character, trigger SafeState.
	    may_trigger_safestate(!op_pending() && restart_edit == 0);

#if defined(FEAT_DIFF)
	    // Updating diffs from changed() does not always work properly,
	    // esp. updating folds.  Do an update just before redrawing if
	    // needed.
	    if (curtab->tp_diff_update || curtab->tp_diff_invalid)
	    {
		ex_diffupdate(NULL);
		curtab->tp_diff_update = FALSE;
	    }

	    // Scroll-binding for diff mode may have been postponed until
	    // here.  Avoids doing it for every change.
	    if (diff_need_scrollbind)
	    {
		check_scrollbind((linenr_T)0, 0L);
		diff_need_scrollbind = FALSE;
	    }
#endif
#if defined(FEAT_FOLDING)
	    // Include a closed fold completely in the Visual area.
	    foldAdjustVisual();
#endif
#ifdef FEAT_FOLDING
	    /*
	     * When 'foldclose' is set, apply 'foldlevel' to folds that don't
	     * contain the cursor.
	     * When 'foldopen' is "all", open the fold(s) under the cursor.
	     * This may mark the window for redrawing.
	     */
	    if (hasAnyFolding(curwin) && !char_avail())
	    {
		foldCheckClose();
		if (fdo_flags & FDO_ALL)
		    foldOpenCursor();
	    }
#endif

	    // Before redrawing, make sure w_topline is correct, and w_leftcol
	    // if lines don't wrap, and w_skipcol if lines wrap.
	    update_topline();
	    validate_cursor();

	    if (VIsual_active)
		update_curbuf(UPD_INVERTED); // update inverted part
	    else if (must_redraw)
	    {
		mch_disable_flush();	// Stop issuing gui_mch_flush().
		update_screen(0);
		mch_enable_flush();
	    }
	    else if (redraw_cmdline || clear_cmdline || redraw_mode)
		showmode();
	    redraw_statuslines();
	    if (need_maketitle)
		maketitle();
#ifdef FEAT_VIMINFO
	    curbuf->b_last_used = vim_time();
#endif
	    // display message after redraw
	    if (keep_msg != NULL)
	    {
		char_u *p = vim_strsave(keep_msg);

		if (p != NULL)
		{
		    // msg_start() will set keep_msg to NULL, make a copy
		    // first.  Don't reset keep_msg, msg_attr_keep() uses it to
		    // check for duplicates.  Never put this message in
		    // history.
		    msg_hist_off = TRUE;
		    msg_attr((char *)p, keep_msg_attr);
		    msg_hist_off = FALSE;
		    vim_free(p);
		}
	    }
	    if (need_fileinfo)		// show file info after redraw
	    {
		fileinfo(FALSE, TRUE, FALSE);
		need_fileinfo = FALSE;
	    }

	    emsg_on_display = FALSE;	// can delete error message now
	    did_emsg = FALSE;
	    msg_didany = FALSE;		// reset lines_left in msg_start()
	    may_clear_sb_text();	// clear scroll-back text on next msg
	    showruler(FALSE);

	    setcursor();
	    cursor_on();

	    do_redraw = FALSE;

#ifdef STARTUPTIME
	    // Now that we have drawn the first screen all the startup stuff
	    // has been done, close any file for startup messages.
	    if (time_fd != NULL)
	    {
		TIME_MSG("first screen update");
		TIME_MSG("--- VIM STARTED ---");
		fclose(time_fd);
		time_fd = NULL;
	    }
#endif
	    // After the first screen update may start triggering WinScrolled
	    // autocmd events.  Store all the scroll positions and sizes now.
	    may_make_initial_scroll_size_snapshot();
	}
#ifdef FEAT_GUI
	if (need_mouse_correct)
	    gui_mouse_correct();
#endif

	// May request the keyboard protocol state now.
	may_send_t_RK();

	// Update w_curswant if w_set_curswant has been set.
	// Postponed until here to avoid computing w_virtcol too often.
	update_curswant();

#ifdef FEAT_EVAL
	/*
	 * May perform garbage collection when waiting for a character, but
	 * only at the very toplevel.  Otherwise we may be using a List or
	 * Dict internally somewhere.
	 * "may_garbage_collect" is reset in vgetc() which is invoked through
	 * do_exmode() and normal_cmd().
	 */
	may_garbage_collect = (!cmdwin && !noexmode);
#endif
	/*
	 * If we're invoked as ex, do a round of ex commands.
	 * Otherwise, get and execute a normal mode command.
	 */
	if (exmode_active)
	{
	    if (noexmode)   // End of ":global/path/visual" commands
		goto theend;
	    do_exmode(exmode_active == EXMODE_VIM);
	}
	else
	{
#ifdef FEAT_TERMINAL
	    if (term_use_loop()
		    && oa.op_type == OP_NOP && oa.regname == NUL
		    && !VIsual_active
		    && !skip_term_loop)
	    {
		// If terminal_loop() returns OK we got a key that is handled
		// in Normal model.  With FAIL we first need to position the
		// cursor and the screen needs to be redrawn.
		if (terminal_loop(TRUE) == OK)
		    normal_cmd(&oa, TRUE);
	    }
	    else
#endif
	    {
#ifdef FEAT_TERMINAL
		skip_term_loop = FALSE;
#endif
		normal_cmd(&oa, TRUE);
	    }
	}
    }

theend:
    current_oap = prev_oap;
}
