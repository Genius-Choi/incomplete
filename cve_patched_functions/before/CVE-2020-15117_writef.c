ProtocolUtil::writef(void* buffer, const char* fmt, va_list args)
{
    UInt8* dst = static_cast<UInt8*>(buffer);

    while (*fmt) {
        if (*fmt == '%') {
            // format specifier.  determine argument size.
            ++fmt;
            UInt32 len = eatLength(&fmt);
            switch (*fmt) {
            case 'i': {
                const UInt32 v = va_arg(args, UInt32);
                switch (len) {
                case 1:
                    // 1 byte integer
                    *dst++ = static_cast<UInt8>(v & 0xff);
                    break;

                case 2:
                    // 2 byte integer
                    *dst++ = static_cast<UInt8>((v >> 8) & 0xff);
                    *dst++ = static_cast<UInt8>( v       & 0xff);
                    break;

                case 4:
                    // 4 byte integer
                    *dst++ = static_cast<UInt8>((v >> 24) & 0xff);
                    *dst++ = static_cast<UInt8>((v >> 16) & 0xff);
                    *dst++ = static_cast<UInt8>((v >>  8) & 0xff);
                    *dst++ = static_cast<UInt8>( v        & 0xff);
                    break;

                default:
                    assert(0 && "invalid integer format length");
                    return;
                }
                break;
            }

            case 'I': {
                switch (len) {
                case 1: {
                    // 1 byte integers
                    const std::vector<UInt8>* list =
                        va_arg(args, const std::vector<UInt8>*);
                    const UInt32 n = (UInt32)list->size();
                    *dst++ = static_cast<UInt8>((n >> 24) & 0xff);
                    *dst++ = static_cast<UInt8>((n >> 16) & 0xff);
                    *dst++ = static_cast<UInt8>((n >>  8) & 0xff);
                    *dst++ = static_cast<UInt8>( n        & 0xff);
                    for (UInt32 i = 0; i < n; ++i) {
                        *dst++ = (*list)[i];
                    }
                    break;
                }

                case 2: {
                    // 2 byte integers
                    const std::vector<UInt16>* list =
                        va_arg(args, const std::vector<UInt16>*);
                    const UInt32 n = (UInt32)list->size();
                    *dst++ = static_cast<UInt8>((n >> 24) & 0xff);
                    *dst++ = static_cast<UInt8>((n >> 16) & 0xff);
                    *dst++ = static_cast<UInt8>((n >>  8) & 0xff);
                    *dst++ = static_cast<UInt8>( n        & 0xff);
                    for (UInt32 i = 0; i < n; ++i) {
                        const UInt16 v = (*list)[i];
                        *dst++ = static_cast<UInt8>((v >> 8) & 0xff);
                        *dst++ = static_cast<UInt8>( v       & 0xff);
                    }
                    break;
                }

                case 4: {
                    // 4 byte integers
                    const std::vector<UInt32>* list =
                        va_arg(args, const std::vector<UInt32>*);
                    const UInt32 n = (UInt32)list->size();
                    *dst++ = static_cast<UInt8>((n >> 24) & 0xff);
                    *dst++ = static_cast<UInt8>((n >> 16) & 0xff);
                    *dst++ = static_cast<UInt8>((n >>  8) & 0xff);
                    *dst++ = static_cast<UInt8>( n        & 0xff);
                    for (UInt32 i = 0; i < n; ++i) {
                        const UInt32 v = (*list)[i];
                        *dst++ = static_cast<UInt8>((v >> 24) & 0xff);
                        *dst++ = static_cast<UInt8>((v >> 16) & 0xff);
                        *dst++ = static_cast<UInt8>((v >>  8) & 0xff);
                        *dst++ = static_cast<UInt8>( v        & 0xff);
                    }
                    break;
                }

                default:
                    assert(0 && "invalid integer vector format length");
                    return;
                }
                break;
            }

            case 's': {
                assert(len == 0);
                const String* src = va_arg(args, String*);
                const UInt32 len = (src != NULL) ? (UInt32)src->size() : 0;
                *dst++ = static_cast<UInt8>((len >> 24) & 0xff);
                *dst++ = static_cast<UInt8>((len >> 16) & 0xff);
                *dst++ = static_cast<UInt8>((len >>  8) & 0xff);
                *dst++ = static_cast<UInt8>( len        & 0xff);
                if (len != 0) {
                    memcpy(dst, src->data(), len);
                    dst += len;
                }
                break;
            }

            case 'S': {
                assert(len == 0);
                const UInt32 len = va_arg(args, UInt32);
                const UInt8* src = va_arg(args, UInt8*);
                *dst++ = static_cast<UInt8>((len >> 24) & 0xff);
                *dst++ = static_cast<UInt8>((len >> 16) & 0xff);
                *dst++ = static_cast<UInt8>((len >>  8) & 0xff);
                *dst++ = static_cast<UInt8>( len        & 0xff);
                memcpy(dst, src, len);
                dst += len;
                break;
            }

            case '%':
                assert(len == 0);
                *dst++ = '%';
                break;

            default:
                assert(0 && "invalid format specifier");
            }

            // next format character
            ++fmt;
        }
        else {
            // copy regular character
            *dst++ = *fmt++;
        }
    }
}
