static pj_bool_t ssock_on_data_sent (pj_ssl_sock_t *ssock,
				     pj_ioqueue_op_key_t *send_key,
				     pj_ssize_t sent)
{
    write_data_t *wdata = (write_data_t*)send_key->user_data;
    pj_ioqueue_op_key_t *app_key = wdata->app_key;
    pj_ssize_t sent_len;

    sent_len = (sent > 0)? wdata->plain_data_len : sent;
    
    /* Update write buffer state */
    pj_lock_acquire(ssock->write_mutex);
    free_send_data(ssock, wdata);
    pj_lock_release(ssock->write_mutex);
    wdata = NULL;

    if (ssock->ssl_state == SSL_STATE_HANDSHAKING) {
	/* Initial handshaking */
	pj_status_t status;
	
	status = ssl_do_handshake(ssock);
	/* Not pending is either success or failed */
	if (status != PJ_EPENDING)
	    return on_handshake_complete(ssock, status);

    } else if (send_key != &ssock->handshake_op_key) {
	/* Some data has been sent, notify application */
	if (ssock->param.cb.on_data_sent) {
	    pj_bool_t ret;
	    ret = (*ssock->param.cb.on_data_sent)(ssock, app_key, 
						  sent_len);
	    if (!ret) {
		/* We've been destroyed */
		return PJ_FALSE;
	    }
	}
    } else {
	/* SSL re-negotiation is on-progress, just do nothing */
    }

    /* Send buffer has been updated, let's try to send any pending data */
    if (ssock->send_buf_pending.data_len) {
	pj_status_t status;
	status = flush_circ_buf_output(ssock, ssock->send_buf_pending.app_key,
				 ssock->send_buf_pending.plain_data_len,
				 ssock->send_buf_pending.flags);
	if (status == PJ_SUCCESS || status == PJ_EPENDING) {
	    ssock->send_buf_pending.data_len = 0;
	}
    }

    return PJ_TRUE;
}
