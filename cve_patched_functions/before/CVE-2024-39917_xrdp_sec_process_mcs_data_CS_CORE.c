xrdp_sec_process_mcs_data_CS_CORE(struct xrdp_sec *self, struct stream *s)
{
#define CS_CORE_MIN_LENGTH \
    (\
     4 +            /* Version */ \
     2 + 2 +        /* desktopWidth + desktopHeight */ \
     2 + 2 +        /* colorDepth + SASSequence */ \
     4 +            /* keyboardLayout */ \
     4 + INFO_CLIENT_NAME_BYTES + /* clientBuild + clientName */ \
     4 + 4 + 4 +    /* keyboardType + keyboardSubType + keyboardFunctionKey */ \
     64 +           /* imeFileName */ \
     0)

    int version;
    int colorDepth;
    int postBeta2ColorDepth;
    int highColorDepth;
    int supportedColorDepths;
    int earlyCapabilityFlags;
    char clientName[INFO_CLIENT_NAME_BYTES / 2] = { '\0' };

    UNUSED_VAR(version);
    struct xrdp_client_info *client_info = &self->rdp_layer->client_info;
    /* Clear physical sizes. These are optional and may not be read later */
    client_info->session_physical_width = 0;
    client_info->session_physical_height = 0;

    /* TS_UD_CS_CORE required fields */
    if (!s_check_rem_and_log(s, CS_CORE_MIN_LENGTH,
                             "Parsing [MS-RDPBCGR] TS_UD_CS_CORE"))
    {
        return 1;
    }
    in_uint32_le(s, version);
    in_uint16_le(s, client_info->display_sizes.session_width);
    in_uint16_le(s, client_info->display_sizes.session_height);
    in_uint16_le(s, colorDepth);
    switch (colorDepth)
    {
        case RNS_UD_COLOR_4BPP:
            client_info->bpp = 4;
            break;
        case RNS_UD_COLOR_8BPP:
            client_info->bpp = 8;
            break;
    }
    in_uint8s(s, 2); /* SASSequence */
    in_uint8s(s, 4); /* keyboardLayout */
    in_uint8s(s, 4); /* clientBuild */

    /* clientName
     *
     * This should be null-terminated. Allow for the possibility it
     * isn't by ignoring the last two bytes and treating them as a
     * terminator anyway */
    in_utf16_le_fixed_as_utf8(s, (INFO_CLIENT_NAME_BYTES - 2) / 2,
                              clientName, sizeof(clientName));
    in_uint8s(s, 2); /* See above */
    LOG(LOG_LEVEL_INFO, "Connected client computer name: %s", clientName);
    in_uint8s(s, 4); /* keyboardType */
    in_uint8s(s, 4); /* keyboardSubType */
    in_uint8s(s, 4); /* keyboardFunctionKey */
    in_uint8s(s, 64); /* imeFileName */
    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_UD_CS_CORE "
              "<Required fields> version %08x, desktopWidth %d, "
              "desktopHeight %d, colorDepth %s, SASSequence (ignored), "
              "keyboardLayout (ignored), clientBuild (ignored), "
              "clientName %s, keyboardType (ignored), "
              "keyboardSubType (ignored), keyboardFunctionKey (ignored), "
              "imeFileName (ignored)",
              version,
              client_info->display_sizes.session_width,
              client_info->display_sizes.session_height,
              (colorDepth == 0xca00 ? "RNS_UD_COLOR_4BPP" :
               colorDepth == 0xca01 ? "RNS_UD_COLOR_8BPP" : "unknown"),
              clientName);

    /* TS_UD_CS_CORE optional fields */
    if (!s_check_rem(s, 2))
    {
        return 0;
    }
    in_uint16_le(s, postBeta2ColorDepth);
    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_UD_CS_CORE "
              "<Optional Field> postBeta2ColorDepth %s",
              postBeta2ColorDepth == 0xca00 ? "RNS_UD_COLOR_4BPP" :
              postBeta2ColorDepth == 0xca01 ? "RNS_UD_COLOR_8BPP" :
              postBeta2ColorDepth == 0xca02 ? "RNS_UD_COLOR_16BPP_555" :
              postBeta2ColorDepth == 0xca03 ? "RNS_UD_COLOR_16BPP_565" :
              postBeta2ColorDepth == 0xca04 ? "RNS_UD_COLOR_24BPP" :
              "unknown");

    switch (postBeta2ColorDepth)
    {
        case RNS_UD_COLOR_4BPP:
            client_info->bpp = 4;
            break;
        case RNS_UD_COLOR_8BPP :
            client_info->bpp = 8;
            break;
        case RNS_UD_COLOR_16BPP_555:
            client_info->bpp = 15;
            break;
        case RNS_UD_COLOR_16BPP_565:
            client_info->bpp = 16;
            break;
        case RNS_UD_COLOR_24BPP:
            client_info->bpp = 24;
            break;
    }
    if (!s_check_rem(s, 2))
    {
        return 0;
    }
    in_uint8s(s, 2); /* clientProductId */
    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_UD_CS_CORE "
              "<Optional Field> clientProductId (ignored)");

    if (!s_check_rem(s, 4))
    {
        return 0;
    }
    in_uint8s(s, 4); /* serialNumber */
    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_UD_CS_CORE "
              "<Optional Field> serialNumber (ignored)");

    if (!s_check_rem(s, 2))
    {
        return 0;
    }
    in_uint16_le(s, highColorDepth);
    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_UD_CS_CORE "
              "<Optional Field> highColorDepth %s",
              highColorDepth == 0x0004 ? "HIGH_COLOR_4BPP" :
              highColorDepth == 0x0008 ? "HIGH_COLOR_8BPP" :
              highColorDepth == 0x000F ? "HIGH_COLOR_15BPP" :
              highColorDepth == 0x0010 ? "HIGH_COLOR_16BPP" :
              highColorDepth == 0x0018 ? "HIGH_COLOR_24BPP" :
              "unknown");
    client_info->bpp = highColorDepth;

    if (!s_check_rem(s, 2))
    {
        return 0;
    }
    in_uint16_le(s, supportedColorDepths);
    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_UD_CS_CORE "
              "<Optional Field> supportedColorDepths %s",
              supportedColorDepths == RNS_UD_24BPP_SUPPORT
              ? "RNS_UD_24BPP_SUPPORT" :
              supportedColorDepths == RNS_UD_16BPP_SUPPORT
              ? "RNS_UD_16BPP_SUPPORT" :
              supportedColorDepths == RNS_UD_15BPP_SUPPORT
              ? "RNS_UD_15BPP_SUPPORT" :
              supportedColorDepths == RNS_UD_32BPP_SUPPORT
              ? "RNS_UD_32BPP_SUPPORT" :
              "unknown");

    if (!s_check_rem(s, 2))
    {
        return 0;
    }
    in_uint16_le(s, earlyCapabilityFlags);
    client_info->mcs_early_capability_flags = earlyCapabilityFlags;
    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_UD_CS_CORE "
              "<Optional Field> earlyCapabilityFlags 0x%4.4x",
              earlyCapabilityFlags);
    if ((earlyCapabilityFlags & RNS_UD_CS_WANT_32BPP_SESSION)
            && (supportedColorDepths & RNS_UD_32BPP_SUPPORT))
    {
        client_info->bpp = 32;
    }
#ifdef XRDP_RFXCODEC
    if (earlyCapabilityFlags & RNS_UD_CS_SUPPORT_DYNVC_GFX_PROTOCOL)
    {
        if (client_info->bpp < 32)
        {
            LOG(LOG_LEVEL_WARNING,
                "client requested gfx protocol with insufficient color depth");
        }
        else if (client_info->max_bpp > 0 && client_info->max_bpp < 32)
        {
            LOG(LOG_LEVEL_WARNING, "Client requested gfx protocol "
                "but the server configuration is limited to %d bpp.",
                client_info->max_bpp);
        }
        else
        {
            LOG(LOG_LEVEL_INFO, "client supports gfx protocol");
            self->rdp_layer->client_info.gfx = 1;
        }
    }
    else
    {
        LOG_DEVEL(LOG_LEVEL_INFO, "client DOES NOT support gfx");
    }
#endif
    if (!s_check_rem(s, 64))
    {
        return 0;
    }
    in_uint8s(s, 64); /* clientDigProductId */
    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_UD_CS_CORE "
              "<Optional Field> clientDigProductId (ignored)");

    if (!s_check_rem(s, 1))
    {
        return 0;
    }
    in_uint8(s, client_info->mcs_connection_type); /* connectionType */
    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_UD_CS_CORE "
              "<Optional Field> connectionType 0x%2.2x",
              client_info->mcs_connection_type);

    if (!s_check_rem(s, 1))
    {
        return 0;
    }
    in_uint8s(s, 1); /* pad1octet */
    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_UD_CS_CORE "
              "<Optional Field> pad1octet (ignored)");

    if (!s_check_rem(s, 4))
    {
        return 0;
    }
    in_uint8s(s, 4); /* serverSelectedProtocol */
    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_UD_CS_CORE "
              "<Optional Field> serverSelectedProtocol (ignored)");

    /*
     * Non-zero values for the desktop physical width and height values
     * are only sent if the client has a single monitor. For multiple
     * monitors, the physical size of each monitor is sent in the
     * TS_UD_CS_MONITOR_EX PDU */
    if (!s_check_rem(s, 4))
    {
        return 0;
    }
    in_uint32_le(s, client_info->session_physical_width);
    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_UD_CS_CORE "
              "<Optional Field> desktopPhysicalWidth %u",
              client_info->session_physical_width);

    if (!s_check_rem(s, 4))
    {
        client_info->session_physical_width = 0;
        return 0;
    }
    in_uint32_le(s, client_info->session_physical_height);
    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_UD_CS_CORE "
              "<Optional Field> desktopPhysicalHeight %u",
              client_info->session_physical_height);

    /* MS-RDPBCGR 2.2.1.3.2 */
    if (client_info->session_physical_width < 10 ||
            client_info->session_physical_width > 10000 ||
            client_info->session_physical_height < 10 ||
            client_info->session_physical_height > 10000)
    {
        LOG(LOG_LEVEL_WARNING,
            "Physical desktop dimensions (%ux%u) are invalid",
            client_info->session_physical_width,
            client_info->session_physical_height);
        client_info->session_physical_width = 0;
        client_info->session_physical_height = 0;
    }
    if (!s_check_rem(s, 2))
    {
        return 0;
    }
    in_uint8s(s, 2); /* reserved */
    LOG_DEVEL(LOG_LEVEL_TRACE, "Received [MS-RDPBCGR] TS_UD_CS_CORE "
              "<Optional Field> desktopOrientation (ignored)");

    return 0;
#undef CS_CORE_MIN_LENGTH
}
