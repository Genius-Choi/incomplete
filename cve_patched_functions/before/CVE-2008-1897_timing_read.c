static int timing_read(int *id, int fd, short events, void *cbdata)
{
	char buf[1024];
	int res, processed = 0, totalcalls = 0;
	struct iax2_trunk_peer *tpeer = NULL, *drop = NULL;
#ifdef ZT_TIMERACK
	int x = 1;
#endif
	struct timeval now = ast_tvnow();
	if (iaxtrunkdebug)
		ast_verbose("Beginning trunk processing. Trunk queue ceiling is %d bytes per host\n", trunkmaxsize);
	if (events & AST_IO_PRI) {
#ifdef ZT_TIMERACK
		/* Great, this is a timing interface, just call the ioctl */
		if (ioctl(fd, ZT_TIMERACK, &x)) {
			ast_log(LOG_WARNING, "Unable to acknowledge zap timer. IAX trunking will fail!\n");
			usleep(1);
			return -1;
		}
#endif		
	} else {
		/* Read and ignore from the pseudo channel for timing */
		res = read(fd, buf, sizeof(buf));
		if (res < 1) {
			ast_log(LOG_WARNING, "Unable to read from timing fd\n");
			return 1;
		}
	}
	/* For each peer that supports trunking... */
	AST_LIST_LOCK(&tpeers);
	AST_LIST_TRAVERSE_SAFE_BEGIN(&tpeers, tpeer, list) {
		processed++;
		res = 0;
		ast_mutex_lock(&tpeer->lock);
		/* We can drop a single tpeer per pass.  That makes all this logic
		   substantially easier */
		if (!drop && iax2_trunk_expired(tpeer, &now)) {
			/* Take it out of the list, but don't free it yet, because it
			   could be in use */
			AST_LIST_REMOVE_CURRENT(list);
			drop = tpeer;
		} else {
			res = send_trunk(tpeer, &now);
			trunk_timed++; 
			if (iaxtrunkdebug)
				ast_verbose(" - Trunk peer (%s:%d) has %d call chunk%s in transit, %d bytes backloged and has hit a high water mark of %d bytes\n", ast_inet_ntoa(tpeer->addr.sin_addr), ntohs(tpeer->addr.sin_port), res, (res != 1) ? "s" : "", tpeer->trunkdatalen, tpeer->trunkdataalloc);
		}		
		totalcalls += res;	
		res = 0;
		ast_mutex_unlock(&tpeer->lock);
	}
	AST_LIST_TRAVERSE_SAFE_END;
	AST_LIST_UNLOCK(&tpeers);

	if (drop) {
		ast_mutex_lock(&drop->lock);
		/* Once we have this lock, we're sure nobody else is using it or could use it once we release it, 
		   because by the time they could get tpeerlock, we've already grabbed it */
		ast_debug(1, "Dropping unused iax2 trunk peer '%s:%d'\n", ast_inet_ntoa(drop->addr.sin_addr), ntohs(drop->addr.sin_port));
		if (drop->trunkdata) {
			ast_free(drop->trunkdata);
			drop->trunkdata = NULL;
		}
		ast_mutex_unlock(&drop->lock);
		ast_mutex_destroy(&drop->lock);
		ast_free(drop);
		
	}

	if (iaxtrunkdebug)
		ast_verbose("Ending trunk processing with %d peers and %d call chunks processed\n", processed, totalcalls);
	iaxtrunkdebug = 0;

	return 1;
}
