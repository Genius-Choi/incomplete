static pj_status_t and_media_default_attr (pjmedia_codec_factory *factory,
					   const pjmedia_codec_info *id,
					   pjmedia_codec_param *attr)
{
    unsigned i;

    PJ_ASSERT_RETURN(factory==&and_media_factory.base, PJ_EINVAL);

    pj_bzero(attr, sizeof(pjmedia_codec_param));

    for (i = 0; i < PJ_ARRAY_SIZE(and_media_codec); ++i) {
	pj_str_t name = pj_str((char*)and_media_codec[i].name);
	if ((and_media_codec[i].enabled) &&
	    (pj_stricmp(&id->encoding_name, &name) == 0) &&
	    (id->clock_rate == (unsigned)and_media_codec[i].clock_rate) &&
	    (id->channel_cnt == (unsigned)and_media_codec[i].channel_count) &&
	    (id->pt == (unsigned)and_media_codec[i].pt))
	{
	    attr->info.pt = (pj_uint8_t)id->pt;
	    attr->info.channel_cnt = and_media_codec[i].channel_count;
	    attr->info.clock_rate = and_media_codec[i].clock_rate;
	    attr->info.avg_bps = and_media_codec[i].def_bitrate;
	    attr->info.max_bps = and_media_codec[i].max_bitrate;
	    attr->info.pcm_bits_per_sample = 16;
	    attr->info.frm_ptime =  (pj_uint16_t)
				(and_media_codec[i].samples_per_frame * 1000 /
				and_media_codec[i].channel_count /
				and_media_codec[i].clock_rate);
	    attr->setting.frm_per_pkt = and_media_codec[i].frm_per_pkt;

	    /* Default flags. */
	    attr->setting.plc = 1;
	    attr->setting.penh= 0;
	    attr->setting.vad = 1;
	    attr->setting.cng = attr->setting.vad;
	    attr->setting.dec_fmtp = and_media_codec[i].dec_fmtp;

	    return PJ_SUCCESS;
	}
    }

    return PJMEDIA_CODEC_EUNSUP;
}
