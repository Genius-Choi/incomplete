static void die_on_index_match(const char *path, int force)
{
	struct pathspec ps;
	const char *args[] = { path, NULL };
	parse_pathspec(&ps, 0, PATHSPEC_PREFER_CWD, NULL, args);

	if (repo_read_index_preload(the_repository, NULL, 0) < 0)
		die(_("index file corrupt"));

	if (ps.nr) {
		int i;
		char *ps_matched = xcalloc(ps.nr, 1);

		/* TODO: audit for interaction with sparse-index. */
		ensure_full_index(&the_index);

		/*
		 * Since there is only one pathspec, we just need
		 * need to check ps_matched[0] to know if a cache
		 * entry matched.
		 */
		for (i = 0; i < the_index.cache_nr; i++) {
			ce_path_match(&the_index, the_index.cache[i], &ps,
				      ps_matched);

			if (ps_matched[0]) {
				if (!force)
					die(_("'%s' already exists in the index"),
					    path);
				if (!S_ISGITLINK(the_index.cache[i]->ce_mode))
					die(_("'%s' already exists in the index "
					      "and is not a submodule"), path);
				break;
			}
		}
		free(ps_matched);
	}
	clear_pathspec(&ps);
}
