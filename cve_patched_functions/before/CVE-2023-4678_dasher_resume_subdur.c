static void dasher_resume_subdur(GF_Filter *filter, GF_DasherCtx *ctx)
{
	GF_FilterEvent evt;
	u32 i, count;
	Bool is_last = (ctx->dmode == GF_MPD_TYPE_DYNAMIC_LAST) ? GF_TRUE : GF_FALSE;
	if (!ctx->state) return;

	count = gf_list_count(ctx->pids);
	for (i=0; i<count; i++) {
		GF_DashStream *ds = gf_list_get(ctx->pids, i);
		ds->rep = NULL;
		if ((ds->done==1) && !ctx->subdur && ctx->loop) {}
		else if (ds->reschedule) {
			//we possibly dispatched end of stream on all outputs, we need to force unblockink to get called again
			gf_filter_pid_discard_block(ds->opid);
			continue;
		}
		else if (ds->done != 2) continue;

		if (is_last) continue;

		gf_filter_pid_set_discard(ds->ipid, GF_FALSE);

		//send stop and play
		GF_FEVT_INIT(evt, GF_FEVT_STOP, ds->ipid);
		gf_filter_pid_send_event(ds->ipid, &evt);

		dasher_send_encode_hints(ctx, ds);
		GF_FEVT_INIT(evt, GF_FEVT_PLAY, ds->ipid);
		evt.play.speed = 1.0;
		if (!ctx->subdur || !ctx->loop) {
			ds->seek_to_pck = 0;
		} else {
			//request start after the last packet we processed
			evt.play.from_pck = (u32) ds->seek_to_pck+1;
		}
		gf_filter_pid_send_event(ds->ipid, &evt);

		//full stream looping
		if (ds->subdur_done && !ctx->subdur) {
			ds->loop_state = 0;
			//mark as subdur done to force a context reload through period switch
			ds->done = 2;
			ds->seg_done = GF_FALSE;
			ds->subdur_done = GF_FALSE;
		}
	}

	ctx->subdur_done = GF_FALSE;
	ctx->is_eos = GF_FALSE;
	if (!ctx->post_play_events && !is_last) {
		ctx->current_period->period = NULL;
		ctx->first_context_load = GF_TRUE;
		ctx->post_play_events = GF_TRUE;
	}
	gf_filter_post_process_task(filter);
}
