void LibRaw::crxLoadRaw()
{
  CrxImage img;
  if (libraw_internal_data.unpacker_data.crx_track_selected < 0 ||
      libraw_internal_data.unpacker_data.crx_track_selected >=
          LIBRAW_CRXTRACKS_MAXCOUNT)
    derror();
  crx_data_header_t hdr =
      libraw_internal_data.unpacker_data
          .crx_header[libraw_internal_data.unpacker_data.crx_track_selected];

  img.input = libraw_internal_data.internal_data.input;

  // update sizes for the planes
  if (hdr.nPlanes == 4)
  {
    hdr.f_width >>= 1;
    hdr.f_height >>= 1;
    hdr.tileWidth >>= 1;
    hdr.tileHeight >>= 1;
  }

  imgdata.color.maximum = (1 << hdr.nBits) - 1;

  uint8_t *hdrBuf = (uint8_t *)malloc(hdr.mdatHdrSize);

  // read image header
#ifdef LIBRAW_USE_OPENMP
#pragma omp critical
#endif
  {
#ifndef LIBRAW_USE_OPENMP
    libraw_internal_data.internal_data.input->lock();
#endif
    libraw_internal_data.internal_data.input->seek(
        libraw_internal_data.unpacker_data.data_offset, SEEK_SET);
    libraw_internal_data.internal_data.input->read(hdrBuf, 1, hdr.mdatHdrSize);
#ifndef LIBRAW_USE_OPENMP
    libraw_internal_data.internal_data.input->unlock();
#endif
  }

  // parse and setup the image data
  if (crxSetupImageData(&hdr, &img, (int16_t *)imgdata.rawdata.raw_image,
                        libraw_internal_data.unpacker_data.data_offset,
                        libraw_internal_data.unpacker_data.data_size, hdrBuf))
    derror();
  free(hdrBuf);

  crxLoadDecodeLoop(&img, hdr.nPlanes);

  if (img.encType == 3)
    crxLoadFinalizeLoopE3(&img, img.planeHeight);

  crxFreeImageData(&img);
}
