gda_web_provider_statement_execute (GdaServerProvider *provider, GdaConnection *cnc,
				    GdaStatement *stmt, GdaSet *params,
				    GdaStatementModelUsage model_usage, 
				    GType *col_types, GdaSet **last_inserted_row, GError **error)
{
	GdaWebPStmt *ps;
	WebConnectionData *cdata;
	gboolean allow_noparam;
        gboolean empty_rs = FALSE; /* TRUE when @allow_noparam is TRUE and there is a problem with @params
                                      => resulting data model will be empty (0 row) */

	g_return_val_if_fail (GDA_IS_CONNECTION (cnc), NULL);
	g_return_val_if_fail (gda_connection_get_provider (cnc) == provider, NULL);
	g_return_val_if_fail (GDA_IS_STATEMENT (stmt), NULL);

        allow_noparam = (model_usage & GDA_STATEMENT_MODEL_ALLOW_NOPARAM) &&
                (gda_statement_get_statement_type (stmt) == GDA_SQL_STATEMENT_SELECT);
	
        if (last_inserted_row)
                *last_inserted_row = NULL;

	/* Get private data */
	cdata = (WebConnectionData*) gda_connection_internal_get_provider_data_error (cnc, error);
	if (!cdata) 
		return NULL;


	/* get/create new prepared statement */
	ps = (GdaWebPStmt *) gda_connection_get_prepared_statement (cnc, stmt);
	if (!ps) {
		if (!gda_web_provider_statement_prepare (provider, cnc, stmt, error)) {
			/* this case can appear for example if some variables are used in places
			 * where the C API cannot allow them (for example if the variable is the table name
			 * in a SELECT statement). The action here is to get the actual SQL code for @stmt,
			 * and use that SQL instead of @stmt to create another GdaWebPStmt object.
			 *
			 * Don't call gda_connection_add_prepared_statement() with this new prepared statement
			 * as it will be destroyed once used.
			 */
			return NULL;
		}
		else {
			ps = (GdaWebPStmt *) gda_connection_get_prepared_statement (cnc, stmt);
			g_object_ref (ps);
		}
	}
	else
		g_object_ref (ps);
	g_assert (ps);

	/* prepare XML command */
	xmlDocPtr doc;
	xmlNodePtr root, cmdnode, node;
	gchar *token;
	doc = xmlNewDoc (BAD_CAST "1.0");
	root = xmlNewNode (NULL, BAD_CAST "request");
	xmlDocSetRootElement (doc, root);
	token = _gda_web_compute_token (cdata);
	xmlNewChild (root, NULL, BAD_CAST "token", BAD_CAST token);
	g_free (token);
	cmdnode = xmlNewChild (root, NULL, BAD_CAST "cmd", BAD_CAST "EXEC");
	node = xmlNewTextChild (cmdnode, NULL, BAD_CAST "sql", BAD_CAST gda_pstmt_get_sql (_GDA_PSTMT (ps)));
	if ((gda_statement_get_statement_type (stmt) == GDA_SQL_STATEMENT_SELECT) ||
	    (gda_statement_get_statement_type (stmt) == GDA_SQL_STATEMENT_COMPOUND))
		xmlSetProp (node, BAD_CAST "type", BAD_CAST "SELECT");
	else if (gda_statement_get_statement_type (stmt) == GDA_SQL_STATEMENT_UNKNOWN) {
		if (! g_ascii_strncasecmp (gda_pstmt_get_sql (_GDA_PSTMT (ps)), "select", 6) ||
		    ! g_ascii_strncasecmp (gda_pstmt_get_sql (_GDA_PSTMT (ps)), "pragma", 6) ||
		    ! g_ascii_strncasecmp (gda_pstmt_get_sql (_GDA_PSTMT (ps)), "show", 4) ||
		    ! g_ascii_strncasecmp (gda_pstmt_get_sql (_GDA_PSTMT (ps)), "describe", 8))
			xmlSetProp (node, BAD_CAST "type", BAD_CAST "SELECT");
	}
	xmlNewChild (cmdnode, NULL, BAD_CAST "preparehash", BAD_CAST (gda_web_pstmt_get_pstmt_hash (ps)));

	/* bind statement's parameters */
	GSList *list;
	GdaConnectionEvent *event = NULL;
	int i;
	xmlNodePtr argsnode;
	if (gda_pstmt_get_param_ids (_GDA_PSTMT (ps)))
		argsnode = xmlNewChild (cmdnode, NULL, BAD_CAST "arguments", NULL);

	for (i = 1, list = gda_pstmt_get_param_ids (_GDA_PSTMT (ps)); list; list = list->next, i++) {
		const gchar *pname = (gchar *) list->data;
		GdaHolder *h;
		
		/* find requested parameter */
		if (!params) {
			event = gda_connection_point_available_event (cnc, GDA_CONNECTION_EVENT_ERROR);
			gda_connection_event_set_description (event, _("Missing parameter(s) to execute query"));
			g_set_error (error, GDA_SERVER_PROVIDER_ERROR,
				     GDA_SERVER_PROVIDER_MISSING_PARAM_ERROR,
				     "%s", _("Missing parameter(s) to execute query"));
			break;
		}

		h = gda_set_get_holder (params, pname);
		if (!h) {
			gchar *tmp = gda_alphanum_to_text (g_strdup (pname + 1));
			if (tmp) {
				h = gda_set_get_holder (params, tmp);
				g_free (tmp);
			}
		}
		if (!h) {
			if (allow_noparam) {
                                /* bind param to NULL */
				node = xmlNewChild (argsnode, NULL, BAD_CAST "arg", NULL);
				xmlSetProp (node, BAD_CAST "type", BAD_CAST "NULL");
                                empty_rs = TRUE;
                                continue;
			}
			else {

				gchar *str;
				str = g_strdup_printf (_("Missing parameter '%s' to execute query"), pname);
				event = gda_connection_point_available_event (cnc, GDA_CONNECTION_EVENT_ERROR);
				gda_connection_event_set_description (event, str);
				g_set_error (error, GDA_SERVER_PROVIDER_ERROR,
					     GDA_SERVER_PROVIDER_MISSING_PARAM_ERROR, "%s", str);
				g_free (str);
				break;
                        }
		}
		if (!gda_holder_is_valid (h)) {
			if (allow_noparam) {
                                /* bind param to NULL */
				xmlSetProp (node, BAD_CAST "type", BAD_CAST "NULL");
                                empty_rs = TRUE;
                                continue;
			}
			else {
				gchar *str;
				str = g_strdup_printf (_("Parameter '%s' is invalid"), pname);
				event = gda_connection_point_available_event (cnc, GDA_CONNECTION_EVENT_ERROR);
				gda_connection_event_set_description (event, str);
				g_set_error (error, GDA_SERVER_PROVIDER_ERROR,
					     GDA_SERVER_PROVIDER_MISSING_PARAM_ERROR, "%s", str);
				g_free (str);
				break;
                        }
		}
		else if (gda_holder_value_is_default (h) && !gda_holder_get_value (h)) {
			/* create a new GdaStatement to handle all default values and execute it instead
			 * needs to be adapted to take into account how the database server handles default
			 * values (some accept the DEFAULT keyword), changing the 3rd argument of the
			 * gda_statement_rewrite_for_default_values() call
			 */
			GdaSqlStatement *sqlst;
			GError *lerror = NULL;
			sqlst = gda_statement_rewrite_for_default_values (stmt, params, TRUE, &lerror);
			if (!sqlst) {
				event = gda_connection_point_available_event (cnc,
									      GDA_CONNECTION_EVENT_ERROR);
				gda_connection_event_set_description (event, lerror && lerror->message ? 
								      lerror->message :
								      _("Can't rewrite statement handle default values"));
				g_propagate_error (error, lerror);
				break;
			}
			
			GdaStatement *rstmt;
			GObject *res;
			rstmt = g_object_new (GDA_TYPE_STATEMENT, "structure", sqlst, NULL);
			gda_sql_statement_free (sqlst);
			g_object_unref (ps);
			xmlFreeDoc (doc);
			res = gda_web_provider_statement_execute (provider, cnc,
								  rstmt, params,
								  model_usage,
								  col_types, last_inserted_row, error);
			g_object_unref (rstmt);
			return res;
		}

		/* actual binding using the C API, for parameter at position @i */
		const GValue *value = gda_holder_get_value (h);
		if (!value || gda_value_is_null (value)) {
			GdaStatement *rstmt;
			if (! gda_rewrite_statement_for_null_parameters (stmt, params, &rstmt, error)) {
				gchar *tmp;
				tmp = gda_value_stringify (value);
				node = xmlNewTextChild (argsnode, NULL, BAD_CAST "arg", BAD_CAST tmp);
				g_free (tmp);
				xmlSetProp (node, BAD_CAST "type",
					    BAD_CAST gtype_to_webtype (gda_holder_get_g_type (h)));
			}
			else if (!rstmt)
				return NULL;
			else {
				xmlFreeDoc (doc);

				/* The strategy here is to execute @rstmt using its prepared
				 * statement, but with common data from @ps. Beware that
				 * the @param_ids attribute needs to be retained (i.e. it must not
				 * be the one copied from @ps) */
				GObject *obj;
				GdaWebPStmt *tps;
				GdaPStmt *gtps;
				GSList *prep_param_ids, *copied_param_ids;
				if (!gda_web_provider_statement_prepare (provider, cnc,
									 rstmt, error))
					return NULL;
				tps = (GdaWebPStmt *)
					gda_connection_get_prepared_statement (cnc, rstmt);
				gtps = (GdaPStmt *) tps;

				/* keep @param_ids to avoid being cleared by gda_pstmt_copy_contents() */
				prep_param_ids = gda_pstmt_get_param_ids (_GDA_PSTMT (gtps));
				gda_pstmt_set_param_ids (_GDA_PSTMT (gtps), NULL);
				
				/* actual copy */
				gda_pstmt_copy_contents ((GdaPStmt *) ps, (GdaPStmt *) tps);

				/* restore previous @param_ids */
				copied_param_ids = gda_pstmt_get_param_ids (_GDA_PSTMT (gtps));
				gda_pstmt_set_param_ids (_GDA_PSTMT (gtps), prep_param_ids);

				/* execute */
				obj = gda_web_provider_statement_execute (provider, cnc,
									  rstmt, params,
									  model_usage,
									  col_types,
									  last_inserted_row, error);
				/* clear original @param_ids and restore copied one */
				g_slist_free_full (prep_param_ids, (GDestroyNotify) g_free);

				gda_pstmt_set_param_ids (gtps, copied_param_ids);

				/*if (GDA_IS_DATA_MODEL (obj))
				  gda_data_model_dump ((GdaDataModel*) obj, NULL);*/

				g_object_unref (rstmt);
				g_object_unref (ps);
				return obj;
			}
		}
		else {
			gchar *tmp;
			tmp = gda_value_stringify (value);
			node = xmlNewTextChild (argsnode, NULL, BAD_CAST "arg", BAD_CAST tmp);
			g_free (tmp);
			xmlSetProp (node, BAD_CAST "type",
				    BAD_CAST gtype_to_webtype (gda_holder_get_g_type (h)));
		}
	}
		
	if (event) {
		gda_connection_add_event (cnc, event);
		g_object_unref (ps);
		xmlFreeDoc (doc);
		return NULL;
	}
	
	/* add a connection event for the execution */
	event = gda_connection_point_available_event (cnc, GDA_CONNECTION_EVENT_COMMAND);
        gda_connection_event_set_description (event, gda_pstmt_get_sql (_GDA_PSTMT (ps)));
        gda_connection_add_event (cnc, event);

	if (empty_rs) {
		/* There are some missing parameters, so the SQL can't be executed but we still want
		 * to execute something to get the columns correctly. A possibility is to actually
		 * execute another SQL which is the code shown here.
		 *
		 * To adapt depending on the C API and its features */
		GdaStatement *estmt;
                gchar *esql;
                estmt = gda_select_alter_select_for_empty (stmt, error);
                if (!estmt) {
			g_object_unref (ps);
                        return NULL;
		}
                esql = gda_statement_to_sql (estmt, NULL, error);
                g_object_unref (estmt);
                if (!esql) {
			g_object_unref (ps);
                        return NULL;
		}

		/* Execute the 'esql' SQL code */
                g_free (esql);

		/* modify @doc */
		TO_IMPLEMENT;
	}

	/* send command */
	xmlChar *cmde;
	xmlDocPtr replydoc;
	int size;
	gchar status;
	
	xmlDocDumpMemory (doc, &cmde, &size);
	xmlFreeDoc (doc);
	replydoc = _gda_web_send_message_to_frontend (cnc, cdata, MESSAGE_EXEC, (gchar*) cmde, cdata->key, &status);
	xmlFree (cmde);
	
	if (!replydoc)
		status = 'E';
	if (status != 'O') {
		if (replydoc) {
			_gda_web_set_connection_error_from_xmldoc (cnc, replydoc, error);
			xmlFreeDoc (replydoc);
			if (status == 'C')
				_gda_web_change_connection_to_closed (cnc, cdata);
		}
		else
			_gda_web_change_connection_to_closed (cnc, cdata);
		return NULL;
	}

	/* required: help @cnc keep some stats */
	event = gda_connection_point_available_event (cnc, GDA_CONNECTION_EVENT_NOTICE);
	gda_connection_event_set_description (event, "Command OK");
	gda_connection_add_event (cnc, event);
	gda_connection_internal_statement_executed (cnc, stmt, params, event);

	root = xmlDocGetRootElement (replydoc);
	GObject *retval = NULL;
	for (node = root->children; node; node = node->next) {
		if (!strcmp ((gchar*) node->name, "impacted_rows")) {
			xmlChar *contents;
			GdaSet *set = NULL;

			contents = xmlNodeGetContent (node);
			set = gda_set_new_inline (1, "IMPACTED_ROWS", G_TYPE_INT, atoi ((gchar*) contents));
			xmlFree (contents);
			retval = (GObject*) set;
		}
		else if (!strcmp ((gchar*) node->name, "gda_array")) {
			GdaDataModel *data_model;
			g_rec_mutex_lock (& (cdata->mutex));
			data_model = gda_web_recordset_new (cnc, ps, params, model_usage,
							    col_types, cdata->session_id, node, error);
			g_rec_mutex_unlock (& (cdata->mutex));
			retval = (GObject*) data_model;

			if (! gda_web_recordset_store (GDA_WEB_RECORDSET (data_model), node, error)) {
				g_object_unref (G_OBJECT (data_model));
				retval = NULL;
			}
		}
		else if (!strcmp ((gchar*) node->name, "preparehash")) {
			xmlChar *contents;
			contents = xmlNodeGetContent (node);
			gda_web_pstmt_set_pstmt_hash (ps, (gchar*) contents);
			xmlFree (contents);
		}
	}

	xmlFreeDoc (replydoc);
	g_object_unref (ps);
	return retval;
}
