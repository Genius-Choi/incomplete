    void SipDialogController::doRespondToSipRequest( SipMessageData* pData ) {
        string transactionId( pData->getTransactionId() );
        string startLine( pData->getStartLine()) ;
        string headers( pData->getHeaders() );
        string body( pData->getBody()) ;
        string clientMsgId( pData->getClientMsgId()) ;
        string contentType ;
        string dialogId ;
        string contact, transportDesc ;
        std::shared_ptr<SipTransport> pSelectedTransport ;
        bool bSentOK = true ;
        string failMsg ;
        bool bDestroyIrq = false ;
        bool bClearIIP = false ;
        bool existingDialog = false;
        bool transportGone = false;
        tagi_t* tags = nullptr;

        //decode status 
        sip_status_t* sip_status = sip_status_make( m_pController->getHome(), startLine.c_str() ) ;
        int code = sip_status->st_status ;
        const char* status = sip_status->st_phrase ;
  
        nta_incoming_t* irq = NULL ;
        int rc = -1 ;
        std::shared_ptr<IIP> iip;

        DR_LOG(log_debug) << "SipDialogController::doRespondToSipRequest thread " << std::this_thread::get_id() ;

        /* search for requests within a dialog first */
        irq = findAndRemoveTransactionIdForIncomingRequest( transactionId ) ;
        if( !irq ) {
            if (!IIP_FindByTransactionId(m_invitesInProgress, transactionId, iip)) {
                /* could be a new incoming request that hasn't been responded to yet */
                
                /* we allow the app to set the local tag (ie tag on the To) */
                string toValue;
                string tag;
                if (GetValueForHeader( headers, "to", toValue)) {
                    std::regex re("tag=(.*)");
                    std::smatch mr;
                    if (std::regex_search(toValue, mr, re) && mr.size() > 1) {
                        tag = mr[1] ;
                    }
                }

                if( m_pController->setupLegForIncomingRequest( transactionId, tag ) ) {
                    if (!IIP_FindByTransactionId(m_invitesInProgress, transactionId, iip)) {
                        irq = findAndRemoveTransactionIdForIncomingRequest(transactionId)  ;
                    }
                }
             }
        }
        else {
            existingDialog = true;
        }

        if( irq ) {

            DR_LOG(log_debug) << "SipDialogController::doRespondToSipRequest found incoming transaction " << std::hex << irq  ;

            msg_t* msg = nta_incoming_getrequest( irq ) ;   //adds a reference
            sip_t *sip = sip_object( msg );

            tport_t *tp = nta_incoming_transport(m_agent, irq, msg) ; 

            if (!tp || tport_is_shutdown(tp)) {
                failMsg = "transport for response has been shutdown or closed";
                DR_LOG(log_error) << "SipDialogController::doRespondToSipRequest - unable to forward response as transport has been closed or shutdown "
                    << sip->sip_call_id->i_id << " " << sip->sip_cseq->cs_seq;
                bSentOK = false;
                transportGone = true;
                msg_destroy(msg);
            }
            else {
                tport_t *tport = tport_parent( tp ) ;

                pSelectedTransport = SipTransport::findTransport( tport ) ;
                if (!pSelectedTransport) {
                    bSentOK = false;
                    failMsg = "Unable to find transport for transaction";
                    DR_LOG(log_error) << "SipDialogController::doRespondToSipRequest - unable to find transport for response to "
                        << sip->sip_call_id->i_id << " " << sip->sip_cseq->cs_seq;
                }
                else {
                    pSelectedTransport->getContactUri(contact, true);
                    contact = "<" + contact + ">" ;

                    pSelectedTransport->getDescription(transportDesc);

                    tport_unref( tp ) ;
            
                    //create tags for headers
                    tags = makeTags( headers, transportDesc ) ;

                    if( body.length() && !searchForHeader( tags, siptag_content_type, contentType ) ) {
                        if( 0 == body.find("v=0") ) {
                            contentType = "application/sdp" ;
                            DR_LOG(log_debug) << "SipDialogController::doRespondToSipRequest - automatically detecting content-type as application/sdp"  ;
                        }
                    }

                    rc = nta_incoming_treply( irq, code, status
                        ,TAG_IF( (sip_method_invite == sip->sip_request->rq_method || sip->sip_request->rq_method == sip_method_subscribe) &&
                            !searchForHeader( tags, siptag_contact_str, contact ), SIPTAG_CONTACT_STR(contact.c_str()) )
                        ,TAG_IF(!body.empty(), SIPTAG_PAYLOAD_STR(body.c_str()))
                        ,TAG_IF(!contentType.empty(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))
                        ,TAG_NEXT(tags)
                        ,TAG_END() ) ;
                    if( 0 != rc ) {
                        bSentOK = false ;
                        failMsg = "Unknown server error sending response" ;
                    }
                }
            }

            //  we need to cache source address / port / transport for successful REGISTER or SUBSCRIBE requests from webrtc clients so we can 
            //  later send INVITEs and NOTIFYs
            if( bSentOK && ((sip->sip_request->rq_method == sip_method_subscribe && (202 == code || 200 ==code) ) ||
                (sip->sip_request->rq_method == sip_method_register && 200 == code) ) ) {

                sip_contact_t* contact = sip->sip_contact ;
                if( contact ) {
                    if( !tport_is_dgram(tp) /*&& NULL != strstr( contact->m_url->url_host, ".invalid") */) {
                        bool add = true ;
                        unsigned long expires = 0 ;

                        msg_t *msgResponse = nta_incoming_getresponse( irq ) ;    // adds a reference
                        if (msg) {
                            sip_t *sipResponse = sip_object( msgResponse ) ;
                            if (sipResponse) {
                                if( sip->sip_request->rq_method == sip_method_subscribe ) {
                                    if (sipResponse->sip_expires && sipResponse->sip_expires->ex_delta) {
                                        expires = sipResponse->sip_expires->ex_delta;
                                    }
                                    else {
                                        DR_LOG(log_debug) << "SipDialogController::doRespondToSipRequest - 200-class response to SUBSCRIBE must include expires (rfc3265 3.1.1)"  ;
                                    }
                                }
                                else {
                                    if( NULL != sipResponse->sip_contact && NULL != sipResponse->sip_contact->m_expires ) {
                                        expires = ::atoi( sipResponse->sip_contact->m_expires ) ;
                                    }
                                    else if (NULL != sipResponse->sip_contact && sipResponse->sip_expires->ex_delta) {
                                        expires = sipResponse->sip_expires->ex_delta;
                                    }  
                                }
                                
                                add = expires > 0 ;
                                if( add ) {
                                    theOneAndOnlyController->cacheTportForSubscription( contact->m_url->url_user, contact->m_url->url_host, expires, tp ) ;
                                }
                                else {
                                    theOneAndOnlyController->flushTportForSubscription( contact->m_url->url_user, contact->m_url->url_host ) ;                        
                                }
                            }
                            else {
                                bSentOK = false ;
                                failMsg = "connection error: remote side may have closed socket";                                
                            }
                            msg_destroy( msgResponse ) ;    // releases the reference                            
                        }
                        else {
                            bSentOK = false ;
                            failMsg = "connection error: remote side may have closed socket";
                        }
                    }
                }
            }

            if (existingDialog && bSentOK) {
                nta_leg_t* leg = nta_leg_by_call_id(m_pController->getAgent(), sip->sip_call_id->i_id);
                if (leg) {
                    std::shared_ptr<SipDialog> dlg ;
                    if(findDialogByLeg( leg, dlg )) {
                        dialogId = dlg->getDialogId();
                        DR_LOG(log_debug) << "SipDialogController::doRespondToSipRequest retrieved dialog id for existing dialog " << dialogId  ;
                        if (sip->sip_request->rq_method == sip_method_invite && body.length()) {
                            DR_LOG(log_debug) << "SipDialogController::doRespondToSipRequest updating local sdp for dialog " << dialogId  ;
                            dlg->setLocalSdp( body.c_str() ) ;
                        }
                    }
                }
            }
            msg_destroy( msg ); //release the reference

            DR_LOG(log_debug) << "SipDialogController::doRespondToSipRequest destroying irq " << irq  ;
            bDestroyIrq = true ;                        
        }
        else if( iip ) {
            DR_LOG(log_debug) << "SipDialogController::doRespondToSipRequest found invite or subscribe in progress " << std::hex << iip  ;
           /* invite in progress */
            nta_leg_t* leg = const_cast<nta_leg_t *>(iip->leg()) ;
            irq = const_cast<nta_incoming_t *>(iip->irq()) ;         
            std::shared_ptr<SipDialog> dlg = iip->dlg() ;

            if (dlg->getSipStatus() >= 200) {
                DR_LOG(log_warning) << "SipDialogController::doRespondToSipRequest: iip " << std::hex << iip  << 
                    ": application attempting to send final response " << std::dec << dlg->getSipStatus() << 
                    " when a final response has already been sent; discarding" ;
            }
            else {
                msg_t* msg = nta_incoming_getrequest( irq ) ;   //allocates a reference
                sip_t *sip = sip_object( msg );

                tport_t *tp = nta_incoming_transport(m_agent, irq, msg) ; 
                if (!tp || tport_is_shutdown(tp)) {
                    failMsg = "transport for response has been shutdown or closed";
                    DR_LOG(log_error) << "SipDialogController::doRespondToSipRequest - unable to forward response as transport has been closed or shutdown "
                        << sip->sip_call_id->i_id << " " << sip->sip_cseq->cs_seq;
                    bSentOK = false;
                    transportGone = true;
                    msg_destroy(msg);
                }
                else {
                    tport_t *tport = tport_parent( tp ) ;

                    pSelectedTransport = SipTransport::findTransport( tport ) ;
                    assert(pSelectedTransport); 

                    pSelectedTransport->getContactUri(contact, true);
                    contact = "<" + contact + ">" ;

                    pSelectedTransport->getDescription(transportDesc);

                    tport_unref( tp ) ;
            
                    //create tags for headers
                    tags = makeTags( headers, transportDesc ) ;
                    string customContact ;
                    bool hasCustomContact = searchForHeader( tags, siptag_contact_str, customContact ) ;
                    if( hasCustomContact ) {
                        DR_LOG(log_debug) << "SipDialogController::doRespondToSipRequest - client provided contact header so we wont include our internally-generated one"  ;
                    }

                    dlg->setLocalContactHeader(hasCustomContact ? customContact.c_str() : contact.c_str());

                    dialogId = dlg->getDialogId() ;

                    dlg->setSipStatus( code ) ;

                    /* if the client included Require: 100rel on a provisional, send it reliably */
                    bool bReliable = false ;
                    if( code > 100 && code < 200 && sip->sip_request->rq_method == sip_method_invite) {
                        int i = 0 ;
                        while( tags[i].t_tag != tag_null ) {
                            if( tags[i].t_tag == siptag_require_str && NULL != strstr( (const char*) tags[i].t_value, "100rel") ) {
                                bReliable = true ;
                                break ;
                            }
                            i++ ;
                        }
                    }

                    /* update local sdp if provided */
                    string strLocalSdp ;
                    if( !body.empty()  ) {
                        dlg->setLocalSdp( body.c_str() ) ;
                        string strLocalContentType ;
                        if( searchForHeader( tags, siptag_content_type_str, strLocalContentType ) ) {
                            dlg->setLocalContentType( strLocalContentType ) ;
                        }
                        else {
                            /* set content-type if we can detect it */
                            if( 0 == body.find("v=0") ) {
                                contentType = "application/sdp" ;
                                dlg->setLocalContentType( contentType ) ;
                            }
                        }
                    }

                    /* set session timer if required */
                    sip_session_expires_t *sessionExpires = nullptr;
                    if( 200 == code && sip->sip_request->rq_method == sip_method_invite ) {
                        string strSessionExpires ;
                        if( searchForHeader( tags, siptag_session_expires_str, strSessionExpires ) ) {
                            sip_session_expires_t* se = sip_session_expires_make(m_pController->getHome(), strSessionExpires.c_str() );
                            unsigned long interval = std::max((unsigned long) 90, se->x_delta);
                            SipDialog::SessionRefresher_t who = !se->x_refresher || 0 == strcmp( se->x_refresher, "uac") ? SipDialog::they_are_refresher : SipDialog::we_are_refresher;

                            if (who == SipDialog::we_are_refresher) {
                                DR_LOG(log_debug) << "SipDialogController::doRespondToSipRequest - per app we are refresher, interval will be " << interval  ;
                            }
                            else {
                                DR_LOG(log_debug) << "SipDialogController::doRespondToSipRequest - per app UAC is refresher, interval will be " << interval  ;
                            }
                            dlg->setSessionTimer(interval, who) ;
                            su_free( m_pController->getHome(), se ) ;
                        }
                        else if (sip->sip_session_expires && sip->sip_session_expires->x_refresher) {
                            sip_session_expires_t* se = sip->sip_session_expires;
                            sessionExpires = sip_session_expires_copy(m_pController->getHome(), se);
                            unsigned long interval = std::max((unsigned long) 90, se->x_delta);
                            SipDialog::SessionRefresher_t who = !se->x_refresher || 0 == strcmp( se->x_refresher, "uac") ? SipDialog::they_are_refresher : SipDialog::we_are_refresher;

                            if (who == SipDialog::we_are_refresher) {
                                DR_LOG(log_debug) << "SipDialogController::doRespondToSipRequest - UAC asked us to refresh, interval will be " << interval  ;
                            }
                            else {
                                DR_LOG(log_debug) << "SipDialogController::doRespondToSipRequest - UAC is refresher, interval will be " << interval  ;
                            }
                            dlg->setSessionTimer(interval, who) ;
                        }
                    }

                    /* iterate through data.opts.headers, adding headers to the response */
                    if( bReliable ) {
                        DR_LOG(log_debug) << "Sending " << dec << code << " response reliably"  ;
                        nta_reliable_t* rel = nta_reliable_treply( irq, uasPrack, this, code, status
                            ,TAG_IF( !hasCustomContact, SIPTAG_CONTACT_STR(contact.c_str()))
                            ,TAG_IF(!body.empty(), SIPTAG_PAYLOAD_STR(body.c_str()))
                            ,TAG_IF(!contentType.empty(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))
                            ,TAG_IF(sessionExpires, SIPTAG_SESSION_EXPIRES(sessionExpires))
                            ,TAG_NEXT(tags)
                            ,TAG_END() ) ;

                        if( !rel ) {
                            bSentOK = false ;
                            failMsg = "Remote endpoint does not support 100rel" ;
                            DR_LOG(log_error) << "SipDialogController::doRespondToSipRequest - failed sending reliable provisional response; most likely remote endpoint does not support 100rel"  ;
                        } 
                        else {
                            IIP_SetReliable(m_invitesInProgress, iip, rel);
                        }
                        //TODO: should probably set timer here
                    }
                    else {
                        DR_LOG(log_debug) << "Sending " << dec << code << " response (not reliably)  on irq " << hex << irq  ;
                        rc = nta_incoming_treply( irq, code, status
                            ,TAG_IF( code >= 200 && code < 300 && !hasCustomContact, SIPTAG_CONTACT_STR(contact.c_str()))
                            ,TAG_IF(!body.empty(), SIPTAG_PAYLOAD_STR(body.c_str()))
                            ,TAG_IF(!contentType.empty(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))
                            ,TAG_IF(sessionExpires, SIPTAG_SESSION_EXPIRES(sessionExpires))
                            ,TAG_NEXT(tags)
                            ,TAG_END() ) ; 
                        if( 0 != rc ) {
                            DR_LOG(log_error) << "Error " << dec << rc << " sending response on irq " << hex << irq <<
                                " - this is usually because the application provided a syntactically-invalid header";
                            bSentOK = false ;
                            failMsg = "Unknown server error sending response" ;
                        }
                        else {
                            if( sip_method_subscribe == nta_incoming_method(irq) ) {
                                bClearIIP = true ;

                                // add dialog for SUBSCRIBE dialogs
                                if( 202 == code || 200 == code ) {
                                DR_LOG(log_debug) << "SipDialogController::doRespondToSipRequest: adding dialog for subscribe with dialog id " <<  dlg->getDialogId()  ;
                                this->addDialog( dlg ) ;
                                }
                            }

                            // sofia handles retransmits for us for final failures, but not for success
                            // TODO: figure out why this is
                            if( sip_method_invite == nta_incoming_method(irq) && code == 200 ) {
                                
                                this->addDialog( dlg ) ;

                                if (tport_is_dgram(tp)) {
                                    // set timer G to retransmit 200 OK if we don't get ack
                                    TimerEventHandle t = m_pTQM->addTimer("timerG",
                                        std::bind(&SipDialogController::retransmitFinalResponse, this, irq, tp, dlg), NULL, NTA_SIP_T1 ) ;
                                    dlg->setTimerG(t) ;
                                }
                                // set timer H, which sets the time to stop these retransmissions
                                TimerEventHandle t = m_pTQM->addTimer("timerH",
                                    std::bind(&SipDialogController::endRetransmitFinalResponse, this, irq, tp, dlg), NULL, TIMER_H_MSECS ) ;
                                dlg->setTimerH(t) ;
                            }

                            // stats
                            if (theOneAndOnlyController->getStatsCollector().enabled()) {
            
                                // response time to incoming INVITE request
                                if (sip_method_invite == nta_incoming_method(irq) && code <= 200) {
                                    auto now = std::chrono::steady_clock::now();
                                    std::chrono::duration<double> diff = now - dlg->getArrivalTime();
                                    if (!dlg->hasAlerted()) {
                                        dlg->alerting();
                                        STATS_HISTOGRAM_OBSERVE_NOCHECK(STATS_HISTOGRAM_INVITE_PDD_IN, diff.count())
                                    }
                                    if (code == 200) {
                                        STATS_HISTOGRAM_OBSERVE_NOCHECK(STATS_HISTOGRAM_INVITE_RESPONSE_TIME_IN, diff.count())
                                    }
                                }
                            }
                        }
                    }
                    msg_destroy( msg ); //release the reference
                    if (sessionExpires) su_free(m_pController->getHome(), sessionExpires);
                }
            }
        }
        else {

            DR_LOG(log_error) << "SipDialogController::doRespondToSipRequest - unable to find irq or iip for transaction id " << transactionId  ;

            /* failed */
            string strMethod ;
            bSentOK = false ;
            failMsg = "Response not sent due to unknown transaction" ;  

            if( FindCSeqMethod( headers, strMethod ) ) {
                DR_LOG(log_debug) << "silently discarding response to " << strMethod  ;

                if( 0 == strMethod.compare("CANCEL") ) {
                    failMsg = "200 OK to incoming CANCEL is automatically generated by the stack" ;
                }
            }                     
        }

        if( bSentOK ) {
            string encodedMessage ;
            msg_t* msg = nta_incoming_getresponse( irq ) ;  // adds a ref

            // we can get an rc=0 from nta_incoming_treply above, but have it actually fail
            // in the case of a websocket that closed immediately after sending us a BYE
            if (msg) {
                sip_t *sip = sip_object( msg );
                EncodeStackMessage( sip, encodedMessage ) ;
                SipMsgData_t meta( msg, irq, "application" ) ;

                STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_RESPONSES_OUT, {
                    {"method", sip->sip_cseq->cs_method_name},
                    {"code", boost::lexical_cast<std::string>(code)}})

                string s ;
                meta.toMessageFormat(s) ;
                string data = s + "|" + transactionId + "|" + dialogId + "|" + "|Msg sent:|" + DR_CRLF + encodedMessage ;

                m_pController->getClientController()->route_api_response( clientMsgId, "OK", data) ;

                if( iip && code >= 300 ) {
                    Cdr::postCdr( std::make_shared<CdrStop>( msg, "application", Cdr::call_rejected ) );
                }
                else if (iip && code == 200) {
                    Cdr::postCdr( std::make_shared<CdrStart>( msg, "application", Cdr::uas ) );                
                }

                msg_destroy(msg) ;      // release the ref                          
            }
            else {
                m_pController->getClientController()->route_api_response( clientMsgId, "NOK", "failed sending, possibly due to far end closing socket") ;
            }
        }
        else {
            m_pController->getClientController()->route_api_response( clientMsgId, "NOK", failMsg) ;
        }
        /* tell client controller to flush transaction data on any final response to a non-INVITE */
        if( sip_method_invite != nta_incoming_method(irq) && code >= 200 ) {
            m_pController->getClientController()->removeNetTransaction( transactionId ) ;
        }
        else if( sip_method_invite == nta_incoming_method(irq) && code > 200 ) {
            m_pController->getClientController()->removeNetTransaction( transactionId ) ;            
        }
        else if(sip_method_invite == nta_incoming_method(irq) && code == 200 && existingDialog) {
            m_pController->getClientController()->removeNetTransaction( transactionId ) ;            
        }

        if( bClearIIP && iip) {
            IIP_Clear(m_invitesInProgress, iip);
        }

        if( bDestroyIrq && !transportGone) nta_incoming_destroy(irq) ;    

        pData->~SipMessageData() ;

        deleteTags( tags );

        su_free(m_pController->getHome(), sip_status);

    }
