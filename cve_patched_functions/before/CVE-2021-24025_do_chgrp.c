static bool do_chgrp(const String& filename,
                     const Variant& group,
                     bool islChgrp,
                     const char* funcName) {
  // If filename points to a user file, invoke ExtendedWrapper::chgrp(..)
  Stream::Wrapper* w = Stream::getWrapperFromURI(filename);
  auto usw = dynamic_cast<Stream::ExtendedWrapper*>(w);
  if (usw != nullptr) {
    if (group.isInteger()) {
      return usw->chgrp(filename, group.toInt64());
    } else if (group.isString()) {
      return usw->chgrp(filename, group.toString());
    }
    raise_warning("%s(): parameter 2 should be string or integer, %s given",
      funcName, getDataTypeString(group.getType()).c_str());
    return false;
  }

#ifdef WIN32
  return false;
#else
  int gid;
  if (group.isString()) {
    String sgroup = group.toString();
    auto buf = GroupBuffer{};
    struct group *gr;
    if (getgrnam_r(sgroup.data(), &buf.ent, buf.data.get(), buf.size, &gr)) {
      // failed to read group info
      return false;
    }
    if (!gr) {
      Logger::Verbose("%s/%d: Unable to find gid for %s",
        __FUNCTION__, __LINE__, sgroup.data());
      raise_warning("%s(): Unable to find gid for %s", funcName,
        group.toString().c_str());
      return false;
    }
    gid = gr->gr_gid;
  } else {
    gid = group.toInt32();
  }

  if (islChgrp) {
    CHECK_SYSTEM(lchown(File::TranslatePath(filename).data(), (uid_t)-1, gid));
  } else {
    CHECK_SYSTEM(chown(File::TranslatePath(filename).data(), (uid_t)-1, gid));
  }
  return true;
#endif
}
