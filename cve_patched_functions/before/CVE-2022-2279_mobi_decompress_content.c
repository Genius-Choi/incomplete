static MOBI_RET mobi_decompress_content(const MOBIData *m, char *text, FILE *file, size_t *len) {
    int dump = false;
    if (file != NULL) {
        dump = true;
    }
    if (m == NULL) {
        debug_print("%s", "Mobi structure not initialized\n");
        return MOBI_INIT_FAILED;
    }
    if (mobi_is_encrypted(m) && !mobi_has_drmkey(m)) {
        debug_print("%s", "Document is encrypted\n");
        return MOBI_FILE_ENCRYPTED;
    }
    const size_t offset = mobi_get_kf8offset(m);
    if (m->rh == NULL || m->rh->text_record_count == 0) {
        debug_print("%s", "Text records not found in MOBI header\n");
        return MOBI_DATA_CORRUPT;
    }
    const size_t text_rec_index = 1 + offset;
    size_t text_rec_count = m->rh->text_record_count;
    const uint16_t compression_type = m->rh->compression_type;
    /* check for extra data at the end of text files */
    uint16_t extra_flags = 0;
    if (m->mh && m->mh->extra_flags) {
        extra_flags = *m->mh->extra_flags;
    }
    /* get first text record */
    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, text_rec_index);
    MOBIHuffCdic *huffcdic = NULL;
    if (compression_type == MOBI_COMPRESSION_HUFFCDIC) {
        /* load huff/cdic tables */
        huffcdic = mobi_init_huffcdic();
        if (huffcdic == NULL) {
            debug_print("%s\n", "Memory allocation failed");
            return MOBI_MALLOC_FAILED;
        }
        MOBI_RET ret = mobi_parse_huffdic(m, huffcdic);
        if (ret != MOBI_SUCCESS) {
            mobi_free_huffcdic(huffcdic);
            return ret;
        }
    }
    /* get following CDIC records */
    size_t text_length = 0;
    while (text_rec_count-- && curr) {
        size_t extra_size = 0;
        if (extra_flags) {
            extra_size = mobi_get_record_extrasize(curr, extra_flags);
            if (extra_size == MOBI_NOTSET) {
                mobi_free_huffcdic(huffcdic);
                return MOBI_DATA_CORRUPT;
            }
        }
        size_t decompressed_size = mobi_get_textrecord_maxsize(m);
        unsigned char *decompressed = malloc(decompressed_size);
        if (decompressed == NULL) {
            mobi_free_huffcdic(huffcdic);
            debug_print("Memory allocation failed%s", "\n");
            return MOBI_MALLOC_FAILED;
        }
        MOBI_RET ret = MOBI_SUCCESS;
#ifdef USE_ENCRYPTION
        if (mobi_is_encrypted(m) && mobi_has_drmkey(m)) {
            if (compression_type != MOBI_COMPRESSION_HUFFCDIC) {
                /* decrypt also multibyte extra data */
                extra_size = mobi_get_record_extrasize(curr, extra_flags & 0xfffe);
            }
            if (extra_size == MOBI_NOTSET || extra_size > curr->size) {
                mobi_free_huffcdic(huffcdic);
                free(decompressed);
                return MOBI_DATA_CORRUPT;
            }
            const size_t decrypt_size = curr->size - extra_size;
            if (decrypt_size > decompressed_size) {
                if (decrypt_size <= curr->size) {
                    unsigned char *tmp = realloc(decompressed, decrypt_size);
                    if (tmp == NULL) {
                        debug_print("%s\n", "Memory allocation failed");
                        mobi_free_huffcdic(huffcdic);
                        free(decompressed);
                        return MOBI_MALLOC_FAILED;
                    }
                    decompressed = tmp;
                } else {
                    debug_print("Record too large: %zu\n", decrypt_size);
                    mobi_free_huffcdic(huffcdic);
                    free(decompressed);
                    return MOBI_DATA_CORRUPT;
                }
            }
            if (decrypt_size) {
                ret = mobi_buffer_decrypt(decompressed, curr->data, decrypt_size, m);
                if (ret != MOBI_SUCCESS) {
                    mobi_free_huffcdic(huffcdic);
                    free(decompressed);
                    return ret;
                }
                memcpy(curr->data, decompressed, decrypt_size);
            }
            if (compression_type != MOBI_COMPRESSION_HUFFCDIC && (extra_flags & 1)) {
                // update multibyte data size after decryption
                extra_size = mobi_get_record_extrasize(curr, extra_flags);
                if (extra_size == MOBI_NOTSET) {
                    free(decompressed);
                    return MOBI_DATA_CORRUPT;
                }
            }
        }
#endif
        if (extra_size > curr->size) {
            debug_print("Wrong record size: -%zu\n", extra_size - curr->size);
            mobi_free_huffcdic(huffcdic);
            free(decompressed);
            return MOBI_DATA_CORRUPT;
        }
        if (extra_size == curr->size) {
            debug_print("Skipping empty record%s", "\n");
            free(decompressed);
            curr = curr->next;
            continue;
        }
        const size_t record_size = curr->size - extra_size;
        switch (compression_type) {
            case MOBI_COMPRESSION_NONE:
                /* no compression */
                if (record_size > decompressed_size) {
                    debug_print("Record too large: %zu\n", record_size);
                    free(decompressed);
                    return MOBI_DATA_CORRUPT;
                }
                memcpy(decompressed, curr->data, record_size);
                decompressed_size = record_size;
                if (mobi_exists_mobiheader(m) && mobi_get_fileversion(m) <= 3) {
                    /* workaround for some old files with null characters inside record */
                    mobi_remove_zeros(decompressed, &decompressed_size);
                }
                break;
            case MOBI_COMPRESSION_PALMDOC:
                /* palmdoc lz77 compression */
                ret = mobi_decompress_lz77(decompressed, curr->data, &decompressed_size, record_size);
                if (ret != MOBI_SUCCESS) {
                    free(decompressed);
                    return ret;
                }
                break;
            case MOBI_COMPRESSION_HUFFCDIC:
                /* mobi huffman compression */
                ret = mobi_decompress_huffman(decompressed, curr->data, &decompressed_size, record_size, huffcdic);
                if (ret != MOBI_SUCCESS) {
                    free(decompressed);
                    mobi_free_huffcdic(huffcdic);
                    return ret;
                }
                break;
            default:
                debug_print("%s", "Unknown compression type\n");
                mobi_free_huffcdic(huffcdic);
                free(decompressed);
                return MOBI_DATA_CORRUPT;
        }
        curr = curr->next;
        if (dump) {
            fwrite(decompressed, 1, decompressed_size, file);
        } else {
            if (text_length + decompressed_size > *len) {
                debug_print("%s", "Text buffer too small\n");
                /* free huff/cdic tables */
                mobi_free_huffcdic(huffcdic);
                free(decompressed);
                return MOBI_PARAM_ERR;
            }
            memcpy(text + text_length, decompressed, decompressed_size);
            text_length += decompressed_size;
            text[text_length] = '\0';
        }
        free(decompressed);
    }
    /* free huff/cdic tables */
    mobi_free_huffcdic(huffcdic);
    if (len) {
        *len = text_length;
    }
    return MOBI_SUCCESS;
}
