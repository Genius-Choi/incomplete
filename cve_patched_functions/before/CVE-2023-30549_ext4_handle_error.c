static void ext4_handle_error(struct super_block *sb, bool force_ro, int error,
			      __u32 ino, __u64 block,
			      const char *func, unsigned int line)
{
	journal_t *journal = EXT4_SB(sb)->s_journal;
	bool continue_fs = !force_ro && test_opt(sb, ERRORS_CONT);

	EXT4_SB(sb)->s_mount_state |= EXT4_ERROR_FS;
	if (test_opt(sb, WARN_ON_ERROR))
		WARN_ON_ONCE(1);

	if (!continue_fs && !sb_rdonly(sb)) {
		ext4_set_mount_flag(sb, EXT4_MF_FS_ABORTED);
		if (journal)
			jbd2_journal_abort(journal, -EIO);
	}

	if (!bdev_read_only(sb->s_bdev)) {
		save_error_info(sb, error, ino, block, func, line);
		/*
		 * In case the fs should keep running, we need to writeout
		 * superblock through the journal. Due to lock ordering
		 * constraints, it may not be safe to do it right here so we
		 * defer superblock flushing to a workqueue.
		 */
		if (continue_fs && journal)
			schedule_work(&EXT4_SB(sb)->s_error_work);
		else
			ext4_commit_super(sb);
	}

	/*
	 * We force ERRORS_RO behavior when system is rebooting. Otherwise we
	 * could panic during 'reboot -f' as the underlying device got already
	 * disabled.
	 */
	if (test_opt(sb, ERRORS_PANIC) && !system_going_down()) {
		panic("EXT4-fs (device %s): panic forced after error\n",
			sb->s_id);
	}

	if (sb_rdonly(sb) || continue_fs)
		return;

	ext4_msg(sb, KERN_CRIT, "Remounting filesystem read-only");
	/*
	 * Make sure updated value of ->s_mount_flags will be visible before
	 * ->s_flags update
	 */
	smp_wmb();
	sb->s_flags |= SB_RDONLY;
}
