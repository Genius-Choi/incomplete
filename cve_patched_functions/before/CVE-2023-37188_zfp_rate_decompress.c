int zfp_rate_decompress(const uint8_t *input, int32_t input_len, uint8_t *output,
                        int32_t output_len, uint8_t meta, blosc2_dparams *dparams, const void *chunk) {
  ZFP_ERROR_NULL(input);
  ZFP_ERROR_NULL(output);
  ZFP_ERROR_NULL(dparams);
  BLOSC_UNUSED_PARAM(chunk);

  blosc2_schunk *sc = dparams->schunk;
  int32_t typesize = sc->typesize;

  double ratio = (double) meta / 100.0;
  int8_t ndim;
  int64_t *shape = malloc(8 * sizeof(int64_t));
  int32_t *chunkshape = malloc(8 * sizeof(int32_t));
  int32_t *blockshape = malloc(8 * sizeof(int32_t));
  uint8_t *smeta;
  int32_t smeta_len;
  if (blosc2_meta_get(sc, "b2nd", &smeta, &smeta_len) < 0) {
    BLOSC_TRACE_ERROR("Cannot access b2nd meta info");
    free(shape);
    free(chunkshape);
    free(blockshape);
    return BLOSC2_ERROR_FAILURE;
  }
  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);
  free(smeta);

  zfp_type type;     /* array scalar type */
  zfp_field *field;  /* array meta data */
  zfp_stream *zfp;   /* compressed stream */
  bitstream *stream; /* bit stream to write to or read from */
  size_t zfpsize;    /* byte size of compressed stream */

  switch (typesize) {
    case sizeof(float):
      type = zfp_type_float;
      break;
    case sizeof(double):
      type = zfp_type_double;
      break;
    default:
      free(shape);
      free(chunkshape);
      free(blockshape);
      BLOSC_TRACE_ERROR("ZFP is not available for typesize: %d", typesize);
      return BLOSC2_ERROR_FAILURE;
  }
  double rate =
      ratio * (double) typesize * 8;     // convert from output size / input size to output bits per input value
  zfp = zfp_stream_open(NULL);
  zfp_stream_set_rate(zfp, rate, type, ndim, zfp_false);

  stream = stream_open((void *) input, input_len);
  zfp_stream_set_bit_stream(zfp, stream);
  zfp_stream_rewind(zfp);

  switch (ndim) {
    case 1:
      field = zfp_field_1d((void *) output, type, blockshape[0]);
      break;
    case 2:
      field = zfp_field_2d((void *) output, type, blockshape[1], blockshape[0]);
      break;
    case 3:
      field = zfp_field_3d((void *) output, type, blockshape[2], blockshape[1], blockshape[0]);
      break;
    case 4:
      field = zfp_field_4d((void *) output, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);
      break;
    default:
      free(shape);
      free(chunkshape);
      free(blockshape);
      BLOSC_TRACE_ERROR("ZFP is not available for ndims: %d", ndim);
      return BLOSC2_ERROR_FAILURE;
  }

  zfpsize = zfp_decompress(zfp, field);

  /* clean up */
  zfp_field_free(field);
  zfp_stream_close(zfp);
  stream_close(stream);
  free(shape);
  free(chunkshape);
  free(blockshape);

  if (zfpsize == 0) {
    BLOSC_TRACE_ERROR("\n ZFP: Decompression failed\n");
    return (int) zfpsize;
  }

  return (int) output_len;
}
