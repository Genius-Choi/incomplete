HttpStateData::handle1xx(HttpReply *reply)
{
    if (fwd->al)
        fwd->al->reply = reply;

    HttpReply::Pointer msg(reply); // will destroy reply if unused

    // one 1xx at a time: we must not be called while waiting for previous 1xx
    Must(!flags.handling1xx);
    flags.handling1xx = true;

    const auto statusCode = reply->sline.status();

    // drop1xx() needs to handle HTTP 101 (Switching Protocols) responses
    // specially because they indicate that the server has stopped speaking HTTP
    Must(!flags.serverSwitchedProtocols);
    flags.serverSwitchedProtocols = (statusCode == Http::scSwitchingProtocols);

    if (statusCode == Http::scContinue && request->forcedBodyContinuation)
        return drop1xx("we have sent it already");

    if (!request->canHandle1xx())
        return drop1xx("the client does not support it");

#if USE_HTTP_VIOLATIONS
    // check whether the 1xx response forwarding is allowed by squid.conf
    if (Config.accessList.reply) {
        ACLFilledChecklist ch(Config.accessList.reply, originalRequest().getRaw());
        ch.al = fwd->al;
        ch.reply = reply;
        ch.syncAle(originalRequest().getRaw(), nullptr);
        HTTPMSGLOCK(ch.reply);
        if (!ch.fastCheck().allowed()) // TODO: support slow lookups?
            return drop1xx("http_reply_access blocked it");
    }
#endif // USE_HTTP_VIOLATIONS

    if (flags.serverSwitchedProtocols) {
        if (const auto reason = blockSwitchingProtocols(*reply))
            return drop1xx(reason);
    }

    debugs(11, 2, "forwarding 1xx to client");

    // the Sink will use this to call us back after writing 1xx to the client
    typedef NullaryMemFunT<HttpStateData> CbDialer;
    const AsyncCall::Pointer cb = JobCallback(11, 3, CbDialer, this,
                                  HttpStateData::proceedAfter1xx);
    CallJobHere1(11, 4, request->clientConnectionManager, ConnStateData,
                 ConnStateData::sendControlMsg, HttpControlMsg(msg, cb));
    // If the call is not fired, then the Sink is gone, and HttpStateData
    // will terminate due to an aborted store entry or another similar error.
    // If we get stuck, it is not handle1xx fault if we could get stuck
    // for similar reasons without a 1xx response.
}
