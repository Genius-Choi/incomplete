ecma_proxy_object_construct (ecma_object_t *obj_p, /**< proxy object */
                             ecma_object_t *new_target_p, /**< new target */
                             const ecma_value_t *args_p, /**< argument list */
                             uint32_t argc) /**< number of arguments */
{
  JERRY_ASSERT (ECMA_OBJECT_IS_PROXY (obj_p));
  ECMA_CHECK_STACK_USAGE ();

  ecma_proxy_object_t *proxy_obj_p = (ecma_proxy_object_t *) obj_p;

  /* 1. */
  ecma_value_t handler = proxy_obj_p->handler;

  /* 2-5. */
  ecma_value_t trap = ecma_validate_proxy_object (handler, LIT_MAGIC_STRING_CONSTRUCT);

  /* 6. */
  if (ECMA_IS_VALUE_ERROR (trap))
  {
    return trap;
  }

  ecma_value_t target = proxy_obj_p->target;
  ecma_object_t *target_obj_p = ecma_get_object_from_value (target);

  /* 7. */
  if (ecma_is_value_undefined (trap))
  {
    JERRY_ASSERT (ecma_object_is_constructor (target_obj_p));

    ecma_value_t result = ecma_op_function_construct (target_obj_p, new_target_p, args_p, argc);
    JERRY_BLOCK_TAIL_CALL_OPTIMIZATION ();
    return result;
  }

  /* 8. */
  ecma_value_t args_array = ecma_op_new_array_object_from_buffer (args_p, argc);

  ecma_object_t *func_obj_p = ecma_get_object_from_value (trap);
  ecma_value_t new_target_value = ecma_make_object_value (new_target_p);
  ecma_value_t function_call_args[] = { target, args_array, new_target_value };

  /* 9. */
  ecma_value_t new_obj = ecma_op_function_call (func_obj_p, handler, function_call_args, 3);

  ecma_free_object (args_array);
  ecma_deref_object (func_obj_p);

  /* 10 .*/
  if (ECMA_IS_VALUE_ERROR (new_obj))
  {
    return new_obj;
  }

  /* 11. */
  if (!ecma_is_value_object (new_obj))
  {
    ecma_free_value (new_obj);

    return ecma_raise_type_error (ECMA_ERR_TRAP_MUST_RETURN_WITH_AN_OBJECT);
  }

  /* 12. */
  return new_obj;
} /* ecma_proxy_object_construct */
