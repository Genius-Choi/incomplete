int main(int argc, char * const argv[])
{
	struct fsck_user_input ui;
	struct exfat_blk_dev bd;
	struct pbr *bs = NULL;
	int c, ret, exit_code;
	bool version_only = false;

	memset(&ui, 0, sizeof(ui));
	memset(&bd, 0, sizeof(bd));

	print_level = EXFAT_ERROR;

	if (!setlocale(LC_CTYPE, ""))
		exfat_err("failed to init locale/codeset\n");

	opterr = 0;
	while ((c = getopt_long(argc, argv, "arynpbsVvh", opts, NULL)) != EOF) {
		switch (c) {
		case 'n':
			if (ui.options & FSCK_OPTS_REPAIR_ALL)
				usage(argv[0]);
			ui.options |= FSCK_OPTS_REPAIR_NO;
			break;
		case 'r':
			if (ui.options & FSCK_OPTS_REPAIR_ALL)
				usage(argv[0]);
			ui.options |= FSCK_OPTS_REPAIR_ASK;
			break;
		case 'y':
			if (ui.options & FSCK_OPTS_REPAIR_ALL)
				usage(argv[0]);
			ui.options |= FSCK_OPTS_REPAIR_YES;
			break;
		case 'a':
		case 'p':
			if (ui.options & FSCK_OPTS_REPAIR_ALL)
				usage(argv[0]);
			ui.options |= FSCK_OPTS_REPAIR_AUTO;
			break;
		case 'b':
			ui.options |= FSCK_OPTS_IGNORE_BAD_FS_NAME;
			break;
		case 's':
			ui.options |= FSCK_OPTS_RESCUE_CLUS;
			break;
		case 'V':
			version_only = true;
			break;
		case 'v':
			if (print_level < EXFAT_DEBUG)
				print_level++;
			break;
		case '?':
		case 'h':
		default:
			usage(argv[0]);
		}
	}

	show_version();
	if (optind != argc - 1)
		usage(argv[0]);

	if (version_only)
		exit(FSCK_EXIT_SYNTAX_ERROR);
	if (ui.options & FSCK_OPTS_REPAIR_WRITE)
		ui.ei.writeable = true;
	else {
		if (ui.options & (FSCK_OPTS_IGNORE_BAD_FS_NAME |
				  FSCK_OPTS_RESCUE_CLUS))
			usage(argv[0]);
		ui.options |= FSCK_OPTS_REPAIR_NO;
		ui.ei.writeable = false;
	}

	exfat_fsck.options = ui.options;

	snprintf(ui.ei.dev_name, sizeof(ui.ei.dev_name), "%s", argv[optind]);
	ret = exfat_get_blk_dev_info(&ui.ei, &bd);
	if (ret < 0) {
		exfat_err("failed to open %s. %d\n", ui.ei.dev_name, ret);
		return FSCK_EXIT_OPERATION_ERROR;
	}

	ret = exfat_boot_region_check(&bd, &bs,
				      ui.options & FSCK_OPTS_IGNORE_BAD_FS_NAME ?
				      true : false);
	if (ret)
		goto err;

	exfat_fsck.exfat = exfat_alloc_exfat(&bd, bs);
	if (!exfat_fsck.exfat) {
		ret = -ENOMEM;
		goto err;
	}

	exfat_fsck.buffer_desc = exfat_alloc_buffer(2,
						    exfat_fsck.exfat->clus_size,
						    exfat_fsck.exfat->sect_size);
	if (!exfat_fsck.buffer_desc) {
		ret = -ENOMEM;
		goto err;
	}

	if ((exfat_fsck.options & FSCK_OPTS_REPAIR_WRITE) &&
	    exfat_mark_volume_dirty(exfat_fsck.exfat, true)) {
		ret = -EIO;
		goto err;
	}

	exfat_debug("verifying root directory...\n");
	ret = exfat_root_dir_check(exfat_fsck.exfat);
	if (ret) {
		exfat_err("failed to verify root directory.\n");
		goto out;
	}

	exfat_debug("verifying directory entries...\n");
	ret = exfat_filesystem_check(&exfat_fsck);
	if (ret)
		goto out;

	if (exfat_fsck.options & FSCK_OPTS_RESCUE_CLUS) {
		rescue_orphan_clusters(&exfat_fsck);
		exfat_fsck.dirty = true;
		exfat_fsck.dirty_fat = true;
	}

	if (exfat_fsck.options & FSCK_OPTS_REPAIR_WRITE) {
		ret = write_bitmap(&exfat_fsck);
		if (ret) {
			exfat_err("failed to write bitmap\n");
			goto out;
		}
	}

	if (ui.ei.writeable && fsync(bd.dev_fd)) {
		exfat_err("failed to sync\n");
		ret = -EIO;
		goto out;
	}
	if (exfat_fsck.options & FSCK_OPTS_REPAIR_WRITE)
		exfat_mark_volume_dirty(exfat_fsck.exfat, false);

out:
	exfat_show_info(&exfat_fsck, ui.ei.dev_name);
err:
	if (ret && ret != -EINVAL)
		exit_code = FSCK_EXIT_OPERATION_ERROR;
	else if (ret == -EINVAL ||
		 exfat_stat.error_count != exfat_stat.fixed_count)
		exit_code = FSCK_EXIT_ERRORS_LEFT;
	else if (exfat_fsck.dirty)
		exit_code = FSCK_EXIT_CORRECTED;
	else
		exit_code = FSCK_EXIT_NO_ERRORS;

	if (exfat_fsck.buffer_desc)
		exfat_free_buffer(exfat_fsck.buffer_desc, 2);
	if (exfat_fsck.exfat)
		exfat_free_exfat(exfat_fsck.exfat);
	close(bd.dev_fd);
	return exit_code;
}
