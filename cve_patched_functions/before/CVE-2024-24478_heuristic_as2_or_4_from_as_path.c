heuristic_as2_or_4_from_as_path(tvbuff_t *tvb, gint as_path_offset, gint end_attr_offset, guint8 bgpa_type, gint *number_as_segment)
{
    gint counter_as_segment=0;
    gint offset_check=0;
    guint8 assumed_as_len=0;
    gint asn_is_null=0;
    gint j=0;
    gint k=0;
    gint k_save=0;
    guint8 next_type=0;
    guint8 length=0;
    /* Heuristic is done in two phases
     * First we try to identify the as length (2 or 4 bytes)
     * then we do check that our assumption is ok
     * recalculating the offset and checking we end up with the right result
    * k is used to navigate into the AS_PATH */
    k = as_path_offset;
    /* case of AS_PATH type being explicitly 4 bytes ASN */
    if (bgpa_type == BGPTYPE_AS4_PATH) {
        /* We calculate numbers of segments and return the as length */
        assumed_as_len = 4;
        while (k < end_attr_offset)
        {
            /* we skip segment type and point to length */
            k++;
            length = tvb_get_guint8(tvb, k);
            /* length read let's move to first ASN */
            k++;
            /* we move to the next segment */
            k = k + (length*assumed_as_len);
            counter_as_segment++;
        }
        *number_as_segment = counter_as_segment;
        return(4);
    }
    /* case of user specified ASN length */
    if (bgp_asn_len != 0) {
        /* We calculate numbers of segments and return the as length */
        assumed_as_len = bgp_asn_len;
        while (k < end_attr_offset)
        {
            /* we skip segment type and point to length */
            k++;
            length = tvb_get_guint8(tvb, k);
            /* length read let's move to first ASN */
            k++;
            /* we move to the next segment */
            k = k + (length*assumed_as_len);
            /* if I am not facing the last segment k need to point to next length */
            counter_as_segment++;
        }
        *number_as_segment = counter_as_segment;
        return(bgp_asn_len);
    }
    /* case of a empty path attribute */
    if (as_path_offset == end_attr_offset)
    {
        *number_as_segment = 0;
        return(bgp_asn_len);
    }
    /* case of we run the heuristic to find the as length */
    k_save = k;
    /* we do run the heuristic on first segment and look at next segment if it exists */
    k++;
    length = tvb_get_guint8(tvb, k++);
    /* let's do some checking with an as length 2 bytes */
    offset_check = k + 2*length;
    next_type = tvb_get_guint8(tvb, offset_check);
    /* we do have one segment made of 2 bytes ASN we do reach the end of the attribute taking
     * 2 bytes ASN for our calculation */
    if (offset_check == end_attr_offset)
        assumed_as_len = 2;
    /* else we do check if we see a valid AS segment type after (length * AS 2 bytes) */
    else if (next_type == AS_SET ||
            next_type == AS_SEQUENCE ||
            next_type == AS_CONFED_SEQUENCE ||
            next_type == AS_CONFED_SET) {
        /* that's a good sign to assume ASN 2 bytes let's check that 2 first bytes of each ASN doesn't eq 0 to confirm */
            for (j=0; j < length && !asn_is_null; j++) {
                if(tvb_get_ntohs(tvb, k+(2*j)) == 0) {
                    asn_is_null = 1;
                }
            }
            if (asn_is_null == 0)
                assumed_as_len = 2;
            else
                assumed_as_len = 4;
        }
    else
    /* we didn't find a valid AS segment type in the next coming segment assuming 2 bytes ASN */
        assumed_as_len = 4;
    /* now that we have our assumed as length let's check we can calculate the attribute length properly */
    k = k_save;
    while (k < end_attr_offset)
    {
        /* we skip the AS type */
        k++;
        /* we get the length of the AS segment */
        length = tvb_get_guint8(tvb, k);
        /* let's point to the fist byte of the AS segment */
        k++;
        /* we move to the next segment */
        k = k + (length*assumed_as_len);
        counter_as_segment++;
    }
    if (k == end_attr_offset) {
    /* success */
        *number_as_segment = counter_as_segment;
        return(assumed_as_len);
    } else
    /* we are in trouble */
    return(-1);
}
