void CALLBACK httpapi_WinhttpStatusCallback(
  IN HINTERNET hInternet,
  IN DWORD_PTR dwContext,
  IN DWORD dwInternetStatus,
  IN LPVOID lpvStatusInformation,
  IN DWORD dwStatusInformationLength
)
{
    HTTP_HANDLE_DATA* handleData = (HTTP_HANDLE_DATA*)dwContext;

    (void)dwStatusInformationLength;
    (void)lpvStatusInformation;

    if (dwContext == 0)
    {
        LogError("WinhttpStatusCallback called without context set");
    }
    else if (dwInternetStatus != WINHTTP_CALLBACK_STATUS_SENDING_REQUEST)
    {
        // Silently ignore if there's any statuses we get that we can't handle
        ;
    }
    else if (handleData->trustedCertificate != NULL)
    {
        PCERT_CONTEXT pCertContext = NULL;
        DWORD bufferLength = sizeof(pCertContext);
        bool certificateTrusted;

        if (! WinHttpQueryOption(hInternet, WINHTTP_OPTION_SERVER_CERT_CONTEXT, (void*)&pCertContext, &bufferLength))
        {
            LogErrorWinHTTPWithGetLastErrorAsString("WinHttpQueryOption(WINHTTP_OPTION_SERVER_CERT_CONTEXT) failed");
            certificateTrusted = false;
        }
        else if (x509_verify_certificate_in_chain(handleData->trustedCertificate, pCertContext) != 0)
        {
            LogError("Certificate does not chain up correctly");
            certificateTrusted = false;
        }
        else
        {
            certificateTrusted = true;
        }

        if (certificateTrusted == false)
        {
            LogError("Server certificate is not trusted.  Aborting HTTP request");
            // To signal to caller that the request is to be terminated, the callback closes the handle.
            WinHttpCloseHandle(hInternet);
            // To avoid a double free of this handle (in HTTPAPI_ExecuteRequset cleanup) record we've processed close already.
            handleData->handleClosedOnCallbackError = true;
        }

        if (pCertContext != NULL)
        {
            CertFreeCertificateContext(pCertContext);
        }
    }
}
