static void cyclic_background_refresh(VP8_COMP *cpi, int Q, int lf_adjustment) {
  unsigned char *seg_map = cpi->segmentation_map;
  signed char feature_data[MB_LVL_MAX][MAX_MB_SEGMENTS];
  int i;
  int block_count = cpi->cyclic_refresh_mode_max_mbs_perframe;
  int mbs_in_frame = cpi->common.mb_rows * cpi->common.mb_cols;

  cpi->cyclic_refresh_q = Q / 2;

  if (cpi->oxcf.screen_content_mode) {
    // Modify quality ramp-up based on Q. Above some Q level, increase the
    // number of blocks to be refreshed, and reduce it below the thredhold.
    // Turn-off under certain conditions (i.e., away from key frame, and if
    // we are at good quality (low Q) and most of the blocks were
    // skipped-encoded
    // in previous frame.
    int qp_thresh = (cpi->oxcf.screen_content_mode == 2) ? 80 : 100;
    if (Q >= qp_thresh) {
      cpi->cyclic_refresh_mode_max_mbs_perframe =
          (cpi->common.mb_rows * cpi->common.mb_cols) / 10;
    } else if (cpi->frames_since_key > 250 && Q < 20 &&
               cpi->mb.skip_true_count > (int)(0.95 * mbs_in_frame)) {
      cpi->cyclic_refresh_mode_max_mbs_perframe = 0;
    } else {
      cpi->cyclic_refresh_mode_max_mbs_perframe =
          (cpi->common.mb_rows * cpi->common.mb_cols) / 20;
    }
    block_count = cpi->cyclic_refresh_mode_max_mbs_perframe;
  }

  // Set every macroblock to be eligible for update.
  // For key frame this will reset seg map to 0.
  memset(cpi->segmentation_map, 0, mbs_in_frame);

  if (cpi->common.frame_type != KEY_FRAME && block_count > 0) {
    /* Cycle through the macro_block rows */
    /* MB loop to set local segmentation map */
    i = cpi->cyclic_refresh_mode_index;
    assert(i < mbs_in_frame);
    do {
      /* If the MB is as a candidate for clean up then mark it for
       * possible boost/refresh (segment 1) The segment id may get
       * reset to 0 later if the MB gets coded anything other than
       * last frame 0,0 as only (last frame 0,0) MBs are eligable for
       * refresh : that is to say Mbs likely to be background blocks.
       */
      if (cpi->cyclic_refresh_map[i] == 0) {
        seg_map[i] = 1;
        block_count--;
      } else if (cpi->cyclic_refresh_map[i] < 0) {
        cpi->cyclic_refresh_map[i]++;
      }

      i++;
      if (i == mbs_in_frame) i = 0;

    } while (block_count && i != cpi->cyclic_refresh_mode_index);

    cpi->cyclic_refresh_mode_index = i;

#if CONFIG_TEMPORAL_DENOISING
    if (cpi->oxcf.noise_sensitivity > 0) {
      if (cpi->denoiser.denoiser_mode == kDenoiserOnYUVAggressive &&
          Q < (int)cpi->denoiser.denoise_pars.qp_thresh &&
          (cpi->frames_since_key >
           2 * cpi->denoiser.denoise_pars.consec_zerolast)) {
        // Under aggressive denoising, use segmentation to turn off loop
        // filter below some qp thresh. The filter is reduced for all
        // blocks that have been encoded as ZEROMV LAST x frames in a row,
        // where x is set by cpi->denoiser.denoise_pars.consec_zerolast.
        // This is to avoid "dot" artifacts that can occur from repeated
        // loop filtering on noisy input source.
        cpi->cyclic_refresh_q = Q;
        // lf_adjustment = -MAX_LOOP_FILTER;
        lf_adjustment = -40;
        for (i = 0; i < mbs_in_frame; ++i) {
          seg_map[i] = (cpi->consec_zero_last[i] >
                        cpi->denoiser.denoise_pars.consec_zerolast)
                           ? 1
                           : 0;
        }
      }
    }
#endif
  }

  /* Activate segmentation. */
  cpi->mb.e_mbd.update_mb_segmentation_map = 1;
  cpi->mb.e_mbd.update_mb_segmentation_data = 1;
  enable_segmentation(cpi);

  /* Set up the quant segment data */
  feature_data[MB_LVL_ALT_Q][0] = 0;
  feature_data[MB_LVL_ALT_Q][1] = (cpi->cyclic_refresh_q - Q);
  feature_data[MB_LVL_ALT_Q][2] = 0;
  feature_data[MB_LVL_ALT_Q][3] = 0;

  /* Set up the loop segment data */
  feature_data[MB_LVL_ALT_LF][0] = 0;
  feature_data[MB_LVL_ALT_LF][1] = lf_adjustment;
  feature_data[MB_LVL_ALT_LF][2] = 0;
  feature_data[MB_LVL_ALT_LF][3] = 0;

  /* Initialise the feature data structure */
  set_segment_data(cpi, &feature_data[0][0], SEGMENT_DELTADATA);
}
