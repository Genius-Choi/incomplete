mg_close_connection(struct mg_connection *conn)
{
#if defined(USE_WEBSOCKET)
	struct mg_context *client_ctx = NULL;
#endif /* defined(USE_WEBSOCKET) */

	if ((conn == NULL) || (conn->phys_ctx == NULL)) {
		return;
	}

#if defined(USE_WEBSOCKET)
	if (conn->phys_ctx->context_type == CONTEXT_SERVER) {
		if (conn->in_websocket_handling) {
			/* Set close flag, so the server thread can exit. */
			conn->must_close = 1;
			return;
		}
	}
	if (conn->phys_ctx->context_type == CONTEXT_WS_CLIENT) {

		unsigned int i;

		/* ws/wss client */
		client_ctx = conn->phys_ctx;

		/* client context: loops must end */
		client_ctx->stop_flag = 1;
		conn->must_close = 1;

		/* We need to get the client thread out of the select/recv call
		 * here. */
		/* Since we use a sleep quantum of some seconds to check for recv
		 * timeouts, we will just wait a few seconds in mg_join_thread. */

		/* join worker thread */
		for (i = 0; i < client_ctx->cfg_worker_threads; i++) {
			if (client_ctx->worker_threadids[i] != 0) {
				mg_join_thread(client_ctx->worker_threadids[i]);
			}
		}
	}
#endif /* defined(USE_WEBSOCKET) */

	close_connection(conn);

#if !defined(NO_SSL)
	if (conn->client_ssl_ctx != NULL) {
		SSL_CTX_free((SSL_CTX *)conn->client_ssl_ctx);
	}
#endif

#if defined(USE_WEBSOCKET)
	if (client_ctx != NULL) {
		/* free context */
		mg_free(client_ctx->worker_threadids);
		mg_free(client_ctx);
		(void)pthread_mutex_destroy(&conn->mutex);
		mg_free(conn);
	} else if (conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT) {
		mg_free(conn);
	}
#else
	if (conn->phys_ctx->context_type == CONTEXT_HTTP_CLIENT) { /* Client */
		mg_free(conn);
	}
#endif /* defined(USE_WEBSOCKET) */
}
