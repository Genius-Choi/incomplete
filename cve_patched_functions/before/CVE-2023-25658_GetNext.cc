Status IteratorResource::GetNext(OpKernelContext* ctx,
                                 std::vector<Tensor>* out_tensors,
                                 bool* end_of_sequence) {
  std::shared_ptr<State> captured_state;
  {
    tf_shared_lock l(mu_);
    captured_state = iterator_state_;
  }
  auto iterator = captured_state->iterator();
  if (!iterator) {
    return errors::FailedPrecondition(
        "GetNext() failed because the iterator has not been initialized. "
        "Ensure that you have run the initializer operation for this iterator "
        "before getting the next element.");
  }
  auto* dataset = captured_state->dataset();
  IteratorContext::Params params(ctx);
  params.cancellation_manager = captured_state->cancellation_manager();
  params.flr = captured_state->flr();
  params.function_handle_cache = captured_state->function_handle_cache();
  params.resource_mgr = captured_state->resource_mgr();
  params.symbolic_checkpoint = SymbolicCheckpointEnabled(dataset->options());
  params.thread_factory = unbounded_thread_pool_.get_thread_factory();
  params.thread_pool = &unbounded_thread_pool_;
  std::function<void()> deregister_fn;
  TF_RETURN_IF_ERROR(RegisterCancellationCallback(
      ctx->cancellation_manager(),
      [cm = params.cancellation_manager]() { cm->StartCancel(); },
      &deregister_fn));
  auto cleanup = gtl::MakeCleanup(std::move(deregister_fn));
  IteratorContext iter_ctx(std::move(params));
  const absl::Time start_time = metrics_collector_.RecordStart();
  auto status = iterator->GetNext(&iter_ctx, out_tensors, end_of_sequence);
  metrics_collector_.RecordStop(start_time, *out_tensors);
  const int64_t get_next_latency_micros =
      env_.NowMicros() - absl::ToUnixMicros(start_time);
  tf_dataz_metrics_collector_->RecordGetNextLatency(get_next_latency_micros);
  captured_state->MergeCheckpoint(iter_ctx.checkpoint());
  return status;
}
