std::vector<WinCert> read_certs(peparse::parsed_pe *pe) {
  if (pe == nullptr) {
    return {};
  }

  std::vector<std::uint8_t> raw_cert_table;
  if (!peparse::GetDataDirectoryEntry(pe, peparse::DIR_SECURITY, raw_cert_table)) {
    return {};
  }

  /* The certificate table is composed of 8-byte aligned entries, each of which looks like this:
   *
   * dwLength (uint32_t): length of the raw certificate data
   * wRevision (uint16_t): the certificate revision number
   * wCertificateType (uint16_t): the kind of data in this certificate entry
   * bCertificate (uint8_t[dwLength - 8]): the raw certificate data in this entry
   */
  std::vector<WinCert> certs;
  auto *current_wincert = raw_cert_table.data();
  auto const *const past_secdir = raw_cert_table.data() + raw_cert_table.size();
  // Let us tread carefully, we expect all members of WIN_CERTIFICATE up to bCertificate
  while (current_wincert + 8 < past_secdir) {
    size_t offset = 0;
    std::uint32_t length = *reinterpret_cast<std::uint32_t *>(current_wincert + offset);
    offset += sizeof(length);

    std::uint16_t revision = *reinterpret_cast<std::uint16_t *>(current_wincert + offset);
    offset += sizeof(revision);

    std::uint16_t type = *reinterpret_cast<std::uint16_t *>(current_wincert + offset);
    offset += sizeof(type);

    // Continue only we can satisfy the length
    if (current_wincert + length <= past_secdir && length > offset) {
      std::vector<std::uint8_t> cert_data(current_wincert + offset, current_wincert + length);

      certs.emplace_back(static_cast<certificate_revision>(revision),
                         static_cast<certificate_type>(type),
                         cert_data);
    }

    current_wincert += std::max<std::size_t>(round(length, 8), 8);
  }

  return certs;
}
