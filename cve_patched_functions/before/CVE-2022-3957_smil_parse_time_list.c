static void smil_parse_time_list(GF_Node *e, GF_List *values, char *begin_or_end_list)
{
	SMIL_Time *value;
	char value_string[1025];
	char *str = begin_or_end_list, *tmp;
	u32 len;

	/* get rid of leading spaces */
	while (*str == ' ') str++;

	value_string[1024] = 0;
	while (1) {
		tmp = strchr(str, ';');
		if (tmp) len = (u32) (tmp-str);
		else len = (u32) strlen(str);
		if (len>1024) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[SVG Parsing] SMIL time list attribute too long, max supported 1024 bytes\n"));
			goto err;
		}
		memcpy(value_string, str, len);
		while ((len > 0) && (value_string[len - 1] == ' '))
			len--;
		value_string[len] = 0;

		GF_SAFEALLOC(value, SMIL_Time)
		if (!value) break;
		gf_list_add(values, value);

		if (smil_parse_time(e, value, value_string) != GF_OK) goto err;

		if (!tmp) break;

		str = tmp + 1;
		while (*str == ' ') str++;
	}

	/* sorting timing values */
	if (gf_list_count(values) > 1) {
		SMIL_Time *sv;
		GF_List *sorted = gf_list_new();
		u32 i, count;
		do {
			u8 added = 0;
			SMIL_Time *v = (SMIL_Time*)gf_list_get(values, 0);
			gf_list_rem(values, 0);

			count = gf_list_count(sorted);
			for (i=0; i<count; i++) {
				sv = (SMIL_Time*)gf_list_get(sorted, i);
				if (v->type >= GF_SMIL_TIME_EVENT) {
					/* unresolved or indefinite so add at the end of the sorted list */
					gf_list_add(sorted, v);
					added = 1;
					break;
				} else {
					if (sv->type >= GF_SMIL_TIME_EVENT) {
						gf_list_insert(sorted, v, i);
						added = 1;
						break;
					} else {
						if (v->clock <= sv->clock) {
							gf_list_insert(sorted, v, i);
							added = 1;
							break;
						}
					}
				}
			}
			if (!added) gf_list_add(sorted, v);
		} while (gf_list_count(values) > 0);

		count = gf_list_count(sorted);
		for (i = 0; i < count; i++) {
			gf_list_add(values, gf_list_get(sorted, i));
		}
		gf_list_del(sorted);
	}
	return;

err:
	/* See SVG spec:
	"If the 'begin' attribute is
	syntactically invalid, in the list itself or in any of the individual
	list values, it is equivalent to a single 'begin' value of 'indefinite'."*/
	len = gf_list_count(values);
	while (len) {
		SMIL_Time *v = (SMIL_Time*)gf_list_get(values, 0);
		if (v->element_id) gf_free(v->element_id);
		gf_list_rem(values, 0);
		gf_free(v);
		len--;
	}

	GF_SAFEALLOC(value, SMIL_Time)
	if (!value) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[SVG Parsing] Fail to allocate SMIL time\n"));
		return;
	}

	gf_list_add(values, value);

	switch (e->sgprivate->tag) {
	case TAG_SVG_discard:
		value->type = GF_SMIL_TIME_CLOCK;
		value->clock = 0;
		break;
	default:
		value->type = GF_SMIL_TIME_INDEFINITE;
		break;
	}
	return;
}
