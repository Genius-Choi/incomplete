void apply_gridfit(
    image_desc_t *im)
{
    if (isnan(im->minval) || isnan(im->maxval))
        return;
    ytr(im, DNAN);
    if (im->logarithmic) {
        double    ya, yb, ypix, ypixfrac;
        double    log10_range = log10(im->maxval) - log10(im->minval);

        ya = pow((double) 10, floor(log10(im->minval)));
        while (ya < im->minval)
            ya *= 10;
        if (ya > im->maxval)
            return;     /* don't have y=10^x gridline */
        yb = ya * 10;
        if (yb <= im->maxval) {
            /* we have at least 2 y=10^x gridlines.
               Make sure distance between them in pixels
               are an integer by expanding im->maxval */
            double    y_pixel_delta = ytr(im, ya) - ytr(im, yb);
            double    factor = y_pixel_delta / floor(y_pixel_delta);
            double    new_log10_range = factor * log10_range;
            double    new_ymax_log10 = log10(im->minval) + new_log10_range;

            im->maxval = pow(10, new_ymax_log10);
            ytr(im, DNAN);  /* reset precalc */
            log10_range = log10(im->maxval) - log10(im->minval);
        }
        /* make sure first y=10^x gridline is located on
           integer pixel position by moving scale slightly
           downwards (sub-pixel movement) */
        ypix = ytr(im, ya) + im->ysize; /* add im->ysize so it always is positive */
        ypixfrac = ypix - floor(ypix);
        if (ypixfrac > 0 && ypixfrac < 1) {
            double    yfrac = ypixfrac / im->ysize;

            im->minval = pow(10, log10(im->minval) - yfrac * log10_range);
            im->maxval = pow(10, log10(im->maxval) - yfrac * log10_range);
            ytr(im, DNAN);  /* reset precalc */
        }
    } else {
        /* Make sure we have an integer pixel distance between
           each minor gridline */
        double    ypos1 = ytr(im, im->minval);
        double    ypos2 = ytr(im, im->minval + im->ygrid_scale.gridstep);
        double    y_pixel_delta = ypos1 - ypos2;
        double    factor = y_pixel_delta / floor(y_pixel_delta);
        double    new_range = factor * (im->maxval - im->minval);
        double    gridstep = im->ygrid_scale.gridstep;
        double    minor_y, minor_y_px, minor_y_px_frac;

        if (im->maxval > 0.0)
            im->maxval = im->minval + new_range;
        else
            im->minval = im->maxval - new_range;
        ytr(im, DNAN);  /* reset precalc */
        /* make sure first minor gridline is on integer pixel y coord */
        minor_y = gridstep * floor(im->minval / gridstep);
        while (minor_y < im->minval)
            minor_y += gridstep;
        minor_y_px = ytr(im, minor_y) + im->ysize;  /* ensure > 0 by adding ysize */
        minor_y_px_frac = minor_y_px - floor(minor_y_px);
        if (minor_y_px_frac > 0 && minor_y_px_frac < 1) {
            double    yfrac = minor_y_px_frac / im->ysize;
            double    range = im->maxval - im->minval;

            im->minval = im->minval - yfrac * range;
            im->maxval = im->maxval - yfrac * range;
            ytr(im, DNAN);  /* reset precalc */
        }
        calc_horizontal_grid(im);   /* recalc with changed im->maxval */
    }
}
