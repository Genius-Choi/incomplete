consider_acl(struct hmap *lflows, struct ovn_datapath *od,
             struct nbrec_acl *acl, bool has_stateful, bool ct_masked_mark,
             const struct shash *meter_groups, struct ds *match,
             struct ds *actions)
{
    const char *ct_blocked_match = ct_masked_mark
                                   ? "ct_mark.blocked"
                                   : "ct_label.blocked";
    bool ingress = !strcmp(acl->direction, "from-lport") ? true :false;
    enum ovn_stage stage;

    if (ingress && smap_get_bool(&acl->options, "apply-after-lb", false)) {
        stage = S_SWITCH_IN_ACL_AFTER_LB;
    } else if (ingress) {
        stage = S_SWITCH_IN_ACL;
    } else {
        stage = S_SWITCH_OUT_ACL;
    }

    if (!strcmp(acl->action, "allow-stateless")) {
        ds_clear(actions);
        build_acl_log(actions, acl, meter_groups);
        ds_put_cstr(actions, "next;");
        ovn_lflow_add_with_hint(lflows, od, stage,
                                acl->priority + OVN_ACL_PRI_OFFSET,
                                acl->match, ds_cstr(actions),
                                &acl->header_);
    } else if (!strcmp(acl->action, "allow")
        || !strcmp(acl->action, "allow-related")) {
        /* If there are any stateful flows, we must even commit "allow"
         * actions.  This is because, while the initiater's
         * direction may not have any stateful rules, the server's
         * may and then its return traffic would not have an
         * associated conntrack entry and would return "+invalid". */
        if (!has_stateful) {
            ds_clear(actions);
            build_acl_log(actions, acl, meter_groups);
            ds_put_cstr(actions, "next;");
            ovn_lflow_add_with_hint(lflows, od, stage,
                                    acl->priority + OVN_ACL_PRI_OFFSET,
                                    acl->match, ds_cstr(actions),
                                    &acl->header_);
        } else {
            /* Commit the connection tracking entry if it's a new
             * connection that matches this ACL.  After this commit,
             * the reply traffic is allowed by a flow we create at
             * priority 65535, defined earlier.
             *
             * It's also possible that a known connection was marked for
             * deletion after a policy was deleted, but the policy was
             * re-added while that connection is still known.  We catch
             * that case here and un-set ct_mark.blocked (which will be done
             * by ct_commit in the "stateful" stage) to indicate that the
             * connection should be allowed to resume.
             */
            ds_clear(match);
            ds_clear(actions);
            ds_put_format(match, REGBIT_ACL_HINT_ALLOW_NEW " == 1 && (%s)",
                          acl->match);

            ds_put_cstr(actions, REGBIT_CONNTRACK_COMMIT" = 1; ");
            if (acl->label) {
                ds_put_format(actions, REGBIT_ACL_LABEL" = 1; "
                              REG_LABEL" = %"PRId64"; ", acl->label);
            }
            build_acl_log(actions, acl, meter_groups);
            ds_put_cstr(actions, "next;");
            ovn_lflow_add_with_hint(lflows, od, stage,
                                    acl->priority + OVN_ACL_PRI_OFFSET,
                                    ds_cstr(match),
                                    ds_cstr(actions),
                                    &acl->header_);

            /* Match on traffic in the request direction for an established
             * connection tracking entry that has not been marked for
             * deletion. We use this to ensure that this
             * connection is still allowed by the currently defined
             * policy. Match untracked packets too.
             * Commit the connection only if the ACL has a label. This is done
             * to update the connection tracking entry label in case the ACL
             * allowing the connection changes. */
            ds_clear(match);
            ds_clear(actions);
            ds_put_format(match, REGBIT_ACL_HINT_ALLOW " == 1 && (%s)",
                          acl->match);
            if (acl->label) {
                ds_put_cstr(actions, REGBIT_CONNTRACK_COMMIT" = 1; ");
                ds_put_format(actions, REGBIT_ACL_LABEL" = 1; "
                              REG_LABEL" = %"PRId64"; ", acl->label);
            }
            build_acl_log(actions, acl, meter_groups);
            ds_put_cstr(actions, "next;");
            ovn_lflow_add_with_hint(lflows, od, stage,
                                    acl->priority + OVN_ACL_PRI_OFFSET,
                                    ds_cstr(match), ds_cstr(actions),
                                    &acl->header_);

            /* Related and reply traffic are universally allowed by priority
             * 65532 flows created in build_acls(). If logging is enabled on
             * the ACL, then we need to ensure that the related and reply
             * traffic is logged, so we install a slightly higher-priority
             * flow that matches the ACL, allows the traffic, and logs it.
             *
             * Note: Matching the ct_label.label may prevent OVS flow HW
             * offloading to work for some NICs because masked-access of
             * ct_label is not supported on those NICs due to HW
             * limitations. In such case the user may choose to avoid using the
             * "log-related" option.
             */
            bool log_related = smap_get_bool(&acl->options, "log-related",
                                             false);
            if (acl->log && acl->label && log_related) {
                /* Related/reply flows need to be set on the opposite pipeline
                 * from where the ACL itself is set.
                 */
                enum ovn_stage log_related_stage = ingress ?
                    S_SWITCH_OUT_ACL :
                    S_SWITCH_IN_ACL;
                ds_clear(match);
                ds_clear(actions);

                ds_put_format(match, "ct.est && !ct.rel && !ct.new%s && "
                              "ct.rpl && %s == 0 && "
                              "ct_label.label == %" PRId64,
                              use_ct_inv_match ? " && !ct.inv" : "",
                              ct_blocked_match, acl->label);
                build_acl_log(actions, acl, meter_groups);
                ds_put_cstr(actions, "next;");
                ovn_lflow_add_with_hint(lflows, od, log_related_stage,
                                        UINT16_MAX - 2,
                                        ds_cstr(match), ds_cstr(actions),
                                        &acl->header_);

                ds_clear(match);
                ds_put_format(match, "!ct.est && ct.rel && !ct.new%s && "
                                     "%s == 0 && "
                                     "ct_label.label == %" PRId64,
                                     use_ct_inv_match ? " && !ct.inv" : "",
                                     ct_blocked_match, acl->label);
                ovn_lflow_add_with_hint(lflows, od, log_related_stage,
                                        UINT16_MAX - 2,
                                        ds_cstr(match), ds_cstr(actions),
                                        &acl->header_);
            }

        }
    } else if (!strcmp(acl->action, "drop")
               || !strcmp(acl->action, "reject")) {
        /* The implementation of "drop" differs if stateful ACLs are in
         * use for this datapath.  In that case, the actions differ
         * depending on whether the connection was previously committed
         * to the connection tracker with ct_commit. */
        if (has_stateful) {
            /* If the packet is not tracked or not part of an established
             * connection, then we can simply reject/drop it. */
            ds_clear(match);
            ds_clear(actions);
            ds_put_cstr(match, REGBIT_ACL_HINT_DROP " == 1");
            if (!strcmp(acl->action, "reject")) {
                build_reject_acl_rules(od, lflows, stage, acl, match,
                                       actions, &acl->header_, meter_groups);
            } else {
                ds_put_format(match, " && (%s)", acl->match);
                build_acl_log(actions, acl, meter_groups);
                ds_put_cstr(actions, debug_implicit_drop_action());
                ovn_lflow_add_with_hint(lflows, od, stage,
                                        acl->priority + OVN_ACL_PRI_OFFSET,
                                        ds_cstr(match), ds_cstr(actions),
                                        &acl->header_);
            }
            /* For an existing connection without ct_mark.blocked set, we've
             * encountered a policy change. ACLs previously allowed
             * this connection and we committed the connection tracking
             * entry.  Current policy says that we should drop this
             * connection.  First, we set ct_mark.blocked to indicate
             * that this connection is set for deletion.  By not
             * specifying "next;", we implicitly drop the packet after
             * updating conntrack state.  We would normally defer
             * ct_commit() to the "stateful" stage, but since we're
             * rejecting/dropping the packet, we go ahead and do it here.
             */
            ds_clear(match);
            ds_clear(actions);
            ds_put_cstr(match, REGBIT_ACL_HINT_BLOCK " == 1");
            ds_put_format(actions, "ct_commit { %s = 1; }; ",
                          ct_blocked_match);
            if (!strcmp(acl->action, "reject")) {
                build_reject_acl_rules(od, lflows, stage, acl, match,
                                       actions, &acl->header_, meter_groups);
            } else {
                ds_put_format(match, " && (%s)", acl->match);
                build_acl_log(actions, acl, meter_groups);
                ds_put_cstr(actions, debug_implicit_drop_action());
                ovn_lflow_add_with_hint(lflows, od, stage,
                                        acl->priority + OVN_ACL_PRI_OFFSET,
                                        ds_cstr(match), ds_cstr(actions),
                                        &acl->header_);
            }
        } else {
            /* There are no stateful ACLs in use on this datapath,
             * so a "reject/drop" ACL is simply the "reject/drop"
             * logical flow action in all cases. */
            ds_clear(match);
            ds_clear(actions);
            if (!strcmp(acl->action, "reject")) {
                build_reject_acl_rules(od, lflows, stage, acl, match,
                                       actions, &acl->header_, meter_groups);
            } else {
                build_acl_log(actions, acl, meter_groups);
                ds_put_cstr(actions, debug_implicit_drop_action());
                ovn_lflow_add_with_hint(lflows, od, stage,
                                        acl->priority + OVN_ACL_PRI_OFFSET,
                                        acl->match, ds_cstr(actions),
                                        &acl->header_);
            }
        }
    }
}
