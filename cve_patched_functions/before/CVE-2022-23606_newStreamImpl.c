ConnectionPool::Cancellable* ConnPoolImplBase::newStreamImpl(AttachContext& context,
                                                             bool can_send_early_data) {
  ASSERT(!is_draining_for_deletion_);
  ASSERT(!deferred_deleting_);

  ASSERT(static_cast<ssize_t>(connecting_stream_capacity_) ==
         connectingCapacity(connecting_clients_)); // O(n) debug check.
  if (!ready_clients_.empty()) {
    ActiveClient& client = *ready_clients_.front();
    ENVOY_CONN_LOG(debug, "using existing connection", client);
    attachStreamToClient(client, context);
    // Even if there's a ready client, we may want to preconnect to handle the next incoming stream.
    tryCreateNewConnections();
    return nullptr;
  }

  if (!host_->cluster().resourceManager(priority_).pendingRequests().canCreate()) {
    ENVOY_LOG(debug, "max pending streams overflow");
    onPoolFailure(nullptr, absl::string_view(), ConnectionPool::PoolFailureReason::Overflow,
                  context);
    host_->cluster().stats().upstream_rq_pending_overflow_.inc();
    return nullptr;
  }

  ConnectionPool::Cancellable* pending = newPendingStream(context, can_send_early_data);
  ENVOY_LOG(debug, "trying to create new connection");
  ENVOY_LOG(trace, fmt::format("{}", *this));

  auto old_capacity = connecting_stream_capacity_;
  // This must come after newPendingStream() because this function uses the
  // length of pending_streams_ to determine if a new connection is needed.
  const ConnectionResult result = tryCreateNewConnections();
  // If there is not enough connecting capacity, the only reason to not
  // increase capacity is if the connection limits are exceeded.
  ENVOY_BUG(pending_streams_.size() <= connecting_stream_capacity_ ||
                connecting_stream_capacity_ > old_capacity ||
                (result == ConnectionResult::NoConnectionRateLimited ||
                 result == ConnectionResult::FailedToCreateConnection),
            fmt::format("Failed to create expected connection: {}", *this));
  if (result == ConnectionResult::FailedToCreateConnection) {
    // This currently only happens for HTTP/3 if secrets aren't yet loaded.
    // Trigger connection failure.
    pending->cancel(Envoy::ConnectionPool::CancelPolicy::CloseExcess);
    onPoolFailure(nullptr, absl::string_view(), ConnectionPool::PoolFailureReason::Overflow,
                  context);
    return nullptr;
  }

  return pending;
}
