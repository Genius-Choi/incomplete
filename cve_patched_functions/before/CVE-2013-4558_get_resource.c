get_resource(request_rec *r,
             const char *root_path,
             const char *label,
             int use_checked_in,
             dav_resource **resource)
{
  const char *fs_path;
  const char *repo_name;
  const char *xslt_uri;
  const char *fs_parent_path;
  dav_resource_combined *comb;
  dav_svn_repos *repos;
  const char *cleaned_uri;
  const char *repo_basename;
  const char *relative;
  const char *repos_path;
  const char *repos_key;
  const char *version_name;
  svn_error_t *serr;
  dav_error *err;
  int had_slash;
  dav_locktoken_list *ltl;
  struct cleanup_fs_access_baton *cleanup_baton;
  void *userdata;
  apr_hash_t *fs_config;

  repo_name = dav_svn__get_repo_name(r);
  xslt_uri = dav_svn__get_xslt_uri(r);
  fs_parent_path = dav_svn__get_fs_parent_path(r);

  /* Special case: detect and build the SVNParentPath as a unique type
     of private resource, iff the SVNListParentPath directive is 'on'. */
  if (dav_svn__is_parentpath_list(r))
    {
      err = get_parentpath_resource(r, resource);
      if (err)
        return err;
      return NULL;
    }

  /* This does all the work of interpreting/splitting the request uri. */
  err = dav_svn_split_uri(r, r->uri, root_path,
                          &cleaned_uri, &had_slash,
                          &repo_basename, &relative, &repos_path);
  if (err)
    return err;

  /* The path that we will eventually try to open as an svn
     repository.  Normally defined by the SVNPath directive. */
  fs_path = dav_svn__get_fs_path(r);

  /* If the SVNParentPath directive was used instead... */
  if (fs_parent_path != NULL)
    {
      /* ...then the URL to the repository is actually one implicit
         component longer... */
      root_path = svn_urlpath__join(root_path, repo_basename, r->pool);
      /* ...and we need to specify exactly what repository to open. */
      fs_path = svn_dirent_join(fs_parent_path, repo_basename, r->pool);
    }

  /* Start building and filling a 'combination' object. */
  comb = apr_pcalloc(r->pool, sizeof(*comb));
  comb->res.info = &comb->priv;
  comb->res.hooks = &dav_svn__hooks_repository;
  comb->res.pool = r->pool;
  comb->res.uri = cleaned_uri;

  /* Original request, off which to generate subrequests later. */
  comb->priv.r = r;

  /* ### ugly hack to carry over Content-Type data to the open_stream, which
     ### does not have access to the request headers. */
  {
    const char *ct = apr_table_get(r->headers_in, "content-type");

    comb->priv.is_svndiff =
      ct != NULL
      && strcmp(ct, SVN_SVNDIFF_MIME_TYPE) == 0;
  }

  negotiate_encoding_prefs(r, &comb->priv.svndiff_version);

  /* ### and another hack for computing diffs to send to the client */
  comb->priv.delta_base = apr_table_get(r->headers_in,
                                        SVN_DAV_DELTA_BASE_HEADER);

  /* Gather any options requested by an svn client. */
  comb->priv.svn_client_options = apr_table_get(r->headers_in,
                                                SVN_DAV_OPTIONS_HEADER);

  /* See if the client sent a custom 'version name' request header. */
  version_name = apr_table_get(r->headers_in, SVN_DAV_VERSION_NAME_HEADER);
  comb->priv.version_name
    = version_name ? SVN_STR_TO_REV(version_name): SVN_INVALID_REVNUM;

  /* Remember checksums, if any. */
  comb->priv.base_checksum =
    apr_table_get(r->headers_in, SVN_DAV_BASE_FULLTEXT_MD5_HEADER);
  comb->priv.result_checksum =
    apr_table_get(r->headers_in, SVN_DAV_RESULT_FULLTEXT_MD5_HEADER);

  /* "relative" is part of the "uri" string, so it has the proper
     lifetime to store here. */
  /* ### that comment no longer applies. we're creating a string with its
     ### own lifetime now. so WHY are we using a string? hmm... */
  comb->priv.uri_path = svn_stringbuf_create(relative, r->pool);

  /* initialize this until we put something real here */
  comb->priv.root.rev = SVN_INVALID_REVNUM;

  /* create the repository structure and stash it away */
  repos = apr_pcalloc(r->pool, sizeof(*repos));
  repos->pool = r->pool;

  comb->priv.repos = repos;

  /* We are assuming the root_path will live at least as long as this
     resource. Considering that it typically comes from the per-dir
     config in mod_dav, this is valid for now. */
  repos->root_path = svn_path_uri_encode(root_path, r->pool);

  /* where is the SVN FS for this resource? */
  repos->fs_path = fs_path;

  /* A name for the repository */
  repos->repo_name = repo_name;

  /* The repository filesystem basename */
  repos->repo_basename = repo_basename;

  /* An XSL transformation */
  repos->xslt_uri = xslt_uri;

  /* Is autoversioning active in this repos? */
  repos->autoversioning = dav_svn__get_autoversioning_flag(r);

  /* Are bulk updates allowed in this repos? */
  repos->bulk_updates = dav_svn__get_bulk_updates_flag(r);

  /* Are we advertising HTTP v2 protocol support? */
  repos->v2_protocol = dav_svn__check_httpv2_support(r);

  /* Path to activities database */
  repos->activities_db = dav_svn__get_activities_db(r);
  if (repos->activities_db == NULL)
    /* If not specified, use default ($repos/dav/activities.d). */
    repos->activities_db = svn_dirent_join(repos->fs_path,
                                         DEFAULT_ACTIVITY_DB,
                                         r->pool);
  else if (fs_parent_path != NULL)
    /* If this is a ParentPath-based repository, treat the specified
       path as a similar parent directory. */
    repos->activities_db = svn_dirent_join(repos->activities_db,
                                           svn_dirent_basename(repos->fs_path,
                                                               r->pool),
                                           r->pool);

  /* Remember various bits for later URL construction */
  repos->base_url = ap_construct_url(r->pool, "", r);
  repos->special_uri = dav_svn__get_special_uri(r);

  /* Remember who is making this request */
  repos->username = r->user;

  /* Allocate room for capabilities, but don't search for any until
     we know that this is a Subversion client. */
  repos->client_capabilities = apr_hash_make(repos->pool);

  /* Remember if the requesting client is a Subversion client, and if
     so, what its capabilities are. */
  {
    const char *val = apr_table_get(r->headers_in, "User-Agent");

    if (val && (ap_strstr_c(val, "SVN/") == val))
      {
        repos->is_svn_client = TRUE;

        /* Client capabilities are self-reported.  There is no
           guarantee the client actually has the capabilities it says
           it has, we just assume it is in the client's interests to
           report accurately.  Also, we only remember the capabilities
           the server cares about (even though the client may send
           more than that). */

        /* Start out assuming no capabilities. */
        svn_hash_sets(repos->client_capabilities,
                      SVN_RA_CAPABILITY_MERGEINFO,
                      capability_no);

        /* Then see what we can find. */
        val = apr_table_get(r->headers_in, "DAV");
        if (val)
          {
            apr_array_header_t *vals
              = svn_cstring_split(val, ",", TRUE, r->pool);

            if (svn_cstring_match_list(SVN_DAV_NS_DAV_SVN_MERGEINFO, vals))
              {
                svn_hash_sets(repos->client_capabilities,
                              SVN_RA_CAPABILITY_MERGEINFO, capability_yes);
              }
          }
      }
  }

  /* Retrieve/cache open repository */
  repos_key = apr_pstrcat(r->pool, "mod_dav_svn:", fs_path, SVN_VA_NULL);
  apr_pool_userdata_get(&userdata, repos_key, r->connection->pool);
  repos->repos = userdata;
  if (repos->repos == NULL)
    {
      const char *fs_type;

      /* construct FS configuration parameters */
      fs_config = apr_hash_make(r->connection->pool);
      svn_hash_sets(fs_config, SVN_FS_CONFIG_FSFS_CACHE_DELTAS,
                    dav_svn__get_txdelta_cache_flag(r) ? "1" :"0");
      svn_hash_sets(fs_config, SVN_FS_CONFIG_FSFS_CACHE_FULLTEXTS,
                    dav_svn__get_fulltext_cache_flag(r) ? "1" :"0");
      svn_hash_sets(fs_config, SVN_FS_CONFIG_FSFS_CACHE_REVPROPS,
                    dav_svn__get_revprop_cache_flag(r) ? "1" :"0");

      /* Disallow BDB/event until issue 4157 is fixed. */
      if (!strcmp(ap_show_mpm(), "event"))
        {
          serr = svn_repos__fs_type(&fs_type, fs_path, r->connection->pool);
          if (serr)
            {
              /* svn_repos_open2 is going to fail, use that error. */
              svn_error_clear(serr);
              serr = NULL;
            }
          else if (!strcmp(fs_type, "bdb"))
            serr = svn_error_createf(SVN_ERR_UNSUPPORTED_FEATURE, NULL,
                                     "BDB repository at '%s' is not compatible "
                                     "with event MPM",
                                     fs_path);
        }
      else
        serr = NULL;

      /* open the FS */
      if (!serr)
        serr = svn_repos_open2(&(repos->repos), fs_path, fs_config,
                               r->connection->pool);
      if (serr != NULL)
        {
          /* The error returned by svn_repos_open2 might contain the
             actual path to the failed repository.  We don't want to
             leak that path back to the client, because that would be
             a security risk, but we do want to log the real error on
             the server side. */
          return dav_svn__sanitize_error(serr, "Could not open the requested "
                                         "SVN filesystem",
                                         HTTP_INTERNAL_SERVER_ERROR, r);
        }

      /* Cache the open repos for the next request on this connection */
      apr_pool_userdata_set(repos->repos, repos_key,
                            NULL, r->connection->pool);

      /* Store the capabilities of the current connection, making sure
         to use the same pool repos->repos itself was created in. */
      serr = svn_repos_remember_client_capabilities
        (repos->repos, capabilities_as_list(repos->client_capabilities,
                                            r->connection->pool));
      if (serr != NULL)
        {
          return dav_svn__sanitize_error(serr,
                                         "Error storing client capabilities "
                                         "in repos object",
                                         HTTP_INTERNAL_SERVER_ERROR, r);
        }

      /* Configure hook script environment variables. */
      serr = svn_repos_hooks_setenv(repos->repos, dav_svn__get_hooks_env(r),
                                    r->pool);
      if (serr)
        return dav_svn__sanitize_error(serr,
                                       "Error settings hooks environment",
                                       HTTP_INTERNAL_SERVER_ERROR, r);
    }

  /* cache the filesystem object */
  repos->fs = svn_repos_fs(repos->repos);

  /* capture warnings during cleanup of the FS */
  svn_fs_set_warning_func(repos->fs, log_warning, r);

  /* if an authenticated username is present, attach it to the FS */
  if (r->user)
    {
      svn_fs_access_t *access_ctx;

      /* The fs is cached in connection->pool, but the fs access
         context lives in r->pool.  Because the username or token
         could change on each request, we need to make sure that the
         fs points to a NULL access context after the request is gone. */
      cleanup_baton = apr_pcalloc(r->pool, sizeof(*cleanup_baton));
      cleanup_baton->pool = r->pool;
      cleanup_baton->fs = repos->fs;
      apr_pool_cleanup_register(r->pool, cleanup_baton, cleanup_fs_access,
                                apr_pool_cleanup_null);

      /* Create an access context based on the authenticated username. */
      serr = svn_fs_create_access(&access_ctx, r->user, r->pool);
      if (serr)
        {
          return dav_svn__sanitize_error(serr,
                                         "Could not create fs access context",
                                         HTTP_INTERNAL_SERVER_ERROR, r);
        }

      /* Attach the access context to the fs. */
      serr = svn_fs_set_access(repos->fs, access_ctx);
      if (serr)
        {
          return dav_svn__sanitize_error(serr, "Could not attach access "
                                         "context to fs",
                                         HTTP_INTERNAL_SERVER_ERROR, r);
        }
    }

  /* Look for locktokens in the "If:" request header. */
  err = dav_get_locktoken_list(r, &ltl);

  /* dav_get_locktoken_list claims to return a NULL list when no
     locktokens are present.  But it actually throws this error
     instead!  So we're deliberately trapping/ignoring it.

     This is a workaround for a bug in mod_dav.  Remove this when the
     bug is fixed in mod_dav.  See Subversion Issue #2248 */
  if (err && (err->error_id != DAV_ERR_IF_ABSENT))
    return err;

  /* If one or more locktokens are present in the header, push them
     into the filesystem access context. */
  if (ltl)
    {
      svn_fs_access_t *access_ctx;
      dav_locktoken_list *list = ltl;

      serr = svn_fs_get_access(&access_ctx, repos->fs);
      if (serr || !access_ctx)
        {
          if (serr == NULL)
            serr = svn_error_create(SVN_ERR_FS_LOCK_OWNER_MISMATCH, NULL, NULL);
          return dav_svn__sanitize_error(serr, "Lock token is in request, "
                                         "but no user name",
                                         HTTP_BAD_REQUEST, r);
        }

      do {
        /* Note the path/lock pairs are only for lock token checking
           in access, and the relative path is not actually accurate
           as it contains the !svn bits.  However, we're using only
           the tokens anyway (for access control). */

        serr = svn_fs_access_add_lock_token2(access_ctx, relative,
                                             list->locktoken->uuid_str);

        if (serr)
          return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                      "Error pushing token into filesystem.",
                                      r->pool);
        list = list->next;

      } while (list);
    }


  /* Figure out the type of the resource. Note that we have a PARSE step
     which is separate from a PREP step. This is because the PARSE can
     map multiple URLs to the same resource type. The PREP operates on
     the type of the resource. */

  /* skip over the leading "/" in the relative URI */
  if (parse_uri(comb, relative + 1, label, use_checked_in))
    goto malformed_URI;

  /* Check for a query string on a regular-type resource; this allows
     us to discover and parse  a "universal" rev-path URI of the form
     "path?[r=REV][&p=PEGREV]" */
  if ((comb->res.type == DAV_RESOURCE_TYPE_REGULAR)
      && (r->parsed_uri.query != NULL)
      && ((err = parse_querystring(r, r->parsed_uri.query, comb, r->pool))))
    return err;

#ifdef SVN_DEBUG
  if (comb->res.type == DAV_RESOURCE_TYPE_UNKNOWN)
    {
      /* Unknown URI. Return NULL to indicate "no resource" */
      DBG0("DESIGN FAILURE: should not be UNKNOWN at this point");
      *resource = NULL;
      return NULL;
    }
#endif

  /* prepare the resource for operation */
  if ((err = prep_resource(comb)) != NULL)
    return err;

  /* a GET request for a REGULAR collection resource MUST have a trailing
     slash. Redirect to include one if it does not. */
  if (comb->res.collection && comb->res.type == DAV_RESOURCE_TYPE_REGULAR
      && !had_slash && r->method_number == M_GET)
    {
      const char *new_path = apr_pstrcat(r->pool,
                                         ap_escape_uri(r->pool, r->uri),
                                         "/",
                                         r->args ? "?" : "",
                                         r->args ? r->args : "",
                                         SVN_VA_NULL);
      apr_table_setn(r->headers_out, "Location",
                     ap_construct_url(r->pool, new_path, r));
      return dav_svn__new_error(r->pool, HTTP_MOVED_PERMANENTLY, 0,
                                "Requests for a collection must have a "
                                "trailing slash on the URI.");
    }

  /* HTTPv2: for write-requests, out-of-dateness checks happen via
     Base-Version header rather via CHECKOUT requests.

     If a Base-Version header is present on a write request, we need
     to do the out-of-dateness check *here*, rather than in other
     dav-provider vtable funcs.  That's because a number of mod_dav
     methods annoyingly trap and genericize our error messages.  */
  if ((err = do_out_of_date_check(comb, r)) != NULL)
    return err;

  *resource = &comb->res;
  return NULL;

 malformed_URI:
  /* A malformed URI error occurs when a URI indicates the "special" area,
     yet it has an improper construction. Generally, this is because some
     doofus typed it in manually or has a buggy client. */
  /* ### pick something other than HTTP_INTERNAL_SERVER_ERROR */
  /* ### are SVN_ERR_APMOD codes within the right numeric space? */
  return dav_svn__new_error(r->pool, HTTP_INTERNAL_SERVER_ERROR,
                            SVN_ERR_APMOD_MALFORMED_URI,
                            "The URI indicated a resource within Subversion's "
                            "special resource area, but does not exist. This "
                            "is generally caused by a problem in the client "
                            "software.");
}
