int pico_ipv4_frame_push(struct pico_stack *S, struct pico_frame *f, struct pico_ip4 *dst, uint8_t proto)
{

    struct pico_ipv4_route *route;
    struct pico_ipv4_link *link;
    struct pico_ipv4_hdr *hdr;
    uint8_t ttl = PICO_IPV4_DEFAULT_TTL;
    uint8_t vhl = 0x45; /* version 4, header length 20 */
#ifdef PICO_SUPPORT_MCAST
    struct pico_tree_node *index;
#endif

    if (!f || !dst) {
        pico_err = PICO_ERR_EINVAL;
        goto drop;
    }


    hdr = (struct pico_ipv4_hdr *) f->net_hdr;
    if (!hdr) {
        dbg("IP header error\n");
        pico_err = PICO_ERR_EINVAL;
        goto drop;
    }

    if (dst->addr == 0) {
        dbg("IP destination addr error\n");
        pico_err = PICO_ERR_EINVAL;
        goto drop;
    }

    route = route_find(S, dst);
    if (!route) {
        /* dbg("Route to %08x not found.\n", long_be(dst->addr)); */


        pico_err = PICO_ERR_EHOSTUNREACH;
        goto drop;
    } else {
        link = route->link;
#ifdef PICO_SUPPORT_MCAST
        if (pico_ipv4_is_multicast(dst->addr)) { /* if multicast */
            switch (proto) {
            case PICO_PROTO_UDP:
                if (pico_udp_get_mc_ttl(f->sock, &ttl) < 0)
                    ttl = PICO_IP_DEFAULT_MULTICAST_TTL;

                break;
#ifdef PICO_SUPPORT_IGMP
            case PICO_PROTO_IGMP:
                vhl = 0x46; /* header length 24 */
                ttl = 1;
                /* router alert (RFC 2113) */
                hdr->options[0] = 0x94;
                hdr->options[1] = 0x04;
                hdr->options[2] = 0x00;
                hdr->options[3] = 0x00;
                if (f->dev && link->dev != f->dev) { /* default link is not requested link */
                    pico_tree_foreach(index, &S->Tree_dev_link) {
                        link = index->keyValue;
                        if (link->dev == f->dev)
                            break;
                    }
                }

                break;
#endif
            default:
                ttl = PICO_IPV4_DEFAULT_TTL;
            }
        }

#endif
    }

    hdr->vhl = vhl;
    hdr->len = short_be((uint16_t)(f->transport_len + f->net_len));
    hdr->id = short_be(S->ipv4_progressive_id);

    if (
#ifdef PICO_SUPPORT_IPV4FRAG
        (0 == (f->frag & PICO_IPV4_MOREFRAG))  &&
#endif
        1 )
        S->ipv4_progressive_id++;

    if (f->send_ttl > 0) {
        ttl = f->send_ttl;
    }

    hdr->dst.addr = dst->addr;
    hdr->src.addr = link->address.addr;
    hdr->ttl = ttl;
    hdr->tos = f->send_tos;
    hdr->proto = proto;
    hdr->frag = short_be(PICO_IPV4_DONTFRAG);

#ifdef PICO_SUPPORT_IPV4FRAG
#  ifdef PICO_SUPPORT_UDP
    if (proto == PICO_PROTO_UDP) {
        /* first fragment, can not use transport_len to calculate IP length */
        if (f->transport_hdr != f->payload)
            hdr->len = short_be((uint16_t)(f->payload_len + sizeof(struct pico_udp_hdr) + f->net_len));

        /* set fragmentation flags and offset calculated in socket layer */
        hdr->frag = short_be(f->frag);
    }

    if (proto == PICO_PROTO_ICMP4)
    {
        hdr->frag = short_be(f->frag);
    }

#   endif
#endif /* PICO_SUPPORT_IPV4FRAG */
    pico_ipv4_checksum(f);

    if (f->sock && f->sock->dev) {
        /* if the socket has its device set, use that (currently used for DHCP) */
        f->dev = f->sock->dev;
    } else {
        f->dev = link->dev;
        if (f->sock)
            f->sock->dev = f->dev;
    }

#ifdef PICO_SUPPORT_MCAST
    if (pico_ipv4_is_multicast(hdr->dst.addr)) {
        struct pico_frame *cpy;
        int retval;
        /* Sending UDP multicast datagram, am I member? If so, loopback copy */
        if ((proto != PICO_PROTO_IGMP) && (pico_ipv4_mcast_filter(S,f) == 0)) {
            ip_mcast_dbg("MCAST: sender is member of group, loopback copy\n");
            cpy = pico_frame_copy(f);
            if (!cpy) {
                pico_err = PICO_ERR_ENOMEM;
                ip_mcast_dbg("MCAST: Failed to copy frame\n");
                goto drop;
            }

            retval = pico_enqueue(&S->q_ipv4.in, cpy);
            if (retval <= 0)
                pico_frame_discard(cpy);
        }
    }

#endif

/* #ifdef PICO_SUPPORT_AODV */
#if 0
    {
        union pico_address node_address;
        node_address.ip4.addr = hdr->dst.addr;
        if(hdr->dst.addr && pico_ipv4_is_unicast(hdr->dst.addr))
            pico_aodv_lookup(&node_address);
    }
#endif

    if (pico_ipv4_link_get(S, &hdr->dst)) {
        /* it's our own IP */
        return pico_enqueue(&S->q_ipv4.in, f);
    } else{
        /* TODO: Check if there are members subscribed here */
        return pico_enqueue(&S->q_ipv4.out, f);
    }

drop:
    pico_frame_discard(f);
    return -1;
}
