void vp8_change_config(VP8_COMP *cpi, VP8_CONFIG *oxcf) {
  VP8_COMMON *cm = &cpi->common;
  int last_w, last_h;
  unsigned int prev_number_of_layers;
  unsigned int raw_target_rate;

  if (!cpi) return;

  if (!oxcf) return;

  if (cm->version != oxcf->Version) {
    cm->version = oxcf->Version;
    vp8_setup_version(cm);
  }

  last_w = cpi->oxcf.Width;
  last_h = cpi->oxcf.Height;
  prev_number_of_layers = cpi->oxcf.number_of_layers;

  cpi->oxcf = *oxcf;

  switch (cpi->oxcf.Mode) {
    case MODE_REALTIME:
      cpi->pass = 0;
      cpi->compressor_speed = 2;

      if (cpi->oxcf.cpu_used < -16) {
        cpi->oxcf.cpu_used = -16;
      }

      if (cpi->oxcf.cpu_used > 16) cpi->oxcf.cpu_used = 16;

      break;

    case MODE_GOODQUALITY:
      cpi->pass = 0;
      cpi->compressor_speed = 1;

      if (cpi->oxcf.cpu_used < -5) {
        cpi->oxcf.cpu_used = -5;
      }

      if (cpi->oxcf.cpu_used > 5) cpi->oxcf.cpu_used = 5;

      break;

    case MODE_BESTQUALITY:
      cpi->pass = 0;
      cpi->compressor_speed = 0;
      break;

    case MODE_FIRSTPASS:
      cpi->pass = 1;
      cpi->compressor_speed = 1;
      break;
    case MODE_SECONDPASS:
      cpi->pass = 2;
      cpi->compressor_speed = 1;

      if (cpi->oxcf.cpu_used < -5) {
        cpi->oxcf.cpu_used = -5;
      }

      if (cpi->oxcf.cpu_used > 5) cpi->oxcf.cpu_used = 5;

      break;
    case MODE_SECONDPASS_BEST:
      cpi->pass = 2;
      cpi->compressor_speed = 0;
      break;
  }

  if (cpi->pass == 0) cpi->auto_worst_q = 1;

  cpi->oxcf.worst_allowed_q = q_trans[oxcf->worst_allowed_q];
  cpi->oxcf.best_allowed_q = q_trans[oxcf->best_allowed_q];
  cpi->oxcf.cq_level = q_trans[cpi->oxcf.cq_level];

  if (oxcf->fixed_q >= 0) {
    if (oxcf->worst_allowed_q < 0) {
      cpi->oxcf.fixed_q = q_trans[0];
    } else {
      cpi->oxcf.fixed_q = q_trans[oxcf->worst_allowed_q];
    }

    if (oxcf->alt_q < 0) {
      cpi->oxcf.alt_q = q_trans[0];
    } else {
      cpi->oxcf.alt_q = q_trans[oxcf->alt_q];
    }

    if (oxcf->key_q < 0) {
      cpi->oxcf.key_q = q_trans[0];
    } else {
      cpi->oxcf.key_q = q_trans[oxcf->key_q];
    }

    if (oxcf->gold_q < 0) {
      cpi->oxcf.gold_q = q_trans[0];
    } else {
      cpi->oxcf.gold_q = q_trans[oxcf->gold_q];
    }
  }

  cpi->ext_refresh_frame_flags_pending = 0;

  cpi->baseline_gf_interval =
      cpi->oxcf.alt_freq ? cpi->oxcf.alt_freq : DEFAULT_GF_INTERVAL;

  // GF behavior for 1 pass CBR, used when error_resilience is off.
  if (!cpi->oxcf.error_resilient_mode &&
      cpi->oxcf.end_usage == USAGE_STREAM_FROM_SERVER &&
      cpi->oxcf.Mode == MODE_REALTIME)
    cpi->baseline_gf_interval = cpi->gf_interval_onepass_cbr;

#if (CONFIG_REALTIME_ONLY & CONFIG_ONTHEFLY_BITPACKING)
  cpi->oxcf.token_partitions = 3;
#endif

  if (cpi->oxcf.token_partitions >= 0 && cpi->oxcf.token_partitions <= 3) {
    cm->multi_token_partition = (TOKEN_PARTITION)cpi->oxcf.token_partitions;
  }

  setup_features(cpi);

  if (!cpi->use_roi_static_threshold) {
    int i;
    for (i = 0; i < MAX_MB_SEGMENTS; ++i) {
      cpi->segment_encode_breakout[i] = cpi->oxcf.encode_breakout;
    }
  }

  /* At the moment the first order values may not be > MAXQ */
  if (cpi->oxcf.fixed_q > MAXQ) cpi->oxcf.fixed_q = MAXQ;

  /* local file playback mode == really big buffer */
  if (cpi->oxcf.end_usage == USAGE_LOCAL_FILE_PLAYBACK) {
    cpi->oxcf.starting_buffer_level = 60000;
    cpi->oxcf.optimal_buffer_level = 60000;
    cpi->oxcf.maximum_buffer_size = 240000;
    cpi->oxcf.starting_buffer_level_in_ms = 60000;
    cpi->oxcf.optimal_buffer_level_in_ms = 60000;
    cpi->oxcf.maximum_buffer_size_in_ms = 240000;
  }

  raw_target_rate = (unsigned int)((int64_t)cpi->oxcf.Width * cpi->oxcf.Height *
                                   8 * 3 * cpi->framerate / 1000);
  if (cpi->oxcf.target_bandwidth > raw_target_rate)
    cpi->oxcf.target_bandwidth = raw_target_rate;
  /* Convert target bandwidth from Kbit/s to Bit/s */
  cpi->oxcf.target_bandwidth *= 1000;

  cpi->oxcf.starting_buffer_level = rescale(
      (int)cpi->oxcf.starting_buffer_level, cpi->oxcf.target_bandwidth, 1000);

  /* Set or reset optimal and maximum buffer levels. */
  if (cpi->oxcf.optimal_buffer_level == 0) {
    cpi->oxcf.optimal_buffer_level = cpi->oxcf.target_bandwidth / 8;
  } else {
    cpi->oxcf.optimal_buffer_level = rescale(
        (int)cpi->oxcf.optimal_buffer_level, cpi->oxcf.target_bandwidth, 1000);
  }

  if (cpi->oxcf.maximum_buffer_size == 0) {
    cpi->oxcf.maximum_buffer_size = cpi->oxcf.target_bandwidth / 8;
  } else {
    cpi->oxcf.maximum_buffer_size = rescale((int)cpi->oxcf.maximum_buffer_size,
                                            cpi->oxcf.target_bandwidth, 1000);
  }
  // Under a configuration change, where maximum_buffer_size may change,
  // keep buffer level clipped to the maximum allowed buffer size.
  if (cpi->bits_off_target > cpi->oxcf.maximum_buffer_size) {
    cpi->bits_off_target = cpi->oxcf.maximum_buffer_size;
    cpi->buffer_level = cpi->bits_off_target;
  }

  /* Set up frame rate and related parameters rate control values. */
  vp8_new_framerate(cpi, cpi->framerate);

  /* Set absolute upper and lower quality limits */
  cpi->worst_quality = cpi->oxcf.worst_allowed_q;
  cpi->best_quality = cpi->oxcf.best_allowed_q;

  /* active values should only be modified if out of new range */
  if (cpi->active_worst_quality > cpi->oxcf.worst_allowed_q) {
    cpi->active_worst_quality = cpi->oxcf.worst_allowed_q;
  }
  /* less likely */
  else if (cpi->active_worst_quality < cpi->oxcf.best_allowed_q) {
    cpi->active_worst_quality = cpi->oxcf.best_allowed_q;
  }
  if (cpi->active_best_quality < cpi->oxcf.best_allowed_q) {
    cpi->active_best_quality = cpi->oxcf.best_allowed_q;
  }
  /* less likely */
  else if (cpi->active_best_quality > cpi->oxcf.worst_allowed_q) {
    cpi->active_best_quality = cpi->oxcf.worst_allowed_q;
  }

  cpi->buffered_mode = cpi->oxcf.optimal_buffer_level > 0;

  cpi->cq_target_quality = cpi->oxcf.cq_level;

  /* Only allow dropped frames in buffered mode */
  cpi->drop_frames_allowed = cpi->oxcf.allow_df && cpi->buffered_mode;

  cpi->target_bandwidth = cpi->oxcf.target_bandwidth;

  // Check if the number of temporal layers has changed, and if so reset the
  // pattern counter and set/initialize the temporal layer context for the
  // new layer configuration.
  if (cpi->oxcf.number_of_layers != prev_number_of_layers) {
    // If the number of temporal layers are changed we must start at the
    // base of the pattern cycle, so set the layer id to 0 and reset
    // the temporal pattern counter.
    if (cpi->temporal_layer_id > 0) {
      cpi->temporal_layer_id = 0;
    }
    cpi->temporal_pattern_counter = 0;
    vp8_reset_temporal_layer_change(cpi, oxcf, prev_number_of_layers);
  }

  if (!cpi->initial_width) {
    cpi->initial_width = cpi->oxcf.Width;
    cpi->initial_height = cpi->oxcf.Height;
  }

  cm->Width = cpi->oxcf.Width;
  cm->Height = cpi->oxcf.Height;
  assert(cm->Width <= cpi->initial_width);
  assert(cm->Height <= cpi->initial_height);

  /* TODO(jkoleszar): if an internal spatial resampling is active,
   * and we downsize the input image, maybe we should clear the
   * internal scale immediately rather than waiting for it to
   * correct.
   */

  /* VP8 sharpness level mapping 0-7 (vs 0-10 in general VPx dialogs) */
  if (cpi->oxcf.Sharpness > 7) cpi->oxcf.Sharpness = 7;

  cm->sharpness_level = cpi->oxcf.Sharpness;

  if (cm->horiz_scale != VP8E_NORMAL || cm->vert_scale != VP8E_NORMAL) {
    int hr, hs, vr, vs;

    Scale2Ratio(cm->horiz_scale, &hr, &hs);
    Scale2Ratio(cm->vert_scale, &vr, &vs);

    /* always go to the next whole number */
    cm->Width = (hs - 1 + cpi->oxcf.Width * hr) / hs;
    cm->Height = (vs - 1 + cpi->oxcf.Height * vr) / vs;
  }

  if (last_w != cpi->oxcf.Width || last_h != cpi->oxcf.Height) {
    cpi->force_next_frame_intra = 1;
  }

  if (((cm->Width + 15) & ~15) != cm->yv12_fb[cm->lst_fb_idx].y_width ||
      ((cm->Height + 15) & ~15) != cm->yv12_fb[cm->lst_fb_idx].y_height ||
      cm->yv12_fb[cm->lst_fb_idx].y_width == 0) {
    dealloc_raw_frame_buffers(cpi);
    alloc_raw_frame_buffers(cpi);
    vp8_alloc_compressor_data(cpi);
  }

  if (cpi->oxcf.fixed_q >= 0) {
    cpi->last_q[0] = cpi->oxcf.fixed_q;
    cpi->last_q[1] = cpi->oxcf.fixed_q;
  }

  cpi->Speed = cpi->oxcf.cpu_used;

  /* force to allowlag to 0 if lag_in_frames is 0; */
  if (cpi->oxcf.lag_in_frames == 0) {
    cpi->oxcf.allow_lag = 0;
  }
  /* Limit on lag buffers as these are not currently dynamically allocated */
  else if (cpi->oxcf.lag_in_frames > MAX_LAG_BUFFERS) {
    cpi->oxcf.lag_in_frames = MAX_LAG_BUFFERS;
  }

  /* YX Temp */
  cpi->alt_ref_source = NULL;
  cpi->is_src_frame_alt_ref = 0;

#if CONFIG_TEMPORAL_DENOISING
  if (cpi->oxcf.noise_sensitivity) {
    if (!cpi->denoiser.yv12_mc_running_avg.buffer_alloc) {
      int width = (cpi->oxcf.Width + 15) & ~15;
      int height = (cpi->oxcf.Height + 15) & ~15;
      if (vp8_denoiser_allocate(&cpi->denoiser, width, height, cm->mb_rows,
                                cm->mb_cols, cpi->oxcf.noise_sensitivity)) {
        vpx_internal_error(&cpi->common.error, VPX_CODEC_MEM_ERROR,
                           "Failed to allocate denoiser");
      }
    }
  }
#endif

#if 0
    /* Experimental RD Code */
    cpi->frame_distortion = 0;
    cpi->last_frame_distortion = 0;
#endif
}
