ordinaryHasInstance(Runtime &runtime, Handle<> constructor, Handle<> object) {
  // 1. If IsCallable(C) is false, return false.
  if (!vmisa<Callable>(*constructor)) {
    return false;
  }

  Callable *ctor = vmcast<Callable>(*constructor);

  BoundFunction *bound;
  // 2. If C has a [[BoundTargetFunction]] internal slot, then
  while (LLVM_UNLIKELY(bound = dyn_vmcast<BoundFunction>(ctor))) {
    // 2a. Let BC be the value of Câ€™s [[BoundTargetFunction]] internal slot.
    // 2b. Return InstanceofOperator(O,BC) (see 12.9.4).
    // Note that we can do this with the loop instead,
    // because bound->getTarget() must be a Callable, and Callables cannot
    // redefine @@hasInstance (non-configurable).
    // Callables call this function directly from their @@hasInstance
    // function.
    ctor = bound->getTarget(runtime);
  }

  // At this point 'ctor' is the actual function with a prototype.
  assert(ctor != nullptr && "ctor must not be null");

  // 3. If Type(O) is not Object, return false.
  if (LLVM_UNLIKELY(!object->isObject())) {
    return false;
  }

  // 4. Let P be Get(C, "prototype").
  auto propRes = JSObject::getNamed_RJS(
      runtime.makeHandle(ctor),
      runtime,
      Predefined::getSymbolID(Predefined::prototype));
  if (LLVM_UNLIKELY(propRes == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }

  // 5. If Type(P) is not Object, throw a TypeError exception.
  Handle<JSObject> ctorPrototype = runtime.makeHandle(
      PseudoHandle<JSObject>::dyn_vmcast(std::move(*propRes)));
  if (LLVM_UNLIKELY(!ctorPrototype)) {
    return runtime.raiseTypeError(
        "function's '.prototype' is not an object in 'instanceof'");
  }

  // 6.1.7.3 Invariants of the Essential Internal Methods notes that
  // detection of infinite prototype chains is not enforceable as an
  // invariant if exotic objects exist in the chain.  Most of the
  // time, ScopedNativeDepthTracker will detect this. Here, we need to
  // check that we're not repeating forever.  Since ordinary object
  // chains are verified at the time the parent is set, we count Proxy
  // objects.  Thus, any length chain of ordinary objects is ok.
  constexpr unsigned int kMaxProxyCount = 1024;
  unsigned int proxyCount = 0;
  MutableHandle<JSObject> head{runtime, vmcast<JSObject>(object.get())};
  GCScopeMarkerRAII gcScope{runtime};
  // 6. Repeat
  while (true) {
    // 6a. Let O be O.[[GetPrototypeOf]]().
    CallResult<PseudoHandle<JSObject>> parentRes =
        JSObject::getPrototypeOf(head, runtime);
    if (LLVM_UNLIKELY(parentRes == ExecutionStatus::EXCEPTION)) {
      return ExecutionStatus::EXCEPTION;
    }
    // 6b. If O is null, return false.
    if (!*parentRes) {
      return false;
    }
    // 6c. If SameValue(P, O) is true, return true.
    if (parentRes->get() == ctorPrototype.get()) {
      return true;
    }
    if (head->isProxyObject()) {
      ++proxyCount;
      if (proxyCount > kMaxProxyCount) {
        return runtime.raiseRangeError(
            "Maximum prototype chain length exceeded");
      }
    }
    head = parentRes->get();
    gcScope.flush();
  }
}
