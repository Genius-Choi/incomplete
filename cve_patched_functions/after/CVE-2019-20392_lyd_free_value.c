lyd_free_value(lyd_val value, LY_DATA_TYPE value_type, uint8_t value_flags, struct lys_type *type, lyd_val *old_val,
               LY_DATA_TYPE *old_val_type, uint8_t *old_val_flags)
{
    if (old_val) {
        *old_val = value;
        *old_val_type = value_type;
        *old_val_flags = value_flags;
        /* we only backup the values for now */
        return;
    }

    /* otherwise the value is correctly freed */
    if (value_flags & LY_VALUE_USER) {
        assert(type->der && type->der->module);
        lytype_free(type->der->module, type->der->name, value);
    } else {
        switch (value_type) {
        case LY_TYPE_BITS:
            if (value.bit) {
                free(value.bit);
            }
            break;
        case LY_TYPE_INST:
            if (!(value_flags & LY_VALUE_UNRES)) {
                break;
            }
            /* fallthrough */
        case LY_TYPE_UNION:
            /* unresolved union leaf */
            lydict_remove(type->parent->module->ctx, value.string);
            break;
        default:
            break;
        }
    }
}
