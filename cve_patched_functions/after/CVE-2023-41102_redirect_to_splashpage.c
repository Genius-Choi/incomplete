static int redirect_to_splashpage(struct MHD_Connection *connection, t_client *client, const char *host, const char *url)
{
	char *originurl_raw;
	char *originurl;
	char *query;
	int ret = 0;
	const char *separator = "&";
	char *querystr;

	query = safe_calloc(QUERYMAXLEN);

	if (!query) {
		ret = send_error(connection, 503);
		free(query);
		return ret;
	}

	querystr = safe_calloc(QUERYMAXLEN);

	if (!querystr) {
		ret = send_error(connection, 503);
		free(querystr);
		return ret;
	}

	originurl_raw = safe_calloc(MID_BUF);

	if (!originurl_raw) {
		ret = send_error(connection, 503);
		free(originurl_raw);
		return ret;
	}

	originurl = safe_calloc(CUSTOM_ENC);

	if (!originurl) {
		ret = send_error(connection, 503);
		free(originurl);
		return ret;
	}

	get_query(connection, &query, separator);

	if (!query) {
		debug(LOG_DEBUG, "Unable to get query string - error 503");
		free(query);
		// probably no mem
		return send_error(connection, 503);
	}

	debug(LOG_DEBUG, "Query string is [ %s ]", query);

	safe_asprintf(&originurl_raw, "http://%s%s%s", host, url, query);
	uh_urlencode(originurl, CUSTOM_ENC, originurl_raw, strlen(originurl_raw));

	if (strcmp(url, "/login") == 0) {
		client->cpi_query = safe_strdup(originurl);
		debug(LOG_DEBUG, "RFC8910 request: %s", client->cpi_query);
	}

	debug(LOG_DEBUG, "originurl_raw: %s", originurl_raw);
	debug(LOG_DEBUG, "originurl: %s", originurl);

	querystr=construct_querystring(connection, client, originurl, querystr);
	ret = encode_and_redirect_to_splashpage(connection, client, originurl, querystr);
	free(originurl_raw);
	free(originurl);
	free(query);
	free(querystr);
	return ret;
}
