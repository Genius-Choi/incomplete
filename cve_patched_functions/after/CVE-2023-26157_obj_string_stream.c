obj_string_stream (Bit_Chain *restrict dat, Dwg_Object *restrict obj,
                   Bit_Chain *restrict str)
{
  BITCODE_RL data_size = 0;            // in byte
  BITCODE_RL start = obj->bitsize - 1; // in bits
  size_t old_size;                     // in byte
  size_t old_byte;
  // assert (dat != str); // r2007 objects are the same, just entities not
  old_size = str->size;
  old_byte = str->byte;

  // str->chain += str->byte;
  // obj->strpos = str->byte * 8 + str->bit;

  str->size = (obj->bitsize / 8) + ((obj->bitsize % 8) ? 1 : 0);
  bit_set_position (str, start);

  if (str->byte > old_size - old_byte)
    {
      LOG_ERROR ("obj_string_stream overflow, bitsize " FORMAT_RL
                 " => " FORMAT_RL " (strpos %zu > diff %zu)",
                 obj->bitsize, obj->size * 8, str->byte, old_size - old_byte);
      str->byte = old_byte;
      str->size = old_size;
      obj->has_strings = 0;
      obj->bitsize = obj->size * 8;
      return DWG_ERR_VALUEOUTOFBOUNDS;
    }
  LOG_HANDLE (" obj string stream +" FORMAT_RL ": @%zu.%u (%zu)", start,
              str->byte, str->bit & 7, bit_position (str));
  obj->has_strings = bit_read_B (str);
  LOG_TRACE (" has_strings: %d\n", (int)obj->has_strings);
  if (!obj->has_strings)
    {
      // FIXME wrong bit
      if (obj->fixedtype == DWG_TYPE_SCALE)
        obj->has_strings = 1;
      // str->size = 0;
      // bit_reset_chain (str);
      return 0;
    }

  bit_advance_position (str, -1); //-17
  str->byte -= 2;
  LOG_HANDLE (" @%zu.%u", str->byte, str->bit & 7);
  data_size = (BITCODE_RL)bit_read_RS (str);
  LOG_HANDLE (" data_size: %u/0x%x [RS]", (unsigned)data_size,
              (unsigned)data_size);

  if (data_size & 0x8000)
    {
      BITCODE_RS hi_size;
      str->byte -= 4;
      data_size &= 0x7FFF;
      LOG_HANDLE (" @%zu.%u", str->byte, str->bit & 7);
      hi_size = bit_read_RS (str);
      LOG_HANDLE (" hi_size " FORMAT_RS "/" FORMAT_RSx " [RS]", hi_size,
                  hi_size);
      data_size |= (hi_size << 15);
      LOG_HANDLE (" => data_size: %u/0x%x\n", (unsigned)data_size,
                  (unsigned)data_size);
      // LOG_TRACE("  -33: @%zu\n", str->byte);
    }
  else
    LOG_HANDLE ("\n");
  str->byte -= 2;
  if (data_size > obj->bitsize)
    {
      LOG_WARN ("Invalid string stream data_size %u > bitsize %u at @%zu.%u\n",
                (unsigned)data_size, (unsigned)obj->bitsize, str->byte,
                str->bit & 7);
      if (dat->from_version == R_2007)
        {
          return 0;
        }
      obj->has_strings = 0;
      bit_reset_chain (str);
      return DWG_ERR_NOTYETSUPPORTED; // a very low severity error
    }
  if (data_size < obj->bitsize)
    {
      obj->stringstream_size = data_size;
      bit_advance_position (str, -(int)data_size);
    }
  else
    {
      bit_set_position (str, 0);
    }
  // bit_reset_chain (str);
  // LOG_TRACE(" %d: @%zu.%u (%zu)\n", -(int)data_size - 16, str->byte,
  // str->bit & 7,
  //          bit_position(str));
  // obj->strpos = obj->bitsize_pos + obj->bitsize - obj->stringstream_size;
  return 0;
}
