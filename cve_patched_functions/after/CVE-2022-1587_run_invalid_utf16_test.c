static int run_invalid_utf16_test(const struct invalid_utf16_regression_test_case *current,
	int pattern_index, int i, pcre2_compile_context_16 *ccontext, pcre2_match_data_16 *mdata)
{
	pcre2_code_16 *code;
	int result, errorcode;
	PCRE2_SIZE length, erroroffset;
	const PCRE2_UCHAR16 *input;
	PCRE2_SIZE *ovector = pcre2_get_ovector_pointer_16(mdata);

	if (current->pattern[i] == NULL)
		return 1;

	code = pcre2_compile_16(current->pattern[i], PCRE2_ZERO_TERMINATED,
		current->compile_options, &errorcode, &erroroffset, ccontext);

	if (!code) {
		printf("Pattern[%d:0] cannot be compiled. Error offset: %d\n", pattern_index, (int)erroroffset);
		return 0;
	}

	if (pcre2_jit_compile_16(code, current->jit_compile_options) != 0) {
		printf("Pattern[%d:0] cannot be compiled by the JIT compiler.\n", pattern_index);
		pcre2_code_free_16(code);
		return 0;
	}

	input = current->input;
	length = 0;

	while (*input++ != 0)
		length++;

	length -= current->skip_left + current->skip_right;

	if (current->jit_compile_options & PCRE2_JIT_COMPLETE) {
		result = pcre2_jit_match_16(code, (current->input + current->skip_left),
			length, current->start_offset - current->skip_left, 0, mdata, NULL);

		if (check_invalid_utf_result(pattern_index, "match", result, current->match_start, current->match_end, ovector)) {
			pcre2_code_free_16(code);
			return 0;
		}
	}

	if (current->jit_compile_options & PCRE2_JIT_PARTIAL_SOFT) {
		result = pcre2_jit_match_16(code, (current->input + current->skip_left),
			length, current->start_offset - current->skip_left, PCRE2_PARTIAL_SOFT, mdata, NULL);

		if (check_invalid_utf_result(pattern_index, "partial match", result, current->match_start, current->match_end, ovector)) {
			pcre2_code_free_16(code);
			return 0;
		}
	}

	pcre2_code_free_16(code);
	return 1;
}
