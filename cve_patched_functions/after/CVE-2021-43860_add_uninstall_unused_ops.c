add_uninstall_unused_ops (FlatpakTransaction  *self,
                          GCancellable        *cancellable,
                          GError             **error)
{
  FlatpakTransactionPrivate *priv = flatpak_transaction_get_instance_private (self);
  g_autoptr(GHashTable) metadata_injection = NULL;
  g_autoptr(GHashTable) eol_injection = NULL;
  g_autoptr(GPtrArray) to_be_excluded = NULL;
  g_auto(GStrv) old_unused_refs = NULL;
  g_auto(GStrv) unused_refs = NULL;
  const char * const *to_be_excluded_strv = NULL;
  GList *l, *next;
  int i;

  if (priv->disable_deps)
    return TRUE;

  if (!priv->include_unused_uninstall_ops)
    {
      old_unused_refs = flatpak_dir_list_unused_refs (priv->dir,
                                                      NULL, /* arch */
                                                      NULL, /* metadata_injection */
                                                      NULL, /* eol_injection */
                                                      NULL, /* exclude_refs */
                                                      TRUE, /* filter_by_eol */
                                                      cancellable, error);
      if (old_unused_refs == NULL)
        return FALSE;
    }

  /* This is a mapping from refs to #GKeyFile metadata objects, for each ref
   * being installed or updated by the transaction. This will allows us to
   * calculate what dependencies will be used after those operations are
   * executed. For example an app update may drop an extension point and
   * thereby make an installed extension become unused. */
  metadata_injection = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, NULL);

  eol_injection = g_hash_table_new_full (g_str_hash, g_str_equal, NULL, NULL);

  /* This is the set of runtimes and apps scheduled for uninstallation and
   * which are therefore excluded when calculating used refs. */
  to_be_excluded = g_ptr_array_new ();

  for (l = priv->ops; l != NULL; l = next)
    {
      FlatpakTransactionOperation *op = l->data;
      FlatpakTransactionOperationType op_type = flatpak_transaction_operation_get_operation_type (op);

      next = l->next;

      if (op->skip)
        continue;

      g_assert (op_type == FLATPAK_TRANSACTION_OPERATION_UNINSTALL ||
                op_type == FLATPAK_TRANSACTION_OPERATION_INSTALL ||
                op_type == FLATPAK_TRANSACTION_OPERATION_INSTALL_BUNDLE ||
                op_type == FLATPAK_TRANSACTION_OPERATION_UPDATE);

      if (op_type == FLATPAK_TRANSACTION_OPERATION_UNINSTALL)
        g_ptr_array_add (to_be_excluded, (char *)flatpak_decomposed_get_ref (op->ref));
      else
        {
          if (op->resolved_metakey)
            g_hash_table_insert (metadata_injection, (char *)flatpak_decomposed_get_ref (op->ref), op->resolved_metakey);
          g_hash_table_insert (eol_injection, (char *)flatpak_decomposed_get_ref (op->ref),
                               GINT_TO_POINTER (op->eol != NULL || op->eol_rebase != NULL));
        }
    }

  if (to_be_excluded->len > 0)
    {
      g_ptr_array_add (to_be_excluded, NULL);
      to_be_excluded_strv = (const char * const *) to_be_excluded->pdata;
    }

  /* These are the refs that will be unused & eol after the transaction */
  unused_refs = flatpak_dir_list_unused_refs (priv->dir,
                                              NULL, /* arch */
                                              metadata_injection,
                                              eol_injection,
                                              to_be_excluded_strv,
                                              TRUE, /* filter_by_eol */
                                              cancellable, error);
  if (unused_refs == NULL)
    return FALSE;

  /* Schedule each unused runtime to be uninstalled */
  for (i = 0; unused_refs[i] != NULL; i++)
    {
      FlatpakTransactionOperation *uninstall_op;
      const char *unused_ref_str = unused_refs[i];
      g_autoptr(FlatpakDecomposed) unused_ref = flatpak_decomposed_new_from_ref (unused_ref_str, NULL);
      g_autofree char *origin = NULL;

      if (unused_ref == NULL)
        continue;

      /* Don't uninstall refs that were already unused before the transaction (unless include_unused_uninstall_ops is set) */
      if (old_unused_refs &&
          g_strv_contains ((const char * const*)old_unused_refs, flatpak_decomposed_get_ref (unused_ref)))
        continue;

      origin = flatpak_dir_get_origin (priv->dir, unused_ref, NULL, NULL);
      if (origin)
        {
          /* These get added last and have no dependencies, so will run last */
          uninstall_op = flatpak_transaction_add_op (self, origin, unused_ref,
                                                     NULL, NULL, NULL, NULL,
                                                     FLATPAK_TRANSACTION_OPERATION_UNINSTALL,
                                                     FALSE, NULL);
          if (uninstall_op)
            run_operation_last (uninstall_op);
        }
    }

  return TRUE;
}
