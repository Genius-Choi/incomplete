static int rtp_reload(int reload, int by_external_config)
{
	struct ast_config *cfg;
	const char *s;
	struct ast_flags config_flags = { (reload && !by_external_config) ? CONFIG_FLAG_FILEUNCHANGED : 0 };

#ifdef HAVE_PJPROJECT
	struct ast_variable *var;
	struct ast_ice_host_candidate *candidate;
	int acl_subscription_flag = 0;
#endif

	cfg = ast_config_load2("rtp.conf", "rtp", config_flags);
	if (!cfg || cfg == CONFIG_STATUS_FILEUNCHANGED || cfg == CONFIG_STATUS_FILEINVALID) {
		return 0;
	}

#ifdef SO_NO_CHECK
	nochecksums = 0;
#endif

	rtpstart = DEFAULT_RTP_START;
	rtpend = DEFAULT_RTP_END;
	rtcpinterval = RTCP_DEFAULT_INTERVALMS;
	dtmftimeout = DEFAULT_DTMF_TIMEOUT;
	strictrtp = DEFAULT_STRICT_RTP;
	learning_min_sequential = DEFAULT_LEARNING_MIN_SEQUENTIAL;
	learning_min_duration = DEFAULT_LEARNING_MIN_DURATION;
	srtp_replay_protection = DEFAULT_SRTP_REPLAY_PROTECTION;

	/** This resource is not "reloaded" so much as unloaded and loaded again.
	 * In the case of the TURN related variables, the memory referenced by a
	 * previously loaded instance  *should* have been released when the
	 * corresponding pool was destroyed. If at some point in the future this
	 * resource were to support ACTUAL live reconfiguration and did NOT release
	 * the pool this will cause a small memory leak.
	 */

#ifdef HAVE_PJPROJECT
	icesupport = DEFAULT_ICESUPPORT;
	stun_software_attribute = DEFAULT_STUN_SOFTWARE_ATTRIBUTE;
	turnport = DEFAULT_TURN_PORT;
	clean_stunaddr();
	turnaddr = pj_str(NULL);
	turnusername = pj_str(NULL);
	turnpassword = pj_str(NULL);
	host_candidate_overrides_clear();
#endif

#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)
	dtls_mtu = DEFAULT_DTLS_MTU;
#endif

	if ((s = ast_variable_retrieve(cfg, "general", "rtpstart"))) {
		rtpstart = atoi(s);
		if (rtpstart < MINIMUM_RTP_PORT)
			rtpstart = MINIMUM_RTP_PORT;
		if (rtpstart > MAXIMUM_RTP_PORT)
			rtpstart = MAXIMUM_RTP_PORT;
	}
	if ((s = ast_variable_retrieve(cfg, "general", "rtpend"))) {
		rtpend = atoi(s);
		if (rtpend < MINIMUM_RTP_PORT)
			rtpend = MINIMUM_RTP_PORT;
		if (rtpend > MAXIMUM_RTP_PORT)
			rtpend = MAXIMUM_RTP_PORT;
	}
	if ((s = ast_variable_retrieve(cfg, "general", "rtcpinterval"))) {
		rtcpinterval = atoi(s);
		if (rtcpinterval == 0)
			rtcpinterval = 0; /* Just so we're clear... it's zero */
		if (rtcpinterval < RTCP_MIN_INTERVALMS)
			rtcpinterval = RTCP_MIN_INTERVALMS; /* This catches negative numbers too */
		if (rtcpinterval > RTCP_MAX_INTERVALMS)
			rtcpinterval = RTCP_MAX_INTERVALMS;
	}
	if ((s = ast_variable_retrieve(cfg, "general", "rtpchecksums"))) {
#ifdef SO_NO_CHECK
		nochecksums = ast_false(s) ? 1 : 0;
#else
		if (ast_false(s))
			ast_log(LOG_WARNING, "Disabling RTP checksums is not supported on this operating system!\n");
#endif
	}
	if ((s = ast_variable_retrieve(cfg, "general", "dtmftimeout"))) {
		dtmftimeout = atoi(s);
		if ((dtmftimeout < 0) || (dtmftimeout > 64000)) {
			ast_log(LOG_WARNING, "DTMF timeout of '%d' outside range, using default of '%d' instead\n",
				dtmftimeout, DEFAULT_DTMF_TIMEOUT);
			dtmftimeout = DEFAULT_DTMF_TIMEOUT;
		};
	}
	if ((s = ast_variable_retrieve(cfg, "general", "strictrtp"))) {
		if (ast_true(s)) {
			strictrtp = STRICT_RTP_YES;
		} else if (!strcasecmp(s, "seqno")) {
			strictrtp = STRICT_RTP_SEQNO;
		} else {
			strictrtp = STRICT_RTP_NO;
		}
	}
	if ((s = ast_variable_retrieve(cfg, "general", "probation"))) {
		if ((sscanf(s, "%d", &learning_min_sequential) != 1) || learning_min_sequential <= 1) {
			ast_log(LOG_WARNING, "Value for 'probation' could not be read, using default of '%d' instead\n",
				DEFAULT_LEARNING_MIN_SEQUENTIAL);
			learning_min_sequential = DEFAULT_LEARNING_MIN_SEQUENTIAL;
		}
		learning_min_duration = CALC_LEARNING_MIN_DURATION(learning_min_sequential);
	}
	if ((s = ast_variable_retrieve(cfg, "general", "srtpreplayprotection"))) {
		srtp_replay_protection = ast_true(s);
	}
#ifdef HAVE_PJPROJECT
	if ((s = ast_variable_retrieve(cfg, "general", "icesupport"))) {
		icesupport = ast_true(s);
	}
	if ((s = ast_variable_retrieve(cfg, "general", "stun_software_attribute"))) {
		stun_software_attribute = ast_true(s);
	}
	if ((s = ast_variable_retrieve(cfg, "general", "stunaddr"))) {
		char *hostport, *host, *port;
		unsigned int port_parsed = STANDARD_STUN_PORT;
		struct ast_sockaddr stunaddr_parsed;

		hostport = ast_strdupa(s);

		if (!ast_parse_arg(hostport, PARSE_ADDR, &stunaddr_parsed)) {
			ast_debug_stun(3, "stunaddr = '%s' does not need name resolution\n",
				ast_sockaddr_stringify_host(&stunaddr_parsed));
			if (!ast_sockaddr_port(&stunaddr_parsed)) {
				ast_sockaddr_set_port(&stunaddr_parsed, STANDARD_STUN_PORT);
			}
			ast_rwlock_wrlock(&stunaddr_lock);
			ast_sockaddr_to_sin(&stunaddr_parsed, &stunaddr);
			ast_rwlock_unlock(&stunaddr_lock);
		} else if (ast_sockaddr_split_hostport(hostport, &host, &port, 0)) {
			if (port) {
				ast_parse_arg(port, PARSE_UINT32|PARSE_IN_RANGE, &port_parsed, 1, 65535);
			}
			stunaddr.sin_port = htons(port_parsed);

			stunaddr_resolver = ast_dns_resolve_recurring(host, T_A, C_IN,
				&stunaddr_resolve_callback, NULL);
			if (!stunaddr_resolver) {
				ast_log(LOG_ERROR, "Failed to setup recurring DNS resolution of stunaddr '%s'",
					host);
			}
		} else {
			ast_log(LOG_ERROR, "Failed to parse stunaddr '%s'", hostport);
		}
	}
	if ((s = ast_variable_retrieve(cfg, "general", "turnaddr"))) {
		struct sockaddr_in addr;
		addr.sin_port = htons(DEFAULT_TURN_PORT);
		if (ast_parse_arg(s, PARSE_INADDR, &addr)) {
			ast_log(LOG_WARNING, "Invalid TURN server address: %s\n", s);
		} else {
			pj_strdup2_with_null(pool, &turnaddr, ast_inet_ntoa(addr.sin_addr));
			/* ntohs() is not a bug here. The port number is used in host byte order with
			 * a pjnat API. */
			turnport = ntohs(addr.sin_port);
		}
	}
	if ((s = ast_variable_retrieve(cfg, "general", "turnusername"))) {
		pj_strdup2_with_null(pool, &turnusername, s);
	}
	if ((s = ast_variable_retrieve(cfg, "general", "turnpassword"))) {
		pj_strdup2_with_null(pool, &turnpassword, s);
	}

	AST_RWLIST_WRLOCK(&host_candidates);
	for (var = ast_variable_browse(cfg, "ice_host_candidates"); var; var = var->next) {
		struct ast_sockaddr local_addr, advertised_addr;
		unsigned int include_local_address = 0;
		char *sep;

		ast_sockaddr_setnull(&local_addr);
		ast_sockaddr_setnull(&advertised_addr);

		if (ast_parse_arg(var->name, PARSE_ADDR | PARSE_PORT_IGNORE, &local_addr)) {
			ast_log(LOG_WARNING, "Invalid local ICE host address: %s\n", var->name);
			continue;
		}

		sep = strchr(var->value,',');
		if (sep) {
			*sep = '\0';
			sep++;
			sep = ast_skip_blanks(sep);
			include_local_address = strcmp(sep, "include_local_address") == 0;
		}

		if (ast_parse_arg(var->value, PARSE_ADDR | PARSE_PORT_IGNORE, &advertised_addr)) {
			ast_log(LOG_WARNING, "Invalid advertised ICE host address: %s\n", var->value);
			continue;
		}

		if (!(candidate = ast_calloc(1, sizeof(*candidate)))) {
			ast_log(LOG_ERROR, "Failed to allocate ICE host candidate mapping.\n");
			break;
		}

		candidate->include_local = include_local_address;

		ast_sockaddr_copy(&candidate->local, &local_addr);
		ast_sockaddr_copy(&candidate->advertised, &advertised_addr);

		AST_RWLIST_INSERT_TAIL(&host_candidates, candidate, next);
	}
	AST_RWLIST_UNLOCK(&host_candidates);

	ast_rwlock_wrlock(&ice_acl_lock);
	ast_rwlock_wrlock(&stun_acl_lock);

	ice_acl = ast_free_acl_list(ice_acl);
	stun_acl = ast_free_acl_list(stun_acl);

	for (var = ast_variable_browse(cfg, "general"); var; var = var->next) {
		const char* sense = NULL;
		struct ast_acl_list **acl = NULL;
		if (strncasecmp(var->name, "ice_", 4) == 0) {
			sense = var->name + 4;
			acl = &ice_acl;
		} else if (strncasecmp(var->name, "stun_", 5) == 0) {
			sense = var->name + 5;
			acl = &stun_acl;
		} else {
			continue;
		}

		if (strcasecmp(sense, "blacklist") == 0) {
			sense = "deny";
		}

		if (strcasecmp(sense, "acl") && strcasecmp(sense, "permit") && strcasecmp(sense, "deny")) {
			continue;
		}

		ast_append_acl(sense, var->value, acl, NULL, &acl_subscription_flag);
	}
	ast_rwlock_unlock(&ice_acl_lock);
	ast_rwlock_unlock(&stun_acl_lock);

	if (acl_subscription_flag && !acl_change_sub) {
		acl_change_sub = stasis_subscribe(ast_security_topic(), acl_change_stasis_cb, NULL);
		stasis_subscription_accept_message_type(acl_change_sub, ast_named_acl_change_type());
		stasis_subscription_set_filter(acl_change_sub, STASIS_SUBSCRIPTION_FILTER_SELECTIVE);
	} else if (!acl_subscription_flag && acl_change_sub) {
		acl_change_sub = stasis_unsubscribe_and_join(acl_change_sub);
	}
#endif
#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)
	if ((s = ast_variable_retrieve(cfg, "general", "dtls_mtu"))) {
		if ((sscanf(s, "%d", &dtls_mtu) != 1) || dtls_mtu < 256) {
			ast_log(LOG_WARNING, "Value for 'dtls_mtu' could not be read, using default of '%d' instead\n",
				DEFAULT_DTLS_MTU);
			dtls_mtu = DEFAULT_DTLS_MTU;
		}
	}
#endif

	ast_config_destroy(cfg);

	/* Choosing an odd start port casues issues (like a potential infinite loop) and as odd parts are not
	   chosen anyway, we are going to round up and issue a warning */
	if (rtpstart & 1) {
		rtpstart++;
		ast_log(LOG_WARNING, "Odd start value for RTP port in rtp.conf, rounding up to %d\n", rtpstart);
	}

	if (rtpstart >= rtpend) {
		ast_log(LOG_WARNING, "Unreasonable values for RTP start/end port in rtp.conf\n");
		rtpstart = DEFAULT_RTP_START;
		rtpend = DEFAULT_RTP_END;
	}
	ast_verb(2, "RTP Allocating from port range %d -> %d\n", rtpstart, rtpend);
	return 0;
}
