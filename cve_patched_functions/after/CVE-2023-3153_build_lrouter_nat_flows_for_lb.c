build_lrouter_nat_flows_for_lb(struct ovn_lb_vip *lb_vip,
                               struct ovn_northd_lb *lb,
                               struct ovn_northd_lb_vip *vips_nb,
                               struct hmap *lflows,
                               struct ds *match, struct ds *action,
                               const struct shash *meter_groups,
                               const struct chassis_features *features)
{
    bool ipv4 = lb_vip->address_family == AF_INET;
    const char *ip_match = ipv4 ? "ip4" : "ip6";

    int prio = 110;

    struct ds skip_snat_act = DS_EMPTY_INITIALIZER;
    struct ds force_snat_act = DS_EMPTY_INITIALIZER;
    struct ds undnat_match = DS_EMPTY_INITIALIZER;
    struct ds unsnat_match = DS_EMPTY_INITIALIZER;

    ds_clear(match);
    ds_clear(action);

    bool reject = build_lb_vip_actions(lb_vip, vips_nb, action,
                                       lb->selection_fields, &skip_snat_act,
                                       &force_snat_act, false, features);

    /* Higher priority rules are added for load-balancing in DNAT
     * table.  For every match (on a VIP[:port]), we add two flows.
     * One flow is for specific matching on ct.new with an action
     * of "ct_lb_mark($targets);". The other flow is for ct.est with
     * an action of "next;".
     */
    ds_put_format(match, "ct.new && !ct.rel && %s && %s.dst == %s",
                  ip_match, ip_match, lb_vip->vip_str);
    if (lb_vip->port_str) {
        prio = 120;
        ds_put_format(match, " && %s && %s.dst == %s",
                      lb->proto, lb->proto, lb_vip->port_str);
    }

    /* Add logical flows to UNDNAT the load balanced reverse traffic in
     * the router egress pipleine stage - S_ROUTER_OUT_UNDNAT if the logical
     * router has a gateway router port associated.
     */
    ds_put_format(&undnat_match, "%s && (", ip_match);

    for (size_t i = 0; i < lb_vip->n_backends; i++) {
        struct ovn_lb_backend *backend = &lb_vip->backends[i];
        ds_put_format(&undnat_match, "(%s.src == %s", ip_match,
                      backend->ip_str);

        if (backend->port_str) {
            ds_put_format(&undnat_match, " && %s.src == %s) || ",
                          lb->proto, backend->port_str);
        } else {
            ds_put_cstr(&undnat_match, ") || ");
        }
    }
    /* Remove the trailing " || ". */
    ds_truncate(&undnat_match, undnat_match.length - 4);

    ds_put_format(&unsnat_match, "%s && %s.dst == %s && %s",
                  ip_match, ip_match, lb_vip->vip_str, lb->proto);
    if (lb_vip->port_str) {
        ds_put_format(&unsnat_match, " && %s.dst == %s", lb->proto,
                      lb_vip->port_str);
    }

    struct lrouter_nat_lb_flows_ctx ctx = {
        .lb_vip = lb_vip,
        .lb = lb,
        .reject = reject,
        .prio = prio,
        .lflows = lflows,
        .meter_groups = meter_groups,
        .new_match = match,
        .undnat_match = &undnat_match
    };

    ctx.new_action[LROUTER_NAT_LB_FLOW_NORMAL] = ds_cstr(action);
    ctx.new_action[LROUTER_NAT_LB_FLOW_SKIP_SNAT] = ds_cstr(&skip_snat_act);
    ctx.new_action[LROUTER_NAT_LB_FLOW_FORCE_SNAT] = ds_cstr(&force_snat_act);

    enum {
        LROUTER_NAT_LB_AFF            = LROUTER_NAT_LB_FLOW_MAX,
        LROUTER_NAT_LB_AFF_FORCE_SNAT = LROUTER_NAT_LB_FLOW_MAX + 1,
    };
    unsigned long *dp_bitmap[LROUTER_NAT_LB_FLOW_MAX + 2];

    for (size_t i = 0; i < LROUTER_NAT_LB_FLOW_MAX + 2; i++) {
        dp_bitmap[i] = bitmap_allocate(n_datapaths);
    }

    /* Group gw router since we do not have datapath dependency in
     * lflow generation for them.
     */
    size_t index;
    BITMAP_FOR_EACH_1 (index, n_datapaths, lb->nb_lr_map) {
        struct ovn_datapath *od = datapaths_array[index];
        enum lrouter_nat_lb_flow_type type;

        if (lb->skip_snat) {
            type = LROUTER_NAT_LB_FLOW_SKIP_SNAT;
        } else if (!lport_addresses_is_empty(&od->lb_force_snat_addrs) ||
                   od->lb_force_snat_router_ip) {
            type = LROUTER_NAT_LB_FLOW_FORCE_SNAT;
        } else {
            type = LROUTER_NAT_LB_FLOW_NORMAL;
        }

        if (!od->n_l3dgw_ports) {
            bitmap_set1(dp_bitmap[type], index);
        } else {
            build_distr_lrouter_nat_flows_for_lb(&ctx, type, od);
        }

        if (lb->affinity_timeout) {
            if (!lport_addresses_is_empty(&od->lb_force_snat_addrs) ||
                od->lb_force_snat_router_ip) {
                bitmap_set1(dp_bitmap[LROUTER_NAT_LB_AFF_FORCE_SNAT], index);
            } else {
                bitmap_set1(dp_bitmap[LROUTER_NAT_LB_AFF], index);
            }
        }

        if (sset_contains(&od->external_ips, lb_vip->vip_str)) {
            /* The load balancer vip is also present in the NAT entries.
             * So add a high priority lflow to advance the the packet
             * destined to the vip (and the vip port if defined)
             * in the S_ROUTER_IN_UNSNAT stage.
             * There seems to be an issue with ovs-vswitchd. When the new
             * connection packet destined for the lb vip is received,
             * it is dnat'ed in the S_ROUTER_IN_DNAT stage in the dnat
             * conntrack zone. For the next packet, if it goes through
             * unsnat stage, the conntrack flags are not set properly, and
             * it doesn't hit the established state flows in
             * S_ROUTER_IN_DNAT stage. */
            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_IN_UNSNAT, 120,
                                    ds_cstr(&unsnat_match), "next;",
                                    &lb->nlb->header_);
        }
    }

    for (size_t type = 0; type < LROUTER_NAT_LB_FLOW_MAX; type++) {
        build_gw_lrouter_nat_flows_for_lb(&ctx, type, dp_bitmap[type]);
    }

    /* LB affinity flows for datapaths where CMS has specified
     * force_snat_for_lb floag option.
     */
    build_lb_affinity_lr_flows(lflows, lb, lb_vip, ds_cstr(match),
                               "flags.force_snat_for_lb = 1; ",
                               dp_bitmap[LROUTER_NAT_LB_AFF_FORCE_SNAT]);

    /* LB affinity flows for datapaths where CMS has specified
     * skip_snat_for_lb floag option or regular datapaths.
     */
    char *lb_aff_action =
        lb->skip_snat ? "flags.skip_snat_for_lb = 1; " : NULL;
    build_lb_affinity_lr_flows(lflows, lb, lb_vip, ds_cstr(match),
                               lb_aff_action, dp_bitmap[LROUTER_NAT_LB_AFF]);

    ds_destroy(&unsnat_match);
    ds_destroy(&undnat_match);
    ds_destroy(&skip_snat_act);
    ds_destroy(&force_snat_act);

    for (size_t i = 0; i < LROUTER_NAT_LB_FLOW_MAX + 2; i++) {
        bitmap_free(dp_bitmap[i]);
    }
}
