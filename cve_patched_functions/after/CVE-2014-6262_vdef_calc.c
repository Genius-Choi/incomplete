int vdef_calc(
    image_desc_t *im,
    int gdi)
{
    graph_desc_t *src, *dst;
    rrd_value_t *data;
    long      step, steps;

    dst = &im->gdes[gdi];
    src = &im->gdes[dst->vidx];
    data = src->data + src->ds;

    steps = (src->end - src->start) / src->step;
#if 0
    printf
        ("DEBUG: start == %lu, end == %lu, %lu steps\n",
         src->start, src->end, steps);
#endif
    switch (dst->vf.op) {
    case VDEF_PERCENT:{
        rrd_value_t *array;
        int       field;
        if ((array = (rrd_value_t*)malloc(steps * sizeof(double))) == NULL) {
            rrd_set_error("malloc VDEV_PERCENT");
            return -1;
        }
        for (step = 0; step < steps; step++) {
            array[step] = data[step * src->ds_cnt];
        }
        qsort(array, step, sizeof(double), vdef_percent_compar);
        field = round((dst->vf.param * (double)(steps - 1)) / 100.0);
        dst->vf.val = array[field];
        dst->vf.when = 0;   /* no time component */
        free(array);
#if 0
        for (step = 0; step < steps; step++)
            printf("DEBUG: %3li:%10.2f %c\n",
                   step, array[step], step == field ? '*' : ' ');
#endif
    }
        break;
    case VDEF_PERCENTNAN:{
        rrd_value_t *array;
        int       field;
       /* count number of "valid" values */
       int nancount=0;
       for (step = 0; step < steps; step++) {
         if (!isnan(data[step * src->ds_cnt])) { nancount++; }
       }
       /* and allocate it */
        if ((array = (rrd_value_t*)malloc(nancount * sizeof(double))) == NULL) {
            rrd_set_error("malloc VDEV_PERCENT");
            return -1;
        }
       /* and fill it in */
       field=0;
        for (step = 0; step < steps; step++) {
           if (!isnan(data[step * src->ds_cnt])) {
                array[field] = data[step * src->ds_cnt];
               field++;
            }
        }
        qsort(array, nancount, sizeof(double), vdef_percent_compar);
        field = round( dst->vf.param * (double)(nancount - 1) / 100.0);
        dst->vf.val = array[field];
        dst->vf.when = 0;   /* no time component */
        free(array);
    }
        break;
    case VDEF_MAXIMUM:
        step = 0;
        while (step != steps && isnan(data[step * src->ds_cnt]))
            step++;
        if (step == steps) {
            dst->vf.val = DNAN;
            dst->vf.when = 0;
        } else {
            dst->vf.val = data[step * src->ds_cnt];
            dst->vf.when = src->start + (step + 1) * src->step;
        }
        while (step != steps) {
            if (finite(data[step * src->ds_cnt])) {
                if (data[step * src->ds_cnt] > dst->vf.val) {
                    dst->vf.val = data[step * src->ds_cnt];
                    dst->vf.when = src->start + (step + 1) * src->step;
                }
            }
            step++;
        }
        break;
    case VDEF_TOTAL:
    case VDEF_STDEV:
    case VDEF_AVERAGE:{
        int       cnt = 0;
        double    sum = 0.0;
        double    average = 0.0;

        for (step = 0; step < steps; step++) {
            if (finite(data[step * src->ds_cnt])) {
                sum += data[step * src->ds_cnt];
                cnt++;
            };
        }
        if (cnt) {
            if (dst->vf.op == VDEF_TOTAL) {
                dst->vf.val = sum * src->step;
                dst->vf.when = 0;   /* no time component */
            } else if (dst->vf.op == VDEF_AVERAGE) {
                dst->vf.val = sum / cnt;
                dst->vf.when = 0;   /* no time component */
            } else {
                average = sum / cnt;
                sum = 0.0;
                for (step = 0; step < steps; step++) {
                    if (finite(data[step * src->ds_cnt])) {
                        sum += pow((data[step * src->ds_cnt] - average), 2.0);
                    };
                }
                dst->vf.val = pow(sum / cnt, 0.5);
                dst->vf.when = 0;   /* no time component */
            };
        } else {
            dst->vf.val = DNAN;
            dst->vf.when = 0;
        }
    }
        break;
    case VDEF_MINIMUM:
        step = 0;
        while (step != steps && isnan(data[step * src->ds_cnt]))
            step++;
        if (step == steps) {
            dst->vf.val = DNAN;
            dst->vf.when = 0;
        } else {
            dst->vf.val = data[step * src->ds_cnt];
            dst->vf.when = src->start + (step + 1) * src->step;
        }
        while (step != steps) {
            if (finite(data[step * src->ds_cnt])) {
                if (data[step * src->ds_cnt] < dst->vf.val) {
                    dst->vf.val = data[step * src->ds_cnt];
                    dst->vf.when = src->start + (step + 1) * src->step;
                }
            }
            step++;
        }
        break;
    case VDEF_FIRST:
        /* The time value returned here is one step before the
         * actual time value.  This is the start of the first
         * non-NaN interval.
         */
        step = 0;
        while (step != steps && isnan(data[step * src->ds_cnt]))
            step++;
        if (step == steps) {    /* all entries were NaN */
            dst->vf.val = DNAN;
            dst->vf.when = 0;
        } else {
            dst->vf.val = data[step * src->ds_cnt];
            dst->vf.when = src->start + step * src->step;
        }
        break;
    case VDEF_LAST:
        /* The time value returned here is the
         * actual time value.  This is the end of the last
         * non-NaN interval.
         */
        step = steps - 1;
        while (step >= 0 && isnan(data[step * src->ds_cnt]))
            step--;
        if (step < 0) { /* all entries were NaN */
            dst->vf.val = DNAN;
            dst->vf.when = 0;
        } else {
            dst->vf.val = data[step * src->ds_cnt];
            dst->vf.when = src->start + (step + 1) * src->step;
        }
        break;
    case VDEF_LSLSLOPE:
    case VDEF_LSLINT:
    case VDEF_LSLCORREL:{
        /* Bestfit line by linear least squares method */

        int       cnt = 0;
        double    SUMx, SUMy, SUMxy, SUMxx, SUMyy, slope, y_intercept, correl;

        SUMx = 0;
        SUMy = 0;
        SUMxy = 0;
        SUMxx = 0;
        SUMyy = 0;
        for (step = 0; step < steps; step++) {
            if (finite(data[step * src->ds_cnt])) {
                cnt++;
                SUMx += step;
                SUMxx += step * step;
                SUMxy += step * data[step * src->ds_cnt];
                SUMy += data[step * src->ds_cnt];
                SUMyy += data[step * src->ds_cnt] * data[step * src->ds_cnt];
            };
        }

        slope = (SUMx * SUMy - cnt * SUMxy) / (SUMx * SUMx - cnt * SUMxx);
        y_intercept = (SUMy - slope * SUMx) / cnt;
        correl =
            (SUMxy -
             (SUMx * SUMy) / cnt) /
            sqrt((SUMxx -
                  (SUMx * SUMx) / cnt) * (SUMyy - (SUMy * SUMy) / cnt));
        if (cnt) {
            if (dst->vf.op == VDEF_LSLSLOPE) {
                dst->vf.val = slope;
                dst->vf.when = 0;
            } else if (dst->vf.op == VDEF_LSLINT) {
                dst->vf.val = y_intercept;
                dst->vf.when = 0;
            } else if (dst->vf.op == VDEF_LSLCORREL) {
                dst->vf.val = correl;
                dst->vf.when = 0;
            };
        } else {
            dst->vf.val = DNAN;
            dst->vf.when = 0;
        }
    }
        break;
    }
    return 0;
}
