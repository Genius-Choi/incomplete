build_lrouter_ipv4_ip_input(struct ovn_port *op,
                            struct hmap *lflows,
                            struct ds *match, struct ds *actions,
                            const struct shash *meter_groups)
{
    /* No ingress packets are accepted on a chassisredirect
     * port, so no need to program flows for that port. */
    if (op->nbrp && !is_cr_port(op)) {
        if (op->lrp_networks.n_ipv4_addrs) {
            /* L3 admission control: drop packets that originate from an
             * IPv4 address owned by the router or a broadcast address
             * known to the router (priority 100). */
            ds_clear(match);
            ds_put_cstr(match, "ip4.src == ");
            op_put_v4_networks(match, op, true);
            ds_put_cstr(match, " && "REGBIT_EGRESS_LOOPBACK" == 0");
            ovn_lflow_add_with_hint(lflows, op->od, S_ROUTER_IN_IP_INPUT, 100,
                                    ds_cstr(match), debug_drop_action(),
                                    &op->nbrp->header_);

            /* ICMP echo reply.  These flows reply to ICMP echo requests
             * received for the router's IP address. Since packets only
             * get here as part of the logical router datapath, the inport
             * (i.e. the incoming locally attached net) does not matter.
             * The ip.ttl also does not matter (RFC1812 section 4.2.2.9) */
            ds_clear(match);
            ds_put_cstr(match, "ip4.dst == ");
            op_put_v4_networks(match, op, false);
            ds_put_cstr(match, " && icmp4.type == 8 && icmp4.code == 0");

            const char * icmp_actions = "ip4.dst <-> ip4.src; "
                          "ip.ttl = 255; "
                          "icmp4.type = 0; "
                          "flags.loopback = 1; "
                          "next; ";
            ovn_lflow_add_with_hint(lflows, op->od, S_ROUTER_IN_IP_INPUT, 90,
                                    ds_cstr(match), icmp_actions,
                                    &op->nbrp->header_);
        }

        /* BFD msg handling */
        build_lrouter_bfd_flows(lflows, op, meter_groups);

        /* ICMP time exceeded */
        struct ds ip_ds = DS_EMPTY_INITIALIZER;
        for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {
            ds_clear(match);
            ds_clear(actions);
            ds_clear(&ip_ds);
            if (is_l3dgw_port(op)) {
                ds_put_cstr(&ip_ds, "ip4.dst <-> ip4.src");
            } else {
                ds_put_format(&ip_ds, "ip4.dst = ip4.src; ip4.src = %s",
                              op->lrp_networks.ipv4_addrs[i].addr_s);
            }
            ds_put_format(match,
                          "inport == %s && ip4 && "
                          "ip.ttl == {0, 1} && !ip.later_frag", op->json_key);
            ds_put_format(actions,
                          "icmp4 {"
                          "eth.dst <-> eth.src; "
                          "icmp4.type = 11; /* Time exceeded */ "
                          "icmp4.code = 0; /* TTL exceeded in transit */ "
                          "%s ; ip.ttl = 254; "
                          "outport = %s; flags.loopback = 1; output; };",
                          ds_cstr(&ip_ds), op->json_key);
            ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,
                    31, ds_cstr(match), ds_cstr(actions), NULL,
                    copp_meter_get(COPP_ICMP4_ERR, op->od->nbr->copp,
                                   meter_groups),
                    &op->nbrp->header_);

        }
        ds_destroy(&ip_ds);

        /* ARP reply.  These flows reply to ARP requests for the router's own
         * IP address. */
        for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {
            ds_clear(match);
            ds_put_format(match, "arp.spa == %s/%u",
                          op->lrp_networks.ipv4_addrs[i].network_s,
                          op->lrp_networks.ipv4_addrs[i].plen);

            if (op->od->n_l3dgw_ports && op->peer
                && op->peer->od->n_localnet_ports) {
                bool add_chassis_resident_check = false;
                const char *json_key;
                if (is_l3dgw_port(op)) {
                    /* Traffic with eth.src = l3dgw_port->lrp_networks.ea_s
                     * should only be sent from the gateway chassis, so that
                     * upstream MAC learning points to the gateway chassis.
                     * Also need to avoid generation of multiple ARP responses
                     * from different chassis. */
                    add_chassis_resident_check = true;
                    json_key = op->cr_port->json_key;
                } else {
                    /* Check if the option 'reside-on-redirect-chassis'
                     * is set to true on the router port. If set to true
                     * and if peer's logical switch has a localnet port, it
                     * means the router pipeline for the packets from
                     * peer's logical switch is be run on the chassis
                     * hosting the gateway port and it should reply to the
                     * ARP requests for the router port IPs.
                     */
                    add_chassis_resident_check = smap_get_bool(
                        &op->nbrp->options,
                        "reside-on-redirect-chassis", false) &&
                        op->od->n_l3dgw_ports == 1;
                    json_key = op->od->l3dgw_ports[0]->cr_port->json_key;
                }

                if (add_chassis_resident_check) {
                    ds_put_format(match, " && is_chassis_resident(%s)",
                                  json_key);
                }
            }

            build_lrouter_arp_flow(op->od, op,
                                   op->lrp_networks.ipv4_addrs[i].addr_s,
                                   REG_INPORT_ETH_ADDR, match, false, 90,
                                   &op->nbrp->header_, lflows);
        }

        if (sset_count(&op->od->lb_ips->ips_v4_reachable)) {
            ds_clear(match);
            if (is_l3dgw_port(op)) {
                ds_put_format(match, "is_chassis_resident(%s)",
                              op->cr_port->json_key);
            }

            /* Create a single ARP rule for all IPs that are used as VIPs. */
            char *lb_ips_v4_as = lr_lb_address_set_ref(op->od->tunnel_key,
                                                       AF_INET);
            build_lrouter_arp_flow(op->od, op, lb_ips_v4_as,
                                   REG_INPORT_ETH_ADDR,
                                   match, false, 90, NULL, lflows);
            free(lb_ips_v4_as);
        }

        if (sset_count(&op->od->lb_ips->ips_v6_reachable)) {
            ds_clear(match);

            if (is_l3dgw_port(op)) {
                ds_put_format(match, "is_chassis_resident(%s)",
                              op->cr_port->json_key);
            }

            /* Create a single ND rule for all IPs that are used as VIPs. */
            char *lb_ips_v6_as = lr_lb_address_set_ref(op->od->tunnel_key,
                                                       AF_INET6);
            build_lrouter_nd_flow(op->od, op, "nd_na", lb_ips_v6_as, NULL,
                                  REG_INPORT_ETH_ADDR, match, false, 90,
                                  NULL, lflows, meter_groups);
            free(lb_ips_v6_as);
        }

        if (!op->od->is_gw_router && !op->od->n_l3dgw_ports) {
            /* UDP/TCP/SCTP port unreachable. */
            for (int i = 0; i < op->lrp_networks.n_ipv4_addrs; i++) {
                ds_clear(match);
                ds_put_format(match,
                              "ip4 && ip4.dst == %s && !ip.later_frag && udp",
                              op->lrp_networks.ipv4_addrs[i].addr_s);
                const char *action = "icmp4 {"
                                     "eth.dst <-> eth.src; "
                                     "ip4.dst <-> ip4.src; "
                                     "ip.ttl = 255; "
                                     "icmp4.type = 3; "
                                     "icmp4.code = 3; "
                                     "next; };";
                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,
                                          80, ds_cstr(match), action, NULL,
                                          copp_meter_get(
                                              COPP_ICMP4_ERR,
                                              op->od->nbr->copp,
                                              meter_groups),
                                          &op->nbrp->header_);

                ds_clear(match);
                ds_put_format(match,
                              "ip4 && ip4.dst == %s && !ip.later_frag && tcp",
                              op->lrp_networks.ipv4_addrs[i].addr_s);
                action = "tcp_reset {"
                         "eth.dst <-> eth.src; "
                         "ip4.dst <-> ip4.src; "
                         "next; };";
                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,
                                          80, ds_cstr(match), action, NULL,
                                          copp_meter_get(
                                              COPP_TCP_RESET,
                                              op->od->nbr->copp,
                                              meter_groups),
                                          &op->nbrp->header_);

                ds_clear(match);
                ds_put_format(match,
                              "ip4 && ip4.dst == %s && !ip.later_frag && sctp",
                              op->lrp_networks.ipv4_addrs[i].addr_s);
                action = "sctp_abort {"
                         "eth.dst <-> eth.src; "
                         "ip4.dst <-> ip4.src; "
                         "next; };";
                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,
                                          80, ds_cstr(match), action, NULL,
                                          copp_meter_get(
                                              COPP_TCP_RESET,
                                              op->od->nbr->copp,
                                              meter_groups),
                                          &op->nbrp->header_);

                ds_clear(match);
                ds_put_format(match,
                              "ip4 && ip4.dst == %s && !ip.later_frag",
                              op->lrp_networks.ipv4_addrs[i].addr_s);
                action = "icmp4 {"
                         "eth.dst <-> eth.src; "
                         "ip4.dst <-> ip4.src; "
                         "ip.ttl = 255; "
                         "icmp4.type = 3; "
                         "icmp4.code = 2; "
                         "next; };";
                ovn_lflow_add_with_hint__(lflows, op->od, S_ROUTER_IN_IP_INPUT,
                                          70, ds_cstr(match), action, NULL,
                                          copp_meter_get(
                                              COPP_ICMP4_ERR,
                                              op->od->nbr->copp,
                                              meter_groups),
                                          &op->nbrp->header_);
            }
        }

        /* Drop IP traffic destined to router owned IPs except if the IP is
         * also a SNAT IP. Those are dropped later, in stage
         * "lr_in_arp_resolve", if unSNAT was unsuccessful.
         *
         * If op->od->lb_force_snat_router_ip is true, it means the IP of the
         * router port is also SNAT IP.
         *
         * Priority 60.
         */
        if (!op->od->lb_force_snat_router_ip) {
            build_lrouter_drop_own_dest(op, S_ROUTER_IN_IP_INPUT, 60, false,
                                        lflows);
        }
        /* ARP / ND handling for external IP addresses.
         *
         * DNAT and SNAT IP addresses are external IP addresses that need ARP
         * handling.
         *
         * These are already taken care globally, per router. The only
         * exception is on the l3dgw_port where we might need to use a
         * different ETH address.
         */
        if (!is_l3dgw_port(op)) {
            return;
        }

        for (size_t i = 0; i < op->od->nbr->n_nat; i++) {
            struct ovn_nat *nat_entry = &op->od->nat_entries[i];

            /* Skip entries we failed to parse. */
            if (!nat_entry_is_valid(nat_entry)) {
                continue;
            }

            /* Skip SNAT entries for now, we handle unique SNAT IPs separately
             * below.
             */
            if (!strcmp(nat_entry->nb->type, "snat")) {
                continue;
            }
            build_lrouter_port_nat_arp_nd_flow(op, nat_entry, lflows,
                                               meter_groups);
        }

        /* Now handle SNAT entries too, one per unique SNAT IP. */
        struct shash_node *snat_snode;
        SHASH_FOR_EACH (snat_snode, &op->od->snat_ips) {
            struct ovn_snat_ip *snat_ip = snat_snode->data;

            if (ovs_list_is_empty(&snat_ip->snat_entries)) {
                continue;
            }

            struct ovn_nat *nat_entry =
                CONTAINER_OF(ovs_list_front(&snat_ip->snat_entries),
                             struct ovn_nat, ext_addr_list_node);
            build_lrouter_port_nat_arp_nd_flow(op, nat_entry, lflows,
                                               meter_groups);
        }
    }
}
