bool comp_ioption(zckCtx *zck, zck_ioption option, ssize_t value) {
    VALIDATE_BOOL(zck);

    /* Cannot change compression parameters after compression has started */
    if(zck && zck->comp.started) {
        set_error(zck,
                  "Unable to set compression parameters after initialization");
        return false;
    }
    if(option == ZCK_COMP_TYPE) {
        return set_comp_type(zck, value);

    /* Manual chunking */
    } else if(option == ZCK_MANUAL_CHUNK) {
        VALIDATE_WRITE_BOOL(zck);
        if(value != 0) {
            zck_log(ZCK_LOG_DEBUG, "Disabling automatic chunking");
            zck->manual_chunk = 1;
        } else {
            zck_log(ZCK_LOG_DEBUG, "Enabling automatic chunking");
            zck->manual_chunk = 0;
        }
        return true;

    /* Minimum chunk size */
    } else if(option == ZCK_CHUNK_MIN) {
        VALIDATE_WRITE_BOOL(zck);
        if(value < 1) {
            set_error(zck, "Minimum chunk size must be > 0");
            return false;
        }
        if(value > zck->chunk_max_size) {
            set_error(zck, "Minimum chunk size must be <= maximum chunk size");
            return false;
        }
        zck->chunk_min_size = value;
        zck_log(ZCK_LOG_DEBUG, "Setting minimum chunk size to %lli", (long long) value);
        return true;

    /* Maximum chunk size */
    } else if(option == ZCK_CHUNK_MAX) {
        VALIDATE_WRITE_BOOL(zck);
        if(value < 1) {
            set_error(zck, "Maximum chunk size must be > 0");
            return false;
        }
        if(value < zck->chunk_min_size) {
            set_error(zck, "Maximum chunk size must be >= minimum chunk size");
            return false;
        }
        zck->chunk_max_size = value;
        zck_log(ZCK_LOG_DEBUG, "Setting maximum chunk size to %lli", (long long) value);
        return true;

    } else {
        if(zck && zck->comp.set_parameter)
            return zck->comp.set_parameter(zck, &(zck->comp), option, &value);

        set_error(zck, "Unsupported compression parameter: %i",
                  option);
        return false;
    }
    return true;
}
