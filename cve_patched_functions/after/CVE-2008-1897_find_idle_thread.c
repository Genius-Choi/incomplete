static struct iax2_thread *find_idle_thread(void)
{
	struct iax2_thread *thread = NULL;

	/* Pop the head of the idle list off */
	AST_LIST_LOCK(&idle_list);
	thread = AST_LIST_REMOVE_HEAD(&idle_list, list);
	AST_LIST_UNLOCK(&idle_list);

	/* If we popped a thread off the idle list, just return it */
	if (thread) {
		memset(&thread->ffinfo, 0, sizeof(thread->ffinfo));
		return thread;
	}

	/* Pop the head of the dynamic list off */
	AST_LIST_LOCK(&dynamic_list);
	thread = AST_LIST_REMOVE_HEAD(&dynamic_list, list);
	AST_LIST_UNLOCK(&dynamic_list);

	/* If we popped a thread off the dynamic list, just return it */
	if (thread) {
		memset(&thread->ffinfo, 0, sizeof(thread->ffinfo));
		return thread;
	}

	/* If we can't create a new dynamic thread for any reason, return no thread at all */
	if (iaxdynamicthreadcount >= iaxmaxthreadcount || !(thread = ast_calloc(1, sizeof(*thread))))
		return NULL;

	/* Set default values */
	thread->threadnum = ast_atomic_fetchadd_int(&iaxdynamicthreadcount, 1);
	thread->type = IAX_THREAD_TYPE_DYNAMIC;

	/* Initialize lock and condition */
	ast_mutex_init(&thread->lock);
	ast_cond_init(&thread->cond, NULL);

	/* Create thread and send it on it's way */
	if (ast_pthread_create_detached_background(&thread->threadid, NULL, iax2_process_thread, thread)) {
		ast_cond_destroy(&thread->cond);
		ast_mutex_destroy(&thread->lock);
		ast_free(thread);
		return NULL;
	}

	/* this thread is not processing a full frame (since it is idle),
	   so ensure that the field for the full frame call number is empty */
	memset(&thread->ffinfo, 0, sizeof(thread->ffinfo));

	/* Wait for the thread to be ready before returning it to the caller */
	while (!thread->ready_for_signal)
		usleep(1);

	return thread;
}
