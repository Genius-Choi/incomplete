lys_copy_union_leafrefs(struct lys_module *mod, struct lys_node *parent, struct lys_type *type, struct lys_type *prev_new,
                        struct unres_schema *unres)
{
    struct lys_type new;
    unsigned int i, top_type;
    struct lys_ext_instance **ext;
    uint8_t ext_size;
    void *reloc;

    if (!prev_new) {
        /* this is the "top-level" type, meaning it is a real type and no typedef directly above */
        top_type = 1;

        memset(&new, 0, sizeof new);

        new.base = type->base;
        new.parent = (struct lys_tpdf *)parent;

        prev_new = &new;
    } else {
        /* this is not top-level type, just a type of a typedef */
        top_type = 0;
    }

    assert(type->der);
    if (type->der->module) {
        /* typedef, skip it, but keep the extensions */
        ext_size = type->ext_size;
        if (lys_ext_dup(mod->ctx, mod, type->ext, type->ext_size, prev_new, LYEXT_PAR_TYPE, &ext, 0, unres)) {
            return -1;
        }
        if (prev_new->ext) {
            reloc = realloc(prev_new->ext, (prev_new->ext_size + ext_size) * sizeof *prev_new->ext);
            LY_CHECK_ERR_RETURN(!reloc, LOGMEM(mod->ctx), -1);
            prev_new->ext = reloc;

            memcpy(prev_new->ext + prev_new->ext_size, ext, ext_size * sizeof *ext);
            free(ext);

            prev_new->ext_size += ext_size;
        } else {
            prev_new->ext = ext;
            prev_new->ext_size = ext_size;
        }

        if (lys_copy_union_leafrefs(mod, parent, &type->der->type, prev_new, unres)) {
            return -1;
        }
    } else {
        /* type, just make a deep copy */
        switch (type->base) {
        case LY_TYPE_UNION:
            prev_new->info.uni.has_ptr_type = type->info.uni.has_ptr_type;
            prev_new->info.uni.count = type->info.uni.count;
            /* this cannot be a typedef anymore */
            assert(prev_new->info.uni.count);

            prev_new->info.uni.types = calloc(prev_new->info.uni.count, sizeof *prev_new->info.uni.types);
            LY_CHECK_ERR_RETURN(!prev_new->info.uni.types, LOGMEM(mod->ctx), -1);

            for (i = 0; i < prev_new->info.uni.count; i++) {
                if (lys_copy_union_leafrefs(mod, parent, &(type->info.uni.types[i]), &(prev_new->info.uni.types[i]), unres)) {
                    return -1;
                }
            }

            prev_new->der = type->der;
            break;
        default:
            if (lys_type_dup(mod, parent, prev_new, type, 0, 0, unres)) {
                return -1;
            }
            break;
        }
    }

    if (top_type) {
        memcpy(type, prev_new, sizeof *type);
    }
    return EXIT_SUCCESS;
}
