void tlsio_openssl_dowork(CONCRETE_IO_HANDLE tls_io)
{
    if (tls_io == NULL)
    {
        LogError("NULL tls_io.");
    }
    else
    {
        TLS_IO_INSTANCE* tls_io_instance = (TLS_IO_INSTANCE*)tls_io;

        switch (tls_io_instance->tlsio_state)
        {
        case TLSIO_STATE_OPENING_UNDERLYING_IO:
        case TLSIO_STATE_IN_HANDSHAKE:
        case TLSIO_STATE_OPEN:
            /* this is needed in order to pump out bytes produces by OpenSSL for things like renegotiation */
            write_outgoing_bytes(tls_io_instance, NULL, NULL);
            break;
        case TLSIO_STATE_NOT_OPEN:
        case TLSIO_STATE_HANDSHAKE_FAILED:
        case TLSIO_STATE_CLOSING:
        case TLSIO_STATE_ERROR:
        default:
            break;
        }

        if (tls_io_instance->tlsio_state != TLSIO_STATE_NOT_OPEN)
        {
            /* Same behavior as schannel */
            xio_dowork(tls_io_instance->underlying_io);

            if (tls_io_instance->tlsio_state == TLSIO_STATE_HANDSHAKE_FAILED)
            {
                // The handshake failed so we need to close. The tlsio becomes aware of the
                // handshake failure during an on_bytes_received while the underlying
                // xio_dowork is pumping data out of the socket in a while loop. The tlsio can't
                // close down during the callback because that would mean the xio_dowork would
                // be trying to read from a closed socket. So instead, the tlsio sets its state
                // to TLSIO_STATE_HANDSHAKE_FAILED during the on_bytes_received callback,
                // can then gracefully shut things down here.
                //
                // Set the state to TLSIO_STATE_ERROR so close won't gripe about the state
                tls_io_instance->tlsio_state = TLSIO_STATE_ERROR;
                tlsio_openssl_close(tls_io_instance, NULL, NULL);
                indicate_open_complete(tls_io_instance, IO_OPEN_ERROR);
            }
        }
    }
}
