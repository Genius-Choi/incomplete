Status ArrayFromMemory(int dim_size, npy_intp* dims, void* data, DataType dtype,
                       std::function<void()> destructor, PyObject** result) {
  if (dtype == DT_STRING || dtype == DT_RESOURCE) {
    return errors::FailedPrecondition(
        "Cannot convert string or resource Tensors.");
  }

  int type_num = -1;
  Status s =
      TF_DataType_to_PyArray_TYPE(static_cast<TF_DataType>(dtype), &type_num);
  if (!s.ok()) {
    return s;
  }

  if (dim_size > NPY_MAXDIMS) {
    return errors::InvalidArgument(
        "Cannot convert tensor with ", dim_size,
        " dimensions to NumPy array. NumPy arrays can have at most ",
        NPY_MAXDIMS, " dimensions");
  }
  auto* np_array = reinterpret_cast<PyArrayObject*>(
      PyArray_SimpleNewFromData(dim_size, dims, type_num, data));
  if (np_array == nullptr) {
    string shape_str = absl::StrJoin(
        absl::Span<npy_intp>{dims, static_cast<size_t>(dim_size)}, ", ");
    if (PyErr_Occurred()) {
      string exception_str = PyExceptionFetch();
      PyErr_Clear();
      return errors::InvalidArgument(
          "Failed to create numpy array from tensor of shape [", shape_str,
          "]. Numpy error: ", exception_str);
    }
    return errors::Internal(
        "Failed to create numpy array from tensor of shape [", shape_str, "]");
  }

  PyArray_CLEARFLAGS(np_array, NPY_ARRAY_OWNDATA);
  if (PyType_Ready(&TensorReleaserType) == -1) {
    return errors::Unknown("Python type initialization failed.");
  }
  auto* releaser = reinterpret_cast<TensorReleaser*>(
      TensorReleaserType.tp_alloc(&TensorReleaserType, 0));
  releaser->destructor = new std::function<void()>(std::move(destructor));
  if (PyArray_SetBaseObject(np_array, reinterpret_cast<PyObject*>(releaser)) ==
      -1) {
    Py_DECREF(releaser);
    return errors::Unknown("Python array refused to use memory.");
  }
  *result = reinterpret_cast<PyObject*>(np_array);
  return OkStatus();
}
