static void websocket_client_thread(Computer *comp, const std::string& str, const std::unordered_map<std::string, std::string>& headers, double timeout) {
#ifdef __APPLE__
    pthread_setname_np("WebSocket Client Thread");
#endif
#ifdef __ANDROID__
    Android_JNI_SetupThread();
#endif
    Poco::URI uri;
    try {
        uri = Poco::URI(str);
    } catch (Poco::SyntaxException &e) {
        websocket_failure_data * data = new websocket_failure_data;
        data->url = str;
        data->reason = "URL malformed";
        queueEvent(comp, websocket_failure, data);
        return;
    }
    if (uri.getHost() == "localhost") uri.setHost("127.0.0.1");
    bool found = false;
    for (const std::string& wclass : config.http_whitelist) {
        if (matchIPClass(uri.getHost(), wclass)) {
            found = true;
            for (const std::string& bclass : config.http_blacklist) {
                if (matchIPClass(uri.getHost(), bclass)) {
                    found = false;
                    break;
                }
            }
            if (!found) break;
        }
    }
    if (!found) {
        websocket_failure_data * data = new websocket_failure_data;
        data->url = str;
        data->reason = "Domain not permitted";
        queueEvent(comp, websocket_failure, data);
        return;
    }
    HTTPClientSession * cs;
    if (uri.getScheme() == "ws") cs = new HTTPClientSession(uri.getHost(), uri.getPort());
    else if (uri.getScheme() == "wss") {
        Context::Ptr ctx = new Context(Context::CLIENT_USE, "", Context::VERIFY_RELAXED, 9, true, "ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH");
        addSystemCertificates(ctx);
#if POCO_VERSION >= 0x010A0000
        ctx->disableProtocols(Context::PROTO_TLSV1_3);
#endif
        cs = new HTTPSClientSession(uri.getHost(), uri.getPort(), ctx);
    } else {
        websocket_failure_data * data = new websocket_failure_data;
        data->url = str;
        data->reason = "Invalid scheme '" + uri.getScheme() + "'";
        queueEvent(comp, websocket_failure, data);
        return;
    }
#if POCO_VERSION >= 0x010C0000
    cs->setReceiveTimeout(Poco::Timespan(timeout * 1000000));
#endif
    size_t pos = str.find('/', str.find(uri.getHost()));
    size_t hash = pos != std::string::npos ? str.find('#', pos) : std::string::npos;
    std::string path = urlEncode(pos != std::string::npos ? str.substr(pos, hash - pos) : "/");
    if (!config.http_proxy_server.empty()) cs->setProxy(config.http_proxy_server, config.http_proxy_port);
    HTTPRequest request(HTTPRequest::HTTP_GET, path, HTTPMessage::HTTP_1_1);
    for (std::pair<std::string, std::string> h : headers) request.set(h.first, h.second);
    if (!request.has("User-Agent")) request.add("User-Agent", "computercraft/" CRAFTOSPC_CC_VERSION " CraftOS-PC/" CRAFTOSPC_VERSION);
    if (!request.has("Accept-Charset")) request.add("Accept-Charset", "UTF-8");
    HTTPResponse response;
    WebSocket* ws;
    try {
        ws = new WebSocket(*cs, request, response);
    } catch (Poco::Exception &e) {
        websocket_failure_data * data = new websocket_failure_data;
        data->url = str;
        data->reason = e.displayText();
        queueEvent(comp, websocket_failure, data);
        return;
    } catch (std::exception &e) {
        websocket_failure_data * data = new websocket_failure_data;
        data->url = str;
        data->reason = e.what();
        queueEvent(comp, websocket_failure, data);
        return;
    }
    //if (config.http_timeout > 0) ws->setReceiveTimeout(Poco::Timespan(config.http_timeout * 1000));
    ws->setReceiveTimeout(Poco::Timespan(1, 0));
#if POCO_VERSION >= 0x01090100
    if (config.http_max_websocket_message > 0) ws->setMaxPayloadSize(config.http_max_websocket_message);
#endif
    ws_handle wsh_orig;
    ws_handle * wsh = &wsh_orig;
    wsh->isServer = false;
    wsh->url = str;
    wsh->ws = ws;
    {
        std::lock_guard<std::mutex> lock(comp->openWebsocketsMutex);
        comp->openWebsockets.push_back(&wsh);
    }
    queueEvent(comp, websocket_success, &wsh);
    char * buf = new char[config.http_max_websocket_message];
    while (wsh->ws) {
        int flags = 0;
        int res;
        try {
            res = ws->receiveFrame(buf, config.http_max_websocket_message, flags);
            if (res < 0 || (res == 0 && flags == 0)) {
                wsh->ws = NULL;
                websocket_closed_data * d = new websocket_closed_data;
                d->url = str;
                d->code = 0;
                queueEvent(comp, websocket_closed, d);
                break;
            }
        } catch (Poco::TimeoutException &e) {
            if (!wsh->ws) {
                websocket_closed_data * d = new websocket_closed_data;
                d->url = str;
                d->code = 1006;
                d->reason = "Timed out";
                queueEvent(comp, websocket_closed, d);
                break;
            }
            continue;
        } catch (NetException &e) {
            wsh->ws = NULL;
            websocket_closed_data * d = new websocket_closed_data;
            d->url = str;
            d->code = 1006;
            d->reason = e.message();
            queueEvent(comp, websocket_closed, d);
            break;
        }
        if ((flags & 0x0f) == WebSocket::FRAME_OP_CLOSE) {
            wsh->ws = NULL;
            websocket_closed_data * d = new websocket_closed_data;
            d->url = str;
            if (res >= 2) {
                d->code = (((uint8_t*)buf)[0] << 8) | ((uint8_t*)buf)[1];
                d->reason = std::string(buf + 2, res - 2);
            } else d->code = 0;
            queueEvent(comp, websocket_closed, d);
            break;
        } else if ((flags & 0x0f) == WebSocket::FRAME_OP_PING) {
            ws->sendFrame(buf, res, WebSocket::FRAME_FLAG_FIN | WebSocket::FRAME_OP_PONG);
        } else {
            ws_message * message = new ws_message;
            message->url = str;
            message->binary = (flags & WebSocket::FRAME_OP_BITMASK) == WebSocket::FRAME_OP_BINARY;
            message->data = std::string((const char*)buf, res);
            queueEvent(comp, websocket_message, message);
        }
        std::this_thread::yield();
    }
    delete[] buf;
    {
        std::lock_guard<std::mutex> lock(comp->openWebsocketsMutex);
        auto it = std::find(comp->openWebsockets.begin(), comp->openWebsockets.end(), (void*)&wsh);
        if (it != comp->openWebsockets.end()) comp->openWebsockets.erase(it);
    }
    try {ws->shutdown();} catch (...) {}
    std::lock_guard<std::mutex> lock(wsh->lock);
    wsh->ws = NULL;
    if (wsh->ud != NULL) *wsh->ud = NULL;
    delete ws;
    delete cs;
}
