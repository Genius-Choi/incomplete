handle_sia_ca(X509_EXTENSION *ext, void *arg)
{
	SIGNATURE_INFO_ACCESS *sia;
	struct sia_ca_uris *uris = arg;
	int error;

	sia = X509V3_EXT_d2i(ext);
	if (sia == NULL)
		return cannot_decode(ext_sia());

	/* rsync, still the preferred and required */
	error = handle_ad("SIA", sia, "caRepository", NID_caRepository,
	    URI_VALID_RSYNC, true, handle_caRepository, &uris->caRepository);
	if (error)
		goto end;

	/* HTTPS RRDP */
	error = handle_ad("SIA", sia, "rpkiNotify", nid_rpkiNotify(),
	    URI_VALID_HTTPS | URI_USE_RRDP_WORKSPACE, false, handle_rpkiNotify,
	    &uris->rpkiNotify);
	if (error)
		goto end;

	/*
	 * Store the manifest URI in @mft.
	 * (We won't actually touch the manifest until we know the certificate
	 * is fully valid.)
	 */
	error = handle_ad("SIA", sia, "rpkiManifest", nid_rpkiManifest(),
	    URI_VALID_RSYNC, true, handle_rpkiManifest, &uris->mft);

end:
	AUTHORITY_INFO_ACCESS_free(sia);
	return error;
}
