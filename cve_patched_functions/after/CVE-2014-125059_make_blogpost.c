struct blogpost make_blogpost(char path[]) {
	struct tm blog_tm;
	memset(&blog_tm, 0, sizeof blog_tm);

	struct blogpost struct_to_return;


	
	/* find the last '/' to
	 * get 2014-12-12-12-12-lala
	 * from /path/to/2014-12-12-12-12-lala */

	char *last_slash_position = strrchr(path, '/');
	if(last_slash_position == NULL) {
		fprintf(stderr, "There's something incredibly wrong with the path (%s) supplied to make_blogpost\n", path);
		exit(EXIT_FAILURE);
	}

	/* this parses the filename that is linke
	 * year-month-day-hour-minute-title */

	/* the string in the time part of the path */
	char time_string[4 + 1 + 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1];
	strncpy(time_string, last_slash_position + 1, sizeof time_string - 1);
	time_string[sizeof time_string - 1] = '\0';

	strptime(time_string, "%Y-%m-%d-%H-%M", &blog_tm);

	struct_to_return.timestamp = mktime(&blog_tm);
	struct_to_return.path = malloc(strlen(path) * sizeof(char));
	strcpy(struct_to_return.path, path);

	/* let's build up the link */
	char *script_name = getenv("SCRIPT_NAME");
	if(script_name == NULL) {
		fprintf(stderr, "Died because of missing self-awareness\n");
		exit(EXIT_FAILURE);
	}
	int bufsize = strlen(script_name) +
		strlen(last_slash_position) + 1;
	struct_to_return.link = malloc(sizeof(char) * bufsize);
	strcpy(struct_to_return.link, script_name);
	strcat(struct_to_return.link, last_slash_position);

	/* that's all */

	return struct_to_return;
}
