static int fs_open(lua_State *L) {
    lastCFunction = __func__;
    Computer * computer = get_comp(L);
    const char * mode = luaL_checkstring(L, 2);
    if (
        (mode[0] != 'r' && mode[0] != 'w' && mode[0] != 'a') ||
        (
            !(mode[1] == '+' && mode[2] == 'b' && mode[3] == '\0') &&
            !(mode[1] == '+' && mode[2] == '\0') &&
            !(mode[1] == 'b' && mode[2] == '\0') &&
            mode[1] != '\0'
        )) luaL_error(L, "%s: Unsupported mode", mode);
    std::string str = checkstring(L, 1);
    const path_t path = mode[0] == 'r' ? fixpath(get_comp(L), str, true) : fixpath_mkdir(get_comp(L), str);
    if (path.empty()) {
        if (mode[0] != 'r' && fixpath_ro(computer, str)) {
            lua_pushnil(L);
            lua_pushfstring(L, "/%s: Access denied", fixpath(computer, str, false, false).string().c_str());
            return 2;
        } else {
            lua_pushnil(L);
            lua_pushfstring(L, "/%s: No such file", fixpath(computer, str, false, false).string().c_str());
            return 2;
        }
    }
    int fpid;
    if (std::regex_search((*path.begin()).native(), pathregex("^\\d+:")) || path == ":bios.lua") {
        if (computer->files_open >= config.maximumFilesOpen) err(L, 1, "Too many files already open");
        std::stringstream ** fp = (std::stringstream**)lua_newuserdata(L, sizeof(std::stringstream**));
        fpid = lua_gettop(L);
#ifdef STANDALONE_ROM
        if (path == ":bios.lua") {
            *fp = new std::stringstream(standaloneBIOS);
        } else {
#endif
            try {
                const FileEntry &d = computer->virtualMounts[(unsigned)std::stoul((*path.begin()).native())]->path(path.lexically_relative(*path.begin()));
                if (d.isDir) {
                    lua_remove(L, fpid);
                    lua_pushnil(L);
                    if (strchr(mode, 'r') != NULL) lua_pushfstring(L, "/%s: Not a file", fixpath(computer, str, false, false).string().c_str());
                    else lua_pushfstring(L, "/%s: Cannot write to directory", fixpath(computer, str, false, false).string().c_str());
                    return 2; 
                }
                *fp = new std::stringstream(d.data);
            } catch (...) {
                lua_remove(L, fpid);
                lua_pushnil(L);
                lua_pushfstring(L, "/%s: No such file", fixpath(computer, str, false, false).string().c_str());
                return 2;
            }
#ifdef STANDALONE_ROM
        }
#endif
    } else {
        std::error_code e;
        if (fs::is_directory(path, e)) { 
            lua_pushnil(L);
            if (strchr(mode, 'r') != NULL) lua_pushfstring(L, "/%s: Not a file", fixpath(computer, str, false, false).string().c_str());
            else lua_pushfstring(L, "/%s: Cannot write to directory", fixpath(computer, str, false, false).string().c_str());
            return 2; 
        }
        if (strcmp(mode, "w") == 0 || strcmp(mode, "a") == 0 || strcmp(mode, "wb") == 0 || strcmp(mode, "ab") == 0) {
            if (fixpath_ro(computer, str)) {
                lua_pushnil(L);
                lua_pushfstring(L, "/%s: Access denied", fixpath(computer, str, false, false).string().c_str());
                return 2; 
            }
            e.clear();
            fs::create_directories(path.parent_path(), e);
            if (e) {
                lua_pushnil(L);
                lua_pushfstring(L, "/%s: Cannot create directory", fixpath(computer, str, false, false).string().c_str());
                return 2; 
            }
        }
        std::fstream ** fp = (std::fstream**)lua_newuserdata(L, sizeof(std::fstream*));
        fpid = lua_gettop(L);
        std::ios::openmode flags = std::ios::binary;
        if (strchr(mode, 'r')) {
            flags |= std::ios::in;
            if (strchr(mode, '+')) flags |= std::ios::out;
        } else if (strchr(mode, 'w')) {
            flags |= std::ios::out | std::ios::trunc;
            if (strchr(mode, '+')) flags |= std::ios::in;
        } else if (strchr(mode, 'a')) {
            flags |= std::ios::in | std::ios::out | std::ios::ate;
            if (strchr(mode, '+')) flags |= std::ios::in;
        }
        *fp = new std::fstream(path, flags);
        if (!(*fp)->is_open()) {
            bool ok = false;
            if (strchr(mode, 'a')) {
                (*fp)->open(path, (flags & ~std::ios::ate) | std::ios::trunc);
                ok = (*fp)->is_open();
            }
            if (!ok) {
                delete *fp;
                lua_remove(L, fpid);
                lua_pushnil(L);
                lua_pushfstring(L, "/%s: No such file", fixpath(computer, str, false, false).native().c_str());
                return 2;
            }
        }
        if (computer->files_open >= config.maximumFilesOpen) {
            (*fp)->close();
            delete *fp;
            err(L, 1, "Too many files already open");
        }
    }
    lua_createtable(L, 0, 1);
    lua_pushvalue(L, fpid);
    lua_pushcclosure(L, fs_handle_gc, 1);
    lua_setfield(L, -2, "__gc");
    lua_setmetatable(L, -2);
    
    lua_createtable(L, 0, 4);
    lua_pushstring(L, "close");
    lua_pushvalue(L, fpid);
    lua_pushcclosure(L, fs_handle_close, 1);
    lua_settable(L, -3);

    lua_pushstring(L, "seek");
    lua_pushvalue(L, fpid);
    lua_pushcclosure(L, fs_handle_seek, 1);
    lua_settable(L, -3);

    if (mode[0] == 'r' || strchr(mode, '+')) {
        if (strchr(mode, 'b')) {
            lua_pushstring(L, "read");
            lua_pushvalue(L, fpid);
            lua_pushcclosure(L, fs_handle_readByte, 1);
            lua_settable(L, -3);
        } else {
            lua_pushstring(L, "read");
            lua_pushvalue(L, fpid);
            lua_pushcclosure(L, fs_handle_readChar, 1);
            lua_settable(L, -3);
        }

        lua_pushstring(L, "readAll");
        lua_pushvalue(L, fpid);
        lua_pushcclosure(L, fs_handle_readAllByte, 1);
        lua_settable(L, -3);

        lua_pushstring(L, "readLine");
        lua_pushvalue(L, fpid);
        lua_pushcclosure(L, fs_handle_readLine, 1);
        lua_settable(L, -3);
    }

    if (mode[0] == 'w' || mode[0] == 'a' || strchr(mode, '+')) {
        if (strchr(mode, 'b')) {
            lua_pushstring(L, "write");
            lua_pushvalue(L, fpid);
            lua_pushcclosure(L, fs_handle_writeByte, 1);
            lua_settable(L, -3);
        } else {
            lua_pushstring(L, "write");
            lua_pushvalue(L, fpid);
            lua_pushcclosure(L, fs_handle_writeString, 1);
            lua_settable(L, -3);
        }

        lua_pushstring(L, "writeLine");
        lua_pushvalue(L, fpid);
        lua_pushcclosure(L, fs_handle_writeLine, 1);
        lua_settable(L, -3);

        lua_pushstring(L, "flush");
        lua_pushvalue(L, fpid);
        lua_pushcclosure(L, fs_handle_flush, 1);
        lua_settable(L, -3);
    }

    computer->files_open++;
    return 1;
}
