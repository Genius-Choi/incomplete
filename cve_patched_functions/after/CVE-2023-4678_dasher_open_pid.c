static void dasher_open_pid(GF_Filter *filter, GF_DasherCtx *ctx, GF_DashStream *ds, GF_List *multi_pids, Bool init_trashed)
{
	GF_DashStream *base_ds = ds->muxed_base ? ds->muxed_base : ds;
	char szSRC[1024];

	if (ctx->sigfrag || ctx->in_error || ctx->gencues || ctx->do_index)
		return;

	switch (ctx->from_index) {
	case IDXMODE_MANIFEST:
	case IDXMODE_CHILD:
	case IDXMODE_ALL:
	case IDXMODE_INIT:
		if (init_trashed) return;
		if (ds->muxed_base && !base_ds->dst_filter) return;
		break;
	}

	assert(!ds->opid);
	assert(base_ds->dst_filter);

	if (ds->tile_base && !init_trashed) {
		s32 res = gf_list_find(ctx->postponed_pids, ds);
		if (res < 0) {
			gf_list_add(ctx->postponed_pids, ds);
			return;
		} else {
			gf_list_rem(ctx->postponed_pids, res);
		}
	} else if (!ds->tile_base) {
		gf_list_del_item(ctx->postponed_pids, ds);
	}

	//tile base not live profile, make sure all our deps are ready
	if (ds->tile_base && !ctx->sseg) {
		u32 i, count = gf_list_count(ds->complementary_streams);
		for (i=0; i<count; i++) {
			GF_DashStream *a_ds = gf_list_get(ds->complementary_streams, i);
			//dep not ready
			if (!a_ds->opid) {
				if (gf_list_find(ctx->postponed_pids, a_ds)<0) {
					gf_list_add(ctx->postponed_pids, a_ds);
				}
				gf_list_del_item(ctx->postponed_pids, ds);
				gf_list_add(ctx->postponed_pids, ds);
				return;
			}
		}
	}

	sprintf(szSRC, "dasher_%p", base_ds->dst_filter);
	ds->opid = gf_filter_pid_new(filter);

#ifdef GPAC_64_BITS
	ds->hls_ref_id = (u64) ds->opid;
#else
	ds->hls_ref_id = (u64) ((u32) ds->opid);
#endif

	gf_filter_pid_copy_properties(ds->opid, ds->ipid);
	if (!ds->muxed_base) {
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_FILE_EXT, &PROP_STRING("*"));
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_MIME, &PROP_STRING(ds->rep->mime_type));
	}
	if (ds->nb_cues) {
		u32 ncues = ds->nb_cues;
		if ((ds->cues[0].sample_num>0) || (ds->cues[0].cts>0) || (ds->cues[0].dts>0))
			ncues++;
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_SEGMENTS, &PROP_UINT(ncues) );
	}
	//for route out
	if (ctx->is_route) {
		if (ctx->do_m3u8)
			gf_filter_pid_set_property(ds->opid, GF_PROP_PCK_HLS_REF, &PROP_LONGUINT( ds->hls_ref_id ) );

		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_REP_ID, &PROP_STRING( ds->rep->id ) );


		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_DUR, &PROP_FRAC( ds->dash_dur ) );
	}

	gf_filter_pid_require_source_id(ds->opid);

	if (ctx->pssh == GF_DASH_PSSH_MPD) {
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_CENC_PSSH, NULL);
	}
	//multi-stsd disabled, remove sdsd template (only needed at init)
	if (ctx->pswitch != DASHER_PSWITCH_STSD) {
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_ISOM_STSD_ALL_TEMPLATES, NULL);
	}

	//force PID ID
	gf_filter_pid_set_property(ds->opid, GF_PROP_PID_ID, &PROP_UINT(ds->pid_id) );
	if (ds->dep_pid_id)
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_DEPENDENCY_ID, &PROP_UINT(ds->dep_pid_id) );

	if (ctx->from_index || ctx->state)
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_SPARSE, &PROP_BOOL(GF_TRUE) );

	gf_filter_pid_set_property(ds->opid, GF_PROP_PID_MUX_SRC, &PROP_STRING(szSRC) );
	gf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MODE, &PROP_UINT(ctx->sseg ? 2 : 1) );
	gf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_DUR, &PROP_FRAC(ds->dash_dur) );
	switch (ctx->seg_sync) {
	case DASHER_SEGSYNC_AUTO:
		//if not HLS or test mode, don't wait for seg sync
		if (!ctx->do_m3u8 || gf_sys_is_test_mode()) break;
		//fallthrough
	case DASHER_SEGSYNC_YES:
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_FORCE_SEG_SYNC, &PROP_BOOL(GF_TRUE) );
		break;
	case DASHER_SEGSYNC_NO:
		break;
	}

	if (init_trashed)
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_NO_INIT, &PROP_BOOL(GF_TRUE));
	//for routeout
	gf_filter_pid_set_property(ds->opid, GF_PROP_PID_PREMUX_STREAM_TYPE, &PROP_UINT(ds->stream_type) );

	if (ds->id != ds->pid_id) {
		dasher_update_dep_list(ctx, ds, "isom:scal");
		dasher_update_dep_list(ctx, ds, "isom:sabt");
	}

	/*timescale forced (bitstream switching) */
	if (ds->force_timescale)
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ds->force_timescale) );

	if (ds->rep && ds->rep->segment_template)
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_TEMPLATE, &PROP_STRING(ds->rep->segment_template->media));
	else if (ds->set && ds->set->segment_template)
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_TEMPLATE, &PROP_STRING(ds->set->segment_template->media));

	gf_filter_pid_set_property(ds->opid, GF_PROP_PID_BITRATE, &PROP_UINT(ds->bitrate));
	gf_filter_pid_set_property(ds->opid, GF_PROP_PCK_FILENAME, &PROP_STRING(ds->init_seg));

	if (ds->rep && ds->rep->codecs)
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_CODEC, &PROP_STRING(ds->rep->codecs));


	if (multi_pids) {
		s32 idx = 1+gf_list_find(multi_pids, ds->ipid);
		assert(idx>0);
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MULTI_PID, &PROP_POINTER(multi_pids) );
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MULTI_PID_IDX, &PROP_UINT(idx) );
	}


	if (ds->tile_base && !ctx->sseg && !ctx->sfile) {
		u32 i, count = gf_list_count(ds->complementary_streams);
		if (!ds->multi_tracks) ds->multi_tracks = gf_list_new();
		gf_list_reset(ds->multi_tracks);

		//gather all streams depending on our base
		for (i=0; i<count; i++) {
			GF_DashStream *a_ds = gf_list_get(ds->complementary_streams, i);
			assert(a_ds->opid);
			gf_list_add(ds->multi_tracks, a_ds->opid);
		}
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MULTI_TRACK, &PROP_POINTER(ds->multi_tracks) );
	}
	if (ds->dep_id && !init_trashed) {
		if (!ds->multi_tracks) ds->multi_tracks = gf_list_new();
		gf_list_reset(ds->multi_tracks);
		dasher_gather_deps(ctx, ds->dep_id, ds->multi_tracks);
		if (gf_list_count(ds->multi_tracks)) {
			gf_filter_pid_set_property(ds->opid, GF_PROP_PID_DASH_MULTI_TRACK, &PROP_POINTER(ds->multi_tracks) );
		} else {
			gf_list_del(ds->multi_tracks);
			ds->multi_tracks = NULL;
		}
	}

	if (ctx->llhls) {
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_LLHLS, &PROP_UINT(ctx->llhls) );
	}

	if ((ctx->dmode > GF_DASH_STATIC) && (ctx->tsb>=0)) {
		u32 tsb_seg = ds->dash_dur.num ? ((u32) (ctx->tsb * ds->dash_dur.den / ds->dash_dur.num)) : 0;
		tsb_seg++;
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_TIMESHIFT_SEGS, &PROP_UINT(tsb_seg) );
	} else {
		gf_filter_pid_set_property(ds->opid, GF_PROP_PID_TIMESHIFT_SEGS, NULL);
	}
}
