ESTree::NodePtr parseJS(
    std::shared_ptr<Context> &context,
    sem::SemContext &semCtx,
    std::unique_ptr<llvh::MemoryBuffer> fileBuf,
    std::unique_ptr<SourceMap> sourceMap = nullptr,
    std::shared_ptr<SourceMapTranslator> sourceMapTranslator = nullptr,
    bool wrapCJSModule = false) {
  assert(fileBuf && "Need a file to compile");
  assert(context && "Need a context to compile using");
  // This value will be set to true if the parser detected the 'use static
  // builtin' directive in the source.
  bool useStaticBuiltinDetected = false;

  bool isLargeFile = fileBuf->getBufferSize() >=
      context->getPreemptiveFileCompilationThreshold();

  int fileBufId =
      context->getSourceErrorManager().addNewSourceBuffer(std::move(fileBuf));
  if (sourceMap != nullptr && sourceMapTranslator != nullptr) {
    sourceMapTranslator->addSourceMap(fileBufId, std::move(sourceMap));
  }

  auto mode = parser::FullParse;

  if (context->isLazyCompilation() && isLargeFile) {
    if (!parser::JSParser::preParseBuffer(
            *context, fileBufId, useStaticBuiltinDetected)) {
      return nullptr;
    }
    mode = parser::LazyParse;
  }

  Optional<ESTree::ProgramNode *> parsedJs;

#ifdef HERMES_USE_FLOWPARSER
  if (cl::FlowParser) {
    parsedJs = parser::parseFlowParser(*context, fileBufId);
  } else
#endif
  {
    parser::JSParser jsParser(*context, fileBufId, mode);
    parsedJs = jsParser.parse();
    // If we are using lazy parse mode, we should have already detected the 'use
    // static builtin' directive in the pre-parsing stage.
    if (mode != parser::LazyParse) {
      useStaticBuiltinDetected = jsParser.getUseStaticBuiltin();
    }
  }
  if (!parsedJs)
    return nullptr;
  ESTree::NodePtr parsedAST = parsedJs.getValue();

  if (cl::StaticBuiltins == cl::StaticBuiltinSetting::AutoDetect) {
    context->setStaticBuiltinOptimization(useStaticBuiltinDetected);
  }

  if (wrapCJSModule) {
    parsedAST =
        hermes::wrapCJSModule(context, cast<ESTree::ProgramNode>(parsedAST));
    if (!parsedAST) {
      return nullptr;
    }
  }

  if (cl::DumpTarget == DumpAST) {
    hermes::dumpESTreeJSON(
        llvh::outs(),
        parsedAST,
        cl::Pretty /* pretty */,
        cl::IncludeEmptyASTNodes ? ESTreeDumpMode::DumpAll
                                 : ESTreeDumpMode::HideEmpty,
        context->getSourceErrorManager(),
        cl::DumpSourceLocation,
        cl::IncludeRawASTProp ? ESTreeRawProp::Include
                              : ESTreeRawProp::Exclude);
    return parsedAST;
  }
  if (cl::DumpTarget == DumpJS) {
    hermes::generateJS(llvh::outs(), parsedAST, cl::Pretty /* pretty */);
    return parsedAST;
  }

  if (!hermes::sem::validateAST(*context, semCtx, parsedAST)) {
    return nullptr;
  }

  if (cl::DumpTarget == DumpTransformedAST) {
    hermes::dumpESTreeJSON(
        llvh::outs(),
        parsedAST,
        cl::Pretty /* pretty */,
        cl::IncludeEmptyASTNodes ? ESTreeDumpMode::DumpAll
                                 : ESTreeDumpMode::HideEmpty,
        context->getSourceErrorManager(),
        cl::DumpSourceLocation,
        cl::IncludeRawASTProp ? ESTreeRawProp::Include
                              : ESTreeRawProp::Exclude);
  }
  if (cl::DumpTarget == DumpTransformedJS) {
    hermes::generateJS(llvh::outs(), parsedAST, cl::Pretty /* pretty */);
  }

  return parsedAST;
}
