OptValue<hbc::DebugSourceLocation> CodeBlock::getSourceLocation(
    uint32_t offset) const {
#ifndef HERMESVM_LEAN
  if (LLVM_UNLIKELY(isLazy())) {
    assert(offset == 0 && "Function is lazy, but debug offset >0 specified");

    auto *provider = (hbc::BCProviderLazy *)getRuntimeModule()->getBytecode();
    auto *func = provider->getBytecodeFunction();
    auto *lazyData = func->getLazyCompilationData();
    auto sourceLoc = lazyData->span.Start;

    SourceErrorManager::SourceCoords coords;
    if (!lazyData->context->getSourceErrorManager().findBufferLineAndLoc(
            sourceLoc, coords)) {
      return llvh::None;
    }

    hbc::DebugSourceLocation location;
    location.line = coords.line;
    location.column = coords.col;
    // We don't actually have a filename table, so we can't really provide
    // this. Fortunately the location of uncompiled codeblocks is primarily
    // used by heap snapshots, which substitutes it for the SourceID anyways.
    location.filenameId = facebook::hermes::debugger::kInvalidLocation;
    return location;
  }
#endif

  auto debugLocsOffset = getDebugSourceLocationsOffset();
  if (!debugLocsOffset) {
    return llvh::None;
  }

  return getRuntimeModule()
      ->getBytecode()
      ->getDebugInfo()
      ->getLocationForAddress(*debugLocsOffset, offset);
}
