process_tcp_options(struct uip_conn *conn)
{
  if((UIP_TCP_BUF->tcpoffset & 0xf0) <= 0x50) {
    return;
  }

  /* Parse the TCP MSS option, if present. */
  for(unsigned c = 0; c < ((UIP_TCP_BUF->tcpoffset >> 4) - 5) << 2 ;) {
    if(UIP_IPTCPH_LEN + c >= UIP_BUFSIZE) {
      /* TCP option data out of bounds. */
      return;
    }
    uint8_t opt = uip_buf[UIP_IPTCPH_LEN + c];
    switch(opt) {
    case TCP_OPT_END:
      /* Stop processing options. */
      return;
    case TCP_OPT_NOOP:
      c++;
      break;
    case TCP_OPT_MSS:
      if(UIP_IPTCPH_LEN + 3 + c >= UIP_BUFSIZE ||
         uip_buf[UIP_IPTCPH_LEN + 1 + c] != TCP_OPT_MSS_LEN) {
	/* TCP option data out of bounds or invalid MSS option length. */
	return;
      }

      /* An MSS option with the right option length. */
      uint16_t tmp16 = (uip_buf[UIP_IPTCPH_LEN + 2 + c] << 8) |
	uip_buf[UIP_IPTCPH_LEN + 3 + c];
      conn->initialmss = conn->mss =
	tmp16 > UIP_TCP_MSS ? UIP_TCP_MSS : tmp16;
      /* Stop processing options. */
      return;
    default:
      if(UIP_IPTCPH_LEN + 1 + c >= UIP_BUFSIZE) {
	/* TCP option data out of bounds. */
	return;
      }
      /* All other options have a length field, so that we easily
	 can skip past them. */
      if(uip_buf[UIP_IPTCPH_LEN + 1 + c] == 0) {
	/* If the length field is zero, the options are malformed
	   and we don't process them further. */
	return;
      }
      c += uip_buf[UIP_IPTCPH_LEN + 1 + c];
      break;
    }
  }
}
