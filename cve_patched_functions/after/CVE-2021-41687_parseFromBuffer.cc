OFCondition UserIdentityNegotiationSubItemAC::parseFromBuffer(unsigned char *readBuffer,
                                                              unsigned long &bytesRead,
                                                              unsigned long availData)
{
  // We need at least 6 bytes for the fields that we always read
  if (availData < 6)
  {
      char buffer[256];
      sprintf(buffer, "DUL illegal user identify ac length %ld. Need at least 6 bytes for"
              " user identify ac", availData);
      return makeDcmnetCondition(DULC_ILLEGALPDULENGTH, OF_error, buffer);
  }

  bytesRead = 0;
  readBuffer += 2; // Skip "item type" and "reserved" field
  unsigned short itemLength = 0;
  EXTRACT_SHORT_BIG(readBuffer, itemLength);
  readBuffer += 2; // Skip "item length

  EXTRACT_SHORT_BIG(readBuffer, m_rspLength);
  readBuffer += 2;

  // Check if itemLength and m_rspLength are valid and we don't read past the
  // end of any buffer
  if (availData - 4 < itemLength || itemLength < 2 || itemLength - 2 < m_rspLength)
  {
      char buffer[256];
      sprintf(buffer, "DUL illegal user identify ac length %ld. Info claims to be %hd bytes. "
              "Response claims to be %hd bytes.", availData, itemLength, m_rspLength);
      return makeDcmnetCondition(DULC_ILLEGALPDULENGTH, OF_error, buffer);
  }

  if (m_rspLength > 0)
  {
    m_serverRsp = new char[m_rspLength];
    memcpy(m_serverRsp, readBuffer, m_rspLength);
    readBuffer += m_rspLength;
  }

  bytesRead = 6 + m_rspLength; // 2+2+2+ response length
  return EC_Normal;
}
