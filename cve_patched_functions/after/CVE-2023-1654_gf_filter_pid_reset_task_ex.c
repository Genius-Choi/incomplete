static void gf_filter_pid_reset_task_ex(GF_FSTask *task, Bool *had_eos)
{
	GF_FilterPidInst *pidi = (GF_FilterPidInst *)task->udta;
	GF_LOG(GF_LOG_INFO, GF_LOG_FILTER, ("Filter %s input PID %s (from %s) resetting buffer\n", task->filter->name, pidi->pid->name, pidi->pid->filter->name ));

	if (had_eos) *had_eos = GF_FALSE;

	//aggregate any pending packet
	gf_filter_aggregate_packets(pidi);

	//trash packets without checking for internal commands except EOS any pending packet
	while (gf_fq_count(pidi->packets)) {
		GF_FilterPacketInstance *pcki = gf_fq_head(pidi->packets);
		if ( (pcki->pck->info.flags & GF_PCK_CMD_MASK) == GF_PCK_CMD_PID_EOS) {
			if (had_eos)
				*had_eos = GF_TRUE;
		}
		//check props change otherwise we could accumulate pid properties no longer valid
		filter_pck_check_prop_change(pidi, pcki, GF_FALSE);

		gf_filter_pid_drop_packet((GF_FilterPid *) pidi);
	}

	gf_filter_pidinst_reset_stats(pidi);

	assert(pidi->discard_packets);
	safe_int_dec(&pidi->discard_packets);

	pidi->last_block_ended = GF_TRUE;
	pidi->first_block_started = GF_FALSE;
	pidi->is_end_of_stream = GF_FALSE;
	pidi->buffer_duration = 0;
	pidi->nb_eos_signaled = 0;
	pidi->pid->has_seen_eos = GF_FALSE;
	pidi->last_clock_type = 0;

	assert(pidi->pid->filter->stream_reset_pending);
	safe_int_dec(& pidi->pid->filter->stream_reset_pending );

	pidi->pid->nb_buffer_unit = 0;
	pidi->pid->buffer_duration = 0;
	gf_filter_pid_check_unblock(pidi->pid);
}
