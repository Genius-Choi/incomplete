void OSD::ShardedOpWQ::_enqueue_front(pair<spg_t, PGQueueable> item)
{
  uint32_t shard_index = item.first.hash_to_shard(shard_list.size());
  ShardData* sdata = shard_list[shard_index];
  assert (NULL != sdata);
  sdata->sdata_op_ordering_lock.Lock();
  auto p = sdata->pg_slots.find(item.first);
  if (p != sdata->pg_slots.end() && !p->second.to_process.empty()) {
    // we may be racing with _process, which has dequeued a new item
    // from pqueue, put it on to_process, and is now busy taking the
    // pg lock.  ensure this old requeued item is ordered before any
    // such newer item in to_process.
    p->second.to_process.push_front(item.second);
    item.second = p->second.to_process.back();
    p->second.to_process.pop_back();
    dout(20) << __func__ << " " << item.first
	     << " " << p->second.to_process.front()
	     << " shuffled w/ " << item.second << dendl;
  } else {
    dout(20) << __func__ << " " << item.first << " " << item.second << dendl;
  }
  sdata->_enqueue_front(item, osd->op_prio_cutoff);
  sdata->sdata_op_ordering_lock.Unlock();
  sdata->sdata_lock.Lock();
  sdata->sdata_cond.SignalOne();
  sdata->sdata_lock.Unlock();
}
