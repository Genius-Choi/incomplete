static int http_websocket(lua_State *L) {
    lastCFunction = __func__;
    if (!config.http_websocket_enabled) luaL_error(L, "Websocket connections are disabled");
    Computer * comp = get_comp(L);
    if (comp->openWebsockets.size() >= (size_t)config.http_max_websockets) return luaL_error(L, "Too many websockets already open");
    if (!(config.serverMode || config.vanilla) && (lua_isnoneornil(L, 1) || lua_isnumber(L, 1))) {
        luaL_error(L, "function has been replaced with http.websocketServer");
    } else if (lua_istable(L, 1)) {
        Computer * comp = get_comp(L);
        if (config.http_max_websockets > 0 && comp->openWebsockets.size() >= (unsigned)config.http_max_websockets) luaL_error(L, "Too many websockets already open");
        std::unordered_map<std::string, std::string> headers;
        lua_getfield(L, 1, "url");
        if (!lua_isstring(L, -1)) luaL_error(L, "bad field 'url' (expected string, got %s)", lua_typename(L, lua_type(L, -1)));
        std::string url = tostring(L, -1);
        lua_pop(L, 1);
        lua_getfield(L, 1, "headers");
        if (!lua_isnil(L, -1) && !lua_istable(L, -1)) luaL_error(L, "bad field 'headers' (expected table, got %s)", lua_typename(L, lua_type(L, -1)));
        if (lua_istable(L, -1)) {
            lua_pushnil(L);
            for (int i = 0; lua_next(L, -2); i++) {
                size_t keyn = 0, valn = 0;
                const char * key = lua_tolstring(L, -2, &keyn), *val = lua_tolstring(L, -1, &valn);
                if (key && val) headers[std::string(key, keyn)] = std::string(val, valn);
                lua_pop(L, 1);
            }
        }
        lua_pop(L, 1);
        lua_getfield(L, 1, "timeout");
        if (!lua_isnil(L, -1) && !lua_isnumber(L, -1)) luaL_error(L, "bad field 'timeout' (expected number, got %s)", lua_typename(L, lua_type(L, -1)));
        double timeout = luaL_optnumber(L, -1, config.http_timeout / 1000.0);
        lua_pop(L, 1);
        std::thread th(websocket_client_thread, comp, url, headers, timeout);
        setThreadName(th, "WebSocket Client Thread");
        th.detach();
    } else if (lua_isstring(L, 1)) {
        Computer * comp = get_comp(L);
        if (config.http_max_websockets > 0 && comp->openWebsockets.size() >= (unsigned)config.http_max_websockets) luaL_error(L, "Too many websockets already open");
        std::string url = tostring(L, 1);
        std::unordered_map<std::string, std::string> headers;
        if (lua_istable(L, 2)) {
            lua_pushvalue(L, 2);
            lua_pushnil(L);
            for (int i = 0; lua_next(L, -2); i++) {
                size_t keyn = 0, valn = 0;
                const char * key = lua_tolstring(L, -2, &keyn), *val = lua_tolstring(L, -1, &valn);
                if (key && val) headers[std::string(key, keyn)] = std::string(val, valn);
                lua_pop(L, 1);
            }
            lua_pop(L, 1);
        }
        std::thread th(websocket_client_thread, comp, url, headers, config.http_timeout / 1000.0);
        setThreadName(th, "WebSocket Client Thread");
        th.detach();
    } else luaL_error(L, (config.serverMode || config.vanilla) ? "bad argument #1 (expected string or table, got %s)" : "bad argument #1 (expected string, table, number, or nil, got %s)", lua_typename(L, lua_type(L, 1)));
    lua_pushboolean(L, true);
    return 1;
}
