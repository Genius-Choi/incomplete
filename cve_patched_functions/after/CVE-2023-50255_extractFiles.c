PluginFinishType LibzipPlugin::extractFiles(const QList<FileEntry> &files, const ExtractionOptions &options)
{
    qInfo() << "解压缩数据";

    setPassword(QString());
    m_workStatus = WT_Extract;
    int errcode = 0;
    m_bOverwriteAll = false;        //是否全部覆盖
    m_bSkipAll = false;             // 是否全部跳过
    m_mapLongName.clear();
    m_setLongName.clear();
    m_mapLongDirName.clear();
    m_mapRealDirValue.clear();
//    m_bHandleCurEntry = false; //false:提取使用选中文件及子文件 true:提取使用选中文件
    zip_error_t err;

    // 打开压缩包
    zip_t *archive = zip_open(QFile::encodeName(m_strArchiveName).constData(), ZIP_RDONLY, &errcode);
    zip_error_init_with_code(&err, errcode);
    if (nullptr == archive) {
        // 特殊包操作
        // return minizip_extractFiles(files, options);
        m_eErrorType = ET_ArchiveDamaged ;
        return PFT_Error;
    }

    // 右键解压时按照按照压缩包大小计算
    if (!options.bExistList) {
        m_dScaleSize = 100.0 / options.qComressSize;
    } else {
        m_dScaleSize = 100.0 / options.qSize;
    }
    m_bDlnfs = m_common->isSubpathOfDlnfs(options.strTargetPath);

    // 执行解压操作
    bool bHandleLongName = false;
    if (options.bAllExtract) {  // 全部解压
        qlonglong qExtractSize = 0;
        zip_int64_t nofEntries = zip_get_num_entries(archive, 0);
        for (zip_int64_t i = 0; i < nofEntries; ++i) {
            if (QThread::currentThread()->isInterruptionRequested()) {
                m_bCancel = false;      // 重置标志位
                break;
            }

            QString strFileName;

            // 解压单个文件
            m_eErrorType = extractEntry(archive, i, options, qExtractSize, strFileName, bHandleLongName);

            // 方便右键解压时提示是否有数据解压出来
            if (!options.bExistList && 0 == i) {
                FileEntry entry;
                entry.strFullPath = strFileName;
                DataManager::get_instance().archiveData().listRootEntry << entry;
            }

            if (ET_NoError == m_eErrorType || (bHandleLongName == true && ET_NoError == m_eErrorType)) {  // 无错误，继续解压下一个文件
                continue;
            } else if (ET_UserCancelOpertion == m_eErrorType) {    // 用户取消，结束解压，返回结束标志
                zip_close(archive);
                return PFT_Cancel;
            } else {    // 处理错误
                // 判断是否需要密码，若需要密码，弹出密码输入对话框，用户输入密码之后，重新解压当前文件
                if (ET_WrongPassword == m_eErrorType || ET_NeedPassword == m_eErrorType) {
                    PasswordNeededQuery query(strFileName);
                    emit signalQuery(&query);
                    query.waitForResponse();

                    if (query.responseCancelled()) {
                        setPassword(QString());
                        zip_close(archive);
                        return PFT_Cancel;
                    } else {
                        setPassword(query.password());
                        zip_set_default_password(archive, m_strPassword.toUtf8().constData());
                        i--;
                    }
                }  else {
                    zip_close(archive);
                    return PFT_Error;
                }

            }
        }
    } else { // 部分提取
        qlonglong qExtractSize = 0;
        m_listCurIndex.clear();
        getIndexBySelEntry(files);    // 获取索引值

        // 提取指定文件
        for (int i = 0; i < m_listCurIndex.count(); ++i) {
            if (QThread::currentThread()->isInterruptionRequested()) {
                break;
            }

            QString strFileName;

            // 解压单个文件
            m_eErrorType = extractEntry(archive, m_listCurIndex[i], options, qExtractSize, strFileName, bHandleLongName);

            if (ET_NoError == m_eErrorType || (bHandleLongName == true && ET_NoError == m_eErrorType)) {  // 无错误，继续解压下一个文件
                continue;
            } else if (ET_UserCancelOpertion == m_eErrorType) {    // 用户取消，结束解压，返回结束标志
                zip_close(archive);
                return PFT_Cancel;
            } else {    // 处理错误
                // 判断是否需要密码，若需要密码，弹出密码输入对话框，用户输入密码之后，重新解压当前文件
                if (ET_WrongPassword == m_eErrorType || ET_NeedPassword == m_eErrorType) {

                    PasswordNeededQuery query(strFileName);
                    emit signalQuery(&query);
                    query.waitForResponse();

                    if (query.responseCancelled()) {
                        setPassword(QString());
                        zip_close(archive);
                        return PFT_Cancel;
                    } else {
                        setPassword(query.password());
                        zip_set_default_password(archive, m_strPassword.toUtf8().constData());
                        i--;
                    }
                } else {
                    zip_close(archive);
                    return PFT_Error;
                }

            }
        }
    }

    if (bHandleLongName == true) {
        m_eErrorType = ET_LongNameError;
    }

    zip_close(archive);
    return PFT_Nomral;
}
