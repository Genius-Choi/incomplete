int gnrc_sixlowpan_frag_rb_dispatch_when_complete(gnrc_sixlowpan_frag_rb_t *rbuf,
                                                   gnrc_netif_hdr_t *netif_hdr)
{
    assert(rbuf);
    assert(netif_hdr);
    int res = (rbuf->super.current_size == rbuf->super.datagram_size);

    if (res) {
        gnrc_pktsnip_t *netif = gnrc_netif_hdr_build(rbuf->super.src,
                                                     rbuf->super.src_len,
                                                     rbuf->super.dst,
                                                     rbuf->super.dst_len);

        if (netif == NULL) {
            DEBUG("6lo rbuf: error allocating netif header\n");
            gnrc_pktbuf_release(rbuf->pkt);
            _tmp_rm(rbuf);
            return -1;
        }

        /* copy the transmit information of the latest fragment into the newly
         * created header to have some link_layer information. The link_layer
         * info of the previous fragments is discarded.
         */
        gnrc_netif_hdr_t *new_netif_hdr = netif->data;
        new_netif_hdr->if_pid = netif_hdr->if_pid;
        new_netif_hdr->flags = netif_hdr->flags;
        new_netif_hdr->lqi = netif_hdr->lqi;
        new_netif_hdr->rssi = netif_hdr->rssi;
        rbuf->pkt = gnrc_pkt_append(rbuf->pkt, netif);
#if IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_STATS)
        gnrc_sixlowpan_frag_stats_get()->fragments += _count_frags(rbuf);
        gnrc_sixlowpan_frag_stats_get()->datagrams++;
#endif
        gnrc_sixlowpan_dispatch_recv(rbuf->pkt, NULL, 0);
        _tmp_rm(rbuf);
    }
    return res;
}
