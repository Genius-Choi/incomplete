static int mg_http_multipart_continue_wait_for_chunk(struct mg_connection *c) {
  struct mg_http_proto_data *pd = mg_http_get_proto_data(c);
  struct mbuf *io = &c->recv_mbuf;

  const char *boundary;
  if ((int) io->len < pd->mp_stream.boundary_len + 6 /* \r\n, --, -- */) {
    return 0;
  }

  boundary = c_strnstr(io->buf, pd->mp_stream.boundary, io->len);
  if (boundary == NULL) {
    int data_len = (io->len - (pd->mp_stream.boundary_len + 6));
    if (data_len > 0) {
      size_t consumed = mg_http_multipart_call_handler(
          c, MG_EV_HTTP_PART_DATA, io->buf, (size_t) data_len);
      mbuf_remove(io, consumed);
    }
    return 0;
  } else if (boundary != NULL) {
    size_t data_len = ((size_t)(boundary - io->buf) - 4);
    size_t consumed = mg_http_multipart_call_handler(c, MG_EV_HTTP_PART_DATA,
                                                     io->buf, data_len);
    mbuf_remove(io, consumed);
    if (consumed == data_len) {
      mbuf_remove(io, 4);
      pd->mp_stream.state = MPS_WAITING_FOR_BOUNDARY;
      return 1;
    } else {
      return 0;
    }
  } else {
    return 0;
  }
}
