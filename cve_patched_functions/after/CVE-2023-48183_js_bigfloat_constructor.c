static JSValue js_bigfloat_constructor(JSContext *ctx,
                                       JSValueConst new_target,
                                       int argc, JSValueConst *argv)
{
    JSValue val;
    if (!JS_IsUndefined(new_target))
        return JS_ThrowTypeError(ctx, "not a constructor");
    if (argc == 0) {
        bf_t *r;
        val = JS_NewBigFloat(ctx);
        if (JS_IsException(val))
            return val;
        r = JS_GetBigFloat(val);
        bf_set_zero(r, 0);
    } else {
        val = JS_DupValue(ctx, argv[0]);
    redo:
        switch(JS_VALUE_GET_NORM_TAG(val)) {
        case JS_TAG_BIG_FLOAT:
            break;
        case JS_TAG_FLOAT64:
            {
                bf_t *r;
                double d = JS_VALUE_GET_FLOAT64(val);
                val = JS_NewBigFloat(ctx);
                if (JS_IsException(val))
                    break;
                r = JS_GetBigFloat(val);
                if (bf_set_float64(r, d))
                    goto fail;
            }
            break;
        case JS_TAG_INT:
            {
                bf_t *r;
                int32_t v = JS_VALUE_GET_INT(val);
                val = JS_NewBigFloat(ctx);
                if (JS_IsException(val))
                    break;
                r = JS_GetBigFloat(val);
                if (bf_set_si(r, v))
                    goto fail;
            }
            break;
        case JS_TAG_BIG_INT:
            /* We keep the full precision of the integer */
            {
                JSBigFloat *p = JS_VALUE_GET_PTR(val);
                val = JS_MKPTR(JS_TAG_BIG_FLOAT, p);
            }
            break;
        case JS_TAG_BIG_DECIMAL:
            val = JS_ToStringFree(ctx, val);
            if (JS_IsException(val))
                break;
            goto redo;
        case JS_TAG_STRING:
            {
                const char *str, *p;
                size_t len;
                int err;

                str = JS_ToCStringLen(ctx, &len, val);
                JS_FreeValue(ctx, val);
                if (!str)
                    return JS_EXCEPTION;
                p = str;
                p += skip_spaces(p);
                if ((p - str) == len) {
                    bf_t *r;
                    val = JS_NewBigFloat(ctx);
                    if (JS_IsException(val))
                        break;
                    r = JS_GetBigFloat(val);
                    bf_set_zero(r, 0);
                    err = 0;
                } else {
                    val = js_atof(ctx, p, &p, 0, ATOD_ACCEPT_BIN_OCT |
                                  ATOD_TYPE_BIG_FLOAT |
                                  ATOD_ACCEPT_PREFIX_AFTER_SIGN);
                    if (JS_IsException(val)) {
                        JS_FreeCString(ctx, str);
                        return JS_EXCEPTION;
                    }
                    p += skip_spaces(p);
                    err = ((p - str) != len);
                }
                JS_FreeCString(ctx, str);
                if (err) {
                    JS_FreeValue(ctx, val);
                    return JS_ThrowSyntaxError(ctx, "invalid bigfloat literal");
                }
            }
            break;
        case JS_TAG_OBJECT:
            val = JS_ToPrimitiveFree(ctx, val, HINT_NUMBER);
            if (JS_IsException(val))
                break;
            goto redo;
        case JS_TAG_NULL:
        case JS_TAG_UNDEFINED:
        default:
            JS_FreeValue(ctx, val);
            return JS_ThrowTypeError(ctx, "cannot convert to bigfloat");
        }
    }
    return val;
 fail:
    JS_FreeValue(ctx, val);
    return JS_EXCEPTION;
}
