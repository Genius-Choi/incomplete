defragmentTCP(DcmTransportConnection *connection, DUL_BLOCKOPTIONS block, time_t timerStart,
              int timeout, void *p, unsigned long l, unsigned long *rtnLen)
{
    unsigned char *b;
    int bytesRead;

    /* assign buffer to local variable */
    b = (unsigned char *) p;

    /* if reference parameter is a valid pointer, initialize its value */
    if (rtnLen != NULL)
        *rtnLen = 0;

    /* if there is no network connection, return an error */
    if (connection == NULL) return DUL_NULLKEY;

    int timeToWait = 0;
    if (block == DUL_NOBLOCK)
    {
        /* figure out how long we want to wait: if timerStart equals 0 we want to wait exactly */
        /* timeout seconds starting from the call to select(...) within the below called function; */
        /* if timerStart does not equal 0 we want to subtract the time which has already passed */
        /* after the timer was started from timeout and wait the resulting amount of seconds */
        /* starting from the call to select(...) within the below called function. */
        if (timerStart == 0) timerStart = time(NULL);
    }

    /* start a loop: since we want to receive l bytes of data over the network, */
    /* we won't stop waiting for data until we actually did receive l bytes. */
    while (l > 0)
    {
        /* receive data from the network connection; wait until */
        /* we actually did receive data or an error occurred */
        do
        {
            /* if DUL_NOBLOCK is specified as a blocking option, we only want to wait a certain
             * time for receiving data over the network. If no data was received during that time,
             * DUL_READTIMEOUT shall be returned. Note that if DUL_BLOCK is specified the application
             * will not stop waiting until data is actually received over the network.
             */
            if (block == DUL_NOBLOCK)
            {
                /* determine remaining time to wait */
                timeToWait = timeout - (int) (time(NULL) - timerStart);

                /* go ahead and see if within timeout seconds data will be received over the network. */
                /* if not, return DUL_READTIMEOUT, if yes, stay in this function. */
                if (!connection->networkDataAvailable(timeToWait)) return DUL_READTIMEOUT;
            }

            /* data has become available, now call read(). */
            bytesRead = connection->read((char*)b, size_t(l));

        } while (bytesRead == -1 && OFStandard::getLastNetworkErrorCode().value() == DCMNET_EINTR);

        /* if we actually received data, move the buffer pointer to its own end, update the variable */
        /* that determines the end of the first loop, and update the reference parameter return variable */
        if (bytesRead > 0) {
            b += bytesRead;
            l -= (unsigned long) bytesRead;
            if (rtnLen != NULL)
                *rtnLen += (unsigned long) bytesRead;
        } else {
            /* in case we did not receive any data, an error must have occurred; return a corresponding result value */
            return DUL_NETWORKCLOSED;
        }
    }
    return EC_Normal;
}
