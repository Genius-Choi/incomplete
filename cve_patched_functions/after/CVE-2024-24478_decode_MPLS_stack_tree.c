decode_MPLS_stack_tree(tvbuff_t *tvb, gint offset, proto_tree *parent_tree)
{
    guint32     label_entry=0;    /* an MPLS label entry (label + COS field + stack bit)   */
    gint        indx;          /* index for the label stack */
    proto_tree  *labels_tree=NULL;
    proto_item  *labels_item=NULL;
    proto_item  *label_item=NULL;
    indx = offset ;
    label_entry = 0x000000 ;

    labels_item = proto_tree_add_item(parent_tree, hf_bgp_update_mpls_label, tvb, offset, 3, ENC_NA);
    proto_item_append_text(labels_item, ": ");
    labels_tree = proto_item_add_subtree(labels_item, ett_bgp_mpls_labels);
    while ((label_entry & BGP_MPLS_BOTTOM_L_STACK) == 0) {

        label_entry = tvb_get_ntoh24(tvb, indx);
        label_item = proto_tree_add_item(labels_tree, hf_bgp_update_mpls_label_value, tvb, indx, 3, ENC_BIG_ENDIAN);
        /* withdrawn routes may contain 0 or 0x800000 in the first label */
        if((indx == offset)&&(label_entry==0||label_entry==0x800000)) {
            proto_item_append_text(labels_item, " (withdrawn)");
            proto_item_append_text(label_item, " (withdrawn)");
            return (1);
        }

        proto_item_append_text(labels_item, "%u%s", label_entry >> 4,
                ((label_entry & BGP_MPLS_BOTTOM_L_STACK) == 0) ? "," : " (bottom)");
        proto_item_append_text(label_item, "%u%s", label_entry >> 4,
                ((label_entry & BGP_MPLS_BOTTOM_L_STACK) == 0) ? "," : " (bottom)");
        indx += 3 ;

        if ((label_entry & BGP_MPLS_BOTTOM_L_STACK) == 0) {
            /* real MPLS multi-label stack in BGP? - maybe later; for now, it must be a bogus packet */
            proto_item_append_text(labels_item, " (BOGUS: Bottom of Stack NOT set!)");
            break;
        }
    }
    proto_item_set_len(labels_item, (indx - offset));
    return((indx - offset) / 3);
}
