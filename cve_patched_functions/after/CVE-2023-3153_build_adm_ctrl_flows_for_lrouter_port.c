build_adm_ctrl_flows_for_lrouter_port(
        struct ovn_port *op, struct hmap *lflows,
        struct ds *match, struct ds *actions)
{
    if (op->nbrp) {
        if (!lrport_is_enabled(op->nbrp)) {
            /* Drop packets from disabled logical ports (since logical flow
             * tables are default-drop). */
            return;
        }

        if (is_cr_port(op)) {
            /* No ingress packets should be received on a chassisredirect
             * port. */
            return;
        }

        /* Store the ethernet address of the port receiving the packet.
         * This will save us from having to match on inport further down in
         * the pipeline.
         */
        ds_clear(match);
        ds_put_format(match, "eth.mcast && inport == %s", op->json_key);
        build_gateway_mtu_flow(lflows, op, S_ROUTER_IN_ADMISSION, 50, 55,
                               match, actions, &op->nbrp->header_,
                               REG_INPORT_ETH_ADDR " = %s; next;",
                               op->lrp_networks.ea_s);

        ds_clear(match);
        ds_put_format(match, "eth.dst == %s && inport == %s",
                      op->lrp_networks.ea_s, op->json_key);
        if (consider_l3dgw_port_is_centralized(op)) {
            ds_put_format(match, " && is_chassis_resident(%s)",
                          op->cr_port->json_key);
        }
        build_gateway_mtu_flow(lflows, op, S_ROUTER_IN_ADMISSION, 50, 55,
                               match, actions, &op->nbrp->header_,
                               REG_INPORT_ETH_ADDR " = %s; next;",
                               op->lrp_networks.ea_s);
    }
}
