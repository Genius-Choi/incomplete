static void link_prepare_wakeup(struct tipc_link *l)
{
	struct sk_buff_head *wakeupq = &l->wakeupq;
	struct sk_buff_head *inputq = l->inputq;
	struct sk_buff *skb, *tmp;
	struct sk_buff_head tmpq;
	int avail[5] = {0,};
	int imp = 0;

	__skb_queue_head_init(&tmpq);

	for (; imp <= TIPC_SYSTEM_IMPORTANCE; imp++)
		avail[imp] = l->backlog[imp].limit - l->backlog[imp].len;

	skb_queue_walk_safe(wakeupq, skb, tmp) {
		imp = TIPC_SKB_CB(skb)->chain_imp;
		if (avail[imp] <= 0)
			continue;
		avail[imp]--;
		__skb_unlink(skb, wakeupq);
		__skb_queue_tail(&tmpq, skb);
	}

	spin_lock_bh(&inputq->lock);
	skb_queue_splice_tail(&tmpq, inputq);
	spin_unlock_bh(&inputq->lock);

}
