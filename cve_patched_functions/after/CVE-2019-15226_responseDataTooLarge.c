void ConnectionManagerImpl::ActiveStreamEncoderFilter::responseDataTooLarge() {
  if (parent_.state_.encoder_filters_streaming_) {
    onEncoderFilterAboveWriteBufferHighWatermark();
  } else {
    parent_.connection_manager_.stats_.named_.rs_too_large_.inc();

    // If headers have not been sent to the user, send a 500.
    if (!headers_continued_) {
      // Make sure we won't end up with nested watermark calls from the body buffer.
      parent_.state_.encoder_filters_streaming_ = true;
      allowIteration();

      parent_.stream_info_.setResponseCodeDetails(
          StreamInfo::ResponseCodeDetails::get().RequestHeadersTooLarge);
      Http::Utility::sendLocalReply(
          Grpc::Common::hasGrpcContentType(*parent_.request_headers_),
          [&](HeaderMapPtr&& response_headers, bool end_stream) -> void {
            parent_.chargeStats(*response_headers);
            parent_.response_headers_ = std::move(response_headers);
            parent_.response_encoder_->encodeHeaders(*parent_.response_headers_, end_stream);
            parent_.state_.local_complete_ = end_stream;
          },
          [&](Buffer::Instance& data, bool end_stream) -> void {
            parent_.response_encoder_->encodeData(data, end_stream);
            parent_.state_.local_complete_ = end_stream;
          },
          parent_.state_.destroyed_, Http::Code::InternalServerError,
          CodeUtility::toString(Http::Code::InternalServerError), absl::nullopt,
          parent_.is_head_request_);
      parent_.maybeEndEncode(parent_.state_.local_complete_);
    } else {
      resetStream();
    }
  }
}
