build_icmperr_pkt_big_flows(struct ovn_port *op, int mtu, struct hmap *lflows,
                            const struct shash *meter_groups, struct ds *match,
                            struct ds *actions, enum ovn_stage stage,
                            struct ovn_port *outport)
{
    char *outport_match = outport ? xasprintf("outport == %s && ",
                                              outport->json_key)
                                  : NULL;

    if (op->lrp_networks.ipv4_addrs) {
        ds_clear(match);
        ds_put_format(match, "inport == %s && %sip4 && "REGBIT_PKT_LARGER
                      " && "REGBIT_EGRESS_LOOPBACK" == 0", op->json_key,
                      outport ? outport_match : "");

        ds_clear(actions);
        /* Set icmp4.frag_mtu to gw_mtu */
        ds_put_format(actions,
            "icmp4_error {"
            REGBIT_EGRESS_LOOPBACK" = 1; "
            REGBIT_PKT_LARGER" = 0; "
            "eth.dst = %s; "
            "ip4.dst = ip4.src; "
            "ip4.src = %s; "
            "ip.ttl = 255; "
            "icmp4.type = 3; /* Destination Unreachable. */ "
            "icmp4.code = 4; /* Frag Needed and DF was Set. */ "
            "icmp4.frag_mtu = %d; "
            "next(pipeline=ingress, table=%d); };",
            op->lrp_networks.ea_s,
            op->lrp_networks.ipv4_addrs[0].addr_s,
            mtu, ovn_stage_get_table(S_ROUTER_IN_ADMISSION));
        ovn_lflow_add_with_hint__(lflows, op->od, stage, 150,
                                  ds_cstr(match), ds_cstr(actions),
                                  NULL,
                                  copp_meter_get(
                                        COPP_ICMP4_ERR,
                                        op->od->nbr->copp,
                                        meter_groups),
                                  &op->nbrp->header_);
    }

    if (op->lrp_networks.ipv6_addrs) {
        ds_clear(match);
        ds_put_format(match, "inport == %s && %sip6 && "REGBIT_PKT_LARGER
                      " && "REGBIT_EGRESS_LOOPBACK" == 0", op->json_key,
                      outport ? outport_match : "");

        ds_clear(actions);
        /* Set icmp6.frag_mtu to gw_mtu */
        ds_put_format(actions,
            "icmp6_error {"
            REGBIT_EGRESS_LOOPBACK" = 1; "
            REGBIT_PKT_LARGER" = 0; "
            "eth.dst = %s; "
            "ip6.dst = ip6.src; "
            "ip6.src = %s; "
            "ip.ttl = 255; "
            "icmp6.type = 2; /* Packet Too Big. */ "
            "icmp6.code = 0; "
            "icmp6.frag_mtu = %d; "
            "next(pipeline=ingress, table=%d); };",
            op->lrp_networks.ea_s,
            op->lrp_networks.ipv6_addrs[0].addr_s,
            mtu, ovn_stage_get_table(S_ROUTER_IN_ADMISSION));
        ovn_lflow_add_with_hint__(lflows, op->od, stage, 150,
                                  ds_cstr(match), ds_cstr(actions),
                                  NULL,
                                  copp_meter_get(
                                        COPP_ICMP6_ERR,
                                        op->od->nbr->copp,
                                        meter_groups),
                                  &op->nbrp->header_);
    }
    free(outport_match);
}
