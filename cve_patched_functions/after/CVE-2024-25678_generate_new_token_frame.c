generate_new_token_frame (struct ietf_full_conn *conn, lsquic_time_t now)
{
    struct lsquic_packet_out *packet_out;
    const struct network_path *path;
    ssize_t token_sz;
    size_t need;
    int w;
    unsigned char token_buf[MAX_RETRY_TOKEN_LEN];

    path = &conn->ifc_paths[conn->ifc_cur_path_id].cop_path;
    token_sz = lsquic_tg_token_size(conn->ifc_enpub->enp_tokgen, TOKEN_RESUME,
                                                            NP_PEER_SA(path));
    need = conn->ifc_conn.cn_pf->pf_new_token_frame_size(token_sz);
    packet_out = get_writeable_packet(conn, need);
    if (!packet_out)
        return;

    token_sz = lsquic_tg_generate_resume(conn->ifc_enpub->enp_tokgen, token_buf,
                                        sizeof(token_buf), NP_PEER_SA(path));
    if (token_sz < 0)
    {
        LSQ_WARN("could not generate resume token");
        conn->ifc_send_flags &= ~SF_SEND_NEW_TOKEN; /* Let's not try again */
        return;
    }

    w = conn->ifc_conn.cn_pf->pf_gen_new_token_frame(
            packet_out->po_data + packet_out->po_data_sz,
            lsquic_packet_out_avail(packet_out), token_buf, token_sz);
    if (w < 0)
    {
        ABORT_ERROR("generating NEW_TOKEN frame failed: %d", errno);
        return;
    }
    LSQ_DEBUG("generated %d-byte NEW_TOKEN frame", w);
    EV_LOG_GENERATED_NEW_TOKEN_FRAME(LSQUIC_LOG_CONN_ID, conn->ifc_conn.cn_pf,
                        packet_out->po_data + packet_out->po_data_sz, w);
    if (0 != lsquic_packet_out_add_frame(packet_out, conn->ifc_pub.mm, 0,
                            QUIC_FRAME_NEW_TOKEN, packet_out->po_data_sz, w))
    {
        ABORT_ERROR("adding frame to packet failed: %d", errno);
        return;
    }
    packet_out->po_frame_types |= QUIC_FTBIT_NEW_TOKEN;
    lsquic_send_ctl_incr_pack_sz(&conn->ifc_send_ctl, packet_out, w);

    conn->ifc_send_flags &= ~SF_SEND_NEW_TOKEN;
    (void) token_sz;
}
