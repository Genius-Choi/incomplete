static int statSyscall(
    const String& path,
    struct stat* buf,
    bool useFileCache = false) {
  bool isRelative = !FileUtil::isAbsolutePath(path.slice());
  int pathIndex = 0;
  Stream::Wrapper* w = Stream::getWrapperFromURI(path, &pathIndex);
  if (!w) return -1;
  bool isFileStream = dynamic_cast<FileStreamWrapper*>(w);
  auto canUseFileCache = useFileCache && isFileStream;
  if (isRelative && !pathIndex) {
    auto fullpath = g_context->getCwd() + String::FromChar('/') + path;
    if (!RID().hasSafeFileAccess() && !canUseFileCache) {
      if (strlen(fullpath.data()) != fullpath.size()) return ENOENT;
      if (!isFileStream && w->isNormalFileStream()) {
        return w->stat(fullpath.data(), buf);
      }
      return ::stat(fullpath.data(), buf);
    }
    std::string realpath = StatCache::realpath(fullpath.data());
    // realpath will return an empty string for nonexistent files
    if (realpath.empty()) {
      return ENOENT;
    }
    auto translatedPath = canUseFileCache ?
      File::TranslatePathWithFileCache(realpath) :
      File::TranslatePath(realpath);
    if (!isFileStream && w->isNormalFileStream()) {
      return w->stat(translatedPath.data(), buf);
    }
    return ::stat(translatedPath.data(), buf);
  }

  auto properPath = w->isNormalFileStream() ? path.substr(pathIndex) : path;
  if (canUseFileCache) {
    return ::stat(File::TranslatePathWithFileCache(properPath).data(), buf);
  }
  return w->stat(properPath, buf);
}
