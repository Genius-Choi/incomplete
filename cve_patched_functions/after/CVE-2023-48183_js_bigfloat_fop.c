static JSValue js_bigfloat_fop(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv, int magic)
{
    bf_t a_s, *a, *r;
    JSFloatEnv *fe;
    int rnd_mode;
    JSValue op1, res;

    op1 = JS_ToNumeric(ctx, argv[0]);
    if (JS_IsException(op1))
        return op1;
    a = JS_ToBigFloat(ctx, &a_s, op1);
    if (!a) {
        JS_FreeValue(ctx, op1);
        return JS_EXCEPTION;
    }
    fe = &ctx->fp_env;
    if (argc > 1) {
        fe = JS_GetOpaque2(ctx, argv[1], JS_CLASS_FLOAT_ENV);
        if (!fe)
            goto fail;
    }
    res = JS_NewBigFloat(ctx);
    if (JS_IsException(res)) {
    fail:
        if (a == &a_s)
            bf_delete(a);
        JS_FreeValue(ctx, op1);
        return JS_EXCEPTION;
    }
    r = JS_GetBigFloat(res);
    switch (magic) {
    case MATH_OP_ABS:
        bf_set(r, a);
        r->sign = 0;
        break;
    case MATH_OP_FLOOR:
        rnd_mode = BF_RNDD;
        goto rint;
    case MATH_OP_CEIL:
        rnd_mode = BF_RNDU;
        goto rint;
    case MATH_OP_ROUND:
        rnd_mode = BF_RNDNA;
        goto rint;
    case MATH_OP_TRUNC:
        rnd_mode = BF_RNDZ;
    rint:
        bf_set(r, a);
        fe->status |= bf_rint(r, rnd_mode);
        break;
    case MATH_OP_SQRT:
        fe->status |= bf_sqrt(r, a, fe->prec, fe->flags);
        break;
    case MATH_OP_FPROUND:
        bf_set(r, a);
        fe->status |= bf_round(r, fe->prec, fe->flags);
        break;
    case MATH_OP_ACOS:
        fe->status |= bf_acos(r, a, fe->prec, fe->flags);
        break;
    case MATH_OP_ASIN:
        fe->status |= bf_asin(r, a, fe->prec, fe->flags);
        break;
    case MATH_OP_ATAN:
        fe->status |= bf_atan(r, a, fe->prec, fe->flags);
        break;
    case MATH_OP_COS:
        fe->status |= bf_cos(r, a, fe->prec, fe->flags);
        break;
    case MATH_OP_EXP:
        fe->status |= bf_exp(r, a, fe->prec, fe->flags);
        break;
    case MATH_OP_LOG:
        fe->status |= bf_log(r, a, fe->prec, fe->flags);
        break;
    case MATH_OP_SIN:
        fe->status |= bf_sin(r, a, fe->prec, fe->flags);
        break;
    case MATH_OP_TAN:
        fe->status |= bf_tan(r, a, fe->prec, fe->flags);
        break;
    case MATH_OP_SIGN:
        if (bf_is_nan(a) || bf_is_zero(a)) {
            bf_set(r, a);
        } else {
            bf_set_si(r, 1 - 2 * a->sign);
        }
        break;
    default:
        abort();
    }
    if (a == &a_s)
        bf_delete(a);
    JS_FreeValue(ctx, op1);
    return res;
}
