void IMAPSession::storeFlagsAndCustomFlags(String * folder, bool identifier_is_uid, IndexSet * identifiers,
                                                      IMAPStoreFlagsRequestKind kind, MessageFlag flags, Array * customFlags, ErrorCode * pError)
{
    struct mailimap_set * imap_set;
    struct mailimap_store_att_flags * store_att_flags;
    struct mailimap_flag_list * flag_list;
    int r;
    clist * setList;

    selectIfNeeded(folder, pError);
    if (* pError != ErrorNone)
        return;

    imap_set = setFromIndexSet(identifiers);
    if (clist_count(imap_set->set_list) == 0) {
        mailimap_set_free(imap_set);
        return;
    }

    setList = splitSet(imap_set, 50);

    flag_list = mailimap_flag_list_new_empty();
    if ((flags & MessageFlagSeen) != 0) {
        struct mailimap_flag * f;

        f = mailimap_flag_new_seen();
        mailimap_flag_list_add(flag_list, f);
    }
    if ((flags & MessageFlagAnswered) != 0) {
        struct mailimap_flag * f;

        f = mailimap_flag_new_answered();
        mailimap_flag_list_add(flag_list, f);
    }
    if ((flags & MessageFlagFlagged) != 0) {
        struct mailimap_flag * f;

        f = mailimap_flag_new_flagged();
        mailimap_flag_list_add(flag_list, f);
    }
    if ((flags & MessageFlagDeleted) != 0) {
        struct mailimap_flag * f;

        f = mailimap_flag_new_deleted();
        mailimap_flag_list_add(flag_list, f);
    }
    if ((flags & MessageFlagDraft) != 0) {
        struct mailimap_flag * f;

        f = mailimap_flag_new_draft();
        mailimap_flag_list_add(flag_list, f);
    }
    if ((flags & MessageFlagMDNSent) != 0) {
        struct mailimap_flag * f;

        f = mailimap_flag_new_flag_keyword(strdup("$MDNSent"));
        mailimap_flag_list_add(flag_list, f);
    }
    if ((flags & MessageFlagForwarded) != 0) {
        struct mailimap_flag * f;

        f = mailimap_flag_new_flag_keyword(strdup("$Forwarded"));
        mailimap_flag_list_add(flag_list, f);
    }
    if ((flags & MessageFlagSubmitPending) != 0) {
        struct mailimap_flag * f;

        f = mailimap_flag_new_flag_keyword(strdup("$SubmitPending"));
        mailimap_flag_list_add(flag_list, f);
    }
    if ((flags & MessageFlagSubmitted) != 0) {
        struct mailimap_flag * f;
        
        f = mailimap_flag_new_flag_keyword(strdup("$Submitted"));
        mailimap_flag_list_add(flag_list, f);
    }
    
    if (customFlags != NULL) {
        for (unsigned int i = 0 ; i < customFlags->count() ; i ++) {
            struct mailimap_flag * f;
            String * customFlag = (String *) customFlags->objectAtIndex(i);
            
            f = mailimap_flag_new_flag_keyword(strdup(customFlag->UTF8Characters()));
            mailimap_flag_list_add(flag_list, f);
        }
    }

    store_att_flags = NULL;
    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {
        struct mailimap_set * current_set;

        current_set = (struct mailimap_set *) clist_content(iter);

        switch (kind) {
            case IMAPStoreFlagsRequestKindRemove:
            store_att_flags = mailimap_store_att_flags_new_remove_flags_silent(flag_list);
            break;
            case IMAPStoreFlagsRequestKindAdd:
            store_att_flags = mailimap_store_att_flags_new_add_flags_silent(flag_list);
            break;
            case IMAPStoreFlagsRequestKindSet:
            store_att_flags = mailimap_store_att_flags_new_set_flags_silent(flag_list);
            break;
        }

#ifdef LIBETPAN_HAS_MAILIMAP_QIP_WORKAROUND
        if (mQipServer) {
            mailimap_set_qip_workaround_enabled(mImap, 1);
        }
#endif

        if (identifier_is_uid) {
            r = mailimap_uid_store(mImap, current_set, store_att_flags);
        }
        else {
            r = mailimap_store(mImap, current_set, store_att_flags);
        }

#ifdef LIBETPAN_HAS_MAILIMAP_QIP_WORKAROUND
        mailimap_set_qip_workaround_enabled(mImap, 0);
#endif

        if (r == MAILIMAP_ERROR_STREAM) {
            mShouldDisconnect = true;
            * pError = ErrorConnection;
            goto release;
        }
        else if (r == MAILIMAP_ERROR_PARSE) {
            mShouldDisconnect = true;
            * pError = ErrorParse;
            goto release;
        }
        else if (hasError(r)) {
            * pError = ErrorStore;
            goto release;
        }
    }
    * pError = ErrorNone;

    release:
    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {
        struct mailimap_set * current_set;

        current_set = (struct mailimap_set *) clist_content(iter);
        mailimap_set_free(current_set);
    }
    clist_free(setList);
    mailimap_store_att_flags_free(store_att_flags);
    mailimap_set_free(imap_set);
}
