    upstream_log_flush_timer_ = parent_.callbacks()->dispatcher().createTimer([this]() -> void {
      // If the request is complete, we've already done the stream-end upstream log, and shouldn't
      // do the periodic log.
      if (!streamInfo().requestComplete().has_value()) {
        upstreamLog(AccessLog::AccessLogType::UpstreamPeriodic);
        resetUpstreamLogFlushTimer();
      }
      // Both downstream and upstream bytes meters may not be initialized when
      // the timer goes off, e.g. if it takes longer than the interval for a
      // connection to be initialized; check for nullptr.
      auto& downstream_bytes_meter = stream_info_.getDownstreamBytesMeter();
      auto& upstream_bytes_meter = stream_info_.getUpstreamBytesMeter();
      const SystemTime now = parent_.callbacks()->dispatcher().timeSource().systemTime();
      if (downstream_bytes_meter) {
        downstream_bytes_meter->takeUpstreamPeriodicLoggingSnapshot(now);
      }
      if (upstream_bytes_meter) {
        upstream_bytes_meter->takeUpstreamPeriodicLoggingSnapshot(now);
      }
    });
