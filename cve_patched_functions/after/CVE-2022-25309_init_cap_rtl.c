init_cap_rtl (
  void
)
{
  int request[_FRIBIDI_NUM_TYPES];
  FriBidiCharType to_type[_FRIBIDI_NUM_TYPES];
  int num_types = 0, count = 0;
  FriBidiCharType i;
  char mark[CAPRTL_CHARS];

  caprtl_to_unicode =
    (FriBidiChar *) fribidi_malloc (CAPRTL_CHARS *
				    sizeof caprtl_to_unicode[0]);
  for (i = 0; i < CAPRTL_CHARS; i++)
    if (CapRTLCharTypes[i] == fribidi_get_bidi_type (i))
      {
	caprtl_to_unicode[i] = i;
	mark[i] = 1;
      }
    else
      {
	int j;

	caprtl_to_unicode[i] = FRIBIDI_UNICODE_CHARS;
	mark[i] = 0;
	if (fribidi_get_mirror_char (i, NULL))
	  {
	    DBG ("warning: I could not map mirroring character map to itself in CapRTL");
	  }

	for (j = 0; j < num_types; j++)
	  if (to_type[j] == CapRTLCharTypes[i])
	    break;
	if (j == num_types)
	  {
	    num_types++;
	    to_type[j] = CapRTLCharTypes[i];
	    request[j] = 0;
	  }
	request[j]++;
	count++;
      }
  for (i = 0; i < 0x10000 && count; i++)	/* Assign BMP chars to CapRTL entries */
    if (!fribidi_get_mirror_char (i, NULL) && !(i < CAPRTL_CHARS && mark[i]))
      {
	int j, k;
	FriBidiCharType t = fribidi_get_bidi_type (i);
	for (j = 0; j < num_types; j++)
	  if (to_type[j] == t)
	    break;
	if (j >= num_types || !request[j])	/* Do not need this type */
	  continue;
	for (k = 0; k < CAPRTL_CHARS; k++)
	  if (caprtl_to_unicode[k] == FRIBIDI_UNICODE_CHARS
	      && to_type[j] == CapRTLCharTypes[k])
	    {
	      request[j]--;
	      count--;
	      caprtl_to_unicode[k] = i;
	      break;
	    }
      }
  if (count)
    {
      int j;

      DBG ("warning: could not find a mapping for CapRTL to Unicode:");
      for (j = 0; j < num_types; j++)
	if (request[j])
	  {
	    DBG2 ("  need this type: %s", fribidi_get_bidi_type_name (to_type[j]));
	  }
    }
}
