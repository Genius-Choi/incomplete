int ds_count(struct sip_msg *msg, int set_id, void *_cmp, pv_spec_p ret,
				ds_partition_t *partition)
{
	pv_value_t pv_val;
	ds_set_p set;
	ds_dest_p dst;
	int count, active = 0, inactive = 0, probing = 0;
	int cmp = (int)(long)_cmp;

	LM_DBG("Searching for set: %d, filtering: %d\n", set_id, cmp);

	/* access ds data under reader's lock */
	lock_start_read( partition->lock );

	if ( ds_get_index( set_id, &set, partition)!=0 ) {
		LM_ERR("INVALID SET %d (not found)!\n",set_id);
		lock_stop_read( partition->lock );
		return -1;
	}

	for (dst = set->dlist; dst; dst = dst->next)
	{
		if ( dst_is_active(*dst) )
		{
			active++;

		} else if (dst->flags & DS_INACTIVE_DST)
		{
			inactive++;

		} else if (dst->flags & DS_PROBING_DST)
		{
			probing++;
		}
	}

	lock_stop_read( partition->lock );

	switch (cmp)
	{
		case DS_COUNT_ACTIVE:
			count = active;
			break;

		case DS_COUNT_ACTIVE|DS_COUNT_INACTIVE:
		case DS_COUNT_ACTIVE|DS_COUNT_PROBING:
			count = (cmp & DS_COUNT_INACTIVE ? active + inactive :
												active + probing);
			break;

		case DS_COUNT_INACTIVE:
		case DS_COUNT_PROBING:
			count = (cmp == DS_COUNT_INACTIVE ? inactive : probing);
			break;

		case DS_COUNT_INACTIVE|DS_COUNT_PROBING:
			count = inactive + probing;
			break;

		default:
			count = active + inactive + probing;
	}

	pv_val.flags = PV_TYPE_INT;
	pv_val.ri = count;

	if (pv_set_value(msg, ret, 0, &pv_val) != 0)
	{
		LM_ERR("SET OUTPUT value failed!\n");
		return -1;
	}

	return 1;
}
