decode_preR13_entities (unsigned long start, unsigned long end,
                        unsigned long offset, Bit_Chain *restrict dat,
                        Dwg_Data *restrict dwg)
{
  int error = 0;
  BITCODE_BL num = dwg->num_objects;
  dat->bit = 0;
  LOG_TRACE ("entities: (0x%lx-0x%lx, offset 0x%lx) TODO\n", start, end,
             offset)
  while (dat->byte < end)
    {
      Dwg_Object *obj;
      Dwg_Object_Entity *ent;
      BITCODE_RS crc;

      if (!num)
        dwg->object
            = (Dwg_Object *)malloc (REFS_PER_REALLOC * sizeof (Dwg_Object));
      else if (num % REFS_PER_REALLOC == 0)
        dwg->object = realloc (dwg->object,
                               (num + REFS_PER_REALLOC) * sizeof (Dwg_Object));
      if (!dwg->object)
        {
          LOG_ERROR ("Out of memory");
          return DWG_ERR_OUTOFMEM;
        }
      obj = &dwg->object[num];
      memset (obj, 0, sizeof (Dwg_Object));
      dwg->num_objects++;
      obj->index = num;
      obj->parent = dwg;
      obj->address = dat->byte;

      DEBUG_HERE;

      switch (obj->type)
        {
        case 1:
          error |= dwg_decode_LINE (dat, obj);
          break;
        case 2:
          error |= dwg_decode_POINT (dat, obj);
          break;
        case 3:
          error |= dwg_decode_CIRCLE (dat, obj);
          break;
        case 4:
          error |= dwg_decode_SHAPE (dat, obj);
          break;
        case 7:
          error |= dwg_decode_TEXT (dat, obj);
          break;
        case 8:
          error |= dwg_decode_ARC (dat, obj);
          break;
        case 9:
          error |= dwg_decode_TRACE (dat, obj);
          break;
        case 11:
          error |= dwg_decode_SOLID (dat, obj);
          break;
        case 12:
          error |= dwg_decode_BLOCK (dat, obj);
          break;
        case 13:
          error |= dwg_decode_ENDBLK (dat, obj);
          break;
        case 14:
          error |= dwg_decode_INSERT (dat, obj);
          break;
        case 15:
          error |= dwg_decode_ATTDEF (dat, obj);
          break;
        case 16:
          error |= dwg_decode_ATTRIB (dat, obj);
          break;
        case 17:
          error |= dwg_decode_SEQEND (dat, obj);
          break;
        case 19:
          error |= dwg_decode_POLYLINE_2D (dat, obj);
          break;
        case 20:
          error |= dwg_decode_VERTEX_2D (dat, obj);
          break;
        case 22:
          error |= dwg_decode__3DFACE (dat, obj);
          break;
        case 23:
          // TODO check opts for the type of dimension
          error |= dwg_decode_DIMENSION_LINEAR (dat, obj);
          break;
        case 24:
          error |= dwg_decode_VPORT (dat, obj);
          break;
        default:
          LOG_ERROR ("Unknown object type %d", obj->type)
          break;
        }

      bit_set_position (dat, obj->address + obj->size - 2);
      crc = bit_read_RS (dat);
      LOG_TRACE ("crc: %04X [RSx]\n", crc);
      num++;

      if (obj->size < 2 || obj->size > 0x1000) // FIXME
        dat->byte = end;
    }

  dat->byte = end;
  return error;
}
