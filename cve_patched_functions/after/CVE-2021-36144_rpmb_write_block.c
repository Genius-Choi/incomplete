rpmb_write_block(__u8 mode, __u8 *key, __u16 addr, void *buf, __u32 count)
{
	int rc;
	int fd;
	__u32 i;
	__u32 write_counter;
	__u16 result;
	struct {
		struct rpmb_ioc_seq_cmd h;
		struct rpmb_ioc_cmd cmd[3];
	} iseq = {};
	struct rpmb_frame frame_write;
	struct rpmb_frame frame_rel[count];
	struct rpmb_frame frame_read;

	if (!buf || count == 0) {
		DPRINTF(("%s:buf or count is invalid!\n", __func__));
		return -ENOBUFS;
	}

	rc = rpmb_get_counter(mode, key, &write_counter, &result);
	if (rc) {
		DPRINTF(("%s: virtio_rpmb_get_counter failed\n", __func__));
		return rc;
	}

	frame_write.addr = swap16(addr);
	frame_write.req_resp = swap16(RPMB_REQ_RESULT_READ);
	frame_write.write_counter = swap32(write_counter);

	for (i = 0; i < count; i++) {
		memset(&frame_rel[i], 0, sizeof(frame_rel[i]));
		memcpy(frame_rel[i].data, buf + i * sizeof(frame_rel[i].data), sizeof(frame_rel[i].data));
		frame_rel[i].write_counter = swap32(write_counter);
		frame_rel[i].addr = swap16(addr);
		frame_rel[i].block_count = swap16(count);
		frame_rel[i].req_resp = swap16(RPMB_REQ_DATA_WRITE);
	}

	iseq.cmd[0].flags = RPMB_F_WRITE | RPMB_F_REL_WRITE;
	iseq.cmd[0].nframes = count;
	iseq.cmd[0].frames_ptr = (__aligned_u64)(intptr_t)(frame_rel);
	iseq.cmd[1].flags = RPMB_F_WRITE;
	iseq.cmd[1].nframes = 1;
	iseq.cmd[1].frames_ptr = (__aligned_u64)(intptr_t)(&frame_write);
	iseq.cmd[2].flags = 0;
	iseq.cmd[2].nframes = 1;
	iseq.cmd[2].frames_ptr = (__aligned_u64)(intptr_t)(&frame_read);
	iseq.h.num_of_cmds = 3;

	if (mode == RPMB_PHY_MODE) {
		fd = open(RPMB_PHY_PATH_NAME, O_RDWR | O_NONBLOCK);
		if (fd < 0) {
			DPRINTF(("failed to open %s for read blocks.\n", RPMB_PHY_PATH_NAME));
			return fd;
		}

		rc = ioctl(fd, RPMB_IOC_SEQ_CMD, &iseq);
		close(fd);
		if (rc) {
			DPRINTF(("read blocks for physical rpmb failed.\n"));
			return rc;
		}

		/*In PHY RPMB MODE, DM doesn't have real RPMB key,
		 *so no necessary to check the mac in the response.
		 */
		rc = rpmb_check_response("write blocks", RPMB_RESP_DATA_WRITE,
								&frame_read, 1, NULL, NULL, &addr);
	} else {
		rc = rpmb_sim_send(&iseq);
		if (rc) {
			DPRINTF(("read blocks for simulated rpmb failed.\n"));
			return rc;
		}

		rc = rpmb_check_response("write blocks", RPMB_RESP_DATA_WRITE,
								&frame_read, 1, key, NULL, &addr);
	}

	return rc;
}
