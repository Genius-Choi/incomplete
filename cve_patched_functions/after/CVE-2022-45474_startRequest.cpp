  void RequestHandler::startRequest(const string& transactionId, 
    const string& httpMethod, const string& url, const string& body, bool verifyPeer) {

    RequestHandler::ConnInfo *conn;
    CURLMcode rc;

    if (0 == url.find("tcp://") || 0 == url.find("tls://")) {
      string json = "{\"action\": \"route\", \"data\": {\"uri\": \"";
      json.append(url.substr(6));
      if (0 == url.find("tcp://")) json.append(";transport=tcp");
      else json.append(";transport=tls");
      json.append("\"}}");
      DR_LOG(log_info) << "RequestHandler::startRequest: no web callback required, sending directly to " << url << ":" << json.c_str() ;
      m_pController->httpCallRoutingComplete(transactionId, 200, json);
      return;
    }


    DR_LOG(log_info) << "RequestHandler::startRequest: sending http " << httpMethod << ": " << url ;

    conn = m_pool.malloc() ;
    CURL* easy = NULL ;
    {
      //alloc and free happen in the same thread
      //std::lock_guard<std::mutex> l( m_lock ) ;
      if( m_cacheEasyHandles.empty() ) {
        m_cacheEasyHandles.push_back(createEasyHandle()) ;
      }
      easy = m_cacheEasyHandles.front() ;
      m_cacheEasyHandles.pop_front() ;
      DR_LOG(log_debug) << "RequestHandler::makeRequestForRoute - after acquiring handle in thread " << 
        std::this_thread::get_id() << " " << dec <<
        m_cacheEasyHandles.size() << " handles remain in cache";
    }

    conn->easy = easy;

    conn->global = &m_g;
    strncpy(conn->url, url.c_str(), URL_LEN) ;
    strncpy(conn->body, body.c_str(), HTTP_BODY_LEN);
    strncpy(conn->transactionId, transactionId.c_str(), TXNID_LEN);
    conn->hdr_list = NULL ;
    *conn->response = '\0' ;

    curl_easy_setopt(easy, CURLOPT_URL, conn->url);
    curl_easy_setopt(easy, CURLOPT_WRITEFUNCTION, write_cb);
    curl_easy_setopt(easy, CURLOPT_WRITEDATA, conn);
    curl_easy_setopt(easy, CURLOPT_ERRORBUFFER, conn->error);
    curl_easy_setopt(easy, CURLOPT_PRIVATE, conn);
    //curl_easy_setopt(easy, CURLOPT_PROGRESSFUNCTION, prog_cb);
    //curl_easy_setopt(easy, CURLOPT_PROGRESSDATA, conn);
    //curl_easy_setopt(easy, CURLOPT_LOW_SPEED_TIME, 3L);
    //curl_easy_setopt(easy, CURLOPT_LOW_SPEED_LIMIT, 10L);
    //curl_easy_setopt(easy, CURLOPT_DEBUGFUNCTION, debug_callback);
    //curl_easy_setopt(easy, CURLOPT_DEBUGDATA, &conn);
    curl_easy_setopt(easy, CURLOPT_VERBOSE, 0L);
    curl_easy_setopt(easy, CURLOPT_NOPROGRESS, 1L);
    //curl_easy_setopt(easy, CURLOPT_HEADERFUNCTION, header_callback);
    //curl_easy_setopt(easy, CURLOPT_HEADERDATA, conn);

    
    /* call this function to get a socket */
    curl_easy_setopt(easy, CURLOPT_OPENSOCKETFUNCTION, opensocket);

    /* call this function to close a socket */
    curl_easy_setopt(easy, CURLOPT_CLOSESOCKETFUNCTION, close_socket);

    if( 0 == url.find("https:") ) {
      curl_easy_setopt(easy, CURLOPT_SSL_VERIFYPEER, verifyPeer);
    }

    conn->hdr_list = curl_slist_append(conn->hdr_list, "Accept: application/json");
    
    if( 0 == httpMethod.compare("POST") ) {
      curl_easy_setopt(easy, CURLOPT_POSTFIELDS, conn->body);
      curl_easy_setopt(easy, CURLOPT_POSTFIELDSIZE, strlen(conn->body));
      conn->hdr_list = curl_slist_append(conn->hdr_list, "Content-Type: text/plain; charset=UTF-8");
    }
    curl_easy_setopt(easy, CURLOPT_HTTPHEADER, conn->hdr_list);

    rc = curl_multi_add_handle(m_g.multi, conn->easy);
    mcode_test("new_conn: curl_multi_add_handle", rc);

    /* note that the add_handle() will set a time-out to trigger very soon so
       that the necessary socket_action() call will be called by this app */
  }
