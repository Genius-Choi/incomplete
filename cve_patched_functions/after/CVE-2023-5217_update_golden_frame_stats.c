static void update_golden_frame_stats(VP8_COMP *cpi) {
  VP8_COMMON *cm = &cpi->common;

  /* Update the Golden frame usage counts. */
  if (cm->refresh_golden_frame) {
    /* Select an interval before next GF */
    if (!cpi->auto_gold) cpi->frames_till_gf_update_due = DEFAULT_GF_INTERVAL;

    if ((cpi->pass != 2) && (cpi->frames_till_gf_update_due > 0)) {
      cpi->current_gf_interval = cpi->frames_till_gf_update_due;

      /* Set the bits per frame that we should try and recover in
       * subsequent inter frames to account for the extra GF spend...
       * note that his does not apply for GF updates that occur
       * coincident with a key frame as the extra cost of key frames
       * is dealt with elsewhere.
       */
      if ((cm->frame_type != KEY_FRAME) && !cpi->source_alt_ref_active) {
        /* Calcluate GF bits to be recovered
         * Projected size - av frame bits available for inter
         * frames for clip as a whole
         */
        cpi->gf_overspend_bits +=
            (cpi->projected_frame_size - cpi->inter_frame_target);
      }

      cpi->non_gf_bitrate_adjustment =
          cpi->gf_overspend_bits / cpi->frames_till_gf_update_due;
    }

    /* Update data structure that monitors level of reference to last GF */
    memset(cpi->gf_active_flags, 1, (cm->mb_rows * cm->mb_cols));
    cpi->gf_active_count = cm->mb_rows * cm->mb_cols;

    /* this frame refreshes means next frames don't unless specified by
     * user
     */
    cm->refresh_golden_frame = 0;
    cpi->frames_since_golden = 0;

    cpi->recent_ref_frame_usage[INTRA_FRAME] = 1;
    cpi->recent_ref_frame_usage[LAST_FRAME] = 1;
    cpi->recent_ref_frame_usage[GOLDEN_FRAME] = 1;
    cpi->recent_ref_frame_usage[ALTREF_FRAME] = 1;

    /* ******** Fixed Q test code only ************ */
    /* If we are going to use the ALT reference for the next group of
     * frames set a flag to say so.
     */
    if (cpi->oxcf.fixed_q >= 0 && cpi->oxcf.play_alternate &&
        !cpi->common.refresh_alt_ref_frame) {
      cpi->source_alt_ref_pending = 1;
      cpi->frames_till_gf_update_due = cpi->baseline_gf_interval;
    }

    if (!cpi->source_alt_ref_pending) cpi->source_alt_ref_active = 0;

    /* Decrement count down till next gf */
    if (cpi->frames_till_gf_update_due > 0) cpi->frames_till_gf_update_due--;

  } else if (!cpi->common.refresh_alt_ref_frame) {
    /* Decrement count down till next gf */
    if (cpi->frames_till_gf_update_due > 0) cpi->frames_till_gf_update_due--;

    if (cpi->frames_till_alt_ref_frame) cpi->frames_till_alt_ref_frame--;

    cpi->frames_since_golden++;

    if (cpi->frames_since_golden > 1) {
      cpi->recent_ref_frame_usage[INTRA_FRAME] +=
          cpi->mb.count_mb_ref_frame_usage[INTRA_FRAME];
      cpi->recent_ref_frame_usage[LAST_FRAME] +=
          cpi->mb.count_mb_ref_frame_usage[LAST_FRAME];
      cpi->recent_ref_frame_usage[GOLDEN_FRAME] +=
          cpi->mb.count_mb_ref_frame_usage[GOLDEN_FRAME];
      cpi->recent_ref_frame_usage[ALTREF_FRAME] +=
          cpi->mb.count_mb_ref_frame_usage[ALTREF_FRAME];
    }
  }
}
