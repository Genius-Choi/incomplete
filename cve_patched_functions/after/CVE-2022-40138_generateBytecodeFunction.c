BytecodeFunctionGenerator::generateBytecodeFunction(
    Function::DefinitionKind definitionKind,
    ValueKind valueKind,
    bool strictMode,
    uint32_t paramCount,
    uint32_t environmentSize,
    uint32_t nameID) {
  if (!complete_) {
    bytecodeGenerationComplete();
  }

  FunctionHeader header{
      bytecodeSize_,
      paramCount,
      frameSize_,
      environmentSize,
      nameID,
      highestReadCacheIndex_,
      highestWriteCacheIndex_};

  switch (definitionKind) {
    case Function::DefinitionKind::ES6Arrow:
    case Function::DefinitionKind::ES6Method:
      header.flags.prohibitInvoke = FunctionHeaderFlag::ProhibitConstruct;
      break;
    case Function::DefinitionKind::ES6Constructor:
      header.flags.prohibitInvoke = FunctionHeaderFlag::ProhibitCall;
      break;
    default:
      // ES9.0 9.2.3 step 4 states that generator functions and async
      // functions cannot be constructed.
      // We place this check outside the `DefinitionKind` because generator
      // functions may also be ES6 methods, for example, and are not included
      // in the DefinitionKind enum.
      // Note that we only have to check for GeneratorFunctionKind in this
      // case, because ES6 methods are already checked above, and ES6
      // constructors are prohibited from being generator functions.
      // As such, this is the only case in which we must change the
      // prohibitInvoke flag based on valueKind.
      header.flags.prohibitInvoke =
          (valueKind == ValueKind::GeneratorFunctionKind ||
           valueKind == ValueKind::AsyncFunctionKind)
          ? FunctionHeaderFlag::ProhibitConstruct
          : FunctionHeaderFlag::ProhibitNone;
      break;
  }

  header.flags.strictMode = strictMode;
  header.flags.hasExceptionHandler = exceptionHandlers_.size();

  return std::make_unique<BytecodeFunction>(
      std::move(opcodes_), std::move(header), std::move(exceptionHandlers_));
}
