void UpstreamRequest::readDisableOrDefer(bool disable) {
  if (!upstream_wait_for_response_headers_before_disabling_read_) {
    if (disable) {
      parent_.cluster()->trafficStats()->upstream_flow_control_paused_reading_total_.inc();
      upstream_->readDisable(true);
    } else {
      parent_.cluster()->trafficStats()->upstream_flow_control_resumed_reading_total_.inc();
      upstream_->readDisable(false);
    }
    return;
  }

  if (disable) {
    // See comments on deferred_read_disabling_count_ for when we do and don't defer.
    if (parent_.downstreamResponseStarted()) {
      // The downstream connection is overrun. Pause reads from upstream.
      // If there are multiple calls to readDisable either the codec (H2) or the
      // underlying Network::Connection (H1) will handle reference counting.
      parent_.cluster()->trafficStats()->upstream_flow_control_paused_reading_total_.inc();
      upstream_->readDisable(disable);
    } else {
      ++deferred_read_disabling_count_;
    }
    return;
  }

  // One source of connection blockage has buffer available.
  if (deferred_read_disabling_count_ > 0) {
    ASSERT(!parent_.downstreamResponseStarted());
    // Cancel out an existing deferred read disabling.
    --deferred_read_disabling_count_;
    return;
  }
  ASSERT(parent_.downstreamResponseStarted());
  // Pass this on to the stream, which
  // will resume reads if this was the last remaining high watermark.
  parent_.cluster()->trafficStats()->upstream_flow_control_resumed_reading_total_.inc();
  upstream_->readDisable(disable);
}
