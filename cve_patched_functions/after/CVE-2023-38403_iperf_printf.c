iperf_printf(struct iperf_test *test, const char* format, ...)
{
    va_list argp;
    int r = 0, r0;
    time_t now;
    struct tm *ltm = NULL;
    char *ct = NULL;

    /* Timestamp if requested */
    if (iperf_get_test_timestamps(test)) {
	time(&now);
	ltm = localtime(&now);
	strftime(iperf_timestr, sizeof(iperf_timestr), iperf_get_test_timestamp_format(test), ltm);
	ct = iperf_timestr;
    }

    /*
     * There are roughly two use cases here.  If we're the client,
     * want to print stuff directly to the output stream.
     * If we're the sender we might need to buffer up output to send
     * to the client.
     *
     * This doesn't make a whole lot of difference except there are
     * some chunks of output on the client (on particular the whole
     * of the server output with --get-server-output) that could
     * easily exceed the size of the line buffer, but which don't need
     * to be buffered up anyway.
     */
    if (test->role == 'c') {
	if (ct) {
            r0 = fprintf(test->outfile, "%s", ct);
            if (r0 < 0)
                return r0;
            r += r0;
	}
	if (test->title) {
	    r0 = fprintf(test->outfile, "%s:  ", test->title);
            if (r0 < 0)
                return r0;
            r += r0;
        }
	va_start(argp, format);
	r0 = vfprintf(test->outfile, format, argp);
	va_end(argp);
        if (r0 < 0)
            return r0;
        r += r0;
    }
    else if (test->role == 's') {
	if (ct) {
	    r0 = snprintf(linebuffer, sizeof(linebuffer), "%s", ct);
            if (r0 < 0)
                return r0;
            r += r0;
	}
        /* Should always be true as long as sizeof(ct) < sizeof(linebuffer) */
        if (r < sizeof(linebuffer)) {
            va_start(argp, format);
            r0 = vsnprintf(linebuffer + r, sizeof(linebuffer) - r, format, argp);
            va_end(argp);
            if (r0 < 0)
                return r0;
            r += r0;
        }
	fprintf(test->outfile, "%s", linebuffer);

	if (test->role == 's' && iperf_get_test_get_server_output(test)) {
	    struct iperf_textline *l = (struct iperf_textline *) malloc(sizeof(struct iperf_textline));
	    l->line = strdup(linebuffer);
	    TAILQ_INSERT_TAIL(&(test->server_output_list), l, textlineentries);
	}
    }
    return r;
}
