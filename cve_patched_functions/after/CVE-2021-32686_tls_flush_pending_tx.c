static void tls_flush_pending_tx(struct tls_transport *tls)
{
    pj_time_val now;

    pj_gettickcount(&now);
    pj_lock_acquire(tls->base.lock);
    while (!pj_list_empty(&tls->delayed_list)) {
	struct delayed_tdata *pending_tx;
	pjsip_tx_data *tdata;
	pj_ioqueue_op_key_t *op_key;
	pj_ssize_t size;
	pj_status_t status;

	pending_tx = tls->delayed_list.next;
	pj_list_erase(pending_tx);

	tdata = pending_tx->tdata_op_key->tdata;
	op_key = (pj_ioqueue_op_key_t*)pending_tx->tdata_op_key;

        if (pending_tx->timeout.sec > 0 &&
            PJ_TIME_VAL_GT(now, pending_tx->timeout))
        {
            pj_lock_release(tls->base.lock);
	    on_data_sent(tls->ssock, op_key, -PJ_ETIMEDOUT);
            pj_lock_acquire(tls->base.lock);
            continue;
        }

	/* send! */
	size = tdata->buf.cur - tdata->buf.start;
	status = pj_ssl_sock_send(tls->ssock, op_key, tdata->buf.start, 
				  &size, 0);

	if (status != PJ_EPENDING) {
            pj_lock_release(tls->base.lock);
	    on_data_sent(tls->ssock, op_key, size);
            pj_lock_acquire(tls->base.lock);
	}
    }
    pj_lock_release(tls->base.lock);
}
