static void *session_do(void *data)
{
	struct ast_tcptls_session_instance *ser = data;
	struct mansession_session *session;
	struct mansession s = {
		.tcptls_session = data,
	};
	int res;
	int arg = 1;
	struct ast_sockaddr ser_remote_address_tmp;

	if (ast_atomic_fetchadd_int(&unauth_sessions, +1) >= authlimit) {
		ast_atomic_fetchadd_int(&unauth_sessions, -1);
		goto done;
	}

	ast_sockaddr_copy(&ser_remote_address_tmp, &ser->remote_address);
	session = build_mansession(&ser_remote_address_tmp);

	if (session == NULL) {
		ast_atomic_fetchadd_int(&unauth_sessions, -1);
		goto done;
	}

	/* here we set TCP_NODELAY on the socket to disable Nagle's algorithm.
	 * This is necessary to prevent delays (caused by buffering) as we
	 * write to the socket in bits and pieces. */
	if (setsockopt(ast_iostream_get_fd(ser->stream), IPPROTO_TCP, TCP_NODELAY, (char *) &arg, sizeof(arg)) < 0) {
		ast_log(LOG_WARNING, "Failed to set TCP_NODELAY on manager connection: %s\n", strerror(errno));
	}
	ast_iostream_nonblock(ser->stream);

	ao2_lock(session);
	/* Hook to the tail of the event queue */
	session->last_ev = grab_last();

	ast_mutex_init(&s.lock);

	/* these fields duplicate those in the 'ser' structure */
	session->stream = s.stream = ser->stream;
	ast_sockaddr_copy(&session->addr, &ser_remote_address_tmp);
	s.session = session;

	AST_LIST_HEAD_INIT_NOLOCK(&session->datastores);

	if(time(&session->authstart) == -1) {
		ast_log(LOG_ERROR, "error executing time(): %s; disconnecting client\n", strerror(errno));
		ast_atomic_fetchadd_int(&unauth_sessions, -1);
		ao2_unlock(session);
		session_destroy(session);
		goto done;
	}
	ao2_unlock(session);

	/*
	 * We cannot let the stream exclusively wait for data to arrive.
	 * We have to wake up the task to send async events.
	 */
	ast_iostream_set_exclusive_input(ser->stream, 0);

	ast_iostream_set_timeout_sequence(ser->stream,
		ast_tvnow(), authtimeout * 1000);

	astman_append(&s, "Asterisk Call Manager/%s\r\n", AMI_VERSION);	/* welcome prompt */
	for (;;) {
		if ((res = do_message(&s)) < 0 || s.write_error) {
			break;
		}
		if (session->authenticated) {
			ast_iostream_set_timeout_disable(ser->stream);
		}
	}
	/* session is over, explain why and terminate */
	if (session->authenticated) {
		if (manager_displayconnects(session)) {
			ast_verb(2, "Manager '%s' logged off from %s\n", session->username, ast_sockaddr_stringify_addr(&session->addr));
		}
	} else {
		ast_atomic_fetchadd_int(&unauth_sessions, -1);
		if (displayconnects) {
			ast_verb(2, "Connect attempt from '%s' unable to authenticate\n", ast_sockaddr_stringify_addr(&session->addr));
		}
	}

	session_destroy(session);

	ast_mutex_destroy(&s.lock);
done:
	ao2_ref(ser, -1);
	ser = NULL;
	return NULL;
}
