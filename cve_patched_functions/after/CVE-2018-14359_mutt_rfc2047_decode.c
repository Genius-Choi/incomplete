void mutt_rfc2047_decode(char **pd)
{
  if (!pd || !*pd)
    return;

  struct Buffer buf = { 0 }; /* Output buffer                          */
  char *s = *pd;             /* Read pointer                           */
  char *beg;                 /* Begin of encoded word                  */
  enum ContentEncoding enc;  /* ENCBASE64 or ENCQUOTEDPRINTABLE        */
  char *charset;             /* Which charset                          */
  size_t charsetlen;         /* Length of the charset                  */
  char *text;                /* Encoded text                           */
  size_t textlen;            /* Length of encoded text                 */

  /* Keep some state in case the next decoded word is using the same charset
   * and it happens to be split in the middle of a multibyte character.
   * See https://github.com/neomutt/neomutt/issues/1015
   */
  struct Buffer prev = { 0 }; /* Previously decoded word                */
  char *prev_charset = NULL;  /* Previously used charset                */
  size_t prev_charsetlen = 0; /* Length of the previously used charset  */

  while (*s)
  {
    beg = parse_encoded_word(s, &enc, &charset, &charsetlen, &text, &textlen);
    if (beg != s)
    {
      /* Some non-encoded text was found */
      size_t holelen = beg ? beg - s : mutt_str_strlen(s);

      /* Ignore whitespace between encoded words */
      if (beg && mutt_str_lws_len(s, holelen) == holelen)
      {
        s = beg;
        continue;
      }

      /* If we have some previously decoded text, add it now */
      if (prev.data)
      {
        finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);
      }

      /* Add non-encoded part */
      {
        if (AssumedCharset && *AssumedCharset)
        {
          char *conv = mutt_str_substr_dup(s, s + holelen);
          mutt_ch_convert_nonmime_string(&conv);
          mutt_buffer_addstr(&buf, conv);
          FREE(&conv);
        }
        else
        {
          mutt_buffer_add(&buf, s, holelen);
        }
      }
      s += holelen;
    }
    if (beg)
    {
      /* Some encoded text was found */
      text[textlen] = '\0';
      char *decoded = rfc2047_decode_word(text, textlen, enc);
      if (decoded == NULL)
      {
        return;
      }
      if (prev.data && ((prev_charsetlen != charsetlen) ||
                        (strncmp(prev_charset, charset, charsetlen) != 0)))
      {
        /* Different charset, convert the previous chunk and add it to the
         * final result */
        finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);
      }

      mutt_buffer_addstr(&prev, decoded);
      FREE(&decoded);
      prev_charset = charset;
      prev_charsetlen = charsetlen;
      s = text + textlen + 2; /* Skip final ?= */
    }
  }

  /* Save the last chunk */
  if (prev.data)
  {
    finalize_chunk(&buf, &prev, prev_charset, prev_charsetlen);
  }

  mutt_buffer_addch(&buf, '\0');
  *pd = buf.data;
}
