void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl) const
{
    vCoins.clear();

    {
        LOCK(cs_wallet);
        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)
        {
            const CWalletTx* pcoin = &(*it).second;

            if (!pcoin->IsFinal())
                continue;

            if (fOnlyConfirmed && !pcoin->IsConfirmed())
                continue;

            if (pcoin->IsCoinBase() && pcoin->GetBlocksToMaturity() > 0)
                continue;

            // If output is less than minimum value, then don't include transaction.
            // This is to help deal with dust spam clogging up create transactions.
            for(unsigned int i = 0; i < pcoin->vout.size(); i++)
                if(!(pcoin->IsSpent(i)) &&
                  IsMine(pcoin->vout[i]) &&
                  !IsLockedCoin((*it).first, i) && 
                  (pcoin->vout[i].nValue >= nMinimumInputValue) &&
                  (!coinControl || !coinControl->HasSelected() || coinControl->IsSelected((*it).first, i)))
                    vCoins.push_back(COutput(pcoin, i, pcoin->GetDepthInMainChain()));
        }
    }
}
