yajl_gen_alloc2(const yajl_print_t callback,
                const yajl_gen_config * config,
                const yajl_alloc_funcs * afs,
                void * ctx)
{
    yajl_gen g = NULL;
    yajl_alloc_funcs afsBuffer;

    /* first order of business is to set up memory allocation routines */
    if (afs != NULL) {
        if (afs->malloc == NULL || afs->realloc == NULL || afs->free == NULL)
        {
            return NULL;
        }
    } else {
        yajl_set_default_alloc_funcs(&afsBuffer);
        afs = &afsBuffer;
    }

    g = (yajl_gen) YA_MALLOC(afs, sizeof(struct yajl_gen_t));
    if (!g) return NULL;

    memset((void *) g, 0, sizeof(struct yajl_gen_t));
    /* copy in pointers to allocation routines */
    memcpy((void *) &(g->alloc), (void *) afs, sizeof(yajl_alloc_funcs));

    if (config) {
        const char *indent = config->indentString;
        g->pretty = config->beautify;
        g->indentString = config->indentString;
        if (indent) {
          for (; *indent; indent++) {
            if (*indent != '\n'
                && *indent != '\v'
                && *indent != '\f'
                && *indent != '\t'
                && *indent != '\r'
                && *indent != ' ') {
              g->indentString = NULL;
              break;
            }
          }
        }
        if (!g->indentString) {
          g->indentString = "  ";
        }
        g->htmlSafe = config->htmlSafe;
    }

    if (callback) {
        g->print = callback;
        g->ctx = ctx;
    } else {
        g->print = (yajl_print_t)&yajl_buf_append;
        g->ctx = yajl_buf_alloc(&(g->alloc));
    }

    return g;
}
