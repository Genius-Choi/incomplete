int tport_send_msg(tport_t *self, msg_t *msg,
		   tp_name_t const *tpn,
		   struct sigcomp_compartment *cc)
{
  msg_iovec_t *iov, auto_iov[40];
  size_t iovlen, iovused, i, total;
  size_t n;
  ssize_t nerror;
  int sdwn_after, close_after;
  su_time_t now;
  su_addrinfo_t *ai;

  assert(self->tp_queue == NULL ||
	 self->tp_queue[self->tp_qhead] == NULL ||
	 self->tp_queue[self->tp_qhead] == msg);

  if (self->tp_iov)
    /* Use the heap-allocated I/O vector */
    iov = self->tp_iov, iovlen = self->tp_iovlen;
  else
    /* Use the stack I/O vector */
    iov = auto_iov, iovlen = sizeof(auto_iov)/sizeof(auto_iov[0]);

  /* Get a iovec for message contents */
  for (;;) {
    iovused = msg_iovec(msg, iov, iovlen);
    if (iovused <= iovlen)
      break;

    iov = su_realloc(self->tp_home, self->tp_iov, sizeof(*iov) * iovused);

    if (iov == NULL) {
      msg_set_errno(msg, errno);
      return -1;
    }

    self->tp_iov = iov, self->tp_iovlen = iovlen = iovused;
  }

  assert(iovused > 0);

  self->tp_stime = self->tp_ktime = now = su_now();

  nerror = tport_vsend(self, msg, tpn, iov, iovused, cc);
  SU_DEBUG_9(("tport_vsend returned "MOD_ZD"\n", nerror));

  if (nerror == -1)
    return -1;

  n = (size_t)nerror;

  self->tp_unsent = NULL, self->tp_unsentlen = 0;

  if (n > 0 && self->tp_master->mr_log && self->tp_slogged != msg) {
    tport_log_msg(self, msg, "send", "to", now);
    self->tp_slogged = msg;
  }

  for (i = 0, total = 0; i < iovused; i++) {
    if (total + (size_t)iov[i].mv_len > n) {
      if (tport_is_connection_oriented(self)) {
	iov[i].mv_len -= (su_ioveclen_t)(n - total);
	iov[i].mv_base = (char *)iov[i].mv_base + (n - total);
	if (tport_queue_rest(self, msg, &iov[i], iovused - i) < 0)
	  return tport_send_fatal(self, msg, tpn, "tport_queue_rest");
	else
	  return 0;
      }
      else {
	char const *comp = tpn->tpn_comp;

	SU_DEBUG_1(("%s(%p): send truncated for %s/%s:%s%s%s\n",
		    "tport_vsend", (void *)self, tpn->tpn_proto, tpn->tpn_host, tpn->tpn_port,
		    comp ? ";comp=" : "", comp ? comp : ""));

	msg_set_errno(msg, EIO);
	return /* tport_send_fatal(self, msg, tpn, "tport_send") */ -1;
      }
    }

    total += iov[i].mv_len;
  }

  /* We have sent a complete message */
  tport_sent_message(self, msg, 0);

  if (!tport_is_secondary(self))
    return 0;

  ai = msg_addrinfo(msg); assert(ai);
  close_after = (ai->ai_flags & TP_AI_CLOSE) == TP_AI_CLOSE;
  sdwn_after = (ai->ai_flags & TP_AI_SHUTDOWN) == TP_AI_SHUTDOWN ||
    self->tp_send_close;

  if (close_after || sdwn_after)
    tport_shutdown0(self, close_after ? 2 : 1);

  return 0;
}
