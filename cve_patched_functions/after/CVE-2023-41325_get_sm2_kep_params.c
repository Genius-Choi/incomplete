static TEE_Result get_sm2_kep_params(const TEE_Attribute *params,
				     uint32_t param_count,
				     struct ecc_public_key *peer_key,
				     struct ecc_public_key *peer_eph_key,
				     struct sm2_kep_parms *kep_parms)
{
	TEE_Result res = TEE_ERROR_GENERIC;
	size_t n;
	enum {
		IS_INITIATOR,
		PEER_KEY_X,
		PEER_KEY_Y,
		PEER_EPH_KEY_X,
		PEER_EPH_KEY_Y,
		INITIATOR_ID,
		RESPONDER_ID,
	};
	uint8_t mandatory = BIT(IS_INITIATOR) | BIT(PEER_KEY_X) |
		BIT(PEER_KEY_Y) | BIT(PEER_EPH_KEY_X) | BIT(PEER_EPH_KEY_Y) |
		BIT(INITIATOR_ID) | BIT(RESPONDER_ID);
	uint8_t found = 0;

	res = crypto_acipher_alloc_ecc_public_key(peer_key,
						  TEE_TYPE_SM2_KEP_PUBLIC_KEY,
						  256);
	if (res)
		return res;

	res = crypto_acipher_alloc_ecc_public_key(peer_eph_key,
						  TEE_TYPE_SM2_KEP_PUBLIC_KEY,
						  256);
	if (res)
		goto out_p;

	peer_key->curve = TEE_ECC_CURVE_SM2;
	peer_eph_key->curve = TEE_ECC_CURVE_SM2;

	for (n = 0; n < param_count; n++) {
		const TEE_Attribute *p = &params[n];

		switch (p->attributeID) {
		case TEE_ATTR_SM2_KEP_USER:
			kep_parms->is_initiator = !p->content.value.a;
			found |= BIT(IS_INITIATOR);
			break;
		case TEE_ATTR_ECC_PUBLIC_VALUE_X:
			crypto_bignum_bin2bn(p->content.ref.buffer,
					     p->content.ref.length,
					     peer_key->x);
			found |= BIT(PEER_KEY_X);
			break;
		case TEE_ATTR_ECC_PUBLIC_VALUE_Y:
			crypto_bignum_bin2bn(p->content.ref.buffer,
					     p->content.ref.length,
					     peer_key->y);
			found |= BIT(PEER_KEY_Y);
			break;
		case __OPTEE_SM2_KEP_ATTR_ECC_EPHEMERAL_PUBLIC_VALUE_X:
		case TEE_ATTR_ECC_EPHEMERAL_PUBLIC_VALUE_X:
			crypto_bignum_bin2bn(p->content.ref.buffer,
					     p->content.ref.length,
					     peer_eph_key->x);
			found |= BIT(PEER_EPH_KEY_X);
			break;
		case __OPTEE_SM2_KEP_ATTR_ECC_EPHEMERAL_PUBLIC_VALUE_Y:
		case TEE_ATTR_ECC_EPHEMERAL_PUBLIC_VALUE_Y:
			crypto_bignum_bin2bn(p->content.ref.buffer,
					     p->content.ref.length,
					     peer_eph_key->y);
			found |= BIT(PEER_EPH_KEY_Y);
			break;
		case TEE_ATTR_SM2_ID_INITIATOR:
			kep_parms->initiator_id = p->content.ref.buffer;
			kep_parms->initiator_id_len = p->content.ref.length;
			found |= BIT(INITIATOR_ID);
			break;
		case TEE_ATTR_SM2_ID_RESPONDER:
			kep_parms->responder_id = p->content.ref.buffer;
			kep_parms->responder_id_len = p->content.ref.length;
			found |= BIT(RESPONDER_ID);
			break;
		case TEE_ATTR_SM2_KEP_CONFIRMATION_IN:
			kep_parms->conf_in = p->content.ref.buffer;
			kep_parms->conf_in_len = p->content.ref.length;
			break;
		case TEE_ATTR_SM2_KEP_CONFIRMATION_OUT:
			kep_parms->conf_out = p->content.ref.buffer;
			kep_parms->conf_out_len = p->content.ref.length;
			break;
		default:
			/* Unexpected attribute */
			res = TEE_ERROR_BAD_PARAMETERS;
			goto out;
		}
	}

	if ((found & mandatory) != mandatory) {
		res = TEE_ERROR_BAD_PARAMETERS;
		goto out;
	}

	return TEE_SUCCESS;
out:
	crypto_acipher_free_ecc_public_key(peer_eph_key);
out_p:
	crypto_acipher_free_ecc_public_key(peer_key);
	return res;
}
