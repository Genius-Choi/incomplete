m_makespace(struct mbuf *m0, int skip, int hlen, int *off)
{
	struct mbuf *m;
	unsigned remain;

	KASSERT(m0->m_flags & M_PKTHDR);
	/*
	 * Limit the size of the new header to MHLEN. In case
	 * skip = 0 and the first buffer is not a cluster this
	 * is the maximum space available in that mbuf.
	 * In other words this code never prepends a mbuf.
	 */
	KASSERT(hlen < MHLEN);

	for (m = m0; m && skip > m->m_len; m = m->m_next)
		skip -= m->m_len;
	if (m == NULL)
		return (NULL);
	/*
	 * At this point skip is the offset into the mbuf m
	 * where the new header should be placed.  Figure out
	 * if there's space to insert the new header.  If so,
	 * and copying the remainder makes sense then do so.
	 * Otherwise insert a new mbuf in the chain, splitting
	 * the contents of m as needed.
	 */
	remain = m->m_len - skip;		/* data to move */
	if (skip < remain && hlen <= m_leadingspace(m)) {
		if (skip)
			memmove(m->m_data-hlen, m->m_data, skip);
		m->m_data -= hlen;
		m->m_len += hlen;
		*off = skip;
	} else if (hlen > m_trailingspace(m)) {
		struct mbuf *n;

		if (remain > 0) {
			MGET(n, M_DONTWAIT, m->m_type);
			if (n && remain > MLEN) {
				MCLGETL(n, M_DONTWAIT, remain);
				if ((n->m_flags & M_EXT) == 0) {
					m_free(n);
					n = NULL;
				}
			}
			if (n == NULL)
				return (NULL);

			memcpy(n->m_data, mtod(m, char *) + skip, remain);
			n->m_len = remain;
			m->m_len -= remain;

			n->m_next = m->m_next;
			m->m_next = n;
		}

		if (hlen <= m_trailingspace(m)) {
			m->m_len += hlen;
			*off = skip;
		} else {
			n = m_get(M_DONTWAIT, m->m_type);
			if (n == NULL)
				return NULL;

			n->m_len = hlen;

			n->m_next = m->m_next;
			m->m_next = n;

			*off = 0;	/* header is at front ... */
			m = n;		/* ... of new mbuf */
		}
	} else {
		/*
		 * Copy the remainder to the back of the mbuf
		 * so there's space to write the new header.
		 */
		if (remain > 0)
			memmove(mtod(m, caddr_t) + skip + hlen,
			      mtod(m, caddr_t) + skip, remain);
		m->m_len += hlen;
		*off = skip;
	}
	m0->m_pkthdr.len += hlen;		/* adjust packet length */
	return m;
}
