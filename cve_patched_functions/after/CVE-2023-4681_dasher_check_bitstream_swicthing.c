static void dasher_check_bitstream_swicthing(GF_DasherCtx *ctx, GF_MPD_AdaptationSet *set)
{
	u32 i, j, count;
	Bool use_inband = ((ctx->bs_switch==DASHER_BS_SWITCH_INBAND) || (ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS) || (ctx->bs_switch==DASHER_BS_SWITCH_BOTH)) ? GF_TRUE : GF_FALSE;
	Bool use_multi = (ctx->bs_switch==DASHER_BS_SWITCH_MULTI) ? GF_TRUE : GF_FALSE;
	GF_MPD_Representation *base_rep = gf_list_get(set->representations, 0);
	GF_DashStream *base_ds;

	switch (ctx->muxtype) {
	case DASHER_MUX_TS:
	case DASHER_MUX_OGG:
	case DASHER_MUX_RAW:
		set->bitstream_switching = GF_TRUE;
		return;
	//other formats use an init segment
	default:
		break;
	}

	if (ctx->bs_switch==DASHER_BS_SWITCH_OFF) return;
	if (!base_rep) return;
	base_ds = base_rep->playback.udta;

	count = gf_list_count(set->representations);
	if (count==1) {
		if (ctx->bs_switch==DASHER_BS_SWITCH_FORCE) set->bitstream_switching=GF_TRUE;
		else if (use_inband) {
			base_ds->inband_params = ctx->bs_switch==DASHER_BS_SWITCH_BOTH ? 3 : 1;
			if (base_ds->codec_id==GF_CODECID_VVC && ctx->bs_switch==DASHER_BS_SWITCH_INBAND_PPS)
				base_ds->inband_params = 2;
		}
		return;
	}

	for (i=1; i<count; i++) {
		GF_MPD_Representation *rep = gf_list_get(set->representations, i);
		GF_DashStream *ds = rep->playback.udta;
		//same codec ID
		if (ds->codec_id == base_ds->codec_id) {
			//we will use inband params, so bs switching is OK
			if (use_inband || use_multi) continue;
			//we have deps, cannot use bitstream switching except for merged tile base
			if (ds->dep_id) {
				if (ds->codec_id==GF_CODECID_HEVC_TILES) {
					u32 id;
					GF_DashStream *tile_base = get_base_ds(ctx, ds);
					if (!tile_base) return;
					id = tile_base->merged_tile_dep ? tile_base->merged_tile_dep->id : tile_base->id;
					if (base_ds->dep_id==id) continue;
				}
				return;
			}
			//we consider we can switch in non-inband only if we have same CRC for the decoder config
			if (base_ds->dsi_crc == ds->dsi_crc) continue;
			//not the same config, no BS switching
			return;
		}
		//dependencies / different codec IDs, cannot use bitstream switching
		return;
	}
	//ok we can use BS switching, ensure we use the same timescale for every stream
	set->bitstream_switching = GF_TRUE;

	for (i=0; i<count; i++) {
		GF_MPD_Representation *rep = gf_list_get(set->representations, i);
		GF_DashStream *ds = rep->playback.udta;
		if (base_ds->tile_base && ds->tile_base && (base_ds != ds) ) {
			ds->merged_tile_dep = base_ds;
			if (ds->rep) {
				gf_list_rem(set->representations, i);
				i--;
				count--;
				gf_mpd_representation_free(ds->rep);
				ds->rep = NULL;
				//switch dependencyID of all reps depending on this one to the new base
				rewrite_dep_ids(ctx, ds);
				//and ignore this rep while flushing segments
				base_ds->nb_rep--;
			}
		}
		for (j=i+1; j<count; j++) {
			GF_DashStream *a_ds;
			rep = gf_list_get(set->representations, j);
			a_ds = rep->playback.udta;
			if (a_ds->stream_type != ds->stream_type) continue;
			if (a_ds->timescale != ds->timescale)
				a_ds->force_timescale = ds->timescale;
		}
	}
}
