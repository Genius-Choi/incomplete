wasm_loader_get_const_offset(WASMLoaderContext *ctx, uint8 type, void *value,
                             int16 *offset, char *error_buf,
                             uint32 error_buf_size)
{
    int8 bytes_to_increase;
    int16 operand_offset = 0;
    Const *c;

    /* Search existing constant */
    for (c = (Const *)ctx->const_buf;
         (uint8 *)c < ctx->const_buf + ctx->num_const * sizeof(Const); c++) {
        /* TODO: handle v128 type? */
        if ((type == c->value_type)
            && ((type == VALUE_TYPE_I64 && *(int64 *)value == c->value.i64)
                || (type == VALUE_TYPE_I32 && *(int32 *)value == c->value.i32)
#if WASM_ENABLE_REF_TYPES != 0
                || (type == VALUE_TYPE_FUNCREF
                    && *(int32 *)value == c->value.i32)
                || (type == VALUE_TYPE_EXTERNREF
                    && *(int32 *)value == c->value.i32)
#endif
                || (type == VALUE_TYPE_F64
                    && (0 == memcmp(value, &(c->value.f64), sizeof(float64))))
                || (type == VALUE_TYPE_F32
                    && (0
                        == memcmp(value, &(c->value.f32), sizeof(float32)))))) {
            operand_offset = c->slot_index;
            break;
        }
        if (is_32bit_type(c->value_type))
            operand_offset += 1;
        else
            operand_offset += 2;
    }

    if ((uint8 *)c == ctx->const_buf + ctx->num_const * sizeof(Const)) {
        /* New constant, append to the const buffer */
        if ((type == VALUE_TYPE_F64) || (type == VALUE_TYPE_I64)) {
            bytes_to_increase = 2;
        }
        else {
            bytes_to_increase = 1;
        }

        /* The max cell num of const buffer is 32768 since the valid index range
         * is -32768 ~ -1. Return an invalid index 0 to indicate the buffer is
         * full */
        if (ctx->const_cell_num > INT16_MAX - bytes_to_increase + 1) {
            *offset = 0;
            return true;
        }

        if ((uint8 *)c == ctx->const_buf + ctx->const_buf_size) {
            MEM_REALLOC(ctx->const_buf, ctx->const_buf_size,
                        ctx->const_buf_size + 4 * sizeof(Const));
            ctx->const_buf_size += 4 * sizeof(Const);
            c = (Const *)(ctx->const_buf + ctx->num_const * sizeof(Const));
        }
        c->value_type = type;
        switch (type) {
            case VALUE_TYPE_F64:
                bh_memcpy_s(&(c->value.f64), sizeof(WASMValue), value,
                            sizeof(float64));
                ctx->const_cell_num += 2;
                /* The const buf will be reversed, we use the second cell */
                /* of the i64/f64 const so the finnal offset is corrent */
                operand_offset++;
                break;
            case VALUE_TYPE_I64:
                c->value.i64 = *(int64 *)value;
                ctx->const_cell_num += 2;
                operand_offset++;
                break;
            case VALUE_TYPE_F32:
                bh_memcpy_s(&(c->value.f32), sizeof(WASMValue), value,
                            sizeof(float32));
                ctx->const_cell_num++;
                break;
            case VALUE_TYPE_I32:
                c->value.i32 = *(int32 *)value;
                ctx->const_cell_num++;
                break;
#if WASM_ENABLE_REF_TYPES != 0
            case VALUE_TYPE_EXTERNREF:
            case VALUE_TYPE_FUNCREF:
                c->value.i32 = *(int32 *)value;
                ctx->const_cell_num++;
                break;
#endif
            default:
                break;
        }
        c->slot_index = operand_offset;
        ctx->num_const++;
        LOG_OP("#### new const [%d]: %ld\n", ctx->num_const,
               (int64)c->value.i64);
    }
    /* use negetive index for const */
    operand_offset = -(operand_offset + 1);
    *offset = operand_offset;
    return true;
fail:
    return false;
}
