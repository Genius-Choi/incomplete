pf_state_expires(const struct pf_state *st, uint8_t stimeout)
{
	u_int32_t	timeout;
	u_int32_t	start;
	u_int32_t	end;
	u_int32_t	states;

	/*
	 * pf_state_expires is used by the state purge task to
	 * decide if a state is a candidate for cleanup, and by the
	 * pfsync state export code to populate an expiry time.
	 *
	 * this function may be called by the state purge task while
	 * the state is being modified. avoid inconsistent reads of
	 * state->timeout by having the caller do the read (and any
	 * checks it needs to do on the same variable) and then pass
	 * their view of the timeout in here for this function to use.
	 * the only consequence of using a stale timeout value is
	 * that the state won't be a candidate for purging until the
	 * next pass of the purge task.
	 */

	/* handle all PFTM_* >= PFTM_MAX here */
	if (stimeout >= PFTM_MAX)
		return (0);

	KASSERT(stimeout < PFTM_MAX);

	timeout = st->rule.ptr->timeout[stimeout];
	if (!timeout)
		timeout = pf_default_rule.timeout[stimeout];

	start = st->rule.ptr->timeout[PFTM_ADAPTIVE_START];
	if (start) {
		end = st->rule.ptr->timeout[PFTM_ADAPTIVE_END];
		states = st->rule.ptr->states_cur;
	} else {
		start = pf_default_rule.timeout[PFTM_ADAPTIVE_START];
		end = pf_default_rule.timeout[PFTM_ADAPTIVE_END];
		states = pf_status.states;
	}
	if (end && states > start && start < end) {
		if (states >= end)
			return (0);

		timeout = (u_int64_t)timeout * (end - states) / (end - start);
	}

	return (st->expire + timeout);
}
