static int action_login(struct mansession *s, const struct message *m)
{

	/* still authenticated - don't process again */
	if (s->session->authenticated) {
		astman_send_ack(s, m, "Already authenticated");
		return 0;
	}

	if (authenticate(s, m)) {
		sleep(1);
		astman_send_error(s, m, "Authentication failed");
		return -1;
	}
	s->session->authenticated = 1;
	ast_atomic_fetchadd_int(&unauth_sessions, -1);
	if (manager_displayconnects(s->session)) {
		ast_verb(2, "%sManager '%s' logged on from %s\n", (s->session->managerid ? "HTTP " : ""), s->session->username, ast_sockaddr_stringify_addr(&s->session->addr));
	}
	astman_send_ack(s, m, "Authentication accepted");
	if ((s->session->send_events & EVENT_FLAG_SYSTEM)
		&& (s->session->readperm & EVENT_FLAG_SYSTEM)
		&& ast_test_flag(&ast_options, AST_OPT_FLAG_FULLY_BOOTED)) {
		struct ast_str *auth = ast_str_alloca(MAX_AUTH_PERM_STRING);
		const char *cat_str = authority_to_str(EVENT_FLAG_SYSTEM, &auth);
		long uptime = 0;
		long lastreloaded = 0;
		struct timeval tmp;
		struct timeval curtime = ast_tvnow();

		if (ast_startuptime.tv_sec) {
			tmp = ast_tvsub(curtime, ast_startuptime);
			uptime = tmp.tv_sec;
		}

		if (ast_lastreloadtime.tv_sec) {
			tmp = ast_tvsub(curtime, ast_lastreloadtime);
			lastreloaded = tmp.tv_sec;
		}

		astman_append(s, "Event: FullyBooted\r\n"
			"Privilege: %s\r\n"
			"Uptime: %ld\r\n"
			"LastReload: %ld\r\n"
			"Status: Fully Booted\r\n\r\n", cat_str, uptime, lastreloaded);
	}
	return 0;
}
