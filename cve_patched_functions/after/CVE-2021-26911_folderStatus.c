IMAPFolderStatus * IMAPSession::folderStatus(String * folder, ErrorCode * pError)
{
    int r;

    MCLog("status");
    if (mState != STATE_LOGGEDIN && mState != STATE_SELECTED) {
        * pError = ErrorFolderState;
        MCLog("trying to fetch status in bad state");
        IMAPFolderStatus * empty;
        empty = new IMAPFolderStatus();
        empty->autorelease();
        return empty;
    }

    if (folder == NULL) {
        * pError = ErrorMissingFolder;
        MCLog("trying to fetch status without folder");
        IMAPFolderStatus * empty;
        empty = new IMAPFolderStatus();
        empty->autorelease();
        return empty;
    }
    
    if (mImap == NULL) {
        * pError = ErrorDisconnected;
        MCLog("trying to fetch status without connection");
        IMAPFolderStatus * empty;
        empty = new IMAPFolderStatus();
        empty->autorelease();
        return empty;
    }

    struct mailimap_mailbox_data_status * status;

    struct mailimap_status_att_list * status_att_list;
        
    status_att_list = mailimap_status_att_list_new_empty();
    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_UNSEEN);
    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_MESSAGES);
    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_RECENT);
    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_UIDNEXT);
    mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_UIDVALIDITY);
    if (mCondstoreEnabled || mXYMHighestModseqEnabled) {
        mailimap_status_att_list_add(status_att_list, MAILIMAP_STATUS_ATT_HIGHESTMODSEQ);
    }
    
    r = mailimap_status(mImap, MCUTF8(folder), status_att_list, &status);
    
    IMAPFolderStatus * fs;
    fs = new IMAPFolderStatus();
    fs->autorelease();
    
    MCLog("status error : %i", r);
    if (r == MAILIMAP_ERROR_STREAM) {
        mShouldDisconnect = true;
        * pError = ErrorConnection;
        MCLog("status error : %s %i", MCUTF8DESC(this), * pError);
        mailimap_status_att_list_free(status_att_list);
        return fs;
    }
    else if (r == MAILIMAP_ERROR_PARSE) {
        mShouldDisconnect = true;
        * pError = ErrorParse;
        mailimap_status_att_list_free(status_att_list);
        return fs;
    }
    else if (hasError(r)) {
        * pError = ErrorNonExistantFolder;
        mailimap_status_att_list_free(status_att_list);
        return fs;
    }
    
    clistiter * cur;
    
    
    if (status != NULL) {
        
            struct mailimap_status_info * status_info;
            for(cur = clist_begin(status->st_info_list) ; cur != NULL ;
                cur = clist_next(cur)) {                
                
                status_info = (struct mailimap_status_info *) clist_content(cur);
                                
                switch (status_info->st_att) {
                    case MAILIMAP_STATUS_ATT_UNSEEN:
                        fs->setUnseenCount(status_info->st_value);
                        break;
                    case MAILIMAP_STATUS_ATT_MESSAGES:
                        fs->setMessageCount(status_info->st_value);
                        break;
                    case MAILIMAP_STATUS_ATT_RECENT:
                        fs->setRecentCount(status_info->st_value);
                        break;
                    case MAILIMAP_STATUS_ATT_UIDNEXT:
                        fs->setUidNext(status_info->st_value);
                        break;                        
                    case MAILIMAP_STATUS_ATT_UIDVALIDITY:
                        fs->setUidValidity(status_info->st_value);
                        break;
                    case MAILIMAP_STATUS_ATT_EXTENSION: {
                        struct mailimap_extension_data * ext_data = status_info->st_ext_data;
                        if (ext_data->ext_extension == &mailimap_extension_condstore) {
                            struct mailimap_condstore_status_info * status_info = (struct mailimap_condstore_status_info *) ext_data->ext_data;
                            fs->setHighestModSeqValue(status_info->cs_highestmodseq_value);
                        }
                        break;
                    }
                }
            }            

        mailimap_mailbox_data_status_free(status);
    }

    mailimap_status_att_list_free(status_att_list);

    return fs;
}
