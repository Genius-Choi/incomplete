    void CFontFileType1::WriteEncoded(char **ppNewEncoding, FontFileOutputFunc pOutputFunc, void *pOutputStream)
    {
        char sBuffer[512];
        char *sLine, *sLine2, *sCurChar;

        // копируем все до строчки /Encoding
        for ( sLine = (char *)m_sFile; sLine && strncmp( sLine, "/Encoding", 9); sLine = GetNextLine(sLine) );
        if ( !sLine )
        {
            // не нашли кодировку, тогда копируем целиком фонт файл
            (*pOutputFunc)( pOutputStream, (char *)m_sFile, m_nLen);
            return;
        }
        (*pOutputFunc)( pOutputStream, (char *)m_sFile, sLine - (char *)m_sFile);

        // пишем новую кодировку
        (*pOutputFunc)( pOutputStream, "/Encoding 256 array\n", 20);
        (*pOutputFunc)( pOutputStream, "0 1 255 {1 index exch /.notdef put} for\n", 40);
        for ( int nIndex = 0; nIndex < 256; ++nIndex )
        {
            if (ppNewEncoding[nIndex])
            {
                sprintf( sBuffer, "dup %d /%s put\n", nIndex, ppNewEncoding[nIndex]);
                (*pOutputFunc)( pOutputStream, sBuffer, strlen( sBuffer ));
            }
        }
        (*pOutputFunc)( pOutputStream, "readonly def\n", 13);

        if ( !strncmp( sLine, "/Encoding StandardEncoding def", 30) )
        {
            sLine = GetNextLine(sLine);
        }
        else
        {
            sCurChar = sLine + 10;
            sLine = NULL;
            for (; sCurChar < (char *)m_sFile + m_nLen; ++sCurChar)
            {
                if ((*sCurChar == ' ' || *sCurChar == '\t' || *sCurChar == '\x0a' || *sCurChar == '\x0d' || *sCurChar == '\x0c' || *sCurChar == '\0') && sCurChar + 4 <= (char *)m_sFile + m_nLen && !strncmp(sCurChar + 1, "def", 3) )
                {
                    sLine = sCurChar + 4;
                    break;
                }
            }
        }

        // У некоторых фонтов две записи /Encoding, поэтому проверяем наличие второй записи
        if ( sLine )
        {
            int nIndex;
            for ( sLine2 = sLine, nIndex = 0; nIndex < 20 && sLine2 && strncmp(sLine2, "/Encoding", 9); sLine2 = GetNextLine(sLine2), ++nIndex) ;
            if ( nIndex < 20 && sLine2 )
            {
                (*pOutputFunc)( pOutputStream, sLine, sLine2 - sLine);
                if ( !strncmp(sLine2, "/Encoding StandardEncoding def", 30) )
                {
                    sLine = GetNextLine( sLine2 );
                }
                else
                {
                    sCurChar = sLine2 + 10;
                    sLine = NULL;
                    for (; sCurChar < (char *)m_sFile + m_nLen; ++sCurChar)
                    {
                        if ((*sCurChar == ' ' || *sCurChar == '\t' || *sCurChar == '\x0a' || *sCurChar == '\x0d' || *sCurChar == '\x0c' || *sCurChar == '\0') && sCurChar + 4 <= (char *)m_sFile + m_nLen && !strncmp(sCurChar + 1, "def", 3) )
                        {
                            sLine = sCurChar + 4;
                            break;
                        }
                    }
                }
            }

            // копируем все после кодировки
            if ( sLine )
            {
                (*pOutputFunc)( pOutputStream, sLine, ((char *)m_sFile + m_nLen) - sLine );
            }
        }
    }
