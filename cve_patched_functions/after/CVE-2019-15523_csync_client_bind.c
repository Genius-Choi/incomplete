static void csync_client_bind(int sfd, struct addrinfo *peer_ai)
{
	struct addrinfo hints;
	struct addrinfo *result, *rp;
	int s;

	if (!bind_to_myhostname)
		return;

	memset(&hints, 0, sizeof(struct addrinfo));
	hints.ai_family = peer_ai->ai_family;
	hints.ai_socktype = SOCK_STREAM;

	s = getaddrinfo(bind_to_myhostname ? myhostname : NULL, 0, &hints, &result);
	if (s != 0) {
		csync_debug(1, "Cannot prepare local socket for bind, getaddrinfo: %s\n", gai_strerror(s));
		return;
	}

	for (rp = result; rp != NULL; rp = rp->ai_next) {
		if (bind(sfd, rp->ai_addr, rp->ai_addrlen) == 0)
			break;	/* Success */
	}

	if (rp != NULL) {
		char hbuf[NI_MAXHOST], sbuf[NI_MAXSERV];
		if (getnameinfo(rp->ai_addr, rp->ai_addrlen,
				hbuf, sizeof(hbuf), sbuf, sizeof(sbuf),
				NI_NUMERICHOST | NI_NUMERICSERV) == 0)
			csync_debug(1, "Bound to %s:%s as %s.\n",
				hbuf, sbuf, myhostname);
		else
			/* WTF, is failure even possible here?
			 * Anyways, bind() did not report an error. */
			csync_debug(1, "Bound local socket as %s.\n", myhostname);
	} else
		/* So bind() failed. Ignore, and try to connect anyways.
		 * Maybe it still works, maybe identification paranoia of the
		 * peer will kick us out. */
		csync_debug(1, "Local socket bind() to %s failed; ignored.\n", myhostname);

	freeaddrinfo(result);	/* No longer needed */
}
