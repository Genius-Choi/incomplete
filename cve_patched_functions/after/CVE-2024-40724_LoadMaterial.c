void PLYImporter::LoadMaterial(std::vector<aiMaterial *> *pvOut, std::string &defaultTexture, const bool pointsOnly) {
    ai_assert(nullptr != pvOut);

    // diffuse[4], specular[4], ambient[4]
    // rgba order
    unsigned int aaiPositions[3][4] = {

        { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF },
        { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF },
        { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF },
    };

    PLY::EDataType aaiTypes[3][4] = {
        { EDT_Char, EDT_Char, EDT_Char, EDT_Char },
        { EDT_Char, EDT_Char, EDT_Char, EDT_Char },
        { EDT_Char, EDT_Char, EDT_Char, EDT_Char }
    };
    PLY::ElementInstanceList *pcList = nullptr;

    unsigned int iPhong = 0xFFFFFFFF;
    PLY::EDataType ePhong = EDT_Char;

    unsigned int iOpacity = 0xFFFFFFFF;
    PLY::EDataType eOpacity = EDT_Char;

    // search in the DOM for a vertex entry
    unsigned int _i = 0;
    for (std::vector<PLY::Element>::const_iterator i = this->pcDOM->alElements.begin();
            i != this->pcDOM->alElements.end(); ++i, ++_i) {
        if (PLY::EEST_Material == (*i).eSemantic) {
            pcList = &this->pcDOM->alElementData[_i];

            // now check whether which coordinate sets are available
            unsigned int _a = 0;
            for (std::vector<PLY::Property>::const_iterator
                            a = (*i).alProperties.begin();
                    a != (*i).alProperties.end(); ++a, ++_a) {
                if ((*a).bIsList) continue;

                // pohng specularity      -----------------------------------
                if (PLY::EST_PhongPower == (*a).Semantic) {
                    iPhong = _a;
                    ePhong = (*a).eType;
                }

                // general opacity        -----------------------------------
                if (PLY::EST_Opacity == (*a).Semantic) {
                    iOpacity = _a;
                    eOpacity = (*a).eType;
                }

                // diffuse color channels -----------------------------------
                if (PLY::EST_DiffuseRed == (*a).Semantic) {
                    aaiPositions[0][0] = _a;
                    aaiTypes[0][0] = (*a).eType;
                } else if (PLY::EST_DiffuseGreen == (*a).Semantic) {
                    aaiPositions[0][1] = _a;
                    aaiTypes[0][1] = (*a).eType;
                } else if (PLY::EST_DiffuseBlue == (*a).Semantic) {
                    aaiPositions[0][2] = _a;
                    aaiTypes[0][2] = (*a).eType;
                } else if (PLY::EST_DiffuseAlpha == (*a).Semantic) {
                    aaiPositions[0][3] = _a;
                    aaiTypes[0][3] = (*a).eType;
                }
                // specular color channels -----------------------------------
                else if (PLY::EST_SpecularRed == (*a).Semantic) {
                    aaiPositions[1][0] = _a;
                    aaiTypes[1][0] = (*a).eType;
                } else if (PLY::EST_SpecularGreen == (*a).Semantic) {
                    aaiPositions[1][1] = _a;
                    aaiTypes[1][1] = (*a).eType;
                } else if (PLY::EST_SpecularBlue == (*a).Semantic) {
                    aaiPositions[1][2] = _a;
                    aaiTypes[1][2] = (*a).eType;
                } else if (PLY::EST_SpecularAlpha == (*a).Semantic) {
                    aaiPositions[1][3] = _a;
                    aaiTypes[1][3] = (*a).eType;
                }
                // ambient color channels -----------------------------------
                else if (PLY::EST_AmbientRed == (*a).Semantic) {
                    aaiPositions[2][0] = _a;
                    aaiTypes[2][0] = (*a).eType;
                } else if (PLY::EST_AmbientGreen == (*a).Semantic) {
                    aaiPositions[2][1] = _a;
                    aaiTypes[2][1] = (*a).eType;
                } else if (PLY::EST_AmbientBlue == (*a).Semantic) {
                    aaiPositions[2][2] = _a;
                    aaiTypes[2][2] = (*a).eType;
                } else if (PLY::EST_AmbientAlpha == (*a).Semantic) {
                    aaiPositions[2][3] = _a;
                    aaiTypes[2][3] = (*a).eType;
                }
            }
            break;
        } else if (PLY::EEST_TextureFile == (*i).eSemantic) {
            defaultTexture = (*i).szName;
        }
    }
    // check whether we have a valid source for the material data
    if (nullptr != pcList) {
        for (std::vector<ElementInstance>::const_iterator i = pcList->alInstances.begin(); i != pcList->alInstances.end(); ++i) {
            aiColor4D clrOut;
            aiMaterial *pcHelper = new aiMaterial();

            // build the diffuse material color
            GetMaterialColor((*i).alProperties, aaiPositions[0], aaiTypes[0], &clrOut);
            pcHelper->AddProperty<aiColor4D>(&clrOut, 1, AI_MATKEY_COLOR_DIFFUSE);

            // build the specular material color
            GetMaterialColor((*i).alProperties, aaiPositions[1], aaiTypes[1], &clrOut);
            pcHelper->AddProperty<aiColor4D>(&clrOut, 1, AI_MATKEY_COLOR_SPECULAR);

            // build the ambient material color
            GetMaterialColor((*i).alProperties, aaiPositions[2], aaiTypes[2], &clrOut);
            pcHelper->AddProperty<aiColor4D>(&clrOut, 1, AI_MATKEY_COLOR_AMBIENT);

            // handle phong power and shading mode
            int iMode = (int)aiShadingMode_Gouraud;
            if (0xFFFFFFFF != iPhong) {
                ai_real fSpec = PLY::PropertyInstance::ConvertTo<ai_real>(GetProperty((*i).alProperties, iPhong).avList.front(), ePhong);

                // if shininess is 0 (and the pow() calculation would therefore always
                // become 1, not depending on the angle), use gouraud lighting
                if (fSpec) {
                    // scale this with 15 ... hopefully this is correct
                    fSpec *= 15;
                    pcHelper->AddProperty<ai_real>(&fSpec, 1, AI_MATKEY_SHININESS);

                    iMode = (int)aiShadingMode_Phong;
                }
            }
            pcHelper->AddProperty<int>(&iMode, 1, AI_MATKEY_SHADING_MODEL);

            // handle opacity
            if (0xFFFFFFFF != iOpacity) {
                ai_real fOpacity = PLY::PropertyInstance::ConvertTo<ai_real>(GetProperty((*i).alProperties, iPhong).avList.front(), eOpacity);
                pcHelper->AddProperty<ai_real>(&fOpacity, 1, AI_MATKEY_OPACITY);
            }

            // The face order is absolutely undefined for PLY, so we have to
            // use two-sided rendering to be sure it's ok.
            const int two_sided = 1;
            pcHelper->AddProperty(&two_sided, 1, AI_MATKEY_TWOSIDED);

            // default texture
            if (!defaultTexture.empty()) {
                const aiString name(defaultTexture.c_str());
                pcHelper->AddProperty(&name, _AI_MATKEY_TEXTURE_BASE, aiTextureType_DIFFUSE, 0);
            }

            if (!pointsOnly) {
                pcHelper->AddProperty(&two_sided, 1, AI_MATKEY_TWOSIDED);
            }

            // set to wireframe, so when using this material info we can switch to points rendering
            if (pointsOnly) {
                const int wireframe = 1;
                pcHelper->AddProperty(&wireframe, 1, AI_MATKEY_ENABLE_WIREFRAME);
            }

            // add the newly created material instance to the list
            pvOut->push_back(pcHelper);
        }
    } else {
        // generate a default material
        aiMaterial *pcHelper = new aiMaterial();

        // fill in a default material
        int iMode = (int)aiShadingMode_Gouraud;
        pcHelper->AddProperty<int>(&iMode, 1, AI_MATKEY_SHADING_MODEL);

        // generate white material most 3D engine just multiply ambient / diffuse color with actual ambient / light color
        aiColor3D clr;
        clr.b = clr.g = clr.r = 1.0f;
        pcHelper->AddProperty<aiColor3D>(&clr, 1, AI_MATKEY_COLOR_DIFFUSE);
        pcHelper->AddProperty<aiColor3D>(&clr, 1, AI_MATKEY_COLOR_SPECULAR);

        clr.b = clr.g = clr.r = 1.0f;
        pcHelper->AddProperty<aiColor3D>(&clr, 1, AI_MATKEY_COLOR_AMBIENT);

        // The face order is absolutely undefined for PLY, so we have to
        // use two-sided rendering to be sure it's ok.
        if (!pointsOnly) {
            const int two_sided = 1;
            pcHelper->AddProperty(&two_sided, 1, AI_MATKEY_TWOSIDED);
        }

        // default texture
        if (!defaultTexture.empty()) {
            const aiString name(defaultTexture.c_str());
            pcHelper->AddProperty(&name, _AI_MATKEY_TEXTURE_BASE, aiTextureType_DIFFUSE, 0);
        }

        // set to wireframe, so when using this material info we can switch to points rendering
        if (pointsOnly) {
            const int wireframe = 1;
            pcHelper->AddProperty(&wireframe, 1, AI_MATKEY_ENABLE_WIREFRAME);
        }

        pvOut->push_back(pcHelper);
    }
}
