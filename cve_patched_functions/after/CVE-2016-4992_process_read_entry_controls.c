process_read_entry_controls(Slapi_PBlock *pb, char *oid)
{
    struct berval *req_value = NULL;
    struct berval *res_value = NULL;
    LDAPControl **req_ctls = NULL;
    Slapi_Entry *e = NULL;
    char **attrs = NULL;
    int attr_count = 0;
    int iscritical = 0;
    int all_attrs = 0;
    int no_attrs = 0;
    int rc = 0;

    slapi_pblock_get(pb, SLAPI_REQCONTROLS, &req_ctls);

    /*
     * Check for the PRE Read Entry Control, and return the pre-modified entry
     */
    if (slapi_control_present(req_ctls, oid, &req_value, &iscritical))
    {
        BerElement *req_ber = NULL;
        Operation *op = pb->pb_op;

        if(strcmp(oid,LDAP_CONTROL_PRE_READ_ENTRY) == 0){
            /* first verify this is the correct operation for a pre-read entry control */
            if(op->o_tag == LDAP_REQ_MODIFY || op->o_tag == LDAP_REQ_DELETE ||
               op->o_tag == LDAP_REQ_MODDN){
                slapi_pblock_get(pb, SLAPI_ENTRY_PRE_OP, &e);
            } else {
                /* Ok, read control not used for this type of operation */
            	LDAPDebug( LDAP_DEBUG_ANY, "process_read_entry_controls: Read Entry Controls "
            	        "can not be used for a %s operation.\n", op_to_string(op->o_tag), 0, 0);
                rc = -1;
                goto done;
            }
        } else {
            /* first verify this is the correct operation for a post-read entry control */
            if(op->o_tag == LDAP_REQ_MODIFY || op->o_tag == LDAP_REQ_ADD ||
               op->o_tag == LDAP_REQ_MODDN){
                slapi_pblock_get(pb, SLAPI_ENTRY_POST_OP, &e);
            } else {
                /* Ok, read control not used for this type of operation */
            	LDAPDebug( LDAP_DEBUG_ANY, "process_read_entry_controls: Read Entry Controls "
                        "can not be used for a %s operation.\n", op_to_string(op->o_tag), 0, 0);
                rc = -1;
                goto done;
            }
        }
        if(e == NULL){
            LDAPDebug( LDAP_DEBUG_ANY, "process_read_entry_controls: unable to retrieve entry\n",0,0,0);
            rc = -1;
            goto done;
        }

#if !defined(DISABLE_ACL_CHECK)
        /* even though we can modify the entry, that doesn't mean we can read it */
        if ( plugin_call_acl_plugin (pb, e, attrs, NULL, SLAPI_ACL_READ,
            ACLPLUGIN_ACCESS_READ_ON_ENTRY, NULL ) != LDAP_SUCCESS )
        {
            LDAPDebug( LDAP_DEBUG_ACL, "process_read_entry_controls: access to entry not allowed (%s)\n",
                slapi_entry_get_dn_const(e), 0, 0 );
            rc = -1;
            goto done;
        }
#endif
        /*
         *  Check the ctl_value for any requested attributes
         */
        if( req_value && req_value->bv_len != 0 && req_value->bv_val){
            if ((req_ber = ber_init(req_value)) == NULL){
                rc = -1;
                goto free;
            }
            if (ber_scanf(req_ber, "{") == LBER_ERROR){
                rc = -1;
                goto free;
            }
            /* process the attributes */
            while(1){
                char *payload = NULL;

                if (ber_get_stringa(req_ber, &payload) != LBER_ERROR){
                    if(strcmp(payload, LDAP_ALL_USER_ATTRS) == 0){
                        all_attrs = 1;
                        slapi_ch_free_string(&payload);
                    } else if(strcmp(payload, LDAP_NO_ATTRS) == 0){
                        no_attrs = 1;
                        slapi_ch_free_string(&payload);
                    } else {
                        charray_add(&attrs, payload);
                        attr_count++;
                    }
                } else {
                    /* we're done */
                    break;
                }
            }
            if(no_attrs && (all_attrs || attr_count)){
                /* Can't have both no attrs and some attributes */
                LDAPDebug( LDAP_DEBUG_ANY, "process_read_entry_controls: Error, both no attributes \"1.1\" and "
                    "specific attributes were requeseted.\n", 0, 0, 0 );
                rc = -1;
                goto free;
            }

            if (ber_scanf(req_ber, "}") == LBER_ERROR){
                rc = -1;
                goto free;
            }
        } else {
            /* this is a problem, malformed request control value */
            LDAPDebug( LDAP_DEBUG_ANY, "process_read_entry_controls: invalid control value.\n",0,0,0);
            rc = -1;
            goto free;
        }

        /*
         * Get the ber encoded string, and add it to the response control
         */
        res_value = encode_read_entry(pb, e, attrs, all_attrs, attr_count);
        if(res_value && res_value->bv_len > 0){
            LDAPControl	new_ctrl = {0};

            new_ctrl.ldctl_oid = oid;
            new_ctrl.ldctl_value = *res_value;
            new_ctrl.ldctl_iscritical = iscritical;
            slapi_pblock_set( pb, SLAPI_ADD_RESCONTROL, &new_ctrl );
            ber_bvfree(res_value);
        } else {
            /* failed to encode the result entry */
            LDAPDebug( LDAP_DEBUG_ANY, "Failed to process READ ENTRY Control (%s), error encoding result entry\n",
                        oid, 0, 0 );
            rc = -1;
        }

free:
        if (NULL != req_ber){
            ber_free(req_ber, 1);
        }
        if(rc != 0){
            /* log an error */
            LDAPDebug( LDAP_DEBUG_ANY, "Failed to process READ ENTRY Control (%s) ber decoding error\n",
                        oid, 0, 0 );
        }
    }
done:
    if(iscritical){
        return rc;
    } else {
        return 0;
    }
}
