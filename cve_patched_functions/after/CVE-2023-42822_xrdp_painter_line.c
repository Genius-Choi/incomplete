xrdp_painter_line(struct xrdp_painter *self,
                  struct xrdp_bitmap *dst,
                  int x1, int y1, int x2, int y2)
{
    struct xrdp_rect clip_rect;
    struct xrdp_rect draw_rect;
    struct xrdp_rect rect;
    struct xrdp_region *region;
    int k;
    int dx;
    int dy;
    int rop;

    LOG_DEVEL(LOG_LEVEL_DEBUG, "xrdp_painter_line:");
    if (self == 0)
    {
        return 0;
    }
    if (self->painter != 0)
    {
#if defined(XRDP_PAINTER)
        int x;
        int y;
        int cx;
        int cy;
        struct painter_bitmap dst_pb;
        struct xrdp_bitmap *ldst;

        LOG_DEVEL(LOG_LEVEL_DEBUG, "xrdp_painter_line: dst->type %d", dst->type);
        LOG_DEVEL(LOG_LEVEL_DEBUG, "xrdp_painter_line: self->rop 0x%2.2x", self->rop);

        if (dst->type != WND_TYPE_OFFSCREEN)
        {
            LOG_DEVEL(LOG_LEVEL_DEBUG, "xrdp_painter_line: using painter");
            ldst = self->wm->screen;

            g_memset(&dst_pb, 0, sizeof(dst_pb));
            dst_pb.format = get_pt_format(self);
            dst_pb.width = ldst->width;
            dst_pb.stride_bytes = ldst->line_size;
            dst_pb.height = ldst->height;
            dst_pb.data = ldst->data;

            xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);
            region = xrdp_region_create(self->wm);
            x = MIN(x1, x2);
            y = MIN(y1, y2);
            cx = g_abs(x1 - x2) + 1;
            cy = g_abs(y1 - y2) + 1;
            xrdp_wm_get_vis_region(self->wm, dst, x, y, cx, cy,
                                   region, self->clip_children);
            x1 += dx;
            y1 += dy;
            x2 += dx;
            y2 += dy;
            k = 0;
            rop = self->rop;

            painter_set_rop(self->painter, rop);
            painter_set_fgcolor(self->painter, self->pen.color);
            while (xrdp_region_get_rect(region, k, &rect) == 0)
            {
                if (rect_intersect(&rect, &clip_rect, &draw_rect))
                {
                    painter_set_clip(self->painter,
                                     draw_rect.left, draw_rect.top,
                                     draw_rect.right - draw_rect.left,
                                     draw_rect.bottom - draw_rect.top);
                    painter_line(self->painter, &dst_pb, x1, y1, x2, y2,
                                 self->pen.width, 0);
                    xrdp_painter_add_dirty_rect(self, x, y, cx, cy,
                                                &draw_rect);
                }
                k++;
            }
            painter_clear_clip(self->painter);
            xrdp_region_delete(region);
        }

        return 0;
#endif
    }

    /* todo data */

    if (dst->type == WND_TYPE_BITMAP)
    {
        return 0;
    }

    xrdp_bitmap_get_screen_clip(dst, self, &clip_rect, &dx, &dy);
    region = xrdp_region_create(self->wm);

    if (dst->type != WND_TYPE_OFFSCREEN)
    {
        xrdp_wm_get_vis_region(self->wm, dst, MIN(x1, x2), MIN(y1, y2),
                               g_abs(x1 - x2) + 1, g_abs(y1 - y2) + 1,
                               region, self->clip_children);
    }
    else
    {
        xrdp_region_add_rect(region, &clip_rect);
    }

    x1 += dx;
    y1 += dy;
    x2 += dx;
    y2 += dy;
    k = 0;
    rop = self->rop;

    if (rop < 0x01 || rop > 0x10)
    {
        rop = (rop & 0xf) + 1;
    }

    while (xrdp_region_get_rect(region, k, &rect) == 0)
    {
        if (rect_intersect(&rect, &clip_rect, &draw_rect))
        {
            libxrdp_orders_line(self->session, 1, x1, y1, x2, y2,
                                rop, self->bg_color,
                                &self->pen, &draw_rect);
        }

        k++;
    }

    xrdp_region_delete(region);
    return 0;
}
