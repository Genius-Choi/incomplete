store_char(ch, a, rep, pos)
	LWCHAR ch;
	int a;
	char *rep;
	POSITION pos;
{
	int w;
	int i;
	int replen;
	char cs;

	i = (a & (AT_UNDERLINE|AT_BOLD));
	if (i != AT_NORMAL)
		last_overstrike = i;

#if HILITE_SEARCH
	{
		int matches;
		int resend_last = 0;
		int hl_attr;

		if (pos == NULL_POSITION)
		{
			/* Color the prompt unless it has ansi sequences in it. */
			hl_attr = ansi_in_line ? 0 : AT_STANDOUT|AT_COLOR_PROMPT;
		} else
		{
			hl_attr = is_hilited_attr(pos, pos+1, 0, &matches);
			if (hl_attr == 0 && status_line)
				hl_attr = line_mark_attr;
		}
		if (hl_attr)
		{
			/*
			 * This character should be highlighted.
			 * Override the attribute passed in.
			 */
			if (a != AT_ANSI)
			{
				if (highest_hilite != NULL_POSITION && pos != NULL_POSITION && pos > highest_hilite)
					highest_hilite = pos;
				a |= hl_attr;
			}
			in_hilite = 1;
		} else 
		{
			if (in_hilite)
			{
				/*
				 * This is the first non-hilited char after a hilite.
				 * Resend the last ANSI seq to restore color.
				 */
				resend_last = 1;
			}
			in_hilite = 0;
		}
		if (resend_last)
		{
			int ai;
			for (ai = 0;  ai < NUM_LAST_ANSIS;  ai++)
			{
				int ax = (curr_last_ansi + ai) % NUM_LAST_ANSIS;
				for (i = 0;  i < last_ansis[ax].end;  i++)
					STORE_CHAR(last_ansis[ax].data[i], AT_ANSI, NULL, pos);
			}
		}
	}
#endif

	if (a == AT_ANSI) {
		w = 0;
	} else {
		char *p = &linebuf.buf[linebuf.end];
		LWCHAR prev_ch = (linebuf.end > 0) ? step_char(&p, -1, linebuf.buf) : 0;
		int prev_a = (linebuf.end > 0) ? linebuf.attr[linebuf.end-1] : 0;
		w = pwidth(ch, a, prev_ch, prev_a);
	}

	if (!fits_on_screen(w, a))
		return (1);

	if (rep == NULL)
	{
		cs = (char) ch;
		rep = &cs;
		replen = 1;
	} else
	{
		replen = utf_len(rep[0]);
	}
	if (linebuf.end + replen >= size_linebuf-6)
	{
		/*
		 * Won't fit in line buffer.
		 * Try to expand it.
		 */
		if (expand_linebuf())
			return (1);
	}

	if (cshift == hshift && shifted_ansi.end > 0)
	{
		/* Copy shifted ANSI sequences to beginning of line. */
		for (i = 0;  i < shifted_ansi.end;  i++)
			add_linebuf(shifted_ansi.data[i], AT_ANSI, 0);
		xbuf_reset(&shifted_ansi);
	}
	/* Add the char to the buf, even if we will left-shift it next. */
	inc_end_column(w);
	for (i = 0;  i < replen;  i++)
		add_linebuf(*rep++, a, 0);

	if (cshift < hshift)
	{
		/* We haven't left-shifted enough yet. */
		if (a == AT_ANSI)
			xbuf_add_byte(&shifted_ansi, (unsigned char) ch); /* Save ANSI attributes */
		if (linebuf.end > linebuf.print)
		{
			/* Shift left enough to put last byte of this char at print-1. */
			int i;
			for (i = 0; i < linebuf.print; i++)
			{
				linebuf.buf[i] = linebuf.buf[i+replen];
				linebuf.attr[i] = linebuf.attr[i+replen];
			}
			linebuf.end -= replen;
			cshift += w;
			/*
			 * If the char we just left-shifted was double width,
			 * the 2 spaces we shifted may be too much.
			 * Represent the "half char" at start of line with a highlighted space.
			 */
			while (cshift > hshift)
			{
				add_linebuf(' ', rscroll_attr, 0);
				cshift--;
			}
		}
	}
	return (0);
}
