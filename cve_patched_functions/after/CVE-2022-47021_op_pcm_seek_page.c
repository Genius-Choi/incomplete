static int op_pcm_seek_page(OggOpusFile *_of,
 ogg_int64_t _target_gp,int _li){
  const OggOpusLink *link;
  ogg_page           og;
  ogg_int64_t        pcm_pre_skip;
  ogg_int64_t        pcm_start;
  ogg_int64_t        pcm_end;
  ogg_int64_t        best_gp;
  ogg_int64_t        diff;
  ogg_uint32_t       serialno;
  opus_int32         pre_skip;
  opus_int64         begin;
  opus_int64         end;
  opus_int64         boundary;
  opus_int64         best;
  opus_int64         best_start;
  opus_int64         page_offset;
  opus_int64         d0;
  opus_int64         d1;
  opus_int64         d2;
  int                force_bisect;
  int                buffering;
  int                ret;
  _of->bytes_tracked=0;
  _of->samples_tracked=0;
  link=_of->links+_li;
  best_gp=pcm_start=link->pcm_start;
  pcm_end=link->pcm_end;
  serialno=link->serialno;
  best=best_start=begin=link->data_offset;
  page_offset=-1;
  buffering=0;
  /*We discard the first 80 ms of data after a seek, so seek back that much
     farther.
    If we can't, simply seek to the beginning of the link.*/
  if(OP_UNLIKELY(op_granpos_add(&_target_gp,_target_gp,-80*48)<0)
   ||OP_UNLIKELY(op_granpos_cmp(_target_gp,pcm_start)<0)){
    _target_gp=pcm_start;
  }
  /*Special case seeking to the start of the link.*/
  pre_skip=link->head.pre_skip;
  OP_ALWAYS_TRUE(!op_granpos_add(&pcm_pre_skip,pcm_start,pre_skip));
  if(op_granpos_cmp(_target_gp,pcm_pre_skip)<0)end=boundary=begin;
  else{
    end=boundary=link->end_offset;
#if !defined(OP_SMALL_FOOTPRINT)
    /*If we were decoding from this link, we can narrow the range a bit.*/
    if(_li==_of->cur_link&&_of->ready_state>=OP_INITSET){
      opus_int64 offset;
      int        op_count;
      op_count=_of->op_count;
      /*The offset can be out of range if we were reading through the stream
         and encountered a page with the granule position for another link
         outside of the data range identified during link enumeration when we
         were opening the file.
        We will just ignore the current position in that case.
        The only way the offset can be valid _and_ we can fail the granule
         position checks below is if someone changed the contents of the last
         page since we read it.
        We'd be within our rights to just return OP_EBADLINK, but instead we'll
         simply ignore the current position in that case, too.*/
      offset=_of->offset;
      if(op_count>0&&OP_LIKELY(begin<=offset&&offset<=end)){
        ogg_int64_t gp;
        /*Make sure the timestamp is valid.
          The granule position might be -1 if we collected the packets from a
           page without a granule position after reporting a hole.*/
        gp=_of->op[op_count-1].granulepos;
        if(OP_LIKELY(gp!=-1)&&OP_LIKELY(op_granpos_cmp(pcm_start,gp)<0)
         &&OP_LIKELY(op_granpos_cmp(pcm_end,gp)>0)){
          OP_ALWAYS_TRUE(!op_granpos_diff(&diff,gp,_target_gp));
          /*We only actually use the current time if either
            a) We can cut off at least half the range, or
            b) We're seeking sufficiently close to the current position that
                it's likely to be informative.
            Otherwise it appears using the whole link range to estimate the
             first seek location gives better results, on average.*/
          if(diff<0){
            if(offset-begin>=end-begin>>1||diff>-OP_CUR_TIME_THRESH){
              best=begin=offset;
              best_gp=pcm_start=gp;
              /*If we have buffered data from a continued packet, remember the
                 offset of the previous page's start, so that if we do wind up
                 having to seek back here later, we can prime the stream with
                 the continued packet data.
                With no continued packet, we remember the end of the page.*/
              best_start=_of->os.body_returned<_of->os.body_fill?
               _of->prev_page_offset:best;
              /*If there's completed packets and data in the stream state,
                 prev_page_offset should always be set.*/
              OP_ASSERT(best_start>=0);
              /*Buffer any continued packet data starting from here.*/
              buffering=1;
            }
          }
          else{
            ogg_int64_t prev_page_gp;
            /*We might get lucky and already have the packet with the target
               buffered.
              Worth checking.
              For very small files (with all of the data in a single page,
               generally 1 second or less), we can loop them continuously
               without seeking at all.*/
            if(op_granpos_add(&prev_page_gp,_of->op[0].granulepos,
             -op_get_packet_duration(_of->op[0].packet,_of->op[0].bytes))<0) {
              /*We validate/sanitize the per-packet timestamps, so the only way
                 we should fail to calculate a granule position for the
                 previous page is if the first page with completed packets in
                 the stream is also the last, and end-trimming causes the
                 apparent granule position preceding the first sample in the
                 first packet to underflow.
                The starting PCM offset is then 0 by spec mandate (see also:
                 op_find_initial_pcm_offset()).*/
              OP_ASSERT(_of->op[0].e_o_s);
              prev_page_gp=0;
            }
            if(op_granpos_cmp(prev_page_gp,_target_gp)<=0){
              /*Don't call op_decode_clear(), because it will dump our
                 packets.*/
              _of->op_pos=0;
              _of->od_buffer_size=0;
              _of->prev_packet_gp=prev_page_gp;
              /*_of->prev_page_offset already points to the right place.*/
              _of->ready_state=OP_STREAMSET;
              return op_make_decode_ready(_of);
            }
            /*No such luck.
              Check if we can cut off at least half the range, though.*/
            if(offset-begin<=end-begin>>1||diff<OP_CUR_TIME_THRESH){
              /*We really want the page start here, but this will do.*/
              end=boundary=offset;
              pcm_end=gp;
            }
          }
        }
      }
    }
#endif
  }
  /*This code was originally based on the "new search algorithm by HB (Nicholas
     Vinen)" from libvorbisfile.
    It has been modified substantially since.*/
  op_decode_clear(_of);
  if(!buffering)ogg_stream_reset_serialno(&_of->os,serialno);
  _of->cur_link=_li;
  _of->ready_state=OP_STREAMSET;
  /*Initialize the interval size history.*/
  d2=d1=d0=end-begin;
  force_bisect=0;
  while(begin<end){
    opus_int64 bisect;
    opus_int64 next_boundary;
    opus_int32 chunk_size;
    if(end-begin<OP_CHUNK_SIZE)bisect=begin;
    else{
      /*Update the interval size history.*/
      d0=d1>>1;
      d1=d2>>1;
      d2=end-begin>>1;
      if(force_bisect)bisect=begin+(end-begin>>1);
      else{
        ogg_int64_t diff2;
        OP_ALWAYS_TRUE(!op_granpos_diff(&diff,_target_gp,pcm_start));
        OP_ALWAYS_TRUE(!op_granpos_diff(&diff2,pcm_end,pcm_start));
        /*Take a (pretty decent) guess.*/
        bisect=begin+op_rescale64(diff,diff2,end-begin)-OP_CHUNK_SIZE;
      }
      if(bisect-OP_CHUNK_SIZE<begin)bisect=begin;
      force_bisect=0;
    }
    if(bisect!=_of->offset){
      /*Discard any buffered continued packet data.*/
      if(buffering)ogg_stream_reset(&_of->os);
      buffering=0;
      page_offset=-1;
      ret=op_seek_helper(_of,bisect);
      if(OP_UNLIKELY(ret<0))return ret;
    }
    chunk_size=OP_CHUNK_SIZE;
    next_boundary=boundary;
    /*Now scan forward and figure out where we landed.
      In the ideal case, we will see a page with a granule position at or
       before our target, followed by a page with a granule position after our
       target (or the end of the search interval).
      Then we can just drop out and will have all of the data we need with no
       additional seeking.
      If we landed too far before, or after, we'll break out and do another
       bisection.*/
    while(begin<end){
      page_offset=op_get_next_page(_of,&og,boundary);
      if(page_offset<0){
        if(page_offset<OP_FALSE)return (int)page_offset;
        /*There are no more pages in our interval from our stream with a valid
           timestamp that start at position bisect or later.*/
        /*If we scanned the whole interval, we're done.*/
        if(bisect<=begin+1)end=begin;
        else{
          /*Otherwise, back up one chunk.
            First, discard any data from a continued packet.*/
          if(buffering)ogg_stream_reset(&_of->os);
          buffering=0;
          bisect=OP_MAX(bisect-chunk_size,begin);
          ret=op_seek_helper(_of,bisect);
          if(OP_UNLIKELY(ret<0))return ret;
          /*Bump up the chunk size.*/
          chunk_size=OP_MIN(2*chunk_size,OP_CHUNK_SIZE_MAX);
          /*If we did find a page from another stream or without a timestamp,
             don't read past it.*/
          boundary=next_boundary;
        }
      }
      else{
        ogg_int64_t gp;
        int         has_packets;
        /*Save the offset of the first page we found after the seek, regardless
           of the stream it came from or whether or not it has a timestamp.*/
        next_boundary=OP_MIN(page_offset,next_boundary);
        if(serialno!=(ogg_uint32_t)ogg_page_serialno(&og))continue;
        has_packets=ogg_page_packets(&og)>0;
        /*Force the gp to -1 (as it should be per spec) if no packets end on
           this page.
          Otherwise we might get confused when we try to pull out a packet
           with that timestamp and can't find it.*/
        gp=has_packets?ogg_page_granulepos(&og):-1;
        if(gp==-1){
          if(buffering){
            if(OP_LIKELY(!has_packets))ogg_stream_pagein(&_of->os,&og);
            else{
              /*If packets did end on this page, but we still didn't have a
                 valid granule position (in violation of the spec!), stop
                 buffering continued packet data.
                Otherwise we might continue past the packet we actually
                 wanted.*/
              ogg_stream_reset(&_of->os);
              buffering=0;
            }
          }
          continue;
        }
        if(op_granpos_cmp(gp,_target_gp)<0){
          /*We found a page that ends before our target.
            Advance to the raw offset of the next page.*/
          begin=_of->offset;
          if(OP_UNLIKELY(op_granpos_cmp(pcm_start,gp)>0)
           ||OP_UNLIKELY(op_granpos_cmp(pcm_end,gp)<0)){
            /*Don't let pcm_start get out of range!
              That could happen with an invalid timestamp.*/
            break;
          }
          /*Save the byte offset of the end of the page with this granule
             position.*/
          best=best_start=begin;
          /*Buffer any data from a continued packet, if necessary.
            This avoids the need to seek back here if the next timestamp we
             encounter while scanning forward lies after our target.*/
          if(buffering)ogg_stream_reset(&_of->os);
          if(op_page_continues(&og)){
            op_buffer_continued_data(_of,&og);
            /*If we have a continued packet, remember the offset of this
               page's start, so that if we do wind up having to seek back here
               later, we can prime the stream with the continued packet data.
              With no continued packet, we remember the end of the page.*/
            best_start=page_offset;
          }
          /*Then force buffering on, so that if a packet starts (but does not
             end) on the next page, we still avoid the extra seek back.*/
          buffering=1;
          best_gp=pcm_start=gp;
          OP_ALWAYS_TRUE(!op_granpos_diff(&diff,_target_gp,pcm_start));
          /*If we're more than a second away from our target, break out and
             do another bisection.*/
          if(diff>48000)break;
          /*Otherwise, keep scanning forward (do NOT use begin+1).*/
          bisect=begin;
        }
        else{
          /*We found a page that ends after our target.*/
          /*If we scanned the whole interval before we found it, we're done.*/
          if(bisect<=begin+1)end=begin;
          else{
            end=bisect;
            /*In later iterations, don't read past the first page we found.*/
            boundary=next_boundary;
            /*If we're not making much progress shrinking the interval size,
               start forcing straight bisection to limit the worst case.*/
            force_bisect=end-begin>d0*2;
            /*Don't let pcm_end get out of range!
              That could happen with an invalid timestamp.*/
            if(OP_LIKELY(op_granpos_cmp(pcm_end,gp)>0)
             &&OP_LIKELY(op_granpos_cmp(pcm_start,gp)<=0)){
              pcm_end=gp;
            }
            break;
          }
        }
      }
    }
  }
  /*Found our page.*/
  OP_ASSERT(op_granpos_cmp(best_gp,pcm_start)>=0);
  /*Seek, if necessary.
    If we were buffering data from a continued packet, we should be able to
     continue to scan forward to get the rest of the data (even if
     page_offset==-1).
    Otherwise, we need to seek back to best_start.*/
  if(!buffering){
    if(best_start!=page_offset){
      page_offset=-1;
      ret=op_seek_helper(_of,best_start);
      if(OP_UNLIKELY(ret<0))return ret;
    }
    if(best_start<best){
      /*Retrieve the page at best_start, if we do not already have it.*/
      if(page_offset<0){
        page_offset=op_get_next_page(_of,&og,link->end_offset);
        if(OP_UNLIKELY(page_offset<OP_FALSE))return (int)page_offset;
        if(OP_UNLIKELY(page_offset!=best_start))return OP_EBADLINK;
      }
      op_buffer_continued_data(_of,&og);
      page_offset=-1;
    }
  }
  /*Update prev_packet_gp to allow per-packet granule position assignment.*/
  _of->prev_packet_gp=best_gp;
  _of->prev_page_offset=best_start;
  ret=op_fetch_and_process_page(_of,page_offset<0?NULL:&og,page_offset,0,1);
  if(OP_UNLIKELY(ret<0))return OP_EBADLINK;
  /*Verify result.*/
  if(OP_UNLIKELY(op_granpos_cmp(_of->prev_packet_gp,_target_gp)>0)){
    return OP_EBADLINK;
  }
  /*Our caller will set cur_discard_count to handle pre-roll.*/
  return 0;
}
