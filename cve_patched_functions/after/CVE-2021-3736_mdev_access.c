static ssize_t mdev_access(struct mdev_state *mdev_state, char *buf,
			   size_t count, loff_t pos, bool is_write)
{
	struct page *pg;
	loff_t poff;
	char *map;
	int ret = 0;

	mutex_lock(&mdev_state->ops_lock);

	if (pos < MBOCHS_CONFIG_SPACE_SIZE) {
		if (is_write)
			handle_pci_cfg_write(mdev_state, pos, buf, count);
		else
			memcpy(buf, (mdev_state->vconfig + pos), count);

	} else if (pos >= MBOCHS_MMIO_BAR_OFFSET &&
		   pos + count <= (MBOCHS_MMIO_BAR_OFFSET +
				   MBOCHS_MMIO_BAR_SIZE)) {
		pos -= MBOCHS_MMIO_BAR_OFFSET;
		if (is_write)
			handle_mmio_write(mdev_state, pos, buf, count);
		else
			handle_mmio_read(mdev_state, pos, buf, count);

	} else if (pos >= MBOCHS_EDID_OFFSET &&
		   pos + count <= (MBOCHS_EDID_OFFSET +
				   MBOCHS_EDID_SIZE)) {
		pos -= MBOCHS_EDID_OFFSET;
		if (pos < MBOCHS_EDID_BLOB_OFFSET) {
			handle_edid_regs(mdev_state, pos, buf, count, is_write);
		} else {
			pos -= MBOCHS_EDID_BLOB_OFFSET;
			handle_edid_blob(mdev_state, pos, buf, count, is_write);
		}

	} else if (pos >= MBOCHS_MEMORY_BAR_OFFSET &&
		   pos + count <=
		   MBOCHS_MEMORY_BAR_OFFSET + mdev_state->memsize) {
		pos -= MBOCHS_MMIO_BAR_OFFSET;
		poff = pos & ~PAGE_MASK;
		pg = __mbochs_get_page(mdev_state, pos >> PAGE_SHIFT);
		map = kmap(pg);
		if (is_write)
			memcpy(map + poff, buf, count);
		else
			memcpy(buf, map + poff, count);
		kunmap(pg);
		put_page(pg);

	} else {
		dev_dbg(mdev_state->vdev.dev, "%s: %s @0x%llx (unhandled)\n",
			__func__, is_write ? "WR" : "RD", pos);
		ret = -1;
		goto accessfailed;
	}

	ret = count;


accessfailed:
	mutex_unlock(&mdev_state->ops_lock);

	return ret;
}
