static memcached_return_t textual_read_one_response(memcached_instance_st *instance, char *buffer,
                                                    const size_t buffer_length,
                                                    memcached_result_st *result) {
  size_t total_read;
  memcached_return_t rc = memcached_io_readline(instance, buffer, buffer_length, total_read);

  if (memcached_failed(rc)) {
    return rc;
  }
  assert(total_read);

  switch (buffer[0]) {
  case 'V': {
    // VALUE
    if (buffer[1] == 'A' and buffer[2] == 'L' and buffer[3] == 'U' and buffer[4] == 'E') /* VALUE */
    {
      /* We add back in one because we will need to search for END */
      memcached_server_response_increment(instance);
      return textual_value_fetch(instance, buffer, result);
    }
    // VERSION
    else if (buffer[1] == 'E' and buffer[2] == 'R' and buffer[3] == 'S' and buffer[4] == 'I'
             and buffer[5] == 'O' and buffer[6] == 'N') /* VERSION */
    {
      /* Find the space, and then move one past it to copy version */
      char *response_ptr = strchr(buffer, ' ');

      char *endptr;
      errno = 0;
      long int version = strtol(response_ptr, &endptr, 10);
      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX
          or version == 0) {
        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;
        return memcached_set_error(
            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,
            memcached_literal_param("strtol() failed to parse major version"));
      }
      instance->major_version = uint8_t(version);

      endptr++;
      errno = 0;
      version = strtol(endptr, &endptr, 10);
      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {
        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;
        return memcached_set_error(
            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,
            memcached_literal_param("strtol() failed to parse minor version"));
      }
      instance->minor_version = uint8_t(version);

      endptr++;
      errno = 0;
      version = strtol(endptr, &endptr, 10);
      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {
        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;
        return memcached_set_error(
            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,
            memcached_literal_param("strtol() failed to parse micro version"));
      }
      instance->micro_version = uint8_t(version);

      return MEMCACHED_SUCCESS;
    }
  } break;

  case 'O': {
    // OK
    if (buffer[1] == 'K') {
      return MEMCACHED_SUCCESS;
    }
  } break;

  case 'S': {
    // STAT
    if (buffer[1] == 'T' and buffer[2] == 'A' and buffer[3] == 'T') /* STORED STATS */ {
      memcached_server_response_increment(instance);
      return MEMCACHED_STAT;
    }
    // SERVER_ERROR
    else if (buffer[1] == 'E' and buffer[2] == 'R' and buffer[3] == 'V' and buffer[4] == 'E'
             and buffer[5] == 'R' and buffer[6] == '_' and buffer[7] == 'E' and buffer[8] == 'R'
             and buffer[9] == 'R' and buffer[10] == 'O' and buffer[11] == 'R')
    {
      if (total_read == memcached_literal_param_size("SERVER_ERROR")) {
        return MEMCACHED_SERVER_ERROR;
      }

      if (total_read >= memcached_literal_param_size("SERVER_ERROR object too large for cache")
          and (memcmp(buffer, memcached_literal_param("SERVER_ERROR object too large for cache"))
               == 0))
      {
        return MEMCACHED_E2BIG;
      }

      if (total_read >= memcached_literal_param_size("SERVER_ERROR out of memory")
          and ((memcmp(buffer, memcached_literal_param("SERVER_ERROR out of memory")) == 0)
               or (memcmp(buffer, memcached_literal_param("SERVER_ERROR Out of memory")) == 0)))
      {
        return MEMCACHED_SERVER_MEMORY_ALLOCATION_FAILURE;
      }

      // Move past the basic error message and whitespace
      char *startptr = buffer + memcached_literal_param_size("SERVER_ERROR");
      if (startptr[0] == ' ') {
        startptr++;
      }

      char *endptr = startptr;
      while (*endptr != '\r' && *endptr != '\n') endptr++;

      return memcached_set_error(*instance, MEMCACHED_SERVER_ERROR, MEMCACHED_AT, startptr,
                                 size_t(endptr - startptr));
    }
    // STORED
    else if (buffer[1] == 'T' and buffer[2] == 'O'
             and buffer[3] == 'R') //  and buffer[4] == 'E' and buffer[5] == 'D')
    {
      return MEMCACHED_STORED;
    }
  } break;

  case 'D': {
    // DELETED
    if (buffer[1] == 'E' and buffer[2] == 'L' and buffer[3] == 'E' and buffer[4] == 'T'
        and buffer[5] == 'E' and buffer[6] == 'D')
    {
      return MEMCACHED_DELETED;
    }
  } break;

  case 'N': {
    // NOT_FOUND
    if (buffer[1] == 'O' and buffer[2] == 'T' and buffer[3] == '_' and buffer[4] == 'F'
        and buffer[5] == 'O' and buffer[6] == 'U' and buffer[7] == 'N' and buffer[8] == 'D')
    {
      return MEMCACHED_NOTFOUND;
    }
    // NOT_STORED
    else if (buffer[1] == 'O' and buffer[2] == 'T' and buffer[3] == '_' and buffer[4] == 'S'
             and buffer[5] == 'T' and buffer[6] == 'O' and buffer[7] == 'R' and buffer[8] == 'E'
             and buffer[9] == 'D')
    {
      return MEMCACHED_NOTSTORED;
    }
  } break;

  case 'E': /* PROTOCOL ERROR or END */
  {
    // END
    if (buffer[1] == 'N' and buffer[2] == 'D') {
      return MEMCACHED_END;
    }
#if 0
      // PROTOCOL_ERROR
      else if (buffer[1] == 'R' and buffer[2] == 'O' and buffer[3] == 'T' and buffer[4] == 'O' and buffer[5] == 'C' and buffer[6] == 'O' and buffer[7] == 'L'
               and buffer[8] == '_'
               and buffer[9] == 'E' and buffer[10] == 'R' and buffer[11] == 'R' and buffer[12] == 'O' and buffer[13] == 'R')
      {
        return MEMCACHED_PROTOCOL_ERROR;
      }
#endif
    // ERROR
    else if (buffer[1] == 'R' and buffer[2] == 'R' and buffer[3] == 'O' and buffer[4] == 'R')
    {
      return MEMCACHED_ERROR;
    }
    // EXISTS
    else if (buffer[1] == 'X' and buffer[2] == 'I' and buffer[3] == 'S' and buffer[4] == 'T'
             and buffer[5] == 'S')
    {
      return MEMCACHED_DATA_EXISTS;
    }
  } break;

  case 'T': /* TOUCHED */
  {
    // TOUCHED
    if (buffer[1] == 'O' and buffer[2] == 'U' and buffer[3] == 'C' and buffer[4] == 'H'
        and buffer[5] == 'E' and buffer[6] == 'D')
    {
      return MEMCACHED_SUCCESS;
    }
  } break;

  case 'I': /* ITEM */
  {
    // ITEM
    if (buffer[1] == 'T' and buffer[2] == 'E' and buffer[3] == 'M') {
      /* We add back in one because we will need to search for END */
      memcached_server_response_increment(instance);
      return MEMCACHED_ITEM;
    }
  } break;

  case 'C': /* CLIENT ERROR */
  {
    // CLIENT_ERROR
    if (buffer[1] == 'L' and buffer[2] == 'I' and buffer[3] == 'E' and buffer[4] == 'N'
        and buffer[5] == 'T' and buffer[6] == '_' and buffer[7] == 'E' and buffer[8] == 'R'
        and buffer[9] == 'R' and buffer[10] == 'O' and buffer[11] == 'R')
    {
      // Move past the basic error message and whitespace
      char *startptr = buffer + memcached_literal_param_size("CLIENT_ERROR");
      if (startptr[0] == ' ') {
        startptr++;
      }

      char *endptr = startptr;
      while (*endptr != '\r' && *endptr != '\n') endptr++;

      return memcached_set_error(*instance, MEMCACHED_CLIENT_ERROR, MEMCACHED_AT, startptr,
                                 size_t(endptr - startptr));
    }
  } break;

  case '0': /* INCR/DECR response */
  case '1': /* INCR/DECR response */
  case '2': /* INCR/DECR response */
  case '3': /* INCR/DECR response */
  case '4': /* INCR/DECR response */
  case '5': /* INCR/DECR response */
  case '6': /* INCR/DECR response */
  case '7': /* INCR/DECR response */
  case '8': /* INCR/DECR response */
  case '9': /* INCR/DECR response */
  {
    errno = 0;
    unsigned long long int auto_return_value = strtoull(buffer, (char **) NULL, 10);

    if (auto_return_value == ULLONG_MAX and errno == ERANGE) {
      result->numeric_value = UINT64_MAX;
      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,
                                 memcached_literal_param("Numeric response was out of range"));
    } else if (errno == EINVAL) {
      result->numeric_value = UINT64_MAX;
      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,
                                 memcached_literal_param("Numeric response was out of range"));
    } else if (errno) {
      result->numeric_value = UINT64_MAX;
      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,
                                 memcached_literal_param("Numeric response was out of range"));
    }

    result->numeric_value = uint64_t(auto_return_value);

    WATCHPOINT_STRING(buffer);
    return MEMCACHED_SUCCESS;
  }

  default:
    break;
  }

  buffer[total_read] = 0;
#if 0
  if (total_read >= sizeof("STORSTORED") -1)
  {
    fprintf(stderr, "%s:%d '%s', %.*s\n", __FILE__, __LINE__,
            buffer, MEMCACHED_MAX_BUFFER, instance->read_buffer);
    assert(memcmp(buffer,"STORSTORED", sizeof("STORSTORED") -1));
  }
#endif
  return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT, buffer,
                             total_read);
}
