static GF_Err swf_def_sound(SWFReader *read)
{
	SWFSound *snd;
	GF_SAFEALLOC(snd , SWFSound);
	if (!snd) return GF_OUT_OF_MEM;
	snd->ID = swf_get_16(read);
	snd->format = swf_read_int(read, 4);
	snd->sound_rate = swf_read_int(read, 2);
	snd->bits_per_sample = swf_read_int(read, 1) ? 16 : 8;
	snd->stereo = swf_read_int(read, 1);
	snd->sample_count = swf_get_32(read);

	switch (snd->format) {
	/*raw PCM*/
	case 0:
		swf_report(read, GF_NOT_SUPPORTED, "Raw PCM Audio not supported");
		gf_free(snd);
		break;
	/*ADPCM*/
	case 1:
		swf_report(read, GF_NOT_SUPPORTED, "AD-PCM Audio not supported");
		gf_free(snd);
		break;
	/*MP3*/
	case 2:
	{
		char szName[1024];
		u32 alloc_size, tot_size;
		char *frame;
		GF_Err e=GF_OK;

		sprintf(szName, "swf_sound_%d.mp3", snd->ID);
		if (read->localPath) {
			snd->szFileName = (char*)gf_malloc(sizeof(char)*GF_MAX_PATH);
			strcpy(snd->szFileName, read->localPath);
			strcat(snd->szFileName, szName);
		} else {
			snd->szFileName = gf_strdup(szName);
		}
		snd->output = gf_fopen(snd->szFileName, "wb");

		alloc_size = 4096;
		frame = (char*)gf_malloc(sizeof(char)*4096);
		/*snd->frame_delay_ms =*/ swf_get_16(read);
		snd->frame_delay_ms = read->current_frame*1000;
		snd->frame_delay_ms /= read->frame_rate;
		tot_size = 9;
		/*parse all frames*/
		while (tot_size<read->size) {
			u32 toread = read->size - tot_size;
			if (toread>alloc_size) toread = alloc_size;
			swf_read_data(read, frame, toread);
			if (gf_fwrite(frame, sizeof(char)*toread, snd->output) != toread)
				e = GF_IO_ERR;
			tot_size += toread;
		}

		gf_free(frame);
		if (e) {
			gf_free(snd);
			return e;
		}
		return gf_list_add(read->sounds, snd);
	}
	case 3:
		swf_report(read, GF_NOT_SUPPORTED, "Unrecognized sound format");
		gf_free(snd);
		break;
	}
	return GF_OK;
}
