typedArrayPrototypeReduce(void *ctx, Runtime &runtime, NativeArgs args) {
  // Whether this call is "reduce" or "reduceRight".
  bool right = static_cast<bool>(ctx);
  if (JSTypedArrayBase::validateTypedArray(runtime, args.getThisHandle()) ==
      ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto self = args.vmcastThis<JSTypedArrayBase>();
  double len = self->getLength();
  auto callbackfn = args.dyncastArg<Callable>(0);
  if (!callbackfn) {
    return runtime.raiseTypeError("callbackfn must be a Callable");
  }
  const bool calledWithInitialValue = args.getArgCount() >= 2;
  if (len == 0 && !calledWithInitialValue) {
    return runtime.raiseTypeError(
        "reduce needs to provide an initial value for an empty TypedArray");
  }
  // If the intial value is not provided, it must be the first value from the
  // array.
  MutableHandle<> accumulator(runtime);
  if (calledWithInitialValue) {
    accumulator = args.getArg(1);
  } else {
    accumulator = JSObject::getOwnIndexed(
        createPseudoHandle(self.get()), runtime, right ? len - 1 : 0);
  }

  auto inRange = [right](double i, double len) {
    return right ? i >= 0 : i < len;
  };
  double i = right ? len - 1 : 0;
  // Move it up one if there was not an initial value specified.
  if (!calledWithInitialValue) {
    i += right ? -1 : 1;
  }

  Handle<> undefinedThis = Runtime::getUndefinedValue();
  GCScope scope(runtime);
  auto marker = scope.createMarker();
  for (; inRange(i, len); i += right ? -1 : 1) {
    if (!self->attached(runtime)) {
      // If the callback detached this TypedArray, raise a TypeError and don't
      // continue.
      return runtime.raiseTypeError("Detached the TypedArray in the callback");
    }
    HermesValue val =
        JSObject::getOwnIndexed(createPseudoHandle(self.get()), runtime, i);
    auto callRes = Callable::executeCall4(
        callbackfn,
        runtime,
        undefinedThis,
        accumulator.getHermesValue(),
        val,
        HermesValue::encodeNumberValue(i),
        self.getHermesValue());
    if (callRes == ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
    accumulator = std::move(*callRes);
    scope.flushToMarker(marker);
  }
  return accumulator.getHermesValue();
}
