static unsigned char *print_number(const cJSON *item, printbuffer *p)
{
    unsigned char *str = NULL;
    double d = item->valuedouble;
    /* special case for 0. */
    if (d == 0)
    {
        if (p)
        {
            str = ensure(p, 2);
        }
        else
        {
            str = (unsigned char*)cJSON_malloc(2);
        }
        if (str)
        {
            strcpy((char*)str,"0");
        }
    }
    /* value is an int */
    else if ((FABS(((double)item->valueint) - d) <= DBL_EPSILON) && (d <= INT_MAX) && (d >= INT_MIN))
    {
        if (p)
        {
            str = ensure(p, 21);
        }
        else
        {
            /* 2^64+1 can be represented in 21 chars. */
            str = (unsigned char*)cJSON_malloc(21);
        }
        if (str)
        {
            sprintf((char*)str, "%d", item->valueint);
        }
    }
    /* value is a floating point number */
    else
    {
        if (p)
        {
            /* This is a nice tradeoff. */
            str = ensure(p, 64);
        }
        else
        {
            /* This is a nice tradeoff. */
            str = (unsigned char*)cJSON_malloc(64);
        }
        if (str)
        {
            /* This checks for NaN and Infinity */
            if ((d * 0) != 0)
            {
                sprintf((char*)str, "null");
            }
            else if ((FABS(FLOOR(d) - d) <= DBL_EPSILON) && (FABS(d) < 1.0e60))
            {
                sprintf((char*)str, "%.0f", d);
            }
            else if ((FABS(d) < 1.0e-6) || (FABS(d) > 1.0e9))
            {
                sprintf((char*)str, "%e", d);
            }
            else
            {
                sprintf((char*)str, "%f", d);
            }
        }
    }
    return str;
}
