bool may_do_cert_auth(struct pam_ctx *pctx, struct pam_data *pd)
{
    size_t c;
    errno_t ret;

    if (!pctx->cert_auth) {
        return false;
    }

    if (pd->cmd != SSS_PAM_PREAUTH && pd->cmd != SSS_PAM_AUTHENTICATE) {
        return false;
    }

    if (pd->cmd == SSS_PAM_AUTHENTICATE
           && sss_authtok_get_type(pd->authtok) != SSS_AUTHTOK_TYPE_SC_PIN
           && sss_authtok_get_type(pd->authtok) != SSS_AUTHTOK_TYPE_SC_KEYPAD) {
        return false;
    }

    if (pd->service == NULL || *pd->service == '\0') {
        return false;
    }

    /* Initialize smartcard allowed services just once */
    if (pctx->smartcard_services == NULL) {
        ret = get_sc_services(pctx, pctx, &pctx->smartcard_services);
        if (ret != EOK) {
            DEBUG(SSSDBG_CRIT_FAILURE,
                  "Failed to get p11 allowed services %d[%s]",
                  ret, sss_strerror(ret));
            sss_log(SSS_LOG_ERR,
                    "Failed to evaluate pam_p11_allowed_services option, "
                    "please check for typos in the SSSD configuration");
            return false;
        }
    }

    for (c = 0; pctx->smartcard_services[c] != NULL; c++) {
        if (strcmp(pd->service, pctx->smartcard_services[c]) == 0) {
            break;
        }
    }
    if (pctx->smartcard_services[c] == NULL) {
        DEBUG(SSSDBG_CRIT_FAILURE,
              "Smartcard authentication for service [%s] not supported.\n",
              pd->service);
        return false;
    }

    return true;
}
