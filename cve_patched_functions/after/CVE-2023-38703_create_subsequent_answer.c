static pj_status_t create_subsequent_answer(struct transport_ice *tp_ice,
                                            pj_pool_t *sdp_pool,
                                            pjmedia_sdp_session *loc_sdp,
                                            const pjmedia_sdp_session *rem_sdp,
                                            unsigned media_index)
{
    pj_status_t status;

    /* We have a session */
    status = verify_ice_sdp(tp_ice, sdp_pool, rem_sdp, media_index, 
                            PJ_ICE_SESS_ROLE_CONTROLLED, 
                            &tp_ice->rem_offer_state);
    if (status != PJ_SUCCESS) {
        /* Something wrong with the offer */
        return status;
    }

    if (pj_ice_strans_has_sess(tp_ice->ice_st)) {
        /*
         * Received subsequent offer while we have ICE active.
         */

        if (tp_ice->rem_offer_state.match_comp_cnt == 0) {
            /* Remote no longer offers ICE */
            encode_no_ice_in_sdp(tp_ice, sdp_pool, loc_sdp, rem_sdp,
                                 media_index);
            return PJ_SUCCESS;
        }

        if (tp_ice->rem_offer_state.ice_mismatch) {
            encode_ice_mismatch(sdp_pool, loc_sdp, media_index);
            return PJ_SUCCESS;
        }

        status = encode_session_in_sdp(tp_ice, sdp_pool, loc_sdp, media_index,
                                       tp_ice->rem_offer_state.match_comp_cnt,
                                       tp_ice->rem_offer_state.ice_restart,
                                       tp_ice->use_rtcp_mux, PJ_FALSE);
        if (status != PJ_SUCCESS)
            return status;

        /* Done */

    } else {
        pj_bool_t with_trickle;

        /*
         * Received subsequent offer while we DON'T have ICE active.
         */

        if (tp_ice->rem_offer_state.match_comp_cnt == 0) {
            /* Remote does not support ICE */
            encode_no_ice_in_sdp(tp_ice, sdp_pool, loc_sdp, rem_sdp,
                                 media_index);
            return PJ_SUCCESS;
        }

        if (tp_ice->rem_offer_state.ice_mismatch) {
            encode_ice_mismatch(sdp_pool, loc_sdp, media_index);
            return PJ_SUCCESS;
        }

        /* Looks like now remote is offering ICE, so we need to create
         * ICE session now.
         */
        status = pj_ice_strans_init_ice(tp_ice->ice_st, 
                                        PJ_ICE_SESS_ROLE_CONTROLLED,
                                        NULL, NULL);
        if (status != PJ_SUCCESS) {
            /* Fail to create new ICE session */
            return status;
        }

        with_trickle = tp_ice->rem_offer_state.has_trickle &&
                       tp_ice->trickle_ice != PJ_ICE_SESS_TRICKLE_DISABLED;
        status = encode_session_in_sdp(tp_ice, sdp_pool, loc_sdp, media_index,
                                       tp_ice->rem_offer_state.match_comp_cnt,
                                       tp_ice->rem_offer_state.ice_restart,
                                       tp_ice->use_rtcp_mux,
                                       with_trickle);
        if (status != PJ_SUCCESS)
            return status;

        /* Done */
    }

    return PJ_SUCCESS;
}
