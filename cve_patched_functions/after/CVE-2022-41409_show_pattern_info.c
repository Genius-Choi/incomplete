show_pattern_info(void)
{
uint32_t compile_options, overall_options, extra_options;
BOOL utf = (FLD(compiled_code, overall_options) & PCRE2_UTF) != 0;

if ((pat_patctl.control & (CTL_BINCODE|CTL_FULLBINCODE)) != 0)
  {
  fprintf(outfile, "------------------------------------------------------------------\n");
  PCRE2_PRINTINT((pat_patctl.control & CTL_FULLBINCODE) != 0);
  }

if ((pat_patctl.control & CTL_INFO) != 0)
  {
  int rc;
  void *nametable;
  uint8_t *start_bits;
  BOOL heap_limit_set, match_limit_set, depth_limit_set;
  uint32_t backrefmax, bsr_convention, capture_count, first_ctype, first_cunit,
    hasbackslashc, hascrorlf, jchanged, last_ctype, last_cunit, match_empty,
    depth_limit, heap_limit, match_limit, minlength, nameentrysize, namecount,
    newline_convention;

  /* Exercise the error route. */

  PCRE2_PATTERN_INFO(rc, compiled_code, 999, NULL);
  (void)rc;

  /* These info requests may return PCRE2_ERROR_UNSET. */

  switch(pattern_info(PCRE2_INFO_HEAPLIMIT, &heap_limit, TRUE))
    {
    case 0:
    heap_limit_set = TRUE;
    break;

    case PCRE2_ERROR_UNSET:
    heap_limit_set = FALSE;
    break;

    default:
    return PR_ABEND;
    }

  switch(pattern_info(PCRE2_INFO_MATCHLIMIT, &match_limit, TRUE))
    {
    case 0:
    match_limit_set = TRUE;
    break;

    case PCRE2_ERROR_UNSET:
    match_limit_set = FALSE;
    break;

    default:
    return PR_ABEND;
    }

  switch(pattern_info(PCRE2_INFO_DEPTHLIMIT, &depth_limit, TRUE))
    {
    case 0:
    depth_limit_set = TRUE;
    break;

    case PCRE2_ERROR_UNSET:
    depth_limit_set = FALSE;
    break;

    default:
    return PR_ABEND;
    }

  /* These info requests should always succeed. */

  if (pattern_info(PCRE2_INFO_BACKREFMAX, &backrefmax, FALSE) +
      pattern_info(PCRE2_INFO_BSR, &bsr_convention, FALSE) +
      pattern_info(PCRE2_INFO_CAPTURECOUNT, &capture_count, FALSE) +
      pattern_info(PCRE2_INFO_FIRSTBITMAP, &start_bits, FALSE) +
      pattern_info(PCRE2_INFO_FIRSTCODEUNIT, &first_cunit, FALSE) +
      pattern_info(PCRE2_INFO_FIRSTCODETYPE, &first_ctype, FALSE) +
      pattern_info(PCRE2_INFO_HASBACKSLASHC, &hasbackslashc, FALSE) +
      pattern_info(PCRE2_INFO_HASCRORLF, &hascrorlf, FALSE) +
      pattern_info(PCRE2_INFO_JCHANGED, &jchanged, FALSE) +
      pattern_info(PCRE2_INFO_LASTCODEUNIT, &last_cunit, FALSE) +
      pattern_info(PCRE2_INFO_LASTCODETYPE, &last_ctype, FALSE) +
      pattern_info(PCRE2_INFO_MATCHEMPTY, &match_empty, FALSE) +
      pattern_info(PCRE2_INFO_MINLENGTH, &minlength, FALSE) +
      pattern_info(PCRE2_INFO_NAMECOUNT, &namecount, FALSE) +
      pattern_info(PCRE2_INFO_NAMEENTRYSIZE, &nameentrysize, FALSE) +
      pattern_info(PCRE2_INFO_NAMETABLE, &nametable, FALSE) +
      pattern_info(PCRE2_INFO_NEWLINE, &newline_convention, FALSE)
      != 0)
    return PR_ABEND;

  fprintf(outfile, "Capture group count = %d\n", capture_count);

  if (backrefmax > 0)
    fprintf(outfile, "Max back reference = %d\n", backrefmax);

  if (maxlookbehind > 0)
    fprintf(outfile, "Max lookbehind = %d\n", maxlookbehind);

  if (heap_limit_set)
    fprintf(outfile, "Heap limit = %u\n", heap_limit);

  if (match_limit_set)
    fprintf(outfile, "Match limit = %u\n", match_limit);

  if (depth_limit_set)
    fprintf(outfile, "Depth limit = %u\n", depth_limit);

  if (namecount > 0)
    {
    fprintf(outfile, "Named capture groups:\n");
    for (; namecount > 0; namecount--)
      {
      int imm2_size = test_mode == PCRE8_MODE ? 2 : 1;
      uint32_t length = (uint32_t)STRLEN(nametable + imm2_size);
      fprintf(outfile, "  ");

      /* In UTF mode the name may be a UTF string containing non-ASCII
      letters and digits. We must output it as a UTF-8 string. In non-UTF mode,
      use the normal string printing functions, which use escapes for all
      non-ASCII characters. */

      if (utf)
        {
#ifdef SUPPORT_PCRE2_32
        if (test_mode == PCRE32_MODE)
          {
          PCRE2_SPTR32 nameptr = (PCRE2_SPTR32)nametable + imm2_size;
          while (*nameptr != 0)
            {
            uint8_t u8buff[6];
            int len = ord2utf8(*nameptr++, u8buff);
            fprintf(outfile, "%.*s", len, u8buff);
            }
          }
#endif
#ifdef SUPPORT_PCRE2_16
        if (test_mode == PCRE16_MODE)
          {
          PCRE2_SPTR16 nameptr = (PCRE2_SPTR16)nametable + imm2_size;
          while (*nameptr != 0)
            {
            int len;
            uint8_t u8buff[6];
            uint32_t c = *nameptr++ & 0xffff;
            if (c >= 0xD800 && c < 0xDC00)
              c = ((c & 0x3ff) << 10) + (*nameptr++ & 0x3ff) + 0x10000;
            len = ord2utf8(c, u8buff);
            fprintf(outfile, "%.*s", len, u8buff);
            }
          }
#endif
#ifdef SUPPORT_PCRE2_8
        if (test_mode == PCRE8_MODE)
          fprintf(outfile, "%s", (PCRE2_SPTR8)nametable + imm2_size);
#endif
        }
      else  /* Not UTF mode */
        {
        PCHARSV(nametable, imm2_size, length, FALSE, outfile);
        }

      while (length++ < nameentrysize - imm2_size) putc(' ', outfile);

#ifdef SUPPORT_PCRE2_32
      if (test_mode == PCRE32_MODE)
        fprintf(outfile, "%3d\n", (int)(((PCRE2_SPTR32)nametable)[0]));
#endif
#ifdef SUPPORT_PCRE2_16
      if (test_mode == PCRE16_MODE)
        fprintf(outfile, "%3d\n", (int)(((PCRE2_SPTR16)nametable)[0]));
#endif
#ifdef SUPPORT_PCRE2_8
      if (test_mode == PCRE8_MODE)
        fprintf(outfile, "%3d\n", (int)(
        ((((PCRE2_SPTR8)nametable)[0]) << 8) | ((PCRE2_SPTR8)nametable)[1]));
#endif

      nametable = (void*)((PCRE2_SPTR8)nametable + nameentrysize * code_unit_size);
      }
    }

  if (hascrorlf)     fprintf(outfile, "Contains explicit CR or LF match\n");
  if (hasbackslashc) fprintf(outfile, "Contains \\C\n");
  if (match_empty)   fprintf(outfile, "May match empty string\n");

  pattern_info(PCRE2_INFO_ARGOPTIONS, &compile_options, FALSE);
  pattern_info(PCRE2_INFO_ALLOPTIONS, &overall_options, FALSE);
  pattern_info(PCRE2_INFO_EXTRAOPTIONS, &extra_options, FALSE);

  /* Remove UTF/UCP if they were there only because of forbid_utf. This saves
  cluttering up the verification output of non-UTF test files. */

  if ((pat_patctl.options & PCRE2_NEVER_UTF) == 0)
    {
    compile_options &= ~PCRE2_NEVER_UTF;
    overall_options &= ~PCRE2_NEVER_UTF;
    }

  if ((pat_patctl.options & PCRE2_NEVER_UCP) == 0)
    {
    compile_options &= ~PCRE2_NEVER_UCP;
    overall_options &= ~PCRE2_NEVER_UCP;
    }

  if ((compile_options|overall_options) != 0)
    {
    if (compile_options == overall_options)
      show_compile_options(compile_options, "Options:", "\n");
    else
      {
      show_compile_options(compile_options, "Compile options:", "\n");
      show_compile_options(overall_options, "Overall options:", "\n");
      }
    }

  if (extra_options != 0)
    show_compile_extra_options(extra_options, "Extra options:", "\n");

  if (jchanged) fprintf(outfile, "Duplicate name status changes\n");

  if ((pat_patctl.control2 & CTL2_BSR_SET) != 0 ||
      (FLD(compiled_code, flags) & PCRE2_BSR_SET) != 0)
    fprintf(outfile, "\\R matches %s\n", (bsr_convention == PCRE2_BSR_UNICODE)?
      "any Unicode newline" : "CR, LF, or CRLF");

  if ((FLD(compiled_code, flags) & PCRE2_NL_SET) != 0)
    {
    switch (newline_convention)
      {
      case PCRE2_NEWLINE_CR:
      fprintf(outfile, "Forced newline is CR\n");
      break;

      case PCRE2_NEWLINE_LF:
      fprintf(outfile, "Forced newline is LF\n");
      break;

      case PCRE2_NEWLINE_CRLF:
      fprintf(outfile, "Forced newline is CRLF\n");
      break;

      case PCRE2_NEWLINE_ANYCRLF:
      fprintf(outfile, "Forced newline is CR, LF, or CRLF\n");
      break;

      case PCRE2_NEWLINE_ANY:
      fprintf(outfile, "Forced newline is any Unicode newline\n");
      break;

      case PCRE2_NEWLINE_NUL:
      fprintf(outfile, "Forced newline is NUL\n");
      break;

      default:
      break;
      }
    }

  if (first_ctype == 2)
    {
    fprintf(outfile, "First code unit at start or follows newline\n");
    }
  else if (first_ctype == 1)
    {
    const char *caseless =
      ((FLD(compiled_code, flags) & PCRE2_FIRSTCASELESS) == 0)?
      "" : " (caseless)";
    if (PRINTOK(first_cunit))
      fprintf(outfile, "First code unit = \'%c\'%s\n", first_cunit, caseless);
    else
      {
      fprintf(outfile, "First code unit = ");
      pchar(first_cunit, FALSE, outfile);
      fprintf(outfile, "%s\n", caseless);
      }
    }
  else if (start_bits != NULL)
    {
    int i;
    int c = 24;
    fprintf(outfile, "Starting code units: ");
    for (i = 0; i < 256; i++)
      {
      if ((start_bits[i/8] & (1u << (i&7))) != 0)
        {
        if (c > 75)
          {
          fprintf(outfile, "\n  ");
          c = 2;
          }
        if (PRINTOK(i) && i != ' ')
          {
          fprintf(outfile, "%c ", i);
          c += 2;
          }
        else
          {
          fprintf(outfile, "\\x%02x ", i);
          c += 5;
          }
        }
      }
    fprintf(outfile, "\n");
    }

  if (last_ctype != 0)
    {
    const char *caseless =
      ((FLD(compiled_code, flags) & PCRE2_LASTCASELESS) == 0)?
      "" : " (caseless)";
    if (PRINTOK(last_cunit))
      fprintf(outfile, "Last code unit = \'%c\'%s\n", last_cunit, caseless);
    else
      {
      fprintf(outfile, "Last code unit = ");
      pchar(last_cunit, FALSE, outfile);
      fprintf(outfile, "%s\n", caseless);
      }
    }

  if ((FLD(compiled_code, overall_options) & PCRE2_NO_START_OPTIMIZE) == 0)
    fprintf(outfile, "Subject length lower bound = %d\n", minlength);

  if (pat_patctl.jit != 0 && (pat_patctl.control & CTL_JITVERIFY) != 0)
    {
#ifdef SUPPORT_JIT
    if (FLD(compiled_code, executable_jit) != NULL)
      fprintf(outfile, "JIT compilation was successful\n");
    else
      {
      fprintf(outfile, "JIT compilation was not successful");
      if (jitrc != 0 && !print_error_message(jitrc, " (", ")"))
        return PR_ABEND;
      fprintf(outfile, "\n");
      }
#else
      fprintf(outfile, "JIT support is not available in this version of PCRE2\n");
#endif
    }
  }

if ((pat_patctl.control & CTL_CALLOUT_INFO) != 0)
  {
  int errorcode;
  PCRE2_CALLOUT_ENUMERATE(errorcode, callout_callback, 0);
  if (errorcode != 0)
    {
    fprintf(outfile, "Callout enumerate failed: error %d: ", errorcode);
    if (errorcode < 0 && !print_error_message(errorcode, "", "\n"))
      return PR_ABEND;
    return PR_SKIP;
    }
  }

return PR_OK;
}
