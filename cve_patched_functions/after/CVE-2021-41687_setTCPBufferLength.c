static void setTCPBufferLength(SOCKET sock)
#else
static void setTCPBufferLength(int sock)
#endif
{
    char *TCPBufferLength;
    int bufLen;

    /*
     * check whether environment variable TCP_BUFFER_LENGTH is set.
     * If not, the the operating system is responsible for selecting
     * appropriate values for the TCP send and receive buffer lengths.
     */
    DCMNET_TRACE("checking whether environment variable TCP_BUFFER_LENGTH is set");
    if ((TCPBufferLength = getenv("TCP_BUFFER_LENGTH")) != NULL) {
        if (sscanf(TCPBufferLength, "%d", &bufLen) == 1) {
#if defined(SO_SNDBUF) && defined(SO_RCVBUF)
            if (bufLen == 0)
                bufLen = 65536; // a socket buffer size of 64K gives good throughput for image transmission
            DCMNET_DEBUG("DULFSM: setting TCP buffer length to " << bufLen << " bytes");
            (void) setsockopt(sock, SOL_SOCKET, SO_SNDBUF, (char *) &bufLen, sizeof(bufLen));
            (void) setsockopt(sock, SOL_SOCKET, SO_RCVBUF, (char *) &bufLen, sizeof(bufLen));
#else
            DCMNET_WARN("DULFSM: setTCPBufferLength: cannot set TCP buffer length socket option: "
                << "code disabled because SO_SNDBUF and SO_RCVBUF constants are unknown");
#endif // SO_SNDBUF and SO_RCVBUF
        } else
            DCMNET_WARN("DULFSM: cannot parse environment variable TCP_BUFFER_LENGTH=" << TCPBufferLength);
    } else
        DCMNET_TRACE("  environment variable TCP_BUFFER_LENGTH not set, using the system defaults");
}
