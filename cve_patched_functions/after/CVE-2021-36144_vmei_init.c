vmei_init(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	struct virtio_mei *vmei;
	char tname[MAXCOMLEN + 1];
	pthread_mutexattr_t attr;
	int mutex_type;
	int i, rc;
	char *endptr = NULL;
	char *opt;
	int bus = 0, slot = 0, func = 0;
	char name[DEV_NAME_SIZE + 1];

	vmei_debug = 0;

	if (!opts)
		goto init;

	while ((opt = strsep(&opts, ",")) != NULL) {
		if (parse_bdf(opt, &bus, &slot, &func, 16) == 0)
			continue;
		if (!strncmp(opt, "d", 1)) {
			vmei_debug = strtoul(opt + 1, &endptr, 10);
			if (endptr == opt || vmei_debug > 8) {
				vmei_debug  = 0;
				WPRINTF("init: unknown debug flag %s\n",
					opts + 1);
			}
			continue;
		}
		WPRINTF("Invalid option: %s\n", opt);
	}

	if (vmei_debug)
		vmei_dbg_file = fopen("/tmp/vmei_log", "a+");

init:
	rc = vmei_get_devname(name, sizeof(name), bus, slot, func);
	if (rc) {
		WPRINTF("init: fail to get mei path!\n");
		strncpy(name, "mei0", sizeof(name));
	}

	DPRINTF("init: starting\n");
	vmei = calloc(1, sizeof(*vmei));
	if (!vmei) {
		WPRINTF("init: fail to alloc virtio_heci!\n");
		goto fail;
	}

	vmei->config = calloc(1, sizeof(*vmei->config));
	if (!vmei->config) {
		WPRINTF("init: fail to alloc vmei_config!\n");
		goto fail;
	}

	/* FIXME: fix get correct mapping */
	vmei->vtag = ctx->vmid;
	if (!vmei->vtag)
		vmei->vtag = 1;

	vmei->config->buf_depth = VMEI_BUF_DEPTH;
	vmei->config->hw_ready = 0;

	strncpy(vmei->name, name, sizeof(vmei->name));
	vmei->name[sizeof(vmei->name) - 1] = 0;
	snprintf(vmei->devnode, sizeof(vmei->devnode) - 1,
		 "/dev/%s", vmei->name);

	DPRINTF("devnode = %s\n", vmei->devnode);

	if (vmei_add_reset_event(vmei) < 0)
		WPRINTF("init: resets won't be detected\n");

	/* init mutex attribute properly */
	rc = pthread_mutexattr_init(&attr);
	if (rc) {
		WPRINTF("init: mutexattr init fail, error %d!\n", rc);
		goto fail;
	}

	mutex_type = virtio_uses_msix() ?
		PTHREAD_MUTEX_DEFAULT :
		PTHREAD_MUTEX_RECURSIVE;

	rc = pthread_mutexattr_settype(&attr, mutex_type);
	if (rc) {
		pthread_mutexattr_destroy(&attr);
		WPRINTF("init: mutexattr_settype failed, error %d!\n", rc);
		goto fail;
	}

	rc = pthread_mutex_init(&vmei->mutex, &attr);
	pthread_mutexattr_destroy(&attr);
	if (rc) {
		WPRINTF("init: mutex init failed, error %d!\n", rc);
		goto fail;
	}

	virtio_linkup(&vmei->base, &virtio_mei_ops, vmei, dev, vmei->vqs, BACKEND_VBSU);
	vmei->base.mtx = &vmei->mutex;

	for (i = 0; i < VMEI_VQ_NUM; i++)
		vmei->vqs[i].qsize = VMEI_RING_SZ;
	vmei->vqs[VMEI_RXQ].notify = vmei_notify_rx;
	vmei->vqs[VMEI_TXQ].notify = vmei_notify_tx;

	/* initialize config space */
	pci_set_cfgdata16(dev, PCIR_DEVICE, VIRTIO_DEV_HECI);
	pci_set_cfgdata16(dev, PCIR_VENDOR, INTEL_VENDOR_ID);
	pci_set_cfgdata8(dev, PCIR_CLASS, PCIC_SIMPLECOMM);
	pci_set_cfgdata8(dev, PCIR_SUBCLASS, PCIS_SIMPLECOMM_OTHER);
	pci_set_cfgdata16(dev, PCIR_SUBDEV_0, VIRTIO_TYPE_HECI);
	pci_set_cfgdata16(dev, PCIR_SUBVEND_0, INTEL_VENDOR_ID);

	if (virtio_interrupt_init(&vmei->base, virtio_uses_msix()))
		goto setup_fail;
	virtio_set_io_bar(&vmei->base, 0);

	/*
	 * init clients
	 */
	pthread_mutexattr_init(&attr);
	pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
	pthread_mutex_init(&vmei->list_mutex, &attr);
	pthread_mutexattr_destroy(&attr);
	LIST_INIT(&vmei->active_clients);

	/*
	 * tx stuff, thread, mutex, cond
	 */
	pthread_mutex_init(&vmei->tx_mutex, NULL);
	pthread_cond_init(&vmei->tx_cond, NULL);
	pthread_create(&vmei->tx_thread, NULL,
		       vmei_tx_thread, vmei);
	snprintf(tname, sizeof(tname), "vmei-%d:%d tx", dev->slot, dev->func);
	pthread_setname_np(vmei->tx_thread, tname);

	/*
	 * rx stuff
	 */
	pthread_mutex_init(&vmei->rx_mutex, NULL);
	pthread_cond_init(&vmei->rx_cond, NULL);
	pthread_create(&vmei->rx_thread, NULL,
		       vmei_rx_thread, (void *)vmei);
	snprintf(tname, sizeof(tname), "vmei-%d:%d rx", dev->slot, dev->func);
	pthread_setname_np(vmei->rx_thread, tname);

	/*
	 * start mei backend
	 */
	if (vmei_start(vmei, true) < 0)
		goto start_fail;

	return 0;

start_fail:
	vmei_stop(vmei);
setup_fail:
	pthread_mutex_destroy(&vmei->mutex);
fail:
	if (vmei) {
		free(vmei->config);
		free(vmei);
	}

	WPRINTF("init: error\n");
	return -1;
}
