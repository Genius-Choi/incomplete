static BOOL nsc_context_initialize(NSC_CONTEXT* context, wStream* s)
{
	if (!nsc_stream_initialize(context, s))
		return FALSE;

	const size_t blength = context->width * context->height * 4ull;

	if (!context->BitmapData || (blength > context->BitmapDataLength))
	{
		void* tmp = winpr_aligned_recalloc(context->BitmapData, blength + 16, sizeof(BYTE), 32);

		if (!tmp)
			return FALSE;

		context->BitmapData = tmp;
		context->BitmapDataLength = blength;
	}

	const UINT32 tempWidth = ROUND_UP_TO(context->width, 8);
	const UINT32 tempHeight = ROUND_UP_TO(context->height, 2);
	/* The maximum length a decoded plane can reach in all cases */
	const size_t plength = 1ull * tempWidth * tempHeight;

	if (plength > context->priv->PlaneBuffersLength)
	{
		for (size_t i = 0; i < 4; i++)
		{
			void* tmp = (BYTE*)winpr_aligned_recalloc(context->priv->PlaneBuffers[i], plength,
			                                          sizeof(BYTE), 32);

			if (!tmp)
				return FALSE;

			context->priv->PlaneBuffers[i] = tmp;
		}

		context->priv->PlaneBuffersLength = plength;
	}

	for (size_t i = 0; i < 4; i++)
		context->OrgByteCount[i] = context->width * context->height;

	if (context->ChromaSubsamplingLevel)
	{
		context->OrgByteCount[0] = tempWidth * context->height;
		context->OrgByteCount[1] = (tempWidth >> 1) * (tempHeight >> 1);
		context->OrgByteCount[2] = context->OrgByteCount[1];
	}

	return TRUE;
}
