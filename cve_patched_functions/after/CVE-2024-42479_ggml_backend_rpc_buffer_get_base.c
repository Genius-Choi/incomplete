GGML_CALL static void * ggml_backend_rpc_buffer_get_base(ggml_backend_buffer_t buffer) {
    ggml_backend_rpc_buffer_context * ctx = (ggml_backend_rpc_buffer_context *)buffer->context;
    if (ctx->base_cache.find(buffer) != ctx->base_cache.end()) {
        return ctx->base_cache[buffer];
    }
    // input serialization format: | remote_ptr (8 bytes) |
    std::vector<uint8_t> input(sizeof(uint64_t), 0);
    uint64_t remote_ptr = ctx->remote_ptr;
    memcpy(input.data(), &remote_ptr, sizeof(remote_ptr));
    std::vector<uint8_t> output;
    bool status = send_rpc_cmd(ctx->sock, BUFFER_GET_BASE, input, output);
    GGML_ASSERT(status);
    GGML_ASSERT(output.size() == sizeof(uint64_t));
    // output serialization format: | base_ptr (8 bytes) |
    uint64_t base_ptr;
    memcpy(&base_ptr, output.data(), sizeof(base_ptr));
    void * base = reinterpret_cast<void *>(base_ptr);
    ctx->base_cache[buffer] = base;
    return base;
}
