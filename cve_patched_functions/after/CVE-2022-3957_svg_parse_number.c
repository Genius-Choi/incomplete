static u32 svg_parse_number(char *d, Fixed *f, Bool is_angle, GF_Err *out_e)
{
	u32 nb_digit_before = 0;
	u32 nb_digit_after = 0;
	Bool has_fractional = 0;
	Bool is_negative = 0;
	Float _val = 0;
	u32 i = 0;

	/* warning the comma and semicolumn should not be there when parsing a number in a path */
	while ((d[i] != 0) && strchr(" ,;\r\n\t", d[i])) i++;

	if (!d[i]) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, ("[SVG Parsing] Parsing number with empty string or only spaces: %s\n", d));
		*out_e = GF_NON_COMPLIANT_BITSTREAM;
		return 0;
	}
	if (d[i] == '+') {
		i++;
	} else if (d[i] == '-') {
		is_negative = 1;
		i++;
	}
	/* Warning: this is not normal, should be detected somehow by checking the BNF */
	/* if ((d[i]=='N') && (d[i+1]=='a') && (d[i+2]=='N')) {
		i+= 3;
		_val = 0;
		goto end;
	}*/
	/* read the digit-sequence token of the BNF */
	while (d[i] >= '0' && d[i] <= '9' && d[i] != 0) {
		_val = _val*10 + (d[i]-'0');
		nb_digit_before++;
		i++;
	}
	if (d[i] == '.') {
		has_fractional = 1;
		i++;
		while (d[i] >= '0' && d[i] <= '9' && d[i] != 0) {
			_val = _val*10 + (d[i]-'0');
			nb_digit_after++;
			i++;
		}
		if (nb_digit_after) {
			_val /= (Float)pow(10,nb_digit_after);
		} else if (nb_digit_before == 0) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[SVG Parsing] Error in parsing number (expecting digits before or after a '.': %s\n", d));
			*out_e = GF_NON_COMPLIANT_BITSTREAM;
			return 0;
		} else {
			/* dangling '.' without digits after. This is allowed by the BNF */
		}
	}
	if ((nb_digit_before == 0) && (has_fractional == 0)) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[SVG Parsing] Error in parsing number (expecting digits):%s\n", d));
		*out_e = GF_NON_COMPLIANT_BITSTREAM;
		return 0;
	}
	/* reading the exponent */
	if (d[i] == 'e' || d[i] == 'E') {
		Bool neg_exp = 0;
		u32 nb_exp_digits = 0;
		s32 exp = 0;
		i++;
		if (d[i] == '+') i++;
		else if (d[i] == '-') {
			i++;
			neg_exp=1;
		}
		while (d[i] >= '0' && d[i] <= '9' && d[i] != 0) {
			exp = exp*10 + (d[i]-'0');
			nb_exp_digits++;
			i++;
		}
		if (nb_exp_digits) {
			_val *= (Float)pow(10, neg_exp ? -exp : exp);
		} else {
			GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[SVG Parsing] Error in parsing exponent, 'e' or 'E' should be followed by digits: %s\n", d));
			*out_e = GF_NON_COMPLIANT_BITSTREAM;
			return 0;
		}
	}
	/* We can now produce the final number */
	if (is_negative) _val *= -1;
	if (is_angle) {
		_val/=180;
		(*f) = gf_mulfix(FLT2FIX(_val), GF_PI);
	} else {
		(*f) = FLT2FIX(_val);
	}

	/* warning the comma and semicolumn should not be there when parsing a path number */
	while (d[i] != 0 && (d[i] == ' ' || d[i] == ',' || d[i] == ';')) i++;
	return i;
}
