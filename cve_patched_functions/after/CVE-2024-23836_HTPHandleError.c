static void HTPHandleError(HtpState *s, const uint8_t dir)
{
    if (s == NULL || s->conn == NULL ||
        s->conn->messages == NULL) {
        return;
    }

    size_t size = htp_list_size(s->conn->messages);
    size_t msg;
    if(size >= HTP_MAX_MESSAGES) {
        if (s->htp_messages_offset < HTP_MAX_MESSAGES) {
            //only once per HtpState
            HTPSetEvent(s, NULL, dir, HTTP_DECODER_EVENT_TOO_MANY_WARNINGS);
            s->htp_messages_offset = HTP_MAX_MESSAGES;
            //too noisy in fuzzing
            //DEBUG_VALIDATE_BUG_ON("Too many libhtp messages");
        }
        // ignore further messages
        return;
    }

    for (msg = s->htp_messages_offset; msg < size; msg++) {
        htp_log_t *log = htp_list_get(s->conn->messages, msg);
        if (log == NULL)
            continue;

        HtpTxUserData *htud = NULL;
        htp_tx_t *tx = log->tx; // will be NULL in <=0.5.9
        if (tx != NULL)
            htud = (HtpTxUserData *) htp_tx_get_user_data(tx);

        SCLogDebug("message %s", log->msg);

        uint8_t id = HTPHandleErrorGetId(log->msg);
        if (id == 0) {
            id = HTPHandleWarningGetId(log->msg);
            if (id == 0)
                id = HTTP_DECODER_EVENT_UNKNOWN_ERROR;
        }

        if (id > 0) {
            HTPSetEvent(s, htud, dir, id);
        }
    }
    s->htp_messages_offset = (uint16_t)msg;
    SCLogDebug("s->htp_messages_offset %u", s->htp_messages_offset);
}
