bool Filter::parseV2Header(const char* buf) {
  const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];
  uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];
  uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];
  size_t hdr_addr_len = (upper_byte << 8) + lower_byte;

  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_LOCAL) {
    // This is locally-initiated, e.g. health-check, and should not override remote address.
    // According to the spec, this address length should be zero for local connection.
    proxy_protocol_header_.emplace(WireHeader{PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, 0, 0});
    return true;
  }

  // Only do connections on behalf of another user, not internally-driven health-checks. If
  // its not on behalf of someone, or its not AF_INET{6} / STREAM/DGRAM, ignore and
  // use the real-remote info
  if ((ver_cmd & 0xf) == PROXY_PROTO_V2_ONBEHALF_OF) {
    uint8_t proto_family = buf[PROXY_PROTO_V2_SIGNATURE_LEN + 1];
    if (((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_STREAM) ||
        ((proto_family & 0x0f) == PROXY_PROTO_V2_TRANSPORT_DGRAM)) {
      if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET) {
        PACKED_STRUCT(struct pp_ipv4_addr {
          uint32_t src_addr;
          uint32_t dst_addr;
          uint16_t src_port;
          uint16_t dst_port;
        });
        const pp_ipv4_addr* v4;
        v4 = reinterpret_cast<const pp_ipv4_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);
        sockaddr_in ra4, la4;
        memset(&ra4, 0, sizeof(ra4));
        memset(&la4, 0, sizeof(la4));
        ra4.sin_family = AF_INET;
        ra4.sin_port = v4->src_port;
        ra4.sin_addr.s_addr = v4->src_addr;

        la4.sin_family = AF_INET;
        la4.sin_port = v4->dst_port;
        la4.sin_addr.s_addr = v4->dst_addr;

        TRY_NEEDS_AUDIT_ADDRESS {
          // TODO(ggreenway): make this work without requiring operating system support for an
          // address family.
          proxy_protocol_header_.emplace(WireHeader{
              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET,
              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET, Network::Address::IpVersion::v4,
              std::make_shared<Network::Address::Ipv4Instance>(&ra4),
              std::make_shared<Network::Address::Ipv4Instance>(&la4)});
        }
        END_TRY CATCH(const EnvoyException& e, {
          ENVOY_LOG(debug, "Proxy protocol failure: {}", e.what());
          return false;
        });

        return true;
      } else if (((proto_family & 0xf0) >> 4) == PROXY_PROTO_V2_AF_INET6) {
        PACKED_STRUCT(struct pp_ipv6_addr {
          uint8_t src_addr[16];
          uint8_t dst_addr[16];
          uint16_t src_port;
          uint16_t dst_port;
        });
        const pp_ipv6_addr* v6;
        v6 = reinterpret_cast<const pp_ipv6_addr*>(&buf[PROXY_PROTO_V2_HEADER_LEN]);
        sockaddr_in6 ra6, la6;
        memset(&ra6, 0, sizeof(ra6));
        memset(&la6, 0, sizeof(la6));
        ra6.sin6_family = AF_INET6;
        ra6.sin6_port = v6->src_port;
        safeMemcpy(&(ra6.sin6_addr.s6_addr), &(v6->src_addr));

        la6.sin6_family = AF_INET6;
        la6.sin6_port = v6->dst_port;
        safeMemcpy(&(la6.sin6_addr.s6_addr), &(v6->dst_addr));

        TRY_NEEDS_AUDIT_ADDRESS {
          proxy_protocol_header_.emplace(WireHeader{
              PROXY_PROTO_V2_HEADER_LEN, hdr_addr_len, PROXY_PROTO_V2_ADDR_LEN_INET6,
              hdr_addr_len - PROXY_PROTO_V2_ADDR_LEN_INET6, Network::Address::IpVersion::v6,
              std::make_shared<Network::Address::Ipv6Instance>(ra6),
              std::make_shared<Network::Address::Ipv6Instance>(la6)});
        }
        END_TRY CATCH(const EnvoyException& e, {
          // TODO(ggreenway): make this work without requiring operating system support for an
          // address family.
          ENVOY_LOG(debug, "Proxy protocol failure: {}", e.what());
          return false;
        });
        return true;
      }
    }
  }
  ENVOY_LOG(debug, "Unsupported command or address family or transport");
  return false;
}
