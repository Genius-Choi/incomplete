static iwrc _jbl_node_from_binn_impl(
  JBLDRCTX   *ctx,
  const binn *bn,
  JBL_NODE    parent,
  char       *key,
  int         klidx,
  bool        clone_strings
  ) {
  binn bv;
  binn_iter iter;
  iwrc rc = 0;

  switch (bn->type) {
    case BINN_OBJECT:
    case BINN_MAP:
      rc = _jbl_create_node(ctx, bn, parent, key, klidx, &parent, clone_strings);
      RCRET(rc);
      if (!ctx->root) {
        ctx->root = parent;
      }
      if (!binn_iter_init(&iter, (binn*) bn, bn->type)) {
        return JBL_ERROR_INVALID;
      }
      if (bn->type == BINN_OBJECT) {
        while (binn_object_next2(&iter, &key, &klidx, &bv)) {
          rc = _jbl_node_from_binn_impl(ctx, &bv, parent, key, klidx, clone_strings);
          RCRET(rc);
        }
      } else if (bn->type == BINN_MAP) {
        while (binn_map_next(&iter, &klidx, &bv)) {
          rc = _jbl_node_from_binn_impl(ctx, &bv, parent, 0, klidx, clone_strings);
          RCRET(rc);
        }
      }
      break;
    case BINN_LIST:
      rc = _jbl_create_node(ctx, bn, parent, key, klidx, &parent, clone_strings);
      RCRET(rc);
      if (!ctx->root) {
        ctx->root = parent;
      }
      if (!binn_iter_init(&iter, (binn*) bn, bn->type)) {
        return JBL_ERROR_INVALID;
      }
      for (int i = 0; binn_list_next(&iter, &bv); ++i) {
        rc = _jbl_node_from_binn_impl(ctx, &bv, parent, 0, i, clone_strings);
        RCRET(rc);
      }
      break;
    default: {
      rc = _jbl_create_node(ctx, bn, parent, key, klidx, 0, clone_strings);
      RCRET(rc);
      break;
    }
  }
  return rc;
}
