static int eval_msg_publish(struct mqtt_test *mqtt_test)
{
	struct mqtt_publish_param *param =
			(struct mqtt_publish_param *)mqtt_test->ctx;
	struct mqtt_publish_param dec_param;
	int rc;
	u8_t type_and_flags;
	u32_t length;
	struct buf_ctx buf;

	memset(&dec_param, 0, sizeof(dec_param));

	buf.cur = client.tx_buf;
	buf.end = client.tx_buf + client.tx_buf_size;

	rc = publish_encode(param, &buf);

	/* Payload is not copied, copy it manually just after the header.*/
	memcpy(buf.end, param->message.payload.data,
	       param->message.payload.len);
	buf.end += param->message.payload.len;

	/**TESTPOINT: Check publish_encode function*/
	zassert_false(rc, "publish_encode failed");

	rc = eval_buffers(&buf, mqtt_test->expected, mqtt_test->expected_len);

	zassert_false(rc, "eval_buffers failed");

	rc = fixed_header_decode(&buf, &type_and_flags, &length);

	zassert_false(rc, "fixed_header_decode failed");

	rc = publish_decode(type_and_flags, length, &buf, &dec_param);

	/**TESTPOINT: Check publish_decode function*/
	zassert_false(rc, "publish_decode failed");

	zassert_equal(dec_param.message_id, param->message_id,
		      "message_id error");
	zassert_equal(dec_param.dup_flag, param->dup_flag,
		      "dup flag error");
	zassert_equal(dec_param.retain_flag, param->retain_flag,
		      "retain flag error");
	zassert_equal(dec_param.message.topic.qos, param->message.topic.qos,
		      "topic qos error");
	zassert_equal(dec_param.message.topic.topic.size,
		      param->message.topic.topic.size,
		      "topic len error");
	if (memcmp(dec_param.message.topic.topic.utf8,
		   param->message.topic.topic.utf8,
		   dec_param.message.topic.topic.size) != 0) {
		zassert_unreachable("topic content error");
	}
	zassert_equal(dec_param.message.payload.len,
		      param->message.payload.len,
		      "payload len error");

	return TC_PASS;
}
