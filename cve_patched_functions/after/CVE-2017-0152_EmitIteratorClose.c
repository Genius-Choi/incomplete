void EmitIteratorClose(Js::RegSlot iteratorLocation, ByteCodeGenerator* byteCodeGenerator, FuncInfo* funcInfo)
{
    Js::RegSlot returnLocation = funcInfo->AcquireTmpRegister();

    Js::ByteCodeLabel skipThrow = byteCodeGenerator->Writer()->DefineLabel();
    Js::ByteCodeLabel noReturn = byteCodeGenerator->Writer()->DefineLabel();

    uint cacheId = funcInfo->FindOrAddInlineCacheId(iteratorLocation, Js::PropertyIds::return_, false, false);
    byteCodeGenerator->Writer()->PatchableProperty(Js::OpCode::LdFld, returnLocation, iteratorLocation, cacheId);

    byteCodeGenerator->Writer()->BrReg2(Js::OpCode::BrEq_A, noReturn, returnLocation, funcInfo->undefinedConstantRegister);

    EmitInvoke(returnLocation, iteratorLocation, Js::PropertyIds::return_, byteCodeGenerator, funcInfo);

    // throw TypeError if the result is not an Object
    byteCodeGenerator->Writer()->BrReg1(Js::OpCode::BrOnObject_A, skipThrow, returnLocation);
    byteCodeGenerator->Writer()->W1(Js::OpCode::RuntimeTypeError, SCODE_CODE(JSERR_NeedObject));
    byteCodeGenerator->Writer()->MarkLabel(skipThrow);
    byteCodeGenerator->Writer()->MarkLabel(noReturn);

    funcInfo->ReleaseTmpRegister(returnLocation);
}
