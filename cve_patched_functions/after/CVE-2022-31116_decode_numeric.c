static FASTCALL_ATTR JSOBJ FASTCALL_MSVC decode_numeric (struct DecoderState *ds)
{
  int intNeg = 1;
  int hasError = 0;
  JSUINT64 intValue;
  JSUINT64 addIntValue;
  int chr;
  char *offset = ds->start;

  JSUINT64 maxIntValue = ULLONG_MAX;
  JSUINT64 overflowLimit = maxIntValue / 10LLU;

  if (*(offset) == 'I')
  {
    goto DECODE_INF;
  }
  else if (*(offset) == 'N')
  {
    goto DECODE_NAN;
  }
  else if (*(offset) == '-')
  {
    offset++;
    intNeg = -1;
    if (*(offset) == 'I')
    {
      goto DECODE_INF;
    }
    maxIntValue = -(JSUINT64) LLONG_MIN;
    overflowLimit = maxIntValue / 10LL;
  }

  // Scan integer part
  intValue = 0;

  while (1)
  {
    chr = (int) (unsigned char) *(offset);

    switch (chr)
    {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      {
        // check whether multiplication would be out of bounds
        if (intValue > overflowLimit)
        {
          hasError = 1;
        }
        intValue *= 10ULL;
        addIntValue = (JSUINT64) (chr - 48);

        // check whether addition would be out of bounds
        if (maxIntValue - intValue < addIntValue)
        {
          hasError = 1;
        }

        intValue += addIntValue;
        offset ++;
        break;
      }
      case '.':
      {
        offset ++;
        return decodeDouble(ds);
      }
      case 'e':
      case 'E':
      {
        offset ++;
        return decodeDouble(ds);
      }

      default:
      {
        if (hasError)
        {
          char *strStart = ds->start;
          ds->lastType = JT_INT;
          ds->start = offset;
          return ds->dec->newIntegerFromString(ds->prv, strStart, offset - strStart);
        }
        goto BREAK_INT_LOOP;
        break;
      }
    }
  }

BREAK_INT_LOOP:

  ds->lastType = JT_INT;
  ds->start = offset;

  if (intNeg == 1 && (intValue & 0x8000000000000000ULL) != 0)
  {
    return ds->dec->newUnsignedLong(ds->prv, intValue);
  }
  else if ((intValue >> 31))
  {
    return ds->dec->newLong(ds->prv, (JSINT64) (intValue * (JSINT64) intNeg));
  }
  else
  {
    return ds->dec->newInt(ds->prv, (JSINT32) (intValue * intNeg));
  }

DECODE_NAN:
    offset++;
    if (*(offset++) != 'a') goto SET_NAN_ERROR;
    if (*(offset++) != 'N') goto SET_NAN_ERROR;

    ds->lastType = JT_NAN;
    ds->start = offset;
    return ds->dec->newNaN(ds->prv);

SET_NAN_ERROR:
    return SetError(ds, -1, "Unexpected character found when decoding 'NaN'");

DECODE_INF:
    offset++;
    if (*(offset++) != 'n') goto SET_INF_ERROR;
    if (*(offset++) != 'f') goto SET_INF_ERROR;
    if (*(offset++) != 'i') goto SET_INF_ERROR;
    if (*(offset++) != 'n') goto SET_INF_ERROR;
    if (*(offset++) != 'i') goto SET_INF_ERROR;
    if (*(offset++) != 't') goto SET_INF_ERROR;
    if (*(offset++) != 'y') goto SET_INF_ERROR;

    ds->start = offset;

    if (intNeg == 1) {
      ds->lastType = JT_POS_INF;
      return ds->dec->newPosInf(ds->prv);
    } else {
      ds->lastType = JT_NEG_INF;
      return ds->dec->newNegInf(ds->prv);
    }

SET_INF_ERROR:
    if (intNeg == 1) {
      const char *msg = "Unexpected character found when decoding 'Infinity'";
      return SetError(ds, -1, msg);
    } else {
      const char *msg = "Unexpected character found when decoding '-Infinity'";
      return SetError(ds, -1, msg);
    }

}
