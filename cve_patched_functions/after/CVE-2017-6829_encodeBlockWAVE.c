int IMA::encodeBlockWAVE(const int16_t *input, uint8_t *output)
{
	int channelCount = m_track->f.channelCount;

	for (int c=0; c<channelCount; c++)
	{
		output[0] = m_adpcmState[c].previousValue & 0xff;
		output[1] = m_adpcmState[c].previousValue >> 8;
		output[2] = m_adpcmState[c].index;
		output[3] = 0;

		output += 4;
	}

	for (int n=0; n<m_framesPerPacket - 1; n += 8)
	{
		for (int c=0; c<channelCount; c++)
		{
			const int16_t *currentInput = input + c;
			for (int s=0; s<4; s++)
			{
				uint8_t encodedValue = encodeSample(m_adpcmState[c], *currentInput);
				currentInput += channelCount;
				encodedValue |= encodeSample(m_adpcmState[c], *currentInput) << 4;
				currentInput += channelCount;
				*output++ = encodedValue;
			}
		}

		input += channelCount * 8;
	}

	return m_bytesPerPacket;
}
