InitFiniNode s_traceRequestStart([]() {
  if (!tl_traceTask && !s_traceTask.load(std::memory_order_acquire)) return;
  if (!tl_traceTask) {
    // Try grab the task.
    tl_traceTask = s_traceTask.exchange(nullptr, std::memory_order_acq_rel);
  }
  if (!tl_traceTask) return; // We lost the race; nothing to do.
  if (tl_traceTask->count == 0) {
    // Task already complete.
    Trace::trace("Trace complete at %d\n", (int)time(nullptr));
    Trace::setTraceThread("");
    delete tl_traceTask;
    tl_traceTask = nullptr;
    return;
  }
  const string url = g_context->getRequestUrl();
  if (url.find(tl_traceTask->url) == string::npos) {
    // URL mismatch; hand task back (and discard any unlikely colliding task).
    delete s_traceTask.exchange(tl_traceTask, std::memory_order_acq_rel);
    tl_traceTask = nullptr;
    Trace::setTraceThread("");
  } else {
    // Work on task.
    --tl_traceTask->count;
    const auto spec = tl_traceTask->spec;
    Trace::setTraceThread(spec);
    Trace::trace("Trace for %s at %d using spec %s\n",
                 url.c_str(), (int)time(nullptr), spec.c_str());
  }
}, InitFiniNode::When::RequestStart, "trace");
