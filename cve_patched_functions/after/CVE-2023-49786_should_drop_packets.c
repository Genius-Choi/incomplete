static int should_drop_packets(struct ast_sockaddr *addr)
{
	struct timeval tv;

	if (!drop_packets_data.num_to_drop) {
		return 0;
	}

	/*
	 * If an address has been specified then filter on it, and also the port if
	 * it too was included.
	 */
	if (!ast_sockaddr_isnull(&drop_packets_data.addr) &&
		(drop_packets_data.port ?
			ast_sockaddr_cmp(&drop_packets_data.addr, addr) :
			ast_sockaddr_cmp_addr(&drop_packets_data.addr, addr)) != 0) {
		/* Address and/or port does not match */
		return 0;
	}

	/* Keep dropping packets until we've reached the total to drop */
	if (drop_packets_data.num_dropped < drop_packets_data.num_to_drop) {
		++drop_packets_data.num_dropped;
		return 1;
	}

	/*
	 * Once the set number of packets has been dropped check to see if it's
	 * time to drop more.
	 */

	if (ast_tvzero(drop_packets_data.interval)) {
		/* If no interval then drop specified number of packets and be done */
		drop_packets_data.num_to_drop = 0;
		return 0;
	}

	tv = ast_tvnow();
	if (ast_tvcmp(tv, drop_packets_data.next) == -1) {
		/* Still waiting for the next time interval to elapse */
		return 0;
	}

	/*
	 * The next time interval has elapsed so update the tracking structure
	 * in order to start dropping more packets, and figure out when the next
	 * time interval is.
	 */
	drop_packets_data_update(tv);
	return 1;
}
