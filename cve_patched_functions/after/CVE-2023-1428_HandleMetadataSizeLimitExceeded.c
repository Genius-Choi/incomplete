  bool HandleMetadataSizeLimitExceeded(const HPackTable::Memento& md) {
    // Collect a summary of sizes so far for debugging
    // Do not collect contents, for fear of exposing PII.
    std::string summary;
    if (metadata_buffer_ != nullptr) {
      MetadataSizeLimitExceededEncoder encoder(summary);
      metadata_buffer_->Encode(&encoder);
    }
    summary =
        absl::StrCat("; adding ", md.key(), " (length ", md.transport_size(),
                     "B)", summary.empty() ? "" : " to ", summary);
    if (metadata_buffer_ != nullptr) metadata_buffer_->Clear();
    // StreamId is used as a signal to skip this stream but keep the connection
    // alive
    return input_->MaybeSetErrorAndReturn(
        [this, summary = std::move(summary)] {
          return grpc_error_set_int(
              grpc_error_set_int(
                  GRPC_ERROR_CREATE(absl::StrCat(
                      "received initial metadata size exceeds limit (",
                      *frame_length_, " vs. ", metadata_size_limit_, ")",
                      summary)),
                  StatusIntProperty::kRpcStatus,
                  GRPC_STATUS_RESOURCE_EXHAUSTED),
              StatusIntProperty::kStreamId, 0);
        },
        false);
  }
