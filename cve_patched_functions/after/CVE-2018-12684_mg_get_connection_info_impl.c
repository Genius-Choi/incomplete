mg_get_connection_info_impl(const struct mg_context *ctx,
                            int idx,
                            char *buffer,
                            int buflen)
{
	const struct mg_connection *conn;
	const struct mg_request_info *ri;
	char block[256];
	int connection_info_length = 0;
	int state = 0;
	const char *state_str = "unknown";

#if defined(_WIN32)
	const char *eol = "\r\n";
#else
	const char *eol = "\n";
#endif

	const char *eoobj = "}";
	int reserved_len = (int)strlen(eoobj) + (int)strlen(eol);

	if ((buffer == NULL) || (buflen < 1)) {
		buflen = 0;
	} else {
		*buffer = 0;
	}

	if ((ctx == NULL) || (idx < 0)) {
		/* Parameter error */
		return 0;
	}

	if ((unsigned)idx >= ctx->cfg_worker_threads) {
		/* Out of range */
		return 0;
	}

	/* Take connection [idx]. This connection is not locked in
	 * any way, so some other thread might use it. */
	conn = (ctx->worker_connections) + idx;

	/* Initialize output string */
	mg_snprintf(NULL, NULL, block, sizeof(block), "{%s", eol);
	connection_info_length += (int)strlen(block);
	if (connection_info_length < buflen) {
		strcat0(buffer, block);
	}

	/* Init variables */
	ri = &(conn->request_info);

#if defined(USE_SERVER_STATS)
	state = conn->conn_state;

	/* State as string */
	switch (state) {
	case 0:
		state_str = "undefined";
		break;
	case 1:
		state_str = "not used";
		break;
	case 2:
		state_str = "init";
		break;
	case 3:
		state_str = "ready";
		break;
	case 4:
		state_str = "processing";
		break;
	case 5:
		state_str = "processed";
		break;
	case 6:
		state_str = "to close";
		break;
	case 7:
		state_str = "closing";
		break;
	case 8:
		state_str = "closed";
		break;
	case 9:
		state_str = "done";
		break;
	}
#endif

	/* Connection info */
	if ((state >= 3) && (state < 9)) {
		mg_snprintf(NULL,
		            NULL,
		            block,
		            sizeof(block),
		            "\"connection\" : {%s"
		            "\"remote\" : {%s"
		            "\"protocol\" : \"%s\",%s"
		            "\"addr\" : \"%s\",%s"
		            "\"port\" : %u%s"
		            "},%s"
		            "\"handled_requests\" : %u%s"
		            "},%s",
		            eol,
		            eol,
		            get_proto_name(conn),
		            eol,
		            ri->remote_addr,
		            eol,
		            ri->remote_port,
		            eol,
		            eol,
		            conn->handled_requests,
		            eol,
		            eol);

		connection_info_length += (int)strlen(block);
		if (connection_info_length + reserved_len < buflen) {
			strcat0(buffer, block);
		}
	}

	/* Request info */
	if ((state >= 4) && (state < 6)) {
		mg_snprintf(NULL,
		            NULL,
		            block,
		            sizeof(block),
		            "\"request_info\" : {%s"
		            "\"method\" : \"%s\",%s"
		            "\"uri\" : \"%s\",%s"
		            "\"query\" : %s%s%s%s"
		            "},%s",
		            eol,
		            ri->request_method,
		            eol,
		            ri->request_uri,
		            eol,
		            ri->query_string ? "\"" : "",
		            ri->query_string ? ri->query_string : "null",
		            ri->query_string ? "\"" : "",
		            eol,
		            eol);

		connection_info_length += (int)strlen(block);
		if (connection_info_length + reserved_len < buflen) {
			strcat0(buffer, block);
		}
	}

	/* Execution time information */
	if ((state >= 2) && (state < 9)) {
		char start_time_str[64] = {0};
		char now_str[64] = {0};
		time_t start_time = conn->conn_birth_time;
		time_t now = time(NULL);

		gmt_time_string(start_time_str,
		                sizeof(start_time_str) - 1,
		                &start_time);
		gmt_time_string(now_str, sizeof(now_str) - 1, &now);

		mg_snprintf(NULL,
		            NULL,
		            block,
		            sizeof(block),
		            "\"time\" : {%s"
		            "\"uptime\" : %.0f,%s"
		            "\"start\" : \"%s\",%s"
		            "\"now\" : \"%s\"%s"
		            "},%s",
		            eol,
		            difftime(now, start_time),
		            eol,
		            start_time_str,
		            eol,
		            now_str,
		            eol,
		            eol);

		connection_info_length += (int)strlen(block);
		if (connection_info_length + reserved_len < buflen) {
			strcat0(buffer, block);
		}
	}

	/* Remote user name */
	if ((ri->remote_user) && (state < 9)) {
		mg_snprintf(NULL,
		            NULL,
		            block,
		            sizeof(block),
		            "\"user\" : {%s"
		            "\"name\" : \"%s\",%s"
		            "},%s",
		            eol,
		            ri->remote_user,
		            eol,
		            eol);

		connection_info_length += (int)strlen(block);
		if (connection_info_length + reserved_len < buflen) {
			strcat0(buffer, block);
		}
	}

	/* Data block */
	if (state >= 3) {
		mg_snprintf(NULL,
		            NULL,
		            block,
		            sizeof(block),
		            "\"data\" : {%s"
		            "\"read\" : %" INT64_FMT ",%s"
		            "\"written\" : %" INT64_FMT "%s"
		            "},%s",
		            eol,
		            conn->consumed_content,
		            eol,
		            conn->num_bytes_sent,
		            eol,
		            eol);

		connection_info_length += (int)strlen(block);
		if (connection_info_length + reserved_len < buflen) {
			strcat0(buffer, block);
		}
	}

	/* State */
	mg_snprintf(NULL,
	            NULL,
	            block,
	            sizeof(block),
	            "\"state\" : \"%s\"%s",
	            state_str,
	            eol);

	connection_info_length += (int)strlen(block);
	if (connection_info_length + reserved_len < buflen) {
		strcat0(buffer, block);
	}

	/* Terminate string */
	if ((buflen > 0) && buffer && buffer[0]) {
		if (connection_info_length < buflen) {
			strcat0(buffer, eoobj);
			strcat0(buffer, eol);
		}
	}
	connection_info_length += reserved_len;

	return connection_info_length;
}
