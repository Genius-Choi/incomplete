static void bin_pe_init_rich_info(RBinPEObj *pe) {
	if (!pe->rich_entries) {
		pe->rich_entries = r_list_newf (free);
	}
	pe->rich_header_offset = pe->nt_header_offset;
	ut64 off = pe->nt_header_offset - sizeof (ut32);
	ut32 magic = 0x68636952; // Rich
	if (off % sizeof (ut32)) {
		return;
	}
	while ((r_buf_read_le32_at (pe->b, off) != magic) && off) {
		off -= sizeof (ut32);
	}
	if (!off) {
		return;
	}
	ut32 mask = r_buf_read_le32_at (pe->b, off + sizeof (ut32));
	magic = 0x536E6144; // DanS
	int data;
	off -= sizeof (ut32);
	while (((data = r_buf_read_le32_at (pe->b, off)) != magic) && data ^ mask && off > 0x80) {
		Pe_image_rich_entry *entry = R_NEW0 (Pe_image_rich_entry);
		if (!entry) {
			return;
		}
		entry->timesUsed = data ^ mask;
		off -= sizeof (ut32);
		data = r_buf_read_le32_at (pe->b, off) ^ mask;
		entry->productId = data >> 16;
		entry->minVersion = data & 0xFFFF;
		entry->productName = _known_product_ids (entry->productId);
		off -= sizeof (ut32);
		r_list_append (pe->rich_entries, entry);
	}
	pe->rich_header_offset = off + sizeof (ut32);
}
