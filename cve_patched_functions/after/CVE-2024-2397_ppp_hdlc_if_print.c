ppp_hdlc_if_print(netdissect_options *ndo,
                  const struct pcap_pkthdr *h, const u_char *p)
{
	u_int length = h->len;
	u_int caplen = h->caplen;
	u_int proto;
	u_int hdrlen = 0;

	ndo->ndo_protocol = "ppp_hdlc";
	if (caplen < 2) {
		nd_print_trunc(ndo);
		ndo->ndo_ll_hdr_len += caplen;
		return;
	}

	switch (GET_U_1(p)) {

	case PPP_ADDRESS:
		if (caplen < 4) {
			nd_print_trunc(ndo);
			ndo->ndo_ll_hdr_len += caplen;
			return;
		}

		if (ndo->ndo_eflag)
			ND_PRINT("%02x %02x %u ", GET_U_1(p),
				 GET_U_1(p + 1), length);
		p += 2;
		length -= 2;
		hdrlen += 2;

		proto = GET_BE_U_2(p);
		p += 2;
		length -= 2;
		hdrlen += 2;
		ND_PRINT("%s: ", tok2str(ppptype2str, "unknown PPP protocol (0x%04x)", proto));

		handle_ppp(ndo, proto, p, length);
		break;

	case CHDLC_UNICAST:
	case CHDLC_BCAST:
		chdlc_if_print(ndo, h, p);
		return;

	default:
		if (caplen < 4) {
			nd_print_trunc(ndo);
			ndo->ndo_ll_hdr_len += caplen;
			return;
		}

		if (ndo->ndo_eflag)
			ND_PRINT("%02x %02x %u ", GET_U_1(p),
				 GET_U_1(p + 1), length);
		p += 2;
		hdrlen += 2;

		/*
		 * XXX - NetBSD's "ppp_netbsd_serial_if_print()" treats
		 * the next two octets as an Ethernet type; does that
		 * ever happen?
		 */
		ND_PRINT("unknown addr %02x; ctrl %02x", GET_U_1(p),
			 GET_U_1(p + 1));
		break;
	}

	ndo->ndo_ll_hdr_len += hdrlen;
}
