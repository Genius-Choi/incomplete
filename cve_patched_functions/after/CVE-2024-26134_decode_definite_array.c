decode_definite_array(CBORDecoderObject *self, Py_ssize_t length)
{
    Py_ssize_t i;
    PyObject *array, *item, *ret = NULL;
    if (length > 65536) {
        // Let cPython manage allocation of huge lists by appending
        // items one-by-one
        array = PyList_New(0);
        if (array) {
            ret = array;
            set_shareable(self, array);
            for (i = 0; i < length; ++i) {
                item = decode(self, DECODE_UNSHARED);
                if (item) {
                    if (PyList_Append(array, item) == -1) {
                        ret = NULL;
                        Py_DECREF(item);
                        break;
                    }
                    Py_DECREF(item);
                } else {
                    ret = NULL;
                    break;
                }
            }
            if (ret && self->immutable) {
                ret = PyList_AsTuple(array);
                if (ret) {
                    Py_DECREF(array);
                    // There's a potential here for an indefinite length recursive
                    // array to wind up with a strange representation (the outer
                    // being a tuple, the inners all being a list). However, a
                    // recursive tuple isn't valid in the first place so it's a bit
                    // of a waste of time searching for recursive references just
                    // to throw an error
                    set_shareable(self, ret);
                } else
                    ret = NULL;
            }
            if (!ret)
                Py_DECREF(array);
        }
    } else {
        if (self->immutable) {
            array = PyTuple_New(length);
            if (array) {
                ret = array;
                for (i = 0; i < length; ++i) {
                    item = decode(self, DECODE_UNSHARED);
                    if (item)
                        PyTuple_SET_ITEM(array, i, item);
                    else {
                        ret = NULL;
                        break;
                    }
                }
            }
            // This is done *after* the construction of the tuple because while
            // it's valid for a tuple object to be shared, it's not valid for it to
            // contain a reference to itself (because a reference to it can't exist
            // during its own construction ... in Python at least; as can be seen
            // above this *is* theoretically possible at the C level).
            set_shareable(self, ret);
        } else {
            array = PyList_New(length);
            if (array) {
                ret = array;
                set_shareable(self, array);
                for (i = 0; i < length; ++i) {
                    item = decode(self, DECODE_UNSHARED);
                    if (item)
                        PyList_SET_ITEM(array, i, item);
                    else {
                        ret = NULL;
                        break;
                    }
                }
            }
        }
        if (!ret)
            Py_DECREF(array);
    }
    return ret;
}
