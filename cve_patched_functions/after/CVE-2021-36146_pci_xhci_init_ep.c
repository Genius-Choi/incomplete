pci_xhci_init_ep(struct pci_xhci_dev_emu *dev, int epid, uint32_t slot)
{
	struct xhci_dev_ctx	*dev_ctx;
	struct pci_xhci_dev_ep	*devep;
	struct xhci_endp_ctx	*ep_ctx;
	pthread_mutexattr_t	attr;
	uint32_t		pstreams;
	int			i, rc;

	dev_ctx = dev->dev_ctx;
	ep_ctx = &dev_ctx->ctx_ep[epid];
	devep = &dev->eps[epid];

	rc = pthread_mutexattr_init(&attr);
	if (rc) {
		UPRINTF(LFTL, "%s: mutexattr init failed %d\r\n", __func__, rc);
		return -1;
	}

	rc = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
	if (rc) {
		UPRINTF(LFTL, "%s: mutexattr set failed %d\r\n", __func__, rc);
		return -1;
	}

	rc = pthread_mutex_init(&devep->mtx, &attr);
	if (rc) {
		UPRINTF(LFTL, "%s: mutexlock init failed %d\r\n", __func__, rc);
		return -1;
	}

	pstreams = XHCI_EPCTX_0_MAXP_STREAMS_GET(ep_ctx->dwEpCtx0);
	if (pstreams > 0) {
		UPRINTF(LDBG, "init_ep %d with pstreams %d\r\n",
				epid, pstreams);

		devep->ep_sctx = XHCI_GADDR(dev->xdev, ep_ctx->qwEpCtx2 &
					    XHCI_EPCTX_2_TR_DQ_PTR_MASK);
		devep->ep_sctx_trbs = calloc(pstreams,
				      sizeof(struct pci_xhci_trb_ring));
		for (i = 0; i < pstreams; i++) {
			devep->ep_sctx_trbs[i].ringaddr =
						 devep->ep_sctx[i].qwSctx0 &
						 XHCI_SCTX_0_TR_DQ_PTR_MASK;
			devep->ep_sctx_trbs[i].ccs =
			     XHCI_SCTX_0_DCS_GET(devep->ep_sctx[i].qwSctx0);
		}
	} else {
		UPRINTF(LDBG, "init_ep %d with no pstreams\r\n", epid);
		devep->ep_ringaddr = ep_ctx->qwEpCtx2 &
				     XHCI_EPCTX_2_TR_DQ_PTR_MASK;
		devep->ep_ccs = XHCI_EPCTX_2_DCS_GET(ep_ctx->qwEpCtx2);
		devep->ep_tr = XHCI_GADDR(dev->xdev, devep->ep_ringaddr);
		UPRINTF(LDBG, "init_ep tr DCS %x\r\n", devep->ep_ccs);
	}

	if (devep->ep_xfer == NULL) {
		devep->ep_xfer = pci_xhci_alloc_usb_xfer(dev, epid);
		if (!devep->ep_xfer)
			goto errout;
	}

	devep->timer_data.dev = dev;
	devep->timer_data.slot = slot;
	devep->timer_data.epnum = epid;
	devep->timer_data.dir = (epid & 0x1) ? TOKEN_IN : TOKEN_OUT;
	devep->isoc_timer.clockid = CLOCK_MONOTONIC;
	rc = acrn_timer_init(&devep->isoc_timer, pci_xhci_isoc_handler,
			&devep->timer_data);
	if (rc < 0) {
		UPRINTF(LFTL, "ep%d: failed to create isoc timer\r\n", epid);
		goto errout;
	}

	return 0;

errout:
	pci_xhci_free_usb_xfer(devep->ep_xfer);
	devep->ep_xfer = NULL;
	devep->timer_data.dev = NULL;
	devep->timer_data.slot = 0;
	devep->timer_data.epnum = 0;
	pthread_mutex_destroy(&devep->mtx);
	return -1;
}
