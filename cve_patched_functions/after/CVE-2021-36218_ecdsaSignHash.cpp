vector <string> ecdsaSignHash(const std::string& encryptedKeyHex, const char *hashHex, int base) {

    CHECK_STATE(hashHex);

    vector <string> signatureVector(3);

    vector<char> errMsg(BUF_LEN, 0);
    int errStatus = 0;
    vector<char> signatureR(BUF_LEN, 0);
    vector<char> signatureS(BUF_LEN, 0);
    vector<uint8_t> encryptedKey(BUF_LEN, 0);
    uint8_t signatureV = 0;
    uint64_t decLen = 0;

    string pubKeyStr = "";

    if (!hex2carray(encryptedKeyHex.c_str(), &decLen, encryptedKey.data(),
                    BUF_LEN)) {
        throw SGXException(INVALID_HEX, "Invalid encryptedKeyHex");
    }

    sgx_status_t status = trustedEcdsaSignAES(eid, &errStatus,
            errMsg.data(), encryptedKey.data(), decLen, hashHex,
                                 signatureR.data(),
                                 signatureS.data(), &signatureV, base);

    HANDLE_TRUSTED_FUNCTION_ERROR(status, errStatus, errMsg.data());


    signatureVector.at(0) = to_string(signatureV);

    if (base == 16) {
        signatureVector.at(1) = "0x" + string(signatureR.data());
        signatureVector.at(2) = "0x" + string(signatureS.data());
    } else {
        signatureVector.at(1) = string(signatureR.data());
        signatureVector.at(2) = string(signatureS.data());
    }

    /* Now verify signature */

    pubKeyStr = getECDSAPubKey(encryptedKeyHex);

    static uint64_t  i = 0;

    i++;

    if (i % 1000 == 0) {

        if (!verifyECDSASig(pubKeyStr, hashHex, signatureR.data(), signatureS.data(), base)) {
            spdlog::error("failed to verify ecdsa signature");
            throw SGXException(667, "ECDSA did not verify");
        }
    }

    return signatureVector;
}
