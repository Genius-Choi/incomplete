DltReturnValue dlt_file_read_header_raw(DltFile *file, int resync, int verbose)
{
    char dltSerialHeaderBuffer[DLT_ID_SIZE];

    PRINT_FUNCTION_VERBOSE(verbose);

    if (file == NULL)
        return DLT_RETURN_WRONG_PARAMETER;

    /* check if serial header exists, ignore if found */
    if (fread(dltSerialHeaderBuffer, sizeof(dltSerialHeaderBuffer), 1, file->handle) != 1) {
        /* cannot read serial header, not enough data available in file */
        if (!feof(file->handle))
            dlt_log(LOG_WARNING, "Cannot read header from file!\n");

        return DLT_RETURN_ERROR;
    }

    if (memcmp(dltSerialHeaderBuffer, dltSerialHeader, sizeof(dltSerialHeader)) == 0) {
        /* serial header found */
        /* nothing to do continue reading */

    }
    else {
        /* serial header not found */
        if (resync) {
            /* increase error counter */
            file->error_messages++;

            /* resync to serial header */
            do {
                memmove(dltSerialHeaderBuffer, dltSerialHeaderBuffer + 1, sizeof(dltSerialHeader) - 1);

                if (fread(dltSerialHeaderBuffer + 3, 1, 1, file->handle) != 1)
                    /* cannot read any data, perhaps end of file reached */
                    return DLT_RETURN_ERROR;

                if (memcmp(dltSerialHeaderBuffer, dltSerialHeader, sizeof(dltSerialHeader)) == 0)
                    /* serial header synchronised */
                    break;
            } while (1);
        }
        else
        /* go back to last file position */
        if (0 != fseek(file->handle, file->file_position, SEEK_SET))
        {
            return DLT_RETURN_ERROR;
        }
    }

    /* load header from file */
    if (fread(file->msg.headerbuffer + sizeof(DltStorageHeader), sizeof(DltStandardHeader), 1, file->handle) != 1) {
        if (!feof(file->handle))
            dlt_log(LOG_WARNING, "Cannot read header from file!\n");

        return DLT_RETURN_ERROR;
    }

    /* set ptrs to structures */
    file->msg.storageheader = (DltStorageHeader *)file->msg.headerbuffer; /* this points now to a empty storage header (filled with '0') */
    file->msg.standardheader = (DltStandardHeader *)(file->msg.headerbuffer + sizeof(DltStorageHeader));

    /* Skip storage header field, fill this field with '0' */
    memset(file->msg.storageheader, 0, sizeof(DltStorageHeader));

    /* Set storage header */
    dlt_set_storageheader(file->msg.storageheader, DLT_COMMON_DUMMY_ECUID);

    /* no check for storage header id*/

    /* calculate complete size of headers */
    file->msg.headersize = (uint32_t) (sizeof(DltStorageHeader) + sizeof(DltStandardHeader) +
        DLT_STANDARD_HEADER_EXTRA_SIZE(file->msg.standardheader->htyp) +
        (DLT_IS_HTYP_UEH(file->msg.standardheader->htyp) ? sizeof(DltExtendedHeader) : 0));

    /* calculate complete size of payload */
    int32_t temp_datasize;
    temp_datasize = DLT_BETOH_16(file->msg.standardheader->len) + (int32_t) sizeof(DltStorageHeader) - (int32_t) file->msg.headersize;

    /* check data size */
    if (temp_datasize < 0) {
        dlt_vlog(LOG_WARNING,
                 "Plausibility check failed. Complete message size too short! (%d)\n",
                 temp_datasize);
        return DLT_RETURN_ERROR;
    }
    else {
        file->msg.datasize = (uint32_t) temp_datasize;
    }

    /* check if verbose mode is on */
    if (verbose) {
        dlt_vlog(LOG_DEBUG, "HeaderSize=%u, DataSize=%u\n",
                 file->msg.headersize, file->msg.datasize);
    }

    return DLT_RETURN_OK;
}
