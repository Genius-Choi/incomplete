decode_flowspec_nlri(proto_tree *tree, tvbuff_t *tvb, gint offset, guint16 afi, guint8 safi, packet_info *pinfo)
{
    guint     tot_flow_len;       /* total length of the flow spec NLRI */
    guint     offset_len;         /* offset of the flow spec NLRI itself could be 1 or 2 bytes */
    guint     cursor_fspec;       /* cursor to move into flow spec nlri */
    gint      filter_len = -1;
    guint16   len_16;
    guint32   rd_type;
    proto_item *item;
    proto_item *filter_item;
    proto_item *disting_item;
    proto_tree *nlri_tree;
    proto_tree *disting_tree;
    proto_tree *filter_tree;


    if (afi != AFNUM_INET && afi != AFNUM_INET6)
    {
        expert_add_info(pinfo, NULL, &ei_bgp_afi_type_not_supported);
        return(-1);
    }

    tot_flow_len = tvb_get_guint8(tvb, offset);
    /* if nlri length is greater than 240 bytes, it is encoded over 2 bytes */
    /* with most significant nibble all in one. 240 is encoded 0xf0f0, 241 0xf0f1 */
    /* max possible value value is 4095 Oxffff */

    if (tot_flow_len >= 240)
    {
        len_16 = tvb_get_ntohs(tvb, offset);
        tot_flow_len = len_16 & 0x0FFF; /* remove most significant nibble */
        offset_len = 2;
    } else {
        offset_len = 1;
    }

    item = proto_tree_add_item(tree, hf_bgp_flowspec_nlri_t, tvb, offset,
                               tot_flow_len+offset_len, ENC_NA);
    proto_item_set_text(item, "FLOW_SPEC_NLRI (%u byte%s)",
                        tot_flow_len+offset_len, plurality(tot_flow_len+offset_len, "", "s"));

    nlri_tree = proto_item_add_subtree(item, ett_bgp_flow_spec_nlri);

    proto_tree_add_uint(nlri_tree, hf_bgp_flowspec_nlri_length, tvb, offset,
                        offset_len, tot_flow_len);

    offset = offset + offset_len;
    cursor_fspec = 0;

    /* when SAFI is VPN Flow Spec, then write route distinguisher */
    if (safi == SAFNUM_FSPEC_VPN_RULE)
    {
        disting_item = proto_tree_add_item(nlri_tree, hf_bgp_flowspec_nlri_route_distinguisher,
                                           tvb, offset, BGP_ROUTE_DISTINGUISHER_SIZE, ENC_NA);
        disting_tree = proto_item_add_subtree(disting_item, ett_bgp_flow_spec_nlri);
        proto_tree_add_item_ret_uint(disting_tree, hf_bgp_flowspec_nlri_route_distinguisher_type,
                                     tvb, offset, 2, ENC_BIG_ENDIAN, &rd_type);
        /* Route Distinguisher Type */
        switch (rd_type) {
        case FORMAT_AS2_LOC:
            proto_tree_add_item(disting_tree, hf_bgp_flowspec_nlri_route_dist_admin_asnum_2,
                                tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(disting_tree, hf_bgp_flowspec_nlri_route_dist_asnum_4,
                                tvb, offset + 4, 4, ENC_BIG_ENDIAN);
            break;

        case FORMAT_IP_LOC:
            proto_tree_add_item(disting_tree, hf_bgp_flowspec_nlri_route_dist_admin_ipv4,
                                tvb, offset + 2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(disting_tree, hf_bgp_flowspec_nlri_route_dist_asnum_2,
                                tvb, offset + 6, 2, ENC_BIG_ENDIAN);
            break;

        case FORMAT_AS4_LOC:
            proto_tree_add_item(disting_tree, hf_bgp_flowspec_nlri_route_dist_admin_asnum_4,
                                tvb, offset + 2, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(disting_tree, hf_bgp_flowspec_nlri_route_dist_asnum_2,
                                tvb, offset + 6, 2, ENC_BIG_ENDIAN);
            break;

        default:
            expert_add_info_format(pinfo, disting_tree, &ei_bgp_length_invalid,
                                   "Unknown Route Distinguisher type (%u)", rd_type);
        }
        cursor_fspec += BGP_ROUTE_DISTINGUISHER_SIZE;
    }

    while (cursor_fspec < tot_flow_len)
    {
        filter_item = proto_tree_add_item(nlri_tree, hf_bgp_flowspec_nlri_filter, tvb, offset+cursor_fspec, 1, ENC_NA);
        filter_tree = proto_item_add_subtree(filter_item, ett_bgp_flow_spec_nlri_filter);
        proto_tree_add_item(filter_tree, hf_bgp_flowspec_nlri_filter_type, tvb, offset+cursor_fspec, 1, ENC_BIG_ENDIAN);
        proto_item_append_text(filter_item, ": %s", val_to_str(tvb_get_guint8(tvb,offset+cursor_fspec), flowspec_nlri_opvaluepair_type, "Unknown filter %d"));
        switch (tvb_get_guint8(tvb,offset+cursor_fspec)) {
        case BGPNLRI_FSPEC_DST_PFIX:
            cursor_fspec++;
            if (afi == AFNUM_INET)
                filter_len = decode_prefix4(filter_tree, pinfo, filter_item, hf_bgp_flowspec_nlri_dst_pref_ipv4,
                                            tvb, offset+cursor_fspec, "Destination IP filter");
            else /* AFNUM_INET6 */
                filter_len = decode_fspec_match_prefix6(filter_tree, filter_item, hf_bgp_flowspec_nlri_dst_ipv6_pref,
                                                        tvb, offset+cursor_fspec, 0, pinfo);
            if (filter_len == -1)
                cursor_fspec= tot_flow_len;
            break;
        case BGPNLRI_FSPEC_SRC_PFIX:
            cursor_fspec++;
            if (afi == AFNUM_INET)
                filter_len = decode_prefix4(filter_tree, pinfo, filter_item, hf_bgp_flowspec_nlri_src_pref_ipv4,
                                            tvb, offset+cursor_fspec, "Source IP filter");
            else /* AFNUM_INET6 */
                filter_len = decode_fspec_match_prefix6(filter_tree, filter_item, hf_bgp_flowspec_nlri_src_ipv6_pref,
                                                        tvb, offset+cursor_fspec, 0, pinfo);
            if (filter_len == -1)
              cursor_fspec= tot_flow_len;
            break;
        case BGPNLRI_FSPEC_IP_PROTO:
            cursor_fspec++;
            filter_len = decode_bgp_nlri_op_dec_value(filter_tree, filter_item, tvb, offset+cursor_fspec);
            break;
        case BGPNLRI_FSPEC_PORT:
            cursor_fspec++;
            filter_len = decode_bgp_nlri_op_dec_value(filter_tree, filter_item, tvb, offset+cursor_fspec);
            break;
        case BGPNLRI_FSPEC_DST_PORT:
            cursor_fspec++;
            filter_len = decode_bgp_nlri_op_dec_value(filter_tree, filter_item, tvb, offset+cursor_fspec);
            break;
        case BGPNLRI_FSPEC_SRC_PORT:
            cursor_fspec++;
            filter_len = decode_bgp_nlri_op_dec_value(filter_tree, filter_item, tvb, offset+cursor_fspec);
            break;
        case BGPNLRI_FSPEC_ICMP_TP:
            cursor_fspec++;
            filter_len = decode_bgp_nlri_op_dec_value(filter_tree, filter_item, tvb, offset+cursor_fspec);
            break;
        case BGPNLRI_FSPEC_ICMP_CD:
            cursor_fspec++;
            filter_len = decode_bgp_nlri_op_dec_value(filter_tree, filter_item, tvb, offset+cursor_fspec);
            break;
        case BGPNLRI_FSPEC_TCP_FLAGS:
            cursor_fspec++;
            filter_len = decode_bgp_nlri_op_tcpf_value(filter_tree, filter_item, tvb, offset+cursor_fspec);
            break;
        case BGPNLRI_FSPEC_PCK_LEN:
            cursor_fspec++;
            filter_len = decode_bgp_nlri_op_dec_value(filter_tree, filter_item, tvb, offset+cursor_fspec);
            break;
        case BGPNLRI_FSPEC_DSCP:
            cursor_fspec++;
            filter_len = decode_bgp_nlri_op_dscp_value(filter_tree, filter_item, tvb, offset+cursor_fspec);
            break;
        case BGPNLRI_FSPEC_FRAGMENT:
            cursor_fspec++;
            filter_len = decode_bgp_nlri_op_fflag_value(filter_tree, filter_item, tvb, offset+cursor_fspec);
            break;
        default:
            return -1;
      }
      if (filter_len>0)
          cursor_fspec += filter_len;
      else
          break;
      proto_item_set_len(filter_item,filter_len+1);
    }
    return(tot_flow_len+offset_len-1);
}
