SWITCH_DECLARE(void) switch_rtp_set_flag(switch_rtp_t *rtp_session, switch_rtp_flag_t flag)
{
	int old_flag = rtp_session->flags[flag];

	switch_mutex_lock(rtp_session->flag_mutex);
	rtp_session->flags[flag] = 1;
	switch_mutex_unlock(rtp_session->flag_mutex);

	if (flag == SWITCH_RTP_FLAG_PASSTHRU) {
		if (!old_flag) {
			switch_rtp_pause_jitter_buffer(rtp_session, SWITCH_TRUE);
		}
	} else if (flag == SWITCH_RTP_FLAG_DTMF_ON) {
		rtp_session->stats.inbound.last_processed_seq = 0;
	} else if (flag == SWITCH_RTP_FLAG_FLUSH) {
		reset_jitter_seq(rtp_session);
	} else if (flag == SWITCH_RTP_FLAG_AUTOADJ) {
		rtp_session->autoadj_window = 20;
		rtp_session->autoadj_threshold = 10;
		rtp_session->autoadj_tally = 0;

		switch_mutex_lock(rtp_session->flag_mutex);
		rtp_session->flags[SWITCH_RTP_FLAG_RTCP_AUTOADJ] = 1;
		switch_mutex_unlock(rtp_session->flag_mutex);

		rtp_session->rtcp_autoadj_window = 20;
		rtp_session->rtcp_autoadj_threshold = 1;
		rtp_session->rtcp_autoadj_tally = 0;

		if (rtp_session->session) {
			switch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);
			const char *x = switch_channel_get_variable(channel, "rtp_auto_adjust_threshold");
			if (x && *x) {
				int xn = atoi(x);
				if (xn > 0 && xn <= 65535) {
					rtp_session->autoadj_window = xn*2;
					rtp_session->autoadj_threshold = xn;
				}
			}
		}


		rtp_flush_read_buffer(rtp_session, SWITCH_RTP_FLUSH_ONCE);


		if (rtp_session->jb) {
			switch_jb_reset(rtp_session->jb);
		}
	} else if (flag == SWITCH_RTP_FLAG_NOBLOCK && rtp_session->sock_input) {
		switch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, TRUE);
	}

}
