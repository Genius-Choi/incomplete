display_selected_modifiers(BOOL for_pattern, const char *title)
{
uint32_t i, j;
uint32_t n = 0;
uint32_t list[MODLISTCOUNT];
uint32_t extra[MODLISTCOUNT];

for (i = 0; i < MODLISTCOUNT; i++)
  {
  BOOL is_pattern = TRUE;
  modstruct *m = modlist + i;

  switch (m->which)
    {
    case MOD_CTC:       /* Compile context */
    case MOD_PAT:       /* Pattern */
    case MOD_PATP:      /* Pattern, OK for Perl-compatible test */
    break;

    /* The MOD_PND and MOD_PNDP modifiers are precisely those that affect
    subjects, but can be given with a pattern. We list them as subject
    modifiers, but marked with an asterisk.*/

    case MOD_CTM:       /* Match context */
    case MOD_DAT:       /* Subject line */
    case MOD_DATP:      /* Subject line, OK for Perl-compatible test */
    case MOD_PND:       /* As PD, but not default pattern */
    case MOD_PNDP:      /* As PND, OK for Perl-compatible test */
    is_pattern = FALSE;
    break;

    default: printf("** Unknown type for modifier '%s'\n", m->name);
    /* Fall through */
    case MOD_PD:        /* Pattern or subject */
    case MOD_PDP:       /* As PD, OK for Perl-compatible test */
    is_pattern = for_pattern;
    break;
    }

  if (for_pattern == is_pattern)
    {
    extra[n] = 0;
    for (size_t k = 0; k < C1MODLISTCOUNT; k++)
      {
      if (strcmp(m->name, c1modlist[k].fullname) == 0)
        {
        extra[n] += 4;
        break;
        }
      }
    list[n++] = i;
    }
  }

/* Now print from the list in two columns. */

printf("-------------- %s MODIFIERS --------------\n", title);

for (i = 0, j = (n+1)/2; i < (n+1)/2; i++, j++)
  {
  modstruct *m = modlist + list[i];
  display_one_modifier(m, for_pattern);
  if (j < n)
    {
    uint32_t k = 27 - strlen(m->name) - extra[i];
    while (k-- > 0) printf(" ");
    display_one_modifier(modlist + list[j], for_pattern);
    }
  printf("\n");
  }
}
