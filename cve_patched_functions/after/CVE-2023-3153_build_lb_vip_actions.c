build_lb_vip_actions(struct ovn_lb_vip *lb_vip,
                     struct ovn_northd_lb_vip *lb_vip_nb,
                     struct ds *action, char *selection_fields,
                     struct ds *skip_snat_action, struct ds *force_snat_action,
                     bool ls_dp, const struct chassis_features *features)
{
    const char *ct_lb_action =
        features->ct_no_masked_label ? "ct_lb_mark" : "ct_lb";
    bool reject = !lb_vip->n_backends && lb_vip->empty_backend_rej;
    bool drop = !lb_vip->n_backends && !lb_vip->empty_backend_rej;

    if (lb_vip_nb->lb_health_check) {
        ds_put_format(action, "%s(backends=", ct_lb_action);

        size_t n_active_backends = 0;
        for (size_t i = 0; i < lb_vip->n_backends; i++) {
            struct ovn_lb_backend *backend = &lb_vip->backends[i];
            struct ovn_northd_lb_backend *backend_nb =
                &lb_vip_nb->backends_nb[i];
            if (!backend_nb->health_check ||
                (backend_nb->health_check && backend_nb->sbrec_monitor &&
                 backend_nb->sbrec_monitor->status &&
                 strcmp(backend_nb->sbrec_monitor->status, "online"))) {
                continue;
            }

            n_active_backends++;
            bool ipv6 = !IN6_IS_ADDR_V4MAPPED(&backend->ip);
            ds_put_format(action, ipv6 ? "[%s]:%"PRIu16"," : "%s:%"PRIu16",",
                          backend->ip_str, backend->port);
        }
        ds_chomp(action, ',');

        drop = !n_active_backends && !lb_vip->empty_backend_rej;
        reject = !n_active_backends && lb_vip->empty_backend_rej;
    } else {
        ds_put_format(action, "%s(backends=%s", ct_lb_action,
                      lb_vip_nb->backend_ips);
    }

    if (reject) {
        int stage = ls_dp ? ovn_stage_get_table(S_SWITCH_OUT_QOS_MARK)
                          : ovn_stage_get_table(S_ROUTER_OUT_SNAT);
        ds_clear(action);
        ds_put_format(action, "reg0 = 0; reject { outport <-> inport; "
                              "next(pipeline=egress,table=%d);};", stage);
    } else if (drop) {
        ds_clear(action);
        ds_put_cstr(action, debug_drop_action());
    } else if (selection_fields && selection_fields[0]) {
        ds_put_format(action, "; hash_fields=\"%s\"", selection_fields);
    }

    bool is_lb_action = !(reject || drop);
    const char *enclose = is_lb_action ? ");" : "";

    if (!ls_dp) {
        bool flag_supported = is_lb_action && features->ct_lb_related;
        ds_put_format(skip_snat_action, "flags.skip_snat_for_lb = 1; %s%s",
                      ds_cstr(action),
                      flag_supported ? "; skip_snat);" : enclose);
        ds_put_format(force_snat_action, "flags.force_snat_for_lb = 1; %s%s",
                      ds_cstr(action),
                      flag_supported ? "; force_snat);" : enclose);
    }

    ds_put_cstr(action, enclose);

    return reject;
}
