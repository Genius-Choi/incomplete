static int encode_without_recode_loop(VP9_COMP *cpi, size_t *size,
                                      uint8_t *dest) {
  VP9_COMMON *const cm = &cpi->common;
  SVC *const svc = &cpi->svc;
  int q = 0, bottom_index = 0, top_index = 0;
  int no_drop_scene_change = 0;
  const INTERP_FILTER filter_scaler =
      (is_one_pass_svc(cpi))
          ? svc->downsample_filter_type[svc->spatial_layer_id]
          : EIGHTTAP;
  const int phase_scaler =
      (is_one_pass_svc(cpi))
          ? svc->downsample_filter_phase[svc->spatial_layer_id]
          : 0;

  if (cm->show_existing_frame) {
    cpi->rc.this_frame_target = 0;
    if (is_psnr_calc_enabled(cpi)) set_raw_source_frame(cpi);
    return 1;
  }

  svc->time_stamp_prev[svc->spatial_layer_id] = svc->time_stamp_superframe;

  // Flag to check if its valid to compute the source sad (used for
  // scene detection and for superblock content state in CBR mode).
  // The flag may get reset below based on SVC or resizing state.
  cpi->compute_source_sad_onepass = cpi->oxcf.mode == REALTIME;

  vpx_clear_system_state();

  set_frame_size(cpi);

  if (is_one_pass_svc(cpi) &&
      cpi->un_scaled_source->y_width == cm->width << 2 &&
      cpi->un_scaled_source->y_height == cm->height << 2 &&
      svc->scaled_temp.y_width == cm->width << 1 &&
      svc->scaled_temp.y_height == cm->height << 1) {
    // For svc, if it is a 1/4x1/4 downscaling, do a two-stage scaling to take
    // advantage of the 1:2 optimized scaler. In the process, the 1/2x1/2
    // result will be saved in scaled_temp and might be used later.
    const INTERP_FILTER filter_scaler2 = svc->downsample_filter_type[1];
    const int phase_scaler2 = svc->downsample_filter_phase[1];
    cpi->Source = vp9_svc_twostage_scale(
        cm, cpi->un_scaled_source, &cpi->scaled_source, &svc->scaled_temp,
        filter_scaler, phase_scaler, filter_scaler2, phase_scaler2);
    svc->scaled_one_half = 1;
  } else if (is_one_pass_svc(cpi) &&
             cpi->un_scaled_source->y_width == cm->width << 1 &&
             cpi->un_scaled_source->y_height == cm->height << 1 &&
             svc->scaled_one_half) {
    // If the spatial layer is 1/2x1/2 and the scaling is already done in the
    // two-stage scaling, use the result directly.
    cpi->Source = &svc->scaled_temp;
    svc->scaled_one_half = 0;
  } else {
    cpi->Source = vp9_scale_if_required(
        cm, cpi->un_scaled_source, &cpi->scaled_source, (cpi->oxcf.pass == 0),
        filter_scaler, phase_scaler);
  }
#ifdef OUTPUT_YUV_SVC_SRC
  // Write out at most 3 spatial layers.
  if (is_one_pass_svc(cpi) && svc->spatial_layer_id < 3) {
    vpx_write_yuv_frame(yuv_svc_src[svc->spatial_layer_id], cpi->Source);
  }
#endif
  // Unfiltered raw source used in metrics calculation if the source
  // has been filtered.
  if (is_psnr_calc_enabled(cpi)) {
#ifdef ENABLE_KF_DENOISE
    if (is_spatial_denoise_enabled(cpi)) {
      cpi->raw_source_frame = vp9_scale_if_required(
          cm, &cpi->raw_unscaled_source, &cpi->raw_scaled_source,
          (cpi->oxcf.pass == 0), EIGHTTAP, phase_scaler);
    } else {
      cpi->raw_source_frame = cpi->Source;
    }
#else
    cpi->raw_source_frame = cpi->Source;
#endif
  }

  if ((cpi->use_svc &&
       (svc->spatial_layer_id < svc->number_spatial_layers - 1 ||
        svc->temporal_layer_id < svc->number_temporal_layers - 1 ||
        svc->current_superframe < 1)) ||
      cpi->resize_pending || cpi->resize_state || cpi->external_resize ||
      cpi->resize_state != ORIG) {
    cpi->compute_source_sad_onepass = 0;
    if (cpi->content_state_sb_fd != NULL)
      memset(cpi->content_state_sb_fd, 0,
             (cm->mi_stride >> 3) * ((cm->mi_rows >> 3) + 1) *
                 sizeof(*cpi->content_state_sb_fd));
  }

  // Avoid scaling last_source unless its needed.
  // Last source is needed if avg_source_sad() is used, or if
  // partition_search_type == SOURCE_VAR_BASED_PARTITION, or if noise
  // estimation is enabled.
  if (cpi->unscaled_last_source != NULL &&
      (cpi->oxcf.content == VP9E_CONTENT_SCREEN ||
       (cpi->oxcf.pass == 0 && cpi->oxcf.rc_mode == VPX_VBR &&
        cpi->oxcf.mode == REALTIME && cpi->oxcf.speed >= 5) ||
       cpi->sf.partition_search_type == SOURCE_VAR_BASED_PARTITION ||
       (cpi->noise_estimate.enabled && !cpi->oxcf.noise_sensitivity) ||
       cpi->compute_source_sad_onepass))
    cpi->Last_Source = vp9_scale_if_required(
        cm, cpi->unscaled_last_source, &cpi->scaled_last_source,
        (cpi->oxcf.pass == 0), EIGHTTAP, 0);

  if (cpi->Last_Source == NULL ||
      cpi->Last_Source->y_width != cpi->Source->y_width ||
      cpi->Last_Source->y_height != cpi->Source->y_height)
    cpi->compute_source_sad_onepass = 0;

  if (frame_is_intra_only(cm) || cpi->resize_pending != 0) {
    memset(cpi->consec_zero_mv, 0,
           cm->mi_rows * cm->mi_cols * sizeof(*cpi->consec_zero_mv));
  }

#if CONFIG_VP9_TEMPORAL_DENOISING
  if (cpi->oxcf.noise_sensitivity > 0 && cpi->use_svc)
    vp9_denoiser_reset_on_first_frame(cpi);
#endif

  // Scene detection is always used for VBR mode or screen-content case.
  // For other cases (e.g., CBR mode) use it for 5 <= speed < 8 for now
  // (need to check encoding time cost for doing this for speed 8).
  cpi->rc.high_source_sad = 0;
  cpi->rc.hybrid_intra_scene_change = 0;
  cpi->rc.re_encode_maxq_scene_change = 0;
  if (cm->show_frame && cpi->oxcf.mode == REALTIME &&
      (cpi->oxcf.rc_mode == VPX_VBR ||
       cpi->oxcf.content == VP9E_CONTENT_SCREEN ||
       (cpi->oxcf.speed >= 5 && cpi->oxcf.speed < 8)))
    vp9_scene_detection_onepass(cpi);

  if (svc->spatial_layer_id == svc->first_spatial_layer_to_encode) {
    svc->high_source_sad_superframe = cpi->rc.high_source_sad;
    svc->high_num_blocks_with_motion = cpi->rc.high_num_blocks_with_motion;
    // On scene change reset temporal layer pattern to TL0.
    // Note that if the base/lower spatial layers are skipped: instead of
    // inserting base layer here, we force max-q for the next superframe
    // with lower spatial layers: this is done in vp9_encodedframe_overshoot()
    // when max-q is decided for the current layer.
    // Only do this reset for bypass/flexible mode.
    if (svc->high_source_sad_superframe && svc->temporal_layer_id > 0 &&
        svc->temporal_layering_mode == VP9E_TEMPORAL_LAYERING_MODE_BYPASS) {
      // rc->high_source_sad will get reset so copy it to restore it.
      int tmp_high_source_sad = cpi->rc.high_source_sad;
      vp9_svc_reset_temporal_layers(cpi, cm->frame_type == KEY_FRAME);
      cpi->rc.high_source_sad = tmp_high_source_sad;
    }
  }

  vp9_update_noise_estimate(cpi);

  // For 1 pass CBR, check if we are dropping this frame.
  // Never drop on key frame, if base layer is key for svc,
  // on scene change, or if superframe has layer sync.
  if ((cpi->rc.high_source_sad || svc->high_source_sad_superframe) &&
      !(cpi->rc.use_post_encode_drop && svc->last_layer_dropped[0]))
    no_drop_scene_change = 1;
  if (cpi->oxcf.pass == 0 && cpi->oxcf.rc_mode == VPX_CBR &&
      !frame_is_intra_only(cm) && !no_drop_scene_change &&
      !svc->superframe_has_layer_sync &&
      (!cpi->use_svc ||
       !svc->layer_context[svc->temporal_layer_id].is_key_frame)) {
    if (vp9_rc_drop_frame(cpi)) return 0;
  }

  // For 1 pass SVC, only ZEROMV is allowed for spatial reference frame
  // when svc->force_zero_mode_spatial_ref = 1. Under those conditions we can
  // avoid this frame-level upsampling (for non intra_only frames).
  // For SVC single_layer mode, dynamic resize is allowed and we need to
  // scale references for this case.
  if (frame_is_intra_only(cm) == 0 &&
      ((svc->single_layer_svc && cpi->oxcf.resize_mode == RESIZE_DYNAMIC) ||
       !(is_one_pass_svc(cpi) && svc->force_zero_mode_spatial_ref))) {
    vp9_scale_references(cpi);
  }

  set_size_independent_vars(cpi);
  set_size_dependent_vars(cpi, &q, &bottom_index, &top_index);

  // search method and step parameter might be changed in speed settings.
  init_motion_estimation(cpi);

  if (cpi->sf.copy_partition_flag) alloc_copy_partition_data(cpi);

  if (cpi->sf.svc_use_lowres_part &&
      svc->spatial_layer_id == svc->number_spatial_layers - 2) {
    if (svc->prev_partition_svc == NULL) {
      CHECK_MEM_ERROR(
          &cm->error, svc->prev_partition_svc,
          (BLOCK_SIZE *)vpx_calloc(cm->mi_stride * cm->mi_rows,
                                   sizeof(*svc->prev_partition_svc)));
    }
  }

  // TODO(jianj): Look into issue of skin detection with high bitdepth.
  if (cm->bit_depth == 8 && cpi->oxcf.speed >= 5 && cpi->oxcf.pass == 0 &&
      cpi->oxcf.rc_mode == VPX_CBR &&
      cpi->oxcf.content != VP9E_CONTENT_SCREEN &&
      cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ) {
    cpi->use_skin_detection = 1;
  }

  // Enable post encode frame dropping for CBR on non key frame, when
  // ext_use_post_encode_drop is specified by user.
  cpi->rc.use_post_encode_drop = cpi->rc.ext_use_post_encode_drop &&
                                 cpi->oxcf.rc_mode == VPX_CBR &&
                                 cm->frame_type != KEY_FRAME;

  vp9_set_quantizer(cpi, q);
  vp9_set_variance_partition_thresholds(cpi, q, 0);

  setup_frame(cpi);

  suppress_active_map(cpi);

  if (cpi->use_svc) {
    // On non-zero spatial layer, check for disabling inter-layer
    // prediction.
    if (svc->spatial_layer_id > 0) vp9_svc_constrain_inter_layer_pred(cpi);
    vp9_svc_assert_constraints_pattern(cpi);
  }

  if (cpi->rc.last_post_encode_dropped_scene_change) {
    cpi->rc.high_source_sad = 1;
    svc->high_source_sad_superframe = 1;
    // For now disable use_source_sad since Last_Source will not be the previous
    // encoded but the dropped one.
    cpi->sf.use_source_sad = 0;
    cpi->rc.last_post_encode_dropped_scene_change = 0;
  }
  // Check if this high_source_sad (scene/slide change) frame should be
  // encoded at high/max QP, and if so, set the q and adjust some rate
  // control parameters.
  if (cpi->sf.overshoot_detection_cbr_rt == FAST_DETECTION_MAXQ &&
      (cpi->rc.high_source_sad ||
       (cpi->use_svc && svc->high_source_sad_superframe))) {
    if (vp9_encodedframe_overshoot(cpi, -1, &q)) {
      vp9_set_quantizer(cpi, q);
      vp9_set_variance_partition_thresholds(cpi, q, 0);
    }
  }

#if !CONFIG_REALTIME_ONLY
  // Variance adaptive and in frame q adjustment experiments are mutually
  // exclusive.
  if (cpi->oxcf.aq_mode == VARIANCE_AQ) {
    vp9_vaq_frame_setup(cpi);
  } else if (cpi->oxcf.aq_mode == EQUATOR360_AQ) {
    vp9_360aq_frame_setup(cpi);
  } else if (cpi->oxcf.aq_mode == COMPLEXITY_AQ) {
    vp9_setup_in_frame_q_adj(cpi);
  } else if (cpi->oxcf.aq_mode == LOOKAHEAD_AQ) {
    // it may be pretty bad for rate-control,
    // and I should handle it somehow
    vp9_alt_ref_aq_setup_map(cpi->alt_ref_aq, cpi);
  } else {
#endif
    // If ROI is enabled and skip feature is used for segmentation, apply cyclic
    // refresh but not apply ROI for skip for the first 20 frames (defined by
    // FRAMES_NO_SKIPPING_AFTER_KEY) after key frame to improve quality.
    if (cpi->roi.enabled && !frame_is_intra_only(cm)) {
      if (cpi->roi.skip[BACKGROUND_SEG_SKIP_ID]) {
        if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ)
          vp9_cyclic_refresh_setup(cpi);
        if (cpi->rc.frames_since_key > FRAMES_NO_SKIPPING_AFTER_KEY)
          apply_roi_map(cpi);
      } else {
        apply_roi_map(cpi);
      }
    } else if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ) {
      vp9_cyclic_refresh_setup(cpi);
    }

#if !CONFIG_REALTIME_ONLY
  }
#endif

  apply_active_map(cpi);

  vp9_encode_frame(cpi);

  // Check if we should re-encode this frame at high Q because of high
  // overshoot based on the encoded frame size. Only for frames where
  // high temporal-source SAD is detected.
  // For SVC: all spatial layers are checked for re-encoding.
  if (cpi->sf.overshoot_detection_cbr_rt == RE_ENCODE_MAXQ &&
      (cpi->rc.high_source_sad ||
       (cpi->use_svc && svc->high_source_sad_superframe))) {
    int frame_size = 0;
    // Get an estimate of the encoded frame size.
    save_coding_context(cpi);
    vp9_pack_bitstream(cpi, dest, size);
    restore_coding_context(cpi);
    frame_size = (int)(*size) << 3;
    // Check if encoded frame will overshoot too much, and if so, set the q and
    // adjust some rate control parameters, and return to re-encode the frame.
    if (vp9_encodedframe_overshoot(cpi, frame_size, &q)) {
      vpx_clear_system_state();
      vp9_set_quantizer(cpi, q);
      vp9_set_variance_partition_thresholds(cpi, q, 0);
      suppress_active_map(cpi);
      // Turn-off cyclic refresh for re-encoded frame.
      if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ) {
        CYCLIC_REFRESH *const cr = cpi->cyclic_refresh;
        unsigned char *const seg_map = cpi->segmentation_map;
        memset(seg_map, 0, cm->mi_rows * cm->mi_cols);
        memset(cr->last_coded_q_map, MAXQ,
               cm->mi_rows * cm->mi_cols * sizeof(*cr->last_coded_q_map));
        cr->sb_index = 0;
        vp9_disable_segmentation(&cm->seg);
      }
      apply_active_map(cpi);
      vp9_encode_frame(cpi);
    }
  }

  // Update some stats from cyclic refresh, and check for golden frame update.
  if (cpi->oxcf.aq_mode == CYCLIC_REFRESH_AQ && cm->seg.enabled &&
      !frame_is_intra_only(cm) && cpi->cyclic_refresh->content_mode)
    vp9_cyclic_refresh_postencode(cpi);

  // Update the skip mb flag probabilities based on the distribution
  // seen in the last encoder iteration.
  // update_base_skip_probs(cpi);
  vpx_clear_system_state();
  return 1;
}
