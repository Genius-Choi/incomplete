add_flow_finish(struct ofproto *ofproto, struct ofproto_flow_mod *ofm,
                const struct openflow_mod_requester *req)
    OVS_REQUIRES(ofproto_mutex)
{
    struct rule *old_rule = rule_collection_n(&ofm->old_rules)
        ? rule_collection_rules(&ofm->old_rules)[0] : NULL;
    struct rule *new_rule = rule_collection_rules(&ofm->new_rules)[0];
    struct ovs_list dead_cookies = OVS_LIST_INITIALIZER(&dead_cookies);

    replace_rule_finish(ofproto, ofm, req, old_rule, new_rule, &dead_cookies);
    learned_cookies_flush(ofproto, &dead_cookies);

    if (old_rule) {
        ovsrcu_postpone(remove_rule_rcu, old_rule);
    } else {
        ofmonitor_report(ofproto->connmgr, new_rule, NXFME_ADDED, 0,
                         req ? req->ofconn : NULL,
                         req ? req->request->xid : 0, NULL);

        /* Send Vacancy Events for OF1.4+. */
        send_table_status(ofproto, new_rule->table_id);
    }
}
