DUL_associationWaiting(DUL_NETWORKKEY * callerNet, int timeout)
{
    PRIVATE_NETWORKKEY *net;
    DcmNativeSocketType s;
    OFBool              assocWaiting = OFFalse;
    struct timeval      t;
    int                 nfound;

    if (callerNet == NULL)
        return OFFalse;

    net = (PRIVATE_NETWORKKEY*)callerNet;

    s = net->networkSpecific.TCP.listenSocket;

#ifndef DCMTK_HAVE_POLL
     fd_set fdset;
     FD_ZERO(&fdset);
     FD_SET(s, &fdset);
#endif

    t.tv_sec = timeout;
    t.tv_usec = 0;
#ifdef DCMTK_HAVE_POLL
    struct pollfd pfd[] = 
    {
       { s, POLLIN, 0 }
    };
    nfound = poll(pfd, 1,  t.tv_sec*1000+(t.tv_usec/1000));
#else
#ifdef HAVE_INTP_SELECT
    nfound = select(OFstatic_cast(int, s + 1), (int *)(&fdset), NULL, NULL, &t);
#else
    // This is safe because on Windows the first select() parameter is ignored anyway
    nfound = select(OFstatic_cast(int, s + 1), &fdset, NULL, NULL, &t);
#endif /* HAVE_INTP_SELECT */
#endif /* DCMTK_HAVE_POLL */
    if (DCM_dcmnetLogger.isEnabledFor(OFLogger::DEBUG_LOG_LEVEL))
    {
        DU_logSelectResult(nfound);
    }
    if (nfound <= 0) assocWaiting = OFFalse;
    else
    {
#ifdef DCMTK_HAVE_POLL
        if (pfd[0].revents & POLLIN)
            assocWaiting = OFTrue;
        else                /* This one should not really happen */
            assocWaiting = OFFalse;
#else
        if (FD_ISSET(s, &fdset))
            assocWaiting = OFTrue;
        else                /* This one should not really happen */
            assocWaiting = OFFalse;
#endif
    }

    return assocWaiting;
}
