uint32_t gssntlm_get_name_attribute(uint32_t *minor_status,
                                    gss_name_t name,
                                    gss_buffer_t attr,
                                    int *authenticated,
                                    int *complete,
                                    gss_buffer_t value,
                                    gss_buffer_t display_value,
                                    int *more)
{
    uint32_t retmin;
    uint32_t retmaj;
    const struct gssntlm_name *in = (const struct gssntlm_name *)name;
    struct gssntlm_name_attribute *found_attr;

    if (name == GSS_C_NO_NAME) {
        return GSSERRS(GSS_S_BAD_NAME, GSS_S_CALL_INACCESSIBLE_READ);
    }
    if (attr == NULL) {
        return GSSERRS(ERR_NOARG, GSS_S_CALL_INACCESSIBLE_READ);
    }

    if (display_value) {
        display_value->value = NULL;
        display_value->length = 0;
    }
    if (more) { *more = 0; }
    if (authenticated) { *authenticated = 0; }
    if (complete) { *complete = 0; }

    found_attr = gssntlm_find_attr(in->attrs, attr->value, attr->length);
    if (!found_attr) {
        return GSSERRS(ENOENT, GSS_S_UNAVAILABLE);
    }

    if (authenticated) { *authenticated = 1; }
    if (complete) { *complete = 1; }
    if (value) {
        gss_buffer_t attr_value = &found_attr->attr_value;
        value->value = malloc(attr_value->length);
        if (!value->value) {
            return GSSERRS(ENOMEM, GSS_S_FAILURE);
        }
        memcpy(value->value, attr_value->value, attr_value->length);
        value->length = attr_value->length;
    }
    return GSSERRS(0, GSS_S_COMPLETE);
}
