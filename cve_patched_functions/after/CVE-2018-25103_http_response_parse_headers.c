handler_t http_response_parse_headers(server *srv, connection *con, http_response_opts *opts, buffer *b) {
    /**
     * possible formats of response headers:
     *
     * proxy or NPH (non-parsed headers):
     *
     *   HTTP/1.0 200 Ok\n
     *   Header: Value\n
     *   \n
     *
     * CGI:
     *
     *   Header: Value\n
     *   Status: 200\n
     *   \n
     *
     * and different mixes of \n and \r\n combinations
     *
     * Some users also forget about CGI and just send a response
     * and hope we handle it. No headers, no header-content separator
     */

    int is_nph = (0 == strncmp(b->ptr, "HTTP/1.", 7)); /*nph (non-parsed hdrs)*/
    int is_header_end = 0;
    size_t last_eol = 0;
    size_t i = 0, header_len = buffer_string_length(b);
    const char *bstart;
    size_t blen;

    if (b->ptr[0] == '\n' || (b->ptr[0] == '\r' && b->ptr[1] == '\n')) {
        /* no HTTP headers */
        i = (b->ptr[0] == '\n') ? 0 : 1;
        is_header_end = 1;
    } else if (is_nph || b->ptr[(i = strcspn(b->ptr, ":\n"))] == ':') {
        /* HTTP headers */
        ++i;
        for (char *c; NULL != (c = strchr(b->ptr+i, '\n')); ++i) {
            i = (uintptr_t)(c - b->ptr);
            /**
             * check if we saw a \n(\r)?\n sequence
             */
            if (last_eol > 0 &&
                ((i - last_eol == 1) ||
                 (i - last_eol == 2 && b->ptr[i - 1] == '\r'))) {
                is_header_end = 1;
                break;
            }

            last_eol = i;
        }
    } else if (i == header_len) { /* (no newline yet; partial header line?) */
    } else if (opts->backend == BACKEND_CGI) {
        /* no HTTP headers, but a body (special-case for CGI compat) */
        /* no colon found; does not appear to be HTTP headers */
        if (0 != http_chunk_append_buffer(srv, con, b)) {
            return HANDLER_ERROR;
        }
        con->http_status = 200; /* OK */
        con->file_started = 1;
        return HANDLER_GO_ON;
    } else {
        /* invalid response headers */
        con->http_status = 502; /* Bad Gateway */
        con->mode = DIRECT;
        return HANDLER_FINISHED;
    }

    if (!is_header_end) {
        /*(reuse MAX_HTTP_REQUEST_HEADER as max size
         * for response headers from backends)*/
        if (header_len > MAX_HTTP_REQUEST_HEADER) {
            log_error_write(srv, __FILE__, __LINE__, "sb",
                            "response headers too large for", con->uri.path);
            con->http_status = 502; /* Bad Gateway */
            con->mode = DIRECT;
            return HANDLER_FINISHED;
        }
        return HANDLER_GO_ON;
    }

    /* the body starts after the EOL */
    bstart = b->ptr + (i + 1);
    blen = header_len - (i + 1);

    /* strip the last \r?\n */
    if (i > 0 && (b->ptr[i - 1] == '\r')) {
        i--;
    }

    buffer_string_set_length(b, i);

    if (opts->backend == BACKEND_PROXY && !is_nph) {
        /* invalid response Status-Line from HTTP proxy */
        con->http_status = 502; /* Bad Gateway */
        con->mode = DIRECT;
        return HANDLER_FINISHED;
    }

    if (0 != http_response_process_headers(srv, con, opts, b)) {
        return HANDLER_ERROR;
    }

    con->file_started = 1;

    if (opts->authorizer
        && (con->http_status == 0 || con->http_status == 200)) {
        return HANDLER_GO_ON;
    }

    if (con->mode == DIRECT) {
        return HANDLER_FINISHED;
    }

    if (opts->local_redir && con->http_status >= 300 && con->http_status < 400){
        /*(con->parsed_response & HTTP_LOCATION)*/
        handler_t rc = http_response_process_local_redir(srv, con, blen);
        if (con->mode == DIRECT) con->file_started = 0;
        if (rc != HANDLER_GO_ON) return rc;
    }

    if (opts->xsendfile_allow) {
        data_string *ds;
        /* X-Sendfile2 is deprecated; historical for fastcgi */
        if (opts->backend == BACKEND_FASTCGI
            && NULL != (ds = (data_string *) array_get_element(con->response.headers, "X-Sendfile2"))) {
            http_response_xsendfile2(srv, con, ds->value, opts->xsendfile_docroot);
            buffer_reset(ds->value); /*(do not send to client)*/
            if (con->mode == DIRECT) con->file_started = 0;
            return HANDLER_FINISHED;
        } else if (NULL != (ds = (data_string *) array_get_element(con->response.headers, "X-Sendfile"))
                   || (opts->backend == BACKEND_FASTCGI /* X-LIGHTTPD-send-file is deprecated; historical for fastcgi */
                       && NULL != (ds = (data_string *) array_get_element(con->response.headers, "X-LIGHTTPD-send-file")))) {
            http_response_xsendfile(srv, con, ds->value, opts->xsendfile_docroot);
            buffer_reset(ds->value); /*(do not send to client)*/
            if (con->mode == DIRECT) con->file_started = 0;
            return HANDLER_FINISHED;
        }
    }

    if (blen > 0) {
        if (0 != http_chunk_append_mem(srv, con, bstart, blen)) {
            return HANDLER_ERROR;
        }
    }

    /* (callback for response headers complete) */
    return (opts->headers) ? opts->headers(srv, con, opts) : HANDLER_GO_ON;
}
