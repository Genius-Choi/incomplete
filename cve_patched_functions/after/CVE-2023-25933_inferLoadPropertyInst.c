bool TypeInferenceImpl::inferLoadPropertyInst(LoadPropertyInst *LPI) {
  bool changed = false;
  bool first = true;
  Type retTy;
  Type originalTy = LPI->getType();
  bool unique = true;

  // Bail out if there are unknown receivers.
  if (cgp_->hasUnknownReceivers(LPI))
    return false;

  // Go over each known receiver R (can be empty)
  for (auto *R : cgp_->getKnownReceivers(LPI)) {
    assert(llvh::isa<AllocObjectInst>(R));
    // Note: currently Array analysis is purposely disabled.

    // Bail out if there are unknown stores.
    if (cgp_->hasUnknownStores(R))
      return false;

    Value *prop = LPI->getProperty();

    // If the property being requested is NOT an owned prop, Bail out
    if (llvh::isa<AllocObjectInst>(R)) {
      if (!isOwnedProperty(cast<AllocObjectInst>(R), prop))
        return false;
    }

    // Go over each store of R (can be empty)
    for (auto *S : cgp_->getKnownStores(R)) {
      assert(
          llvh::isa<StoreOwnPropertyInst>(S) ||
          llvh::isa<StorePropertyInst>(S));
      Value *storeVal = nullptr;

      if (llvh::isa<AllocObjectInst>(R)) {
        // If the property in the store is what this LPI wants, skip the store.
        if (auto *SS = llvh::dyn_cast<StoreOwnPropertyInst>(S)) {
          storeVal = SS->getStoredValue();
          if (prop != SS->getProperty())
            continue;
        }
        if (auto *SS = llvh::dyn_cast<StorePropertyInst>(S)) {
          storeVal = SS->getStoredValue();
          if (prop != SS->getProperty())
            continue;
        }
      }

      if (llvh::isa<AllocArrayInst>(R)) {
        if (auto *SS = llvh::dyn_cast<StorePropertyInst>(S)) {
          storeVal =
              SS->getStoredValue(); // for arrays, no need to match prop name
        }
      }

      assert(storeVal != nullptr);

      if (first) {
        retTy = storeVal->getType();
        first = false;
      } else {
        retTy = Type::unionTy(retTy, storeVal->getType());
        unique = false;
      }
    }
  }
  if (!first && unique) {
    UniquePropertyValue++;
  }
  if (!first && retTy.isProperSubsetOf(originalTy)) {
    LPI->setType(retTy);
    return true;
  }
  return changed;
}
