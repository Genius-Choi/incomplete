pkcs11_login_slot(struct pkcs11_provider *provider, struct pkcs11_slotinfo *si,
    CK_USER_TYPE type)
{
	char			*pin = NULL, prompt[1024];
	CK_RV			 rv;

	if (provider == NULL || si == NULL || !provider->valid) {
		error("no pkcs11 (valid) provider found");
		return (-1);
	}

	if (!pkcs11_interactive) {
		error("need pin entry%s",
		    (si->token.flags & CKF_PROTECTED_AUTHENTICATION_PATH) ?
		    " on reader keypad" : "");
		return (-1);
	}
	if (si->token.flags & CKF_PROTECTED_AUTHENTICATION_PATH)
		verbose("Deferring PIN entry to reader keypad.");
	else {
		snprintf(prompt, sizeof(prompt), "Enter PIN for '%s': ",
		    si->token.label);
		if ((pin = read_passphrase(prompt, RP_ALLOW_EOF)) == NULL) {
			debug_f("no pin specified");
			return (-1);	/* bail out */
		}
	}
	rv = provider->function_list->C_Login(si->session, type, (u_char *)pin,
	    (pin != NULL) ? strlen(pin) : 0);
	if (pin != NULL)
		freezero(pin, strlen(pin));

	switch (rv) {
	case CKR_OK:
	case CKR_USER_ALREADY_LOGGED_IN:
		/* success */
		break;
	case CKR_PIN_LEN_RANGE:
		error("PKCS#11 login failed: PIN length out of range");
		return -1;
	case CKR_PIN_INCORRECT:
		error("PKCS#11 login failed: PIN incorrect");
		return -1;
	case CKR_PIN_LOCKED:
		error("PKCS#11 login failed: PIN locked");
		return -1;
	default:
		error("PKCS#11 login failed: error %lu", rv);
		return -1;
	}
	si->logged_in = 1;
	return (0);
}
