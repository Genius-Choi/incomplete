static void dasher_send_empty_segment(GF_DasherCtx *ctx, GF_DashStream *ds)
{
	GF_FilterPacket *pck=NULL;
	u8 *data;

	if (ds->segment_started) {
		u64 next_cts = ds->first_cts_in_seg + gf_timestamp_rescale(ds->dash_dur.num, ds->dash_dur.den, ds->timescale);
		ds->first_cts_in_next_seg = next_cts;
		assert(ds->nb_comp_done < ds->nb_comp);
		ds->nb_comp_done ++;
		ds->split_dur_next = 0;
		ds->seg_done = GF_TRUE;

		dasher_inject_eods(ctx, ds);

		//force to be last rep in set to be done
		ds->nb_rep_done = ds->nb_rep-1;
		dasher_flush_segment(ctx, ds, GF_FALSE);

		ds->first_cts_in_seg = next_cts;
		ds->split_dur_next = 0;
	}

	if (ds->opid && (!ctx->from_index || (ctx->from_index==IDXMODE_SEG) )) {

		if (ds->codec_id == GF_CODECID_SUBS_XML) {
			//write empty TTML doc
			u32 len = (u32) strlen(empty_ttml);
			pck = gf_filter_pck_new_alloc(ds->opid, len+1, &data);
			memcpy(data, empty_ttml, len);
			data[len] = 0;
		} else if (ds->codec_id == GF_CODECID_WEBVTT) {
			//write empty cue box, 8 byte size of type vtte
			pck = gf_filter_pck_new_alloc(ds->opid, 8, &data);
			data[0] = data[1] = data[2] = 0; data[3] = 8;
			data[4] = 'v'; data[5] = 't'; data[6] = 't'; data[7] = 'e';
		} else if (ds->codec_id == GF_CODECID_TX3G) {
			//write empty tx3g sample, 2 bytes text len=0
			pck = gf_filter_pck_new_alloc(ds->opid, 2, &data);
			data[0] = data[1] = 0;
		} else {
			pck = gf_filter_pck_new_alloc(ds->opid, 0, &data);
		}

		gf_filter_pck_set_dts(pck, ds->first_cts_in_seg);
		gf_filter_pck_set_cts(pck, ds->first_cts_in_seg);
		gf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);
		//we don't assign a duration

		GF_LOG(GF_LOG_DEBUG, GF_LOG_DASH, ("[Dasher] Sending empty text packet CTS "LLU"/%d\n", ds->first_cts_in_seg, ds->timescale));
	}

	dasher_mark_segment_start(ctx, ds, pck, NULL);
	ds->segment_started = GF_TRUE;
	if (pck)
		gf_filter_pck_send(pck);

	if (ctx->do_index) {
		GF_MPD_SegmentURL *s = gf_list_last(ds->rep->segment_list->segment_URLs);
		s->first_tfdt = ds->first_cts_in_seg;
	}

	ds->first_cts_in_next_seg = ds->first_cts_in_seg + gf_timestamp_rescale(ds->dash_dur.num, ds->dash_dur.den, ds->timescale);
	ds->est_first_cts_in_next_seg = ds->first_cts_in_next_seg;
}
