static int pico_tcp_push_nagle_hold(struct pico_socket_tcp *t, struct pico_frame *f)
{
    struct pico_frame *f_new;
    uint32_t total_len = 0;
    pico_schedule_job(t->sock.stack, pico_tcp_out_all, t);
    total_len = f->payload_len + t->tcpq_hold.size;
    if ((total_len >= t->mss) && ((t->tcpq_out.max_size - t->tcpq_out.size) >= t->mss)) {
        /* IF enough data in hold (>mss) AND space in out queue (>mss) */
        /* add current frame in hold and make new segment */
        if (pico_enqueue_segment(&t->tcpq_hold, f) > 0 ) {
            tcp_dbg_nagle("TCP_PUSH - NAGLE - Pushed into hold, make new (enqueued frames out %d)\n", t->tcpq_out.frames);
            t->snd_last += f->payload_len;              /* XXX  WATCH OUT */
            f_new = pico_hold_segment_make(t);
        } else {
            tcp_dbg_nagle("TCP_PUSH - NAGLE - enqueue hold failed 1\n");
            return 0;
        }

        /* and put new frame in out queue */
        if ((f_new != NULL) && (pico_enqueue_segment(&t->tcpq_out, f_new) > 0)) {
            return f_new->payload_len;
        } else {
            tcp_dbg_nagle("TCP_PUSH - NAGLE - enqueue out failed, f_new = %p\n", f_new);
            return -1;              /* XXX something seriously wrong */
        }
    } else {
        /* ELSE put frame in hold queue */
        if (pico_enqueue_segment(&t->tcpq_hold, f) > 0) {
            tcp_dbg_nagle("TCP_PUSH - NAGLE - Pushed into hold (enqueued frames out %d)\n", t->tcpq_out.frames);
            t->snd_last += f->payload_len;              /* XXX  WATCH OUT */
            return f->payload_len;
        } else {
            pico_err = PICO_ERR_EAGAIN;
            tcp_dbg_nagle("TCP_PUSH - NAGLE - enqueue hold failed 2\n");
        }
    }

    return 0;
}
