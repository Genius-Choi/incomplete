static void set_mb_ssim_rdmult_scaling(VP9_COMP *cpi) {
  VP9_COMMON *cm = &cpi->common;
  ThreadData *td = &cpi->td;
  MACROBLOCK *x = &td->mb;
  MACROBLOCKD *xd = &x->e_mbd;
  uint8_t *y_buffer = cpi->Source->y_buffer;
  const int y_stride = cpi->Source->y_stride;
  const int block_size = BLOCK_16X16;

  const int num_8x8_w = num_8x8_blocks_wide_lookup[block_size];
  const int num_8x8_h = num_8x8_blocks_high_lookup[block_size];
  const int num_cols = (cm->mi_cols + num_8x8_w - 1) / num_8x8_w;
  const int num_rows = (cm->mi_rows + num_8x8_h - 1) / num_8x8_h;
  double log_sum = 0.0;
  int row, col;

  // Loop through each 64x64 block.
  for (row = 0; row < num_rows; ++row) {
    for (col = 0; col < num_cols; ++col) {
      int mi_row, mi_col;
      double var = 0.0, num_of_var = 0.0;
      const int index = row * num_cols + col;

      for (mi_row = row * num_8x8_h;
           mi_row < cm->mi_rows && mi_row < (row + 1) * num_8x8_h; ++mi_row) {
        for (mi_col = col * num_8x8_w;
             mi_col < cm->mi_cols && mi_col < (col + 1) * num_8x8_w; ++mi_col) {
          struct buf_2d buf;
          const int row_offset_y = mi_row << 3;
          const int col_offset_y = mi_col << 3;

          buf.buf = y_buffer + row_offset_y * y_stride + col_offset_y;
          buf.stride = y_stride;

          // In order to make SSIM_VAR_SCALE in a same scale for both 8 bit
          // and high bit videos, the variance needs to be divided by 2.0 or
          // 64.0 separately.
          // TODO(sdeng): need to tune for 12bit videos.
#if CONFIG_VP9_HIGHBITDEPTH
          if (cpi->Source->flags & YV12_FLAG_HIGHBITDEPTH)
            var += vp9_high_get_sby_variance(cpi, &buf, BLOCK_8X8, xd->bd);
          else
#endif
            var += vp9_get_sby_variance(cpi, &buf, BLOCK_8X8);

          num_of_var += 1.0;
        }
      }
      var = var / num_of_var / 64.0;

      // Curve fitting with an exponential model on all 16x16 blocks from the
      // Midres dataset.
      var = 67.035434 * (1 - exp(-0.0021489 * var)) + 17.492222;
      cpi->mi_ssim_rdmult_scaling_factors[index] = var;
      log_sum += log(var);
    }
  }
  log_sum = exp(log_sum / (double)(num_rows * num_cols));

  for (row = 0; row < num_rows; ++row) {
    for (col = 0; col < num_cols; ++col) {
      const int index = row * num_cols + col;
      cpi->mi_ssim_rdmult_scaling_factors[index] /= log_sum;
    }
  }

  (void)xd;
}
