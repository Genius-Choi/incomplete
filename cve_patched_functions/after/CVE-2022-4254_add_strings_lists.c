errno_t add_strings_lists(TALLOC_CTX *mem_ctx, const char **l1, const char **l2,
                          bool copy_strings, char ***_new_list)
{
    size_t c;
    size_t l1_count = 0;
    size_t l2_count = 0;
    size_t new_count = 0;
    char **new;
    int ret;

    if (l1 != NULL) {
        for (l1_count = 0; l1[l1_count] != NULL; l1_count++);
    }

    if (l2 != NULL) {
        for (l2_count = 0; l2[l2_count] != NULL; l2_count++);
    }

    new_count = l1_count + l2_count;

    new = talloc_array(mem_ctx, char *, new_count + 1);
    if (new == NULL) {
        DEBUG(SSSDBG_OP_FAILURE, "talloc_array failed.\n");
        return ENOMEM;
    }
    new [new_count] = NULL;

    if (copy_strings) {
        for(c = 0; c < l1_count; c++) {
            new[c] = talloc_strdup(new, l1[c]);
            if (new[c] == NULL) {
                DEBUG(SSSDBG_OP_FAILURE, "talloc_strdup failed.\n");
                ret = ENOMEM;
                goto done;
            }
        }
        for(c = 0; c < l2_count; c++) {
            new[l1_count + c] = talloc_strdup(new, l2[c]);
            if (new[l1_count + c] == NULL) {
                DEBUG(SSSDBG_OP_FAILURE, "talloc_strdup failed.\n");
                ret = ENOMEM;
                goto done;
            }
        }
    } else {
        if (l1 != NULL) {
            memcpy(new, l1, sizeof(char *) * l1_count);
        }

        if (l2 != NULL) {
            memcpy(&new[l1_count], l2, sizeof(char *) * l2_count);
        }
    }

    *_new_list = new;
    ret = EOK;

done:
    if (ret != EOK) {
        talloc_free(new);
    }

    return ret;
}
