static RFX_MESSAGE* rfx_split_message(RFX_CONTEXT* context, RFX_MESSAGE* message,
                                      size_t* numMessages, size_t maxDataSize)
{
	WINPR_ASSERT(context);
	WINPR_ASSERT(message);
	WINPR_ASSERT(numMessages);

	maxDataSize -= 1024; /* reserve enough space for headers */
	*numMessages = ((message->tilesDataSize + maxDataSize) / maxDataSize) * 4ull;

	RFX_MESSAGE* messages =
	    (RFX_MESSAGE*)winpr_aligned_calloc((*numMessages), sizeof(RFX_MESSAGE), 32);
	if (!messages)
		return NULL;

	size_t j = 0;
	for (size_t i = 0; i < message->numTiles; i++)
	{
		RFX_TILE* tile = message->tiles[i];
		RFX_MESSAGE* msg = &messages[j];

		WINPR_ASSERT(tile);
		WINPR_ASSERT(msg);

		const size_t tileDataSize = rfx_tile_length(tile);

		if ((msg->tilesDataSize + tileDataSize) > ((UINT32)maxDataSize))
			j++;

		if (msg->numTiles == 0)
		{
			msg->frameIdx = message->frameIdx + j;
			if (!rfx_clone_quants(msg, message))
				goto free_messages;
			if (!rfx_clone_rects(msg, message))
				goto free_messages;
			msg->freeArray = TRUE;
			if (!rfx_allocate_tiles(msg, message->numTiles, TRUE))
				goto free_messages;
		}

		msg->tilesDataSize += tileDataSize;

		WINPR_ASSERT(msg->numTiles < msg->allocatedTiles);
		msg->tiles[msg->numTiles++] = message->tiles[i];
		message->tiles[i] = NULL;
	}

	*numMessages = j + 1;
	context->frameIdx += j;
	message->numTiles = 0;
	return messages;
free_messages:

	for (size_t i = 0; i < j; i++)
		rfx_allocate_tiles(&messages[i], 0, FALSE);

	winpr_aligned_free(messages);
	return NULL;
}
