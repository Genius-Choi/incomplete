      [this, &header_values, formatter](const HeaderEntry& header) -> HeaderMap::Iterate {
        absl::string_view key_to_use = header.key().getStringView();
        uint32_t key_size_to_use = header.key().size();
        // Translate :authority -> host so that upper layers do not need to deal with this.
        if (key_size_to_use > 1 && key_to_use[0] == ':' && key_to_use[1] == 'a') {
          key_to_use = absl::string_view(header_values.HostLegacy.get());
          key_size_to_use = header_values.HostLegacy.get().size();
        }

        // Skip all headers starting with ':' that make it here.
        if (key_to_use[0] == ':') {
          return HeaderMap::Iterate::Continue;
        }

        encodeFormattedHeader(key_to_use, header.value().getStringView(), formatter);

        return HeaderMap::Iterate::Continue;
      });
