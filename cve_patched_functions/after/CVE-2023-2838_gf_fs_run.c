GF_Err gf_fs_run(GF_FilterSession *fsess)
{
	assert(fsess);

	//non blocking mode and threads created, only run main thread proc
	if (fsess->non_blocking && (fsess->non_blocking==2) ) {
#ifdef GPAC_CONFIG_EMSCRIPTEN
		if (fsess->pending_threads) return GF_NOT_READY;
#endif
		gf_fs_thread_proc(&fsess->main_th);
#ifdef GPAC_CONFIG_EMSCRIPTEN
		if (fsess->in_main_sem_wait) {
			fsess->in_main_sem_wait = GF_FALSE;
			return GF_NOT_READY;
		}
#endif
		return fsess->run_status;
	}

	//run threads
	fsess->run_status = GF_OK;
	fsess->main_th.has_seen_eot = GF_FALSE;
	fsess->nb_threads_stopped = 0;

#ifndef GPAC_DISABLE_THREADS
	u32 i, nb_threads;
	nb_threads = gf_list_count(fsess->threads);
	for (i=0;i<nb_threads; i++) {
		GF_SessionThread *sess_th = gf_list_get(fsess->threads, i);
		if ( gf_th_run(sess_th->th, (gf_thread_run) gf_fs_thread_proc, sess_th) ==GF_OK) {
#ifdef GPAC_CONFIG_EMSCRIPTEN
			if (fsess->non_blocking) {
				safe_int_inc(&fsess->pending_threads);
			}
#endif
		}
	}
#endif


	//run main thread - for emscripten, we only call if no pending threads
#ifdef GPAC_CONFIG_EMSCRIPTEN
	if (!fsess->pending_threads)
#endif
	{
		gf_fs_thread_proc(&fsess->main_th);
	}

	//non blocking mode init, don't wait for other threads
	if (fsess->non_blocking) {
		fsess->non_blocking = 2;
		return fsess->run_status;
	}

#ifndef GPAC_DISABLE_THREADS
	//blocking mode, wait for all threads to be done
	while (nb_threads+1 != fsess->nb_threads_stopped) {
		gf_sleep(1);
	}
#endif

	return fsess->run_status;
}
