Object c_SimpleXMLElement::t_children(const String& ns /* = "" */,
                                      bool is_prefix /* = false */) {
  if (m_is_attribute) {
    return Object();
  }

  Object obj = create_object(m_doc.getTyped<XmlDocWrapper>()->
                             getClass(), Array(), false);
  c_SimpleXMLElement *elem = obj.getTyped<c_SimpleXMLElement>();
  elem->m_root = m_root;
  elem->m_doc = m_doc;
  elem->m_node = m_node;
  elem->m_is_text = m_is_text;
  elem->m_free_text = m_free_text;
  elem->m_is_children = true;
  if (m_is_text) {
    return obj;
  } else if (ns.empty()) {
    elem->m_children.assignRef(m_children);
  } else {
    Array props = Array::Create();
    for (ArrayIter iter(m_children.toArray()); iter; ++iter) {
      if (iter.second().isObject()) {
        c_SimpleXMLElement *elem = iter.second().toObject().
          getTyped<c_SimpleXMLElement>();
        if (elem->m_node && match_ns(elem->m_node, ns, is_prefix)) {
          props.set(iter.first(), iter.second());
        }
      } else {
        Array subnodes;
        for (ArrayIter iter2(iter.second().toArray()); iter2; ++iter2) {
          c_SimpleXMLElement *elem = iter2.second().toObject().
            getTyped<c_SimpleXMLElement>();
          if (elem->m_node && match_ns(elem->m_node, ns, is_prefix)) {
            subnodes.append(iter2.second());
          }
        }
        if (!subnodes.empty()) {
          if (subnodes.size() == 1) {
            props.set(iter.first(), subnodes[0]);
          } else {
            props.set(iter.first(), subnodes);
          }
        }
      }
    }
    elem->m_children = props;
  }
  return obj;
}
