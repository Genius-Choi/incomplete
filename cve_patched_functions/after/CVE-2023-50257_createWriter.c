bool RTPSParticipantImpl::createWriter(RTPSWriter** WriterOut,
        WriterAttributes& param,WriterHistory* hist,WriterListener* listen, const EntityId_t& entityId,bool isBuiltin)
{
    std::string type = (param.endpoint.reliabilityKind == RELIABLE) ? "RELIABLE" :"BEST_EFFORT";
    logInfo(RTPS_PARTICIPANT," of type " << type);
    EntityId_t entId;
    if(entityId== c_EntityId_Unknown)
    {
        if(param.endpoint.topicKind == NO_KEY)
            entId.value[3] = 0x03;
        else if(param.endpoint.topicKind == WITH_KEY)
            entId.value[3] = 0x02;
        uint32_t idnum;
        if(param.endpoint.getEntityID()>0)
            idnum = param.endpoint.getEntityID();
        else
        {
            IdCounter++;
            idnum = IdCounter;
        }

        octet* c = (octet*)&idnum;
        entId.value[2] = c[0];
        entId.value[1] = c[1];
        entId.value[0] = c[2];
        if(this->existsEntityId(entId,WRITER))
        {
            logError(RTPS_PARTICIPANT,"A writer with the same entityId already exists in this RTPSParticipant");
            return false;
        }
    }
    else
    {
        entId = entityId;
    }
    if(!param.endpoint.unicastLocatorList.isValid())
    {
        logError(RTPS_PARTICIPANT,"Unicast Locator List for Writer contains invalid Locator");
        return false;
    }
    if(!param.endpoint.multicastLocatorList.isValid())
    {
        logError(RTPS_PARTICIPANT,"Multicast Locator List for Writer contains invalid Locator");
        return false;
    }
    if(!param.endpoint.outLocatorList.isValid())
    {
        logError(RTPS_PARTICIPANT,"Output Locator List for Writer contains invalid Locator");
        return false;
    }
    if (((param.throughputController.bytesPerPeriod != UINT32_MAX && param.throughputController.periodMillisecs != 0) ||
                (m_att.throughputController.bytesPerPeriod != UINT32_MAX && m_att.throughputController.periodMillisecs != 0)) &&
            param.mode != ASYNCHRONOUS_WRITER)
    {
        logError(RTPS_PARTICIPANT, "Writer has to be configured to publish asynchronously, because a flowcontroller was configured");
        return false;
    }


    // Normalize unicast locators
    if (!param.endpoint.unicastLocatorList.empty())
        m_network_Factory.NormalizeLocators(param.endpoint.unicastLocatorList);

    RTPSWriter* SWriter = nullptr;
    GUID_t guid(m_guid.guidPrefix,entId);
    if(param.endpoint.reliabilityKind == BEST_EFFORT)
        SWriter = (RTPSWriter*)new StatelessWriter(this,guid,param,hist,listen);
    else if(param.endpoint.reliabilityKind == RELIABLE)
        SWriter = (RTPSWriter*)new StatefulWriter(this,guid,param,hist,listen);

    if(SWriter==nullptr)
        return false;

    createSendResources((Endpoint *)SWriter);
    if(param.endpoint.reliabilityKind == RELIABLE)
    {
        if (!createAndAssociateReceiverswithEndpoint((Endpoint *)SWriter))
        {
            delete(SWriter);
            return false;
        }
    }

    // Asynchronous thread runs regardless of mode because of
    // nack response duties.
    AsyncWriterThread::addWriter(*SWriter);

    boost::lock_guard<boost::recursive_mutex> guard(*mp_mutex);
    m_allWriterList.push_back(SWriter);
    if(!isBuiltin)
        m_userWriterList.push_back(SWriter);
    *WriterOut = SWriter;

    // If the terminal throughput controller has proper user defined values, instantiate it
    if (param.throughputController.bytesPerPeriod != UINT32_MAX && param.throughputController.periodMillisecs != 0)
    {
        std::unique_ptr<FlowController> controller(new ThroughputController(param.throughputController, SWriter));
        SWriter->add_flow_controller(std::move(controller));
    }

    return true;
}
