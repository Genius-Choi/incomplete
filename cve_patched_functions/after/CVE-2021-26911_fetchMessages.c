IMAPSyncResult * IMAPSession::fetchMessages(String * folder, IMAPMessagesRequestKind requestKind, bool fetchByUID,
                                            struct mailimap_set * imapset, IndexSet * uidsFilter, IndexSet * numbersFilter,
                                            uint64_t modseq, HashMap * mapping,
                                            IMAPProgressCallback * progressCallback, Array * extraHeaders, ErrorCode * pError)
{
    struct mailimap_fetch_type * fetch_type;
    clist * fetch_result;
    struct mailimap_qresync_vanished * vanished;
    struct mailimap_fetch_att * fetch_att;
    int r;
    bool needsHeader;
    bool needsBody;
    bool needsFlags;
    bool needsGmailLabels;
    bool needsGmailMessageID;
    bool needsGmailThreadID;
    Array * messages;
    IndexSet * vanishedMessages;
    
    selectIfNeeded(folder, pError);
    if (* pError != ErrorNone)
        return NULL;
    
    if (mNeedsMboxMailWorkaround && ((requestKind & IMAPMessagesRequestKindHeaders) != 0)) {
        requestKind = (IMAPMessagesRequestKind) (requestKind & ~IMAPMessagesRequestKindHeaders);
        requestKind = (IMAPMessagesRequestKind) (requestKind | IMAPMessagesRequestKindFullHeaders);
    }
    if (extraHeaders != NULL) {
        requestKind = (IMAPMessagesRequestKind) (requestKind | IMAPMessagesRequestKindExtraHeaders);
    }
    
    if ((requestKind & IMAPMessagesRequestKindHeaders) != 0) {
        mProgressItemsCount = 0;
        mProgressCallback = progressCallback;
    }
    
    messages = Array::array();
    
    needsHeader = false;
    needsBody = false;
    needsFlags = false;
    needsGmailLabels = false;
    needsGmailMessageID = false;
    needsGmailThreadID = false;
    clist * hdrlist = clist_new();
    
    fetch_type = mailimap_fetch_type_new_fetch_att_list_empty();
    fetch_att = mailimap_fetch_att_new_uid();
    mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);
    if ((requestKind & IMAPMessagesRequestKindFlags) != 0) {
        MCLog("request flags");
        fetch_att = mailimap_fetch_att_new_flags();
        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);
        needsFlags = true;
    }
    if ((requestKind & IMAPMessagesRequestKindGmailLabels) != 0) {
        MCLog("request flags");
        fetch_att = mailimap_fetch_att_new_xgmlabels();
        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);
        needsGmailLabels = true;
    }
    if ((requestKind & IMAPMessagesRequestKindGmailThreadID) != 0) {
        fetch_att = mailimap_fetch_att_new_xgmthrid();
        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);
        needsGmailThreadID = true;
    }
    if ((requestKind & IMAPMessagesRequestKindGmailMessageID) != 0) {
        fetch_att = mailimap_fetch_att_new_xgmmsgid();
        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);
        needsGmailMessageID = true;
    }
    if ((requestKind & IMAPMessagesRequestKindFullHeaders) != 0) {
        char * header;
        
        MCLog("request envelope");
        
        // most important header
        header = strdup("Date");
        clist_append(hdrlist, header);
        header = strdup("Subject");
        clist_append(hdrlist, header);
        header = strdup("From");
        clist_append(hdrlist, header);
        header = strdup("Sender");
        clist_append(hdrlist, header);
        header = strdup("Reply-To");
        clist_append(hdrlist, header);
        header = strdup("To");
        clist_append(hdrlist, header);
        header = strdup("Cc");
        clist_append(hdrlist, header);
        header = strdup("Message-ID");
        clist_append(hdrlist, header);
        header = strdup("References");
        clist_append(hdrlist, header);
        header = strdup("In-Reply-To");
        clist_append(hdrlist, header);
    }
    if ((requestKind & IMAPMessagesRequestKindMessageId) != 0) {
        char * header;
        // envelope
        fetch_att = mailimap_fetch_att_new_envelope();
        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);
        MCLog("request envelope");
        header = strdup("Message-ID");
        clist_append(hdrlist, header);
        header = strdup("Subject");
        clist_append(hdrlist, header);
    }
    if ((requestKind & IMAPMessagesRequestKindHeaders) != 0) {
        char * header;
        
        MCLog("request envelope");
        // envelope
        fetch_att = mailimap_fetch_att_new_envelope();
        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);
        
        // references header
        header = strdup("References");
        clist_append(hdrlist, header);
        if ((requestKind & IMAPMessagesRequestKindHeaderSubject) != 0) {
            header = strdup("Subject");
            clist_append(hdrlist, header);
        }
    }
    if ((requestKind & IMAPMessagesRequestKindSize) != 0) {
        // message structure
        MCLog("request size");
        fetch_att = mailimap_fetch_att_new_rfc822_size();
        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);
    }
    
    if ((requestKind & IMAPMessagesRequestKindStructure) != 0) {
        // message structure
        MCLog("request bodystructure");
        fetch_att = mailimap_fetch_att_new_bodystructure();
        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);
        needsBody = true;
    }
    if ((requestKind & IMAPMessagesRequestKindInternalDate) != 0) {
        // internal date
        fetch_att = mailimap_fetch_att_new_internaldate();
        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);
    }
    if ((requestKind & IMAPMessagesRequestKindBody) != 0) {
        fetch_att = mailimap_fetch_att_new_body_peek_section(mailimap_section_new(NULL));
        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);
    }
    if ((requestKind & IMAPMessagesRequestKindExtraHeaders) != 0) {
        // custom header request
        char * header;
        
        if (extraHeaders && extraHeaders->count() > 0) {
            for (unsigned int i = 0; i < extraHeaders->count(); i++) {
                String * headerString = (String *)extraHeaders->objectAtIndex(i);
                header = strdup(headerString->UTF8Characters());
                clist_append(hdrlist, header);
            }
        }
    }
    
    if (clist_begin(hdrlist) != NULL) {
        struct mailimap_header_list * imap_hdrlist;
        struct mailimap_section * section;
        
        imap_hdrlist = mailimap_header_list_new(hdrlist);
        section = mailimap_section_new_header_fields(imap_hdrlist);
        fetch_att = mailimap_fetch_att_new_body_peek_section(section);
        mailimap_fetch_type_new_fetch_att_list_add(fetch_type, fetch_att);
        needsHeader = true;
    }
    else {
        clist_free(hdrlist);
    }
    
    struct msg_att_handler_data msg_att_data;
    
    memset(&msg_att_data, 0, sizeof(msg_att_data));
    msg_att_data.uidsFilter = uidsFilter;
    msg_att_data.numbersFilter = numbersFilter;
    msg_att_data.fetchByUID = fetchByUID;
    msg_att_data.result = messages;
    msg_att_data.requestKind = requestKind;
    msg_att_data.mLastFetchedSequenceNumber = mLastFetchedSequenceNumber;
    msg_att_data.mapping = mapping;
    msg_att_data.needsHeader = needsHeader;
    msg_att_data.needsBody = needsBody;
    msg_att_data.needsFlags = needsFlags;
    msg_att_data.needsGmailLabels = needsGmailLabels;
    msg_att_data.needsGmailMessageID = needsGmailMessageID;
    msg_att_data.needsGmailThreadID = needsGmailThreadID;
    mailimap_set_msg_att_handler(mImap, msg_att_handler, &msg_att_data);
    
    mBodyProgressEnabled = false;
    vanished = NULL;
    
    if (fetchByUID) {
        if ((modseq != 0) && (mCondstoreEnabled || mQResyncEnabled)) {
            if (mQResyncEnabled) {
                r = mailimap_uid_fetch_qresync(mImap, imapset, fetch_type, modseq,
                                               &fetch_result,  &vanished);
            }
            else { /* condstore */
                r = mailimap_uid_fetch_changedsince(mImap, imapset, fetch_type, modseq,
                                                    &fetch_result);
            }
        }
        else {
            r = mailimap_uid_fetch(mImap, imapset, fetch_type, &fetch_result);
        }
    } else {
        if ((modseq != 0) && (mCondstoreEnabled || mQResyncEnabled)) {
            if (mQResyncEnabled) {
                r = mailimap_fetch_qresync(mImap, imapset, fetch_type, modseq,
                                           &fetch_result,  &vanished);
            }
            else { /* condstore */
                r = mailimap_fetch_changedsince(mImap, imapset, fetch_type, modseq,
                                                &fetch_result);
            }
        }
        else {
            r = mailimap_fetch(mImap, imapset, fetch_type, &fetch_result);
        }
    }
    
    vanishedMessages = NULL;
    if (vanished != NULL) {
        vanishedMessages = indexSetFromSet(vanished->qr_known_uids);
    }
    
    mBodyProgressEnabled = true;
    
    mProgressCallback = NULL;
    
    mLastFetchedSequenceNumber = msg_att_data.mLastFetchedSequenceNumber;
    
    mailimap_fetch_type_free(fetch_type);
    
    mailimap_set_msg_att_handler(mImap, NULL, NULL);
    
    if (r == MAILIMAP_ERROR_STREAM) {
        MCLog("error stream");
        mShouldDisconnect = true;
        * pError = ErrorConnection;
        return NULL;
    }
    else if (r == MAILIMAP_ERROR_PARSE) {
        MCLog("error parse");
        mShouldDisconnect = true;
        * pError = ErrorParse;
        return NULL;
    }
    else if (hasError(r)) {
        MCLog("error fetch");
        * pError = ErrorFetch;
        return NULL;
    }
    
    IMAPSyncResult * result;
    result = new IMAPSyncResult();
    result->setModifiedOrAddedMessages(messages);
    result->setVanishedMessages(vanishedMessages);
    result->autorelease();
    
    if ((requestKind & IMAPMessagesRequestKindHeaders) != 0) {
        if (messages->count() == 0) {
            unsigned int count;
            
            count = clist_count(fetch_result);
            if (count > 0) {
                requestKind = (IMAPMessagesRequestKind) (requestKind & ~IMAPMessagesRequestKindHeaders);
                requestKind = (IMAPMessagesRequestKind) (requestKind | IMAPMessagesRequestKindFullHeaders);

                result = fetchMessages(folder, requestKind, fetchByUID,
                    imapset, uidsFilter, numbersFilter,
                    modseq, NULL, progressCallback, extraHeaders, pError);
                if (result != NULL) {
                    if (result->modifiedOrAddedMessages() != NULL) {
                        if (result->modifiedOrAddedMessages()->count() > 0) {
                            mNeedsMboxMailWorkaround = true;
                        }
                    }
                }
            }
        }
    }
    
    mailimap_fetch_list_free(fetch_result);
    * pError = ErrorNone;
    
    return result;
}
