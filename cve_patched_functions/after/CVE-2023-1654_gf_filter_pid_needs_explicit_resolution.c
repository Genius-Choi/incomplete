static Bool gf_filter_pid_needs_explicit_resolution(GF_FilterPid *pid, GF_Filter *dst)
{
	u32 i;
	const GF_FilterCapability *caps;
	u32 nb_caps;
	Bool dst_has_raw_cid_in = GF_FALSE;
	const GF_PropertyValue *stream_type = gf_filter_pid_get_property_first(pid, GF_PROP_PID_STREAM_TYPE);
	if (!stream_type) return GF_TRUE;

	if (stream_type->value.uint==GF_STREAM_FILE) return GF_FALSE;
	if (stream_type->value.uint==GF_STREAM_ENCRYPTED) {
		stream_type = gf_filter_pid_get_property_first(pid, GF_PROP_PID_ORIG_STREAM_TYPE);
		if (!stream_type) return GF_TRUE;
	}

	caps = dst->forced_caps ? dst->forced_caps : dst->freg->caps;
	nb_caps = dst->forced_caps ? dst->nb_forced_caps : dst->freg->nb_caps;

	for (i=0; i<nb_caps; i++) {
		const GF_FilterCapability *cap = &caps[i];
		if (!(cap->flags & GF_CAPFLAG_INPUT)) continue;

		if (cap->code != GF_PROP_PID_CODECID) continue;
		if (cap->val.value.uint==GF_CODECID_RAW)
			dst_has_raw_cid_in = GF_TRUE;
	}


	for (i=0; i<nb_caps; i++) {
		const GF_FilterCapability *cap = &caps[i];
		if (!(cap->flags & GF_CAPFLAG_INPUT)) continue;

		if (cap->code != GF_PROP_PID_STREAM_TYPE) continue;
		//output type is file or same media type, allow looking for filter chains
		if ((cap->val.value.uint==GF_STREAM_FILE) || (cap->val.value.uint==stream_type->value.uint)) return GF_FALSE;
		//allow text|scene|video -> raw video for dynamic compositor
		if (dst_has_raw_cid_in  && (cap->val.value.uint==GF_STREAM_VISUAL)) {
			switch (stream_type->value.uint) {
			case GF_STREAM_TEXT:
			case GF_STREAM_SCENE:
			case GF_STREAM_OD:
				return GF_FALSE;
			default:
				break;
			}
		}
	}
	//no mathing type found, we will need an explicit filter to solve this link (ie the link will be to the explicit filter)
	return GF_TRUE;
}
