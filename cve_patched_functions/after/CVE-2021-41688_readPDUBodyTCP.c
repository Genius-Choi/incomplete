readPDUBodyTCP(PRIVATE_ASSOCIATIONKEY ** association,
               DUL_BLOCKOPTIONS block, int timeout,
               unsigned char *buffer, unsigned long maxLength,
               unsigned char *pduType, unsigned char *pduReserved,
               unsigned long *pduLength)
{
    OFCondition cond = EC_Normal;
    unsigned long
        length;

    /* check if the association does not already contain PDU head information. */
    if ((*association)->inputPDU == NO_PDU) {
        /* If it does not, we need to try to receive PDU head information over the network */
        cond = readPDUHead(association, (*association)->pduHead,
                           sizeof((*association)->pduHead),
                           block, timeout, &(*association)->nextPDUType,
                           &(*association)->nextPDUReserved,
                           &(*association)->nextPDULength);
        /* return error if there was one */
        if (cond.bad())
            return cond;
    }
    /* determine PDU type and its values in the reserved field and in the PDU length field */
    *pduType = (*association)->nextPDUType;
    *pduReserved = (*association)->nextPDUReserved;
    *pduLength = (*association)->nextPDULength;

    /* (for non-blocking reading) if the timeout refers to */
    /* the default timeout, set timeout correspondingly */
    if (timeout == PRV_DEFAULTTIMEOUT)
        timeout = (*association)->timeout;

    /* bugfix by meichel 97/04/28: test if PDU fits into buffer */
    if (*pduLength > maxLength)
    {
      /* if it doesn't, set error indicator variable */
      cond = DUL_ILLEGALPDULENGTH;
    } else {
      /* if it does, read the current PDU's PDVs from the incoming socket stream. (Note that the */
      /* PDVs of the current PDU are (*association)->nextPDULength bytes long. Hence, in detail */
      /* we want to try to receive (*association)->nextPDULength bytes of data on the network) */
      /* The information that was received will be available through the buffer variable. */
      cond = defragmentTCP((*association)->connection,
                         block, (*association)->timerStart, timeout,
                         buffer, (*association)->nextPDULength, &length);
    }

    /* return result value */
    return cond;
}
