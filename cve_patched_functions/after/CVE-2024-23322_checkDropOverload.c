bool Filter::checkDropOverload(Upstream::ThreadLocalCluster& cluster,
                               std::function<void(Http::ResponseHeaderMap&)>& modify_headers) {
  if (cluster.dropOverload().value()) {
    ENVOY_STREAM_LOG(debug, "Router filter: cluster DROP_OVERLOAD configuration: {}", *callbacks_,
                     cluster.dropOverload().value());
    if (config_.random_.bernoulli(cluster.dropOverload())) {
      ENVOY_STREAM_LOG(debug, "The request is dropped by DROP_OVERLOAD", *callbacks_);
      callbacks_->streamInfo().setResponseFlag(StreamInfo::CoreResponseFlag::DropOverLoad);
      chargeUpstreamCode(Http::Code::ServiceUnavailable, nullptr, true);
      callbacks_->sendLocalReply(
          Http::Code::ServiceUnavailable, "drop overload",
          [modify_headers, this](Http::ResponseHeaderMap& headers) {
            if (!config_.suppress_envoy_headers_) {
              headers.addReference(Http::Headers::get().EnvoyDropOverload,
                                   Http::Headers::get().EnvoyDropOverloadValues.True);
            }
            modify_headers(headers);
          },
          absl::nullopt, StreamInfo::ResponseCodeDetails::get().DropOverload);

      cluster.info()->loadReportStats().upstream_rq_drop_overload_.inc();
      return true;
    }
  }
  return false;
}
