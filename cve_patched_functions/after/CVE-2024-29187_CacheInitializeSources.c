extern "C" HRESULT CacheInitializeSources(
    __in BURN_CACHE* pCache,
    __in BURN_REGISTRATION* pRegistration,
    __in BURN_VARIABLES* pVariables,
    __in BURN_ENGINE_COMMAND* pInternalCommand
    )
{
    Assert(!pCache->fInitializedCacheSources);

    HRESULT hr = S_OK;
    LPWSTR sczCurrentPath = NULL;
    LPWSTR sczCompletedFolder = NULL;
    LPWSTR sczCompletedPath = NULL;
    LPWSTR sczOriginalSource = NULL;
    LPWSTR sczOriginalSourceFolder = NULL;
    BOOL fPathEqual = FALSE;
    LPCWSTR wzSourceProcessPath = pInternalCommand->sczSourceProcessPath;

    hr = PathForCurrentProcess(&sczCurrentPath, NULL);
    ExitOnFailure(hr, "Failed to get current process path.");

    // Determine if we are running from the package cache or not.
    hr = CacheGetCompletedPath(pCache, pRegistration->fPerMachine, pRegistration->sczId, &sczCompletedFolder);
    ExitOnFailure(hr, "Failed to get completed path for bundle.");

    hr = PathConcatRelativeToFullyQualifiedBase(sczCompletedFolder, pRegistration->sczExecutableName, &sczCompletedPath);
    ExitOnFailure(hr, "Failed to combine working path with engine file name.");

    hr = PathCompareCanonicalized(sczCurrentPath, sczCompletedPath, &fPathEqual);
    ExitOnFailure(hr, "Failed to compare current path for bundle: %ls", sczCurrentPath);

    pCache->fRunningFromCache = fPathEqual;

    // If a source process path was not provided (e.g. we are not being
    // run in a clean room) then use the current process path as the
    // source process path.
    if (!wzSourceProcessPath)
    {
        wzSourceProcessPath = sczCurrentPath;
    }

    hr = PathGetDirectory(wzSourceProcessPath, &pCache->sczSourceProcessFolder);
    ExitOnFailure(hr, "Failed to initialize cache source folder.");

    // If we're not running from the cache, ensure the original source is set.
    if (!pCache->fRunningFromCache)
    {
        // If the original source has not been set already then set it where the bundle is
        // running from right now. This value will be persisted and we'll use it when launched
        // from the clean room or package cache since none of our packages will be relative to
        // those locations.
        hr = VariableGetString(pVariables, BURN_BUNDLE_ORIGINAL_SOURCE, &sczOriginalSource);
        if (E_NOTFOUND == hr)
        {
            hr = VariableSetString(pVariables, BURN_BUNDLE_ORIGINAL_SOURCE, wzSourceProcessPath, FALSE, FALSE);
            ExitOnFailure(hr, "Failed to set original source variable.");

            hr = StrAllocString(&sczOriginalSource, wzSourceProcessPath, 0);
            ExitOnFailure(hr, "Failed to copy current path to original source.");
        }

        hr = VariableGetString(pVariables, BURN_BUNDLE_ORIGINAL_SOURCE_FOLDER, &sczOriginalSourceFolder);
        if (E_NOTFOUND == hr)
        {
            hr = PathGetDirectory(sczOriginalSource, &sczOriginalSourceFolder);
            ExitOnFailure(hr, "Failed to get directory from original source path.");

            hr = VariableSetString(pVariables, BURN_BUNDLE_ORIGINAL_SOURCE_FOLDER, sczOriginalSourceFolder, FALSE, FALSE);
            ExitOnFailure(hr, "Failed to set original source directory variable.");
        }
    }

    pCache->fInitializedCacheSources = TRUE;

LExit:
    ReleaseStr(sczCurrentPath);
    ReleaseStr(sczCompletedFolder);
    ReleaseStr(sczCompletedPath);
    ReleaseStr(sczOriginalSource);
    ReleaseStr(sczOriginalSourceFolder);

    return hr;
}
