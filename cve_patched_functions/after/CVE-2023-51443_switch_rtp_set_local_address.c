SWITCH_DECLARE(switch_status_t) switch_rtp_set_local_address(switch_rtp_t *rtp_session, const char *host, switch_port_t port, const char **err)
{
	switch_socket_t *new_sock = NULL, *old_sock = NULL;
	switch_status_t status = SWITCH_STATUS_FALSE;
	int j = 0;
#ifndef WIN32
	char o[5] = "TEST", i[5] = "";
	switch_size_t len, ilen = 0;
	int x;
#endif

	if (rtp_session->ready != 1) {
		if (!switch_rtp_ready(rtp_session)) {
			return SWITCH_STATUS_FALSE;
		}

		READ_INC(rtp_session);
		WRITE_INC(rtp_session);

		if (!switch_rtp_ready(rtp_session)) {
			goto done;
		}
	}


	*err = NULL;

	if (zstr(host) || !port) {
		*err = "Address Error";
		goto done;
	}


	rtp_session->local_host_str = switch_core_strdup(rtp_session->pool, host);
	rtp_session->local_port = port;


	if (switch_sockaddr_info_get(&rtp_session->local_addr, host, SWITCH_UNSPEC, port, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS) {
		*err = "Local Address Error!";
		goto done;
	}


	if (rtp_session->sock_input) {
		switch_rtp_kill_socket(rtp_session);
	}

	if (switch_socket_create(&new_sock, switch_sockaddr_get_family(rtp_session->local_addr), SOCK_DGRAM, 0, rtp_session->pool) != SWITCH_STATUS_SUCCESS) {
		*err = "Socket Error!";
		goto done;
	}

	if (switch_socket_opt_set(new_sock, SWITCH_SO_REUSEADDR, 1) != SWITCH_STATUS_SUCCESS) {
		*err = "Socket Error!";
		goto done;
	}

	if (rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
		switch_socket_opt_set(new_sock, SWITCH_SO_RCVBUF, 1572864);
		switch_socket_opt_set(new_sock, SWITCH_SO_SNDBUF, 1572864);
	} else {
		switch_socket_opt_set(new_sock, SWITCH_SO_RCVBUF, 851968);
		switch_socket_opt_set(new_sock, SWITCH_SO_SNDBUF, 851968);
	}

	if (switch_socket_bind(new_sock, rtp_session->local_addr) != SWITCH_STATUS_SUCCESS) {
		char *em = switch_core_sprintf(rtp_session->pool, "Bind Error! %s:%d", host, port);
		*err = em;
		goto done;
	}


	if ((j = atoi(host)) && j > 223 && j < 240) { /* mcast */
		if (switch_mcast_interface(new_sock, rtp_session->local_addr) != SWITCH_STATUS_SUCCESS) {
			*err = "Multicast Socket interface Error";
			goto done;
		}

		if (switch_mcast_join(new_sock, rtp_session->local_addr, NULL, NULL) != SWITCH_STATUS_SUCCESS) {
			*err = "Multicast Error";
			goto done;
		}

		if (rtp_session->session) {
			switch_channel_t *channel = switch_core_session_get_channel(rtp_session->session);
			const char *var;

			if ((var = switch_channel_get_variable(channel, "multicast_ttl"))) {
				int ttl = atoi(var);

				if (ttl > 0 && ttl < 256) {
					if (switch_mcast_hops(new_sock, (uint8_t) ttl) != SWITCH_STATUS_SUCCESS) {
						*err = "Mutlicast TTL set failed";
						goto done;
					}

				}
			}

		}

	}



#ifndef WIN32
	len = sizeof(i);
	switch_socket_opt_set(new_sock, SWITCH_SO_NONBLOCK, TRUE);

	switch_socket_sendto(new_sock, rtp_session->local_addr, 0, (void *) o, &len);

	x = 0;
	while (!ilen) {
		switch_status_t status;
		ilen = len;
		status = switch_socket_recvfrom(rtp_session->from_addr, new_sock, 0, (void *) i, &ilen);

		if (status != SWITCH_STATUS_SUCCESS && status != SWITCH_STATUS_BREAK) {
			break;
		}

		if (++x > 1000) {
			break;
		}
		switch_cond_next();
	}
	switch_socket_opt_set(new_sock, SWITCH_SO_NONBLOCK, FALSE);

#endif

	old_sock = rtp_session->sock_input;
	rtp_session->sock_input = new_sock;
	new_sock = NULL;

	if (rtp_session->flags[SWITCH_RTP_FLAG_USE_TIMER] || rtp_session->flags[SWITCH_RTP_FLAG_NOBLOCK] || rtp_session->flags[SWITCH_RTP_FLAG_VIDEO]) {
		switch_socket_opt_set(rtp_session->sock_input, SWITCH_SO_NONBLOCK, TRUE);
		switch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_NOBLOCK);
	}

	switch_socket_create_pollset(&rtp_session->read_pollfd, rtp_session->sock_input, SWITCH_POLLIN | SWITCH_POLLERR, rtp_session->pool);

	if (rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP]) {
		if ((status = enable_local_rtcp_socket(rtp_session, err)) == SWITCH_STATUS_SUCCESS) {
			*err = "Success";
		}
	} else {
		status = SWITCH_STATUS_SUCCESS;
		*err = "Success";
	}

	switch_rtp_set_flag(rtp_session, SWITCH_RTP_FLAG_IO);

 done:

	if (new_sock) {
		switch_socket_close(new_sock);
	}

	if (old_sock) {
		switch_socket_close(old_sock);
	}


	if (rtp_session->ready != 1) {
		WRITE_DEC(rtp_session);
		READ_DEC(rtp_session);
	}

	return status;
}
