parse_access_log(CustomLog ** logs)
{
    const char *filename = ConfigParser::NextToken();
    if (!filename) {
        self_destruct();
        return;
    }

    const auto cl = new CustomLog();

    cl->filename = xstrdup(filename);

    if (strcmp(filename, "none") == 0) {
        cl->type = Log::Format::CLF_NONE;
        aclParseAclList(LegacyParser, &cl->aclList, filename);
        while (*logs)
            logs = &(*logs)->next;
        *logs = cl;
        return;
    }

    const char *token = ConfigParser::PeekAtToken();
    if (token && !strchr(token, '=')) { // style #3
        // TODO: Deprecate this style to avoid this dangerous guessing.
        if (Log::TheConfig.knownFormat(token)) {
            cl->setLogformat(token);
            (void)ConfigParser::NextToken(); // consume the token used above
        } else {
            // assume there is no explicit logformat name and use the default
            cl->setLogformat("squid");
        }
    } else { // style #1 or style #4
        // TODO: Drop deprecated style #1 support. We already warn about it, and
        // its exceptional treatment makes detecting "module" typos impractical!
        cl->parseOptions(LegacyParser, "squid");
    }
    assert(cl->type); // setLogformat() was called

    aclParseAclList(LegacyParser, &cl->aclList, cl->filename);

    while (*logs)
        logs = &(*logs)->next;

    *logs = cl;
}
