handle_ad(char const *ia_name, SIGNATURE_INFO_ACCESS *ia,
    char const *ad_name, int ad_nid, int uri_flags, bool required,
    int (*cb)(struct rpki_uri *, uint8_t, void *), void *arg)
{
# define AD_METHOD ((uri_flags & URI_VALID_RSYNC) == URI_VALID_RSYNC ? \
	"RSYNC" : \
	(((uri_flags & URI_VALID_HTTPS) == URI_VALID_HTTPS) ? \
	"HTTPS" : "RSYNC/HTTPS"))
	ACCESS_DESCRIPTION *ad;
	struct rpki_uri *uri;
	bool found = false;
	unsigned int i;
	int error;

	for (i = 0; i < sk_ACCESS_DESCRIPTION_num(ia); i++) {
		ad = sk_ACCESS_DESCRIPTION_value(ia, i);
		if (OBJ_obj2nid(ad->method) == ad_nid) {
			error = uri_create_ad(&uri, ad, uri_flags);
			switch (error) {
			case 0:
				break;
			case ENOTRSYNC:
				continue;
			case ENOTHTTPS:
				continue;
			case ENOTSUPPORTED:
				continue;
			default:
				return error;
			}

			if (found) {
				uri_refput(uri);
				return pr_val_err("Extension '%s' has multiple '%s' %s URIs.",
				    ia_name, ad_name, AD_METHOD);
			}

			error = cb(uri, i, arg);
			if (error) {
				uri_refput(uri);
				return error;
			}

			uri_refput(uri);
			found = true;
		}
	}

	if (required && !found) {
		pr_val_err("Extension '%s' lacks a '%s' valid %s URI.", ia_name,
		    ad_name, AD_METHOD);
		return -ESRCH;
	}

	return 0;
}
