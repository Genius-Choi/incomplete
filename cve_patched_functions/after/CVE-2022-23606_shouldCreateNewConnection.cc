bool ConnPoolImplBase::shouldCreateNewConnection(float global_preconnect_ratio) const {
  // If the host is not healthy, don't make it do extra work, especially as
  // upstream selection logic may result in bypassing this upstream entirely.
  // If an Envoy user wants preconnecting for degraded upstreams this could be
  // added later via extending the preconnect config.
  if (host_->health() != Upstream::Host::Health::Healthy) {
    return pending_streams_.size() > connecting_stream_capacity_;
  }

  // Determine if we are trying to prefetch for global preconnect or local preconnect.
  if (global_preconnect_ratio != 0) {
    // If global preconnecting is on, and this connection is within the global
    // preconnect limit, preconnect.
    // For global preconnect, we anticipate an incoming stream to this pool, since it is
    // prefetching for the next upcoming stream, which will likely be assigned to this pool.
    // We may eventually want to track preconnect_attempts to allow more preconnecting for
    // heavily weighted upstreams or sticky picks.
    return shouldConnect(pending_streams_.size(), num_active_streams_, connecting_stream_capacity_,
                         global_preconnect_ratio, true);
  } else {
    // Ensure this local pool has adequate connections for the given load.
    //
    // Local preconnect does not need to anticipate a stream. It is called as
    // new streams are established or torn down and simply attempts to maintain
    // the correct ratio of streams and anticipated capacity.
    return shouldConnect(pending_streams_.size(), num_active_streams_, connecting_stream_capacity_,
                         perUpstreamPreconnectRatio());
  }
}
