pdfioDictCopy(pdfio_file_t *pdf,	// I - PDF file
              pdfio_dict_t *dict)	// I - Original dictionary
{
  pdfio_dict_t		*ndict;		// New dictionary
  size_t		i;		// Looping var
  _pdfio_pair_t		*p;		// Current source pair
  const char		*key;		// Current destination key
  _pdfio_value_t	v;		// Current destination value


  PDFIO_DEBUG("pdfioDictCopy(pdf=%p, dict=%p(%p))\n", pdf, dict, dict ? dict->pdf : NULL);

  // Create the new dictionary...
  if ((ndict = pdfioDictCreate(pdf)) == NULL)
    return (NULL);

  // Pre-allocate the pairs array to make this a little faster...
  if ((ndict->pairs = (_pdfio_pair_t *)malloc(dict->num_pairs * sizeof(_pdfio_pair_t))) == NULL)
    return (NULL);			// Let pdfioFileClose do the cleanup...

  ndict->alloc_pairs = dict->num_pairs;

  // Copy and add each of the source dictionary's key/value pairs...
  for (i = dict->num_pairs, p = dict->pairs; i > 0; i --, p ++)
  {
    if (!strcmp(p->key, "Length") && p->value.type == PDFIO_VALTYPE_INDIRECT && dict->pdf != pdf)
    {
      // Don't use indirect stream lengths for copied objects...
      pdfio_obj_t *lenobj = pdfioFileFindObj(dict->pdf, p->value.value.indirect.number);
					// Length object

      v.type = PDFIO_VALTYPE_NUMBER;
      if (lenobj)
      {
        if (lenobj->value.type == PDFIO_VALTYPE_NONE)
          _pdfioObjLoad(lenobj);

	v.value.number = lenobj->value.value.number;
      }
      else
        v.value.number = 0.0;
    }
    else if (!_pdfioValueCopy(pdf, &v, dict->pdf, &p->value))
      return (NULL);			// Let pdfioFileClose do the cleanup...

    if (_pdfioStringIsAllocated(dict->pdf, p->key))
      key = pdfioStringCreate(pdf, p->key);
    else
      key = p->key;

    if (!key)
      return (NULL);			// Let pdfioFileClose do the cleanup...

    // Cannot fail since we already allocated space for the pairs...
    _pdfioDictSetValue(ndict, key, &v);
  }

  // Successfully copied the dictionary, so return it...
  return (ndict);
}
