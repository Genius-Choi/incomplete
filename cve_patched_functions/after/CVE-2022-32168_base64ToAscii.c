int base64ToAscii(char *dest, const char *base64Str)
{
	static const int base64IndexArray[123] =
	{
		-1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, -1, -1, -1, -1, -1,
		-1, -1, -1, 62, -1, -1, -1, 63,
		52, 53, 54, 55 ,56, 57, 58, 59,
		60, 61, -1, -1, -1, -1, -1, -1,
		-1,  0,  1,  2,  3,  4,  5,  6,
			7,  8,  9, 10, 11, 12, 13, 14,
		15, 16, 17, 18, 19, 20, 21, 22,
		23, 24, 25, -1, -1, -1, -1 ,-1,
		-1, 26, 27, 28, 29, 30, 31, 32,
		33, 34, 35, 36, 37, 38, 39, 40,
		41, 42, 43, 44, 45, 46, 47, 48,
		49, 50, 51
	};

	size_t b64StrLen = strlen(base64Str);
	size_t nbLoop = b64StrLen / 4;

	size_t i = 0;
	int k = 0;

	enum {b64_just, b64_1padded, b64_2padded} padd = b64_just;
	for ( ; i < nbLoop ; i++)
	{
		size_t j = i * 4;
		UCHAR uc0, uc1, uc2, uc3, p0, p1;

		uc0 = (UCHAR)base64IndexArray[base64Str[j]];
		uc1 = (UCHAR)base64IndexArray[base64Str[j+1]];
		uc2 = (UCHAR)base64IndexArray[base64Str[j+2]];
		uc3 = (UCHAR)base64IndexArray[base64Str[j+3]];

		if ((static_cast<char>(uc0) == -1) || (static_cast<char>(uc1) == -1) || (static_cast<char>(uc2) == -1) || (static_cast<char>(uc3) == -1))
			return -1;

		if (base64Str[j+2] == '=') // && (uc3 == '=')
		{
			uc2 = uc3 = 0;
			padd = b64_2padded;
		}
		else if (base64Str[j+3] == '=')
		{
			uc3 = 0;
			padd = b64_1padded;
		}

		p0 = uc0 << 2;
		p1 = uc1 << 2;
		p1 >>= 6;
		dest[k++] = p0 | p1;

		p0 = uc1 << 4;
		p1 = uc2 << 2;
		p1 >>= 4;
		dest[k++] = p0 | p1;

		p0 = uc2 << 6;
		p1 = uc3;
		dest[k++] = p0 | p1;
	}

	//dest[k] = '\0';
	if (padd == b64_1padded)
	//	dest[k-1] = '\0';
		return k-1;
	else if (padd == b64_2padded)
	//	dest[k-2] = '\0';
		return k-2;

	return k;
}
