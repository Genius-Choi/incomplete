void EmitCatchAndFinallyBlocks(Js::ByteCodeLabel catchLabel,
    Js::ByteCodeLabel finallyLabel,
    Js::RegSlot iteratorLocation,
    Js::RegSlot shouldCallReturnFunctionLocation,
    Js::RegSlot shouldCallReturnFunctionLocationFinally,
    Js::RegSlot yieldExceptionLocation,
    Js::RegSlot yieldOffsetLocation,
    ByteCodeGenerator *byteCodeGenerator,
    FuncInfo *funcInfo
    )
{
    bool isCoroutine = funcInfo->byteCodeFunction->IsCoroutine();
    if (isCoroutine)
    {
        byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();
    }

    EmitTopLevelCatch(catchLabel,
        iteratorLocation,
        shouldCallReturnFunctionLocation,
        shouldCallReturnFunctionLocationFinally,
        byteCodeGenerator,
        funcInfo);

    if (isCoroutine)
    {
        byteCodeGenerator->tryScopeRecordsList.UnlinkFromEnd();
    }

    EmitTopLevelFinally(finallyLabel,
        iteratorLocation,
        shouldCallReturnFunctionLocationFinally,
        yieldExceptionLocation,
        yieldOffsetLocation,
        byteCodeGenerator,
        funcInfo);

    funcInfo->ReleaseTmpRegister(shouldCallReturnFunctionLocationFinally);
    funcInfo->ReleaseTmpRegister(shouldCallReturnFunctionLocation);
}
