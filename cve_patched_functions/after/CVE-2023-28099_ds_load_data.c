static ds_data_t* ds_load_data(ds_partition_t *partition, int use_state_col)
{
	ds_data_t *d_data;
	int i, id, nr_rows, cnt, nr_cols = 8;
	int state;
	int weight;
	int prio;
	struct socket_info *sock;
	str uri;
	str attrs, weight_st;
	str description;
	db_res_t * res = NULL;
	db_val_t * values;
	db_row_t * rows;

	db_key_t query_cols[8] = {&ds_set_id_col, &ds_dest_uri_col,
			&ds_dest_sock_col, &ds_dest_weight_col, &ds_dest_attrs_col,
			&ds_dest_prio_col, &ds_dest_description_col, &ds_dest_state_col};

	if (!use_state_col)
		nr_cols--;

	if(*partition->db_handle == NULL){
			LM_ERR("invalid DB handler\n");
			return NULL;
	}

	if (partition->dbf.use_table(*partition->db_handle, &partition->table_name)
	< 0) {
		LM_ERR("error in use_table\n");
		return NULL;
	}

	d_data = (ds_data_t*)shm_malloc( sizeof(ds_data_t) );
	if (d_data==NULL) {
		LM_ERR("failed to allocate new data structure in shm\n");
		return NULL;
	}
	memset( d_data, 0, sizeof(ds_data_t));

	/*select the whole table and all the columns*/
	if(partition->dbf.query(*partition->db_handle,0,0,0,query_cols,0,nr_cols,
	0,&res) < 0) {
		LM_ERR("error while querying database\n");
		goto error;
	}

	nr_rows = RES_ROW_N(res);
	rows = RES_ROWS(res);
	if(nr_rows == 0) {
		LM_WARN("no dispatching data in the db -- empty destination set\n");
		goto load_done;
	}

	cnt = 0;

	for(i=0; i<nr_rows; i++) {

		values = ROW_VALUES(rows+i);

		/* id */
		if (VAL_NULL(values)) {
			LM_ERR("ds ID column cannot be NULL -> skipping\n");
			continue;
		}
		id = VAL_INT(values);

		/* uri */
		get_str_from_dbval( "URI", values+1,
			1/*not_null*/, 1/*not_empty*/, uri, error2);

		/* sock */
		get_str_from_dbval( "SOCKET", values+2,
			0/*not_null*/, 0/*not_empty*/, attrs, error2);
		if ( attrs.len ) {
			sock = parse_sock_info(&attrs);
			if (sock == NULL) {
				LM_ERR("socket <%.*s> is not local to opensips (we must "
					"listen on it) -> ignoring it\n", attrs.len, attrs.s);
			}
		} else {
			sock = NULL;
		}

		weight = 1;

		/* weight */
		if (values[3].type == DB_INT) {
			weight = VAL_INT(values+3);
			memset(&weight_st, 0, sizeof weight_st);
		} else {
			/* dynamic weight, given as a communication socket string */
			get_str_from_dbval("WEIGHT", values+3,
			                   0/*not_null*/, 0/*not_empty*/, weight_st, error2);
			if (!is_fs_url(&weight_st)) {
				str2int(&weight_st, (unsigned int *)&weight);
				memset(&weight_st, 0, sizeof weight_st);
			}
		}

		/* attrs */
		get_str_from_dbval( "ATTRIBUTES", values+4,
			0/*not_null*/, 0/*not_empty*/, attrs, error2);

		/* priority */
		if (VAL_NULL(values+5))
			prio = 0;
		else
			prio = VAL_INT(values+5);

		/* state */
		if (!use_state_col || VAL_NULL(values+7))
			/* active state */
			state = 0;
		else
			state = VAL_INT(values+7);

		get_str_from_dbval( "DESCRIPTION", values+6,
			0/*not_null*/, 0/*not_empty*/, description, error2);

		if (add_dest2list(id, uri, sock, &weight_st, state, weight, prio, attrs, description, d_data)
		!= 0) {
			LM_WARN("failed to add destination <%.*s> in group %d\n",
				uri.len,uri.s,id);
			continue;
		} else {
			cnt++;
		}
	}

	if (cnt==0) {
		LM_WARN("No record loaded from db, running on empty sets\n");
	} else {
		if(reindex_dests( d_data )!=0) {
			LM_ERR("error on reindex\n");
			goto error2;
		}
	}

load_done:
	partition->dbf.free_result(*partition->db_handle, res);
	return d_data;

error:
	ds_destroy_data_set( d_data );
	return NULL;
error2:
	ds_destroy_data_set( d_data );
	partition->dbf.free_result(*partition->db_handle, res);
	return NULL;
}
