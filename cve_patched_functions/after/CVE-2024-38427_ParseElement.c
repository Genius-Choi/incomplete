bool CIccTagXmlMultiProcessElement::ParseElement(xmlNode *pNode, std::string &parseStr)
{
  xmlAttr *attr;

  if (pNode->type != XML_ELEMENT_NODE) {
    return false;
  }

  CIccMultiProcessElement *pMpe = CreateElement((const icChar*)pNode->name);

  if (!pMpe) {
    parseStr += std::string("Unknown Element Type (") + (const icChar*)pNode->name + ")\n";
    return false;
  }

  CIccMultiProcessElementPtr ptr;

  IIccExtensionMpe *pExt = pMpe->GetExtension();

  if (pExt) {
    if (!strcmp(pExt->GetExtClassName(), "CIccMpeXml")) {
      CIccMpeXml* pXmlMpe = (CIccMpeXml*)pExt;

      if (pXmlMpe->ParseXml(pNode, parseStr)) {
        if ((attr=icXmlFindAttr(pNode, "Reserved"))) {
          sscanf(icXmlAttrValue(attr), "%u", &pMpe->m_nReserved);
        }

        ptr.ptr = pMpe;
        m_list->push_back(ptr);
      }
      else {
        parseStr += std::string("Unable to parse element of type ") + pMpe->GetClassName() + "\n";
        delete pMpe;
        return false;
      }
    }
    else {
      parseStr += std::string("Element ") + pMpe->GetClassName() + "isn't of type CIccMpeXml\n";
      delete pMpe;
      return false;
    }
  }
  else {
    parseStr += std::string("Element ") + pMpe->GetClassName() + "isn't of type CIccMpeXml\n";
    delete pMpe;
    return false;
  }

  return true;
}
