static ERL_NIF_TERM rsa_sign_nif(ErlNifEnv* env, int argc, const ERL_NIF_TERM argv[])
{/* (Type,Data,Key=[E,N,D]) */
    ErlNifBinary data_bin, ret_bin;
    ERL_NIF_TERM head, tail;
    unsigned char hmacbuf[SHA_DIGEST_LENGTH];
    unsigned rsa_s_len;
    RSA *rsa = RSA_new();
    int i, is_sha;

    if (argv[0] == atom_sha) is_sha = 1;
    else if (argv[0] == atom_md5) is_sha = 0;
    else goto badarg;

    if (!inspect_mpint(env,argv[1],&data_bin)
	|| !enif_get_list_cell(env, argv[2], &head, &tail)
	|| !get_bn_from_mpint(env, head, &rsa->e)
	|| !enif_get_list_cell(env, tail, &head, &tail)
	|| !get_bn_from_mpint(env, head, &rsa->n)
	|| !enif_get_list_cell(env, tail, &head, &tail)
	|| !get_bn_from_mpint(env, head, &rsa->d)
	|| !enif_is_empty_list(env,tail)) {
    badarg:
	RSA_free(rsa);
	return enif_make_badarg(env);
    }
    enif_alloc_binary(RSA_size(rsa), &ret_bin);
    if (is_sha) {
	SHA1(data_bin.data+4, data_bin.size-4, hmacbuf);
	ERL_VALGRIND_ASSERT_MEM_DEFINED(hmacbuf, SHA_DIGEST_LENGTH);
	i =  RSA_sign(NID_sha1, hmacbuf, SHA_DIGEST_LENGTH,
		      ret_bin.data, &rsa_s_len, rsa);
    }
    else {
	MD5(data_bin.data+4, data_bin.size-4, hmacbuf);
	ERL_VALGRIND_ASSERT_MEM_DEFINED(hmacbuf, MD5_DIGEST_LENGTH);
	i = RSA_sign(NID_md5, hmacbuf,MD5_DIGEST_LENGTH,
		     ret_bin.data, &rsa_s_len, rsa);     
    }
    RSA_free(rsa);
    if (i) {
	ERL_VALGRIND_MAKE_MEM_DEFINED(ret_bin.data, rsa_s_len);
	if (rsa_s_len != data_bin.size) {
	    enif_realloc_binary(&ret_bin, rsa_s_len);
	    ERL_VALGRIND_ASSERT_MEM_DEFINED(ret_bin.data, rsa_s_len);
	}
	return enif_make_binary(env,&ret_bin);
    }
    else {
	enif_release_binary(&ret_bin);
	return atom_error;
    }
}
