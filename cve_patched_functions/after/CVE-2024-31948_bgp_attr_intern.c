struct attr *bgp_attr_intern(struct attr *attr)
{
	struct attr *find;
	struct ecommunity *ecomm = NULL;
	struct ecommunity *ipv6_ecomm = NULL;
	struct lcommunity *lcomm = NULL;
	struct community *comm = NULL;

	/* Intern referenced structure. */
	if (attr->aspath) {
		if (!attr->aspath->refcnt)
			attr->aspath = aspath_intern(attr->aspath);
		else
			attr->aspath->refcnt++;
	}

	comm = bgp_attr_get_community(attr);
	if (comm) {
		if (!comm->refcnt)
			bgp_attr_set_community(attr, community_intern(comm));
		else
			comm->refcnt++;
	}

	ecomm = bgp_attr_get_ecommunity(attr);
	if (ecomm) {
		if (!ecomm->refcnt)
			bgp_attr_set_ecommunity(attr, ecommunity_intern(ecomm));
		else
			ecomm->refcnt++;
	}

	ipv6_ecomm = bgp_attr_get_ipv6_ecommunity(attr);
	if (ipv6_ecomm) {
		if (!ipv6_ecomm->refcnt)
			bgp_attr_set_ipv6_ecommunity(
				attr, ecommunity_intern(ipv6_ecomm));
		else
			ipv6_ecomm->refcnt++;
	}

	lcomm = bgp_attr_get_lcommunity(attr);
	if (lcomm) {
		if (!lcomm->refcnt)
			bgp_attr_set_lcommunity(attr, lcommunity_intern(lcomm));
		else
			lcomm->refcnt++;
	}

	struct cluster_list *cluster = bgp_attr_get_cluster(attr);

	if (cluster) {
		if (!cluster->refcnt)
			bgp_attr_set_cluster(attr, cluster_intern(cluster));
		else
			cluster->refcnt++;
	}

	struct transit *transit = bgp_attr_get_transit(attr);

	if (transit) {
		if (!transit->refcnt)
			bgp_attr_set_transit(attr, transit_intern(transit));
		else
			transit->refcnt++;
	}
	if (attr->encap_subtlvs) {
		if (!attr->encap_subtlvs->refcnt)
			attr->encap_subtlvs = encap_intern(attr->encap_subtlvs,
							   ENCAP_SUBTLV_TYPE);
		else
			attr->encap_subtlvs->refcnt++;
	}
	if (attr->srv6_l3vpn) {
		if (!attr->srv6_l3vpn->refcnt)
			attr->srv6_l3vpn = srv6_l3vpn_intern(attr->srv6_l3vpn);
		else
			attr->srv6_l3vpn->refcnt++;
	}
	if (attr->srv6_vpn) {
		if (!attr->srv6_vpn->refcnt)
			attr->srv6_vpn = srv6_vpn_intern(attr->srv6_vpn);
		else
			attr->srv6_vpn->refcnt++;
	}
#ifdef ENABLE_BGP_VNC
	struct bgp_attr_encap_subtlv *vnc_subtlvs =
		bgp_attr_get_vnc_subtlvs(attr);

	if (vnc_subtlvs) {
		if (!vnc_subtlvs->refcnt)
			bgp_attr_set_vnc_subtlvs(
				attr,
				encap_intern(vnc_subtlvs, VNC_SUBTLV_TYPE));
		else
			vnc_subtlvs->refcnt++;
	}
#endif

	/* At this point, attr only contains intern'd pointers.  that means
	 * if we find it in attrhash, it has all the same pointers and we
	 * correctly updated the refcounts on these.
	 * If we don't find it, we need to allocate a one because in all
	 * cases this returns a new reference to a hashed attr, but the input
	 * wasn't on hash. */
	find = (struct attr *)hash_get(attrhash, attr, bgp_attr_hash_alloc);
	find->refcnt++;

	return find;
}
