GF_Err gf_media_change_par(GF_ISOFile *file, u32 track, s32 ar_num, s32 ar_den, Bool force_par, Bool rewrite_bs)
{
	u32 tk_w, tk_h;
	GF_Err e;
	Bool get_par_info = GF_FALSE;

	e = gf_isom_get_visual_info(file, track, 1, &tk_w, &tk_h);
	if (e) return e;

	if ((ar_num < 0) || (ar_den < 0)) {
		get_par_info = GF_TRUE;
		rewrite_bs = GF_FALSE;
	}
	else if (!ar_num || !ar_den) {
		rewrite_bs = GF_FALSE;
	}

	if (get_par_info || rewrite_bs) {
		u32 stype = gf_isom_get_media_subtype(file, track, 1);
		if ((stype==GF_ISOM_SUBTYPE_AVC_H264)
				|| (stype==GF_ISOM_SUBTYPE_AVC2_H264)
				|| (stype==GF_ISOM_SUBTYPE_AVC3_H264)
				|| (stype==GF_ISOM_SUBTYPE_AVC4_H264)
		   ) {
#ifndef GPAC_DISABLE_AV_PARSERS
			GF_AVCConfig *avcc = gf_isom_avc_config_get(file, track, 1);
			if (rewrite_bs) {
				gf_avc_change_par(avcc, ar_num, ar_den);
				e = gf_isom_avc_config_update(file, track, 1, avcc);
			} else {
				GF_NALUFFParam *sl = gf_list_get(avcc->sequenceParameterSets, 0);
				if (sl) {
					gf_avc_get_sps_info(sl->data, sl->size, NULL, NULL, NULL, &ar_num, &ar_den);
				} else {
					ar_num = ar_den = 0;
				}
			}
			gf_odf_avc_cfg_del(avcc);
			if (e) return e;
#endif
		}
#if !defined(GPAC_DISABLE_AV_PARSERS)
		else if ((stype==GF_ISOM_SUBTYPE_HVC1) || (stype==GF_ISOM_SUBTYPE_HVC2)
			|| (stype==GF_ISOM_SUBTYPE_HEV1) || (stype==GF_ISOM_SUBTYPE_HEV2)
		) {
			GF_HEVCConfig *hvcc = gf_isom_hevc_config_get(file, track, 1);
			if (rewrite_bs) {
				gf_hevc_change_par(hvcc, ar_num, ar_den);
				e = gf_isom_hevc_config_update(file, track, 1, hvcc);
			} else {
				u32 i=0;
				GF_NALUFFParamArray *ar;
				ar_num = ar_den = 0;
				while ( (ar = gf_list_enum(hvcc->param_array, &i))) {
					if (ar->type==GF_HEVC_NALU_SEQ_PARAM) {
						GF_NALUFFParam *sl = gf_list_get(ar->nalus, 0);
						if (sl)
							gf_hevc_get_sps_info(sl->data, sl->size, NULL, NULL, NULL, &ar_num, &ar_den);
						break;
					}
				}
			}
			gf_odf_hevc_cfg_del(hvcc);
			if (e) return e;
		}
		else if (stype == GF_ISOM_SUBTYPE_AV01) {
			//GF_AV1Config *av1c = gf_isom_av1_config_get(file, track, 1);
			//TODO: e = gf_isom_av1_config_update(file, track, 1, av1c);
			//gf_odf_av1_cfg_del(av1c);
			//if (e) return e;
			return GF_NOT_SUPPORTED;
		}
		else if ((stype==GF_ISOM_SUBTYPE_VVC1) || (stype==GF_ISOM_SUBTYPE_VVI1)
		) {
			GF_VVCConfig *vvcc = gf_isom_vvc_config_get(file, track, 1);
			if (rewrite_bs) {
				gf_vvc_change_par(vvcc, ar_num, ar_den);
				e = gf_isom_vvc_config_update(file, track, 1, vvcc);
			} else {
				u32 i=0;
				GF_NALUFFParamArray *ar;
				ar_num = ar_den = 0;
				while ( (ar = gf_list_enum(vvcc->param_array, &i))) {
					if (ar->type==GF_VVC_NALU_SEQ_PARAM) {
						GF_NALUFFParam *sl = gf_list_get(ar->nalus, 0);
						if (sl)
							gf_vvc_get_sps_info(sl->data, sl->size, NULL, NULL, NULL, &ar_num, &ar_den);
						break;
					}
				}
			}
			gf_odf_vvc_cfg_del(vvcc);
			if (e) return e;
		}
#endif
		else if (stype==GF_ISOM_SUBTYPE_MPEG4) {
			GF_ESD *esd = gf_isom_get_esd(file, track, 1);
			if (!esd || !esd->decoderConfig || (esd->decoderConfig->streamType!=4) ) {
				if (esd) gf_odf_desc_del((GF_Descriptor *) esd);
				return GF_NOT_SUPPORTED;
			}
#ifndef GPAC_DISABLE_AV_PARSERS
			if (esd->decoderConfig->objectTypeIndication==GF_CODECID_MPEG4_PART2) {
				if (rewrite_bs) {
					e = gf_m4v_rewrite_par(&esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength, ar_num, ar_den);
					if (!e) e = gf_isom_change_mpeg4_description(file, track, 1, esd);
				} else {
					GF_M4VDecSpecInfo dsi;
					e = gf_m4v_get_config(esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, &dsi);
					ar_num = dsi.par_num;
					ar_den = dsi.par_den;
				}
				gf_odf_desc_del((GF_Descriptor *) esd);
				if (e) return e;
			}
#endif
		} else {
			u32 mtype = gf_isom_get_media_type(file, track);
			if (gf_isom_is_video_handler_type(mtype)) {
				if (rewrite_bs) {
					GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER,
						("[ISOBMF] Warning: changing pixel ratio of media subtype \"%s\" is not supported, changing only \"pasp\" signaling\n",
							gf_4cc_to_str(gf_isom_get_media_subtype(file, track, 1)) ));
				}
			} else {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[ISOBMF] Error: changing pixel ratio on non-video track.\n"));
				return GF_BAD_PARAM;
			}
		}
		//auto mode
		if (get_par_info && ((ar_num<=0) || (ar_den<=0))) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[ISOBMF] No sample AR info present in sample description, ignoring SAR update\n"));
			if (force_par)
				return gf_isom_set_pixel_aspect_ratio(file, track, 1, 1, 1, force_par);
			return GF_OK;
		}
	}
	e = gf_isom_set_pixel_aspect_ratio(file, track, 1, ar_num, ar_den, force_par);
	if (e) return e;

	if ((ar_den>0) && (ar_num>0)) {
		tk_w = tk_w * ar_num / ar_den;
	}
	/*PASP has been removed or forced to 1:1, revert to full frame for track layout*/
	else {
		e = gf_isom_get_visual_info(file, track, 1, &tk_w, &tk_h);
		if (e) return e;
	}
	return gf_isom_set_track_layout_info(file, track, tk_w<<16, tk_h<<16, 0, 0, 0);
}
