bool fastly_compute_at_edge_http_req_header_values_get(
    fastly_compute_at_edge_http_types_request_handle_t h, fastly_world_string_t *name,
    fastly_world_option_list_list_u8_t *ret, fastly_compute_at_edge_types_error_t *err) {

  std::vector<Chunk> header_values;

  {
    JS::UniqueLatin1Chars buffer(static_cast<unsigned char *>(cabi_malloc(HEADER_MAX_LEN, 1)));
    uint32_t cursor = 0;
    while (true) {
      int64_t ending_cursor = 0;
      size_t length = 0;
      auto res = fastly::req_header_values_get(h, reinterpret_cast<char *>(name->ptr), name->len,
                                               buffer.get(), HEADER_MAX_LEN, cursor, &ending_cursor,
                                               &length);
      if (!convert_result(res, err)) {
        return false;
      }

      if (length == 0) {
        break;
      }

      std::string_view result{reinterpret_cast<char *>(buffer.get()), length};
      while (!result.empty()) {
        auto end = result.find('\0');
        header_values.emplace_back(Chunk::make(result.substr(0, end)));
        if (end == result.npos) {
          break;
        }

        result = result.substr(end + 1);
      }

      if (ending_cursor < 0) {
        break;
      }
    }
  }

  if (header_values.empty()) {
    ret->is_some = false;
  } else {
    ret->is_some = true;
    ret->val.len = header_values.size();
    ret->val.ptr = static_cast<fastly_world_list_u8_t *>(cabi_malloc(
        header_values.size() * sizeof(fastly_world_list_u8_t), alignof(fastly_world_list_u8_t)));
    auto *next = ret->val.ptr;
    for (auto &chunk : header_values) {
      next->len = chunk.length;
      next->ptr = reinterpret_cast<uint8_t *>(chunk.buffer.release());
      ++next;
    }
  }

  return true;
}
