    OSStatus audio_io_osx::rec_process_impl(
                                           AudioUnitRenderActionFlags *ioActionFlags,
                                           const AudioTimeStamp *inTimeStamp,
                                           uint32_t inBusNumber,
                                           uint32_t inNumberFrames) {
        int16_t dataTmp[inNumberFrames];
        memset(dataTmp, 0, sizeof(int16_t)*inNumberFrames);
        AudioBufferList abList;
        abList.mNumberBuffers = 1;
        abList.mBuffers[0].mData = dataTmp;
        abList.mBuffers[0].mDataByteSize = sizeof(int16_t)*inNumberFrames;  // 2 bytes/sample
        abList.mBuffers[0].mNumberChannels = 1;
        
        // Get data from mic
        OSStatus res = AudioUnitRender(au_rec_,
                                       ioActionFlags, inTimeStamp,
                                       inBusNumber, inNumberFrames, &abList);
        
        if (res != 0) {
            warning("audio_io_osx: Error getting rec data, error = %d \n", res);
            return 0;
        }
        
        uint32_t tmp_rec_latency_ms = get_rec_latency(inTimeStamp);
        
        int32_t diff = (int32_t)tmp_rec_latency_ms - (int32_t)prev_rec_latency_ms_;
        if( diff > DELAY_JUMP_FOR_RESET_MS ){
            /* Sudden Jump in latency - AEC will have problems */
            rec_delay_warning_ = 1;
        }
        prev_rec_latency_ms_ = tmp_rec_latency_ms;
        
        rec_latency_ms_ = tmp_rec_latency_ms;
        
        if (is_recording_) {
            const unsigned int noSamp10ms = rec_fs_hz_ / 100;
            unsigned int dataPos = 0;
            uint16_t bufPos = 0;
            int16_t insertPos = -1;
            unsigned int nCopy = 0;  // Number of samples to copy
            
            while (dataPos < inNumberFrames) {
                // Loop over all recording buffers
                bufPos = 0;
                insertPos = -1;
                nCopy = 0;
                while (bufPos < REC_BUFFERS) {
                    if ((rec_length_[bufPos] > 0)
                        && (rec_length_[bufPos] < noSamp10ms)) {
                        insertPos = static_cast<int16_t>(bufPos);
                        bufPos = REC_BUFFERS;
                    } else if ((-1 == insertPos)
                               && (0 == rec_length_[bufPos])) {
                        insertPos = static_cast<int16_t>(bufPos);
                    }
                    ++bufPos;
                }
                
                // Insert data into buffer
                if (insertPos > -1) {
                    unsigned int dataToCopy = inNumberFrames - dataPos;
                    unsigned int currentRecLen = rec_length_[insertPos];
                    unsigned int roomInBuffer = noSamp10ms - currentRecLen;
                    nCopy = (dataToCopy < roomInBuffer ? dataToCopy : roomInBuffer);
                    
                    memcpy(&rec_buffer_[insertPos][currentRecLen],
                           &dataTmp[dataPos], nCopy*sizeof(int16_t));
                    
                    if (0 == currentRecLen) {
                        rec_seq_[insertPos] = rec_current_seq_;
                        ++rec_current_seq_;
                        
                    }
                    rec_buffer_total_size_ += nCopy;
                    rec_length_[insertPos] += nCopy;
                    dataPos += nCopy;
                } else {
                    error("audio_io_osx: Could not insert into recording buffer. Buffer is full \n");
                    dataPos = inNumberFrames;  // Don't try to insert more
                }
            }
        }
        
        /* wakeup the waiting thread */
        pthread_cond_signal(&cond_);
        
        return 0;
    }
