cifs_setup_session(const unsigned int xid, struct cifs_ses *ses,
		   struct TCP_Server_Info *server,
		   struct nls_table *nls_info)
{
	int rc = -ENOSYS;
	struct sockaddr_in6 *addr6 = (struct sockaddr_in6 *)&server->dstaddr;
	struct sockaddr_in *addr = (struct sockaddr_in *)&server->dstaddr;
	bool is_binding = false;

	spin_lock(&ses->ses_lock);
	if (server->dstaddr.ss_family == AF_INET6)
		scnprintf(ses->ip_addr, sizeof(ses->ip_addr), "%pI6", &addr6->sin6_addr);
	else
		scnprintf(ses->ip_addr, sizeof(ses->ip_addr), "%pI4", &addr->sin_addr);

	if (ses->ses_status != SES_GOOD &&
	    ses->ses_status != SES_NEW &&
	    ses->ses_status != SES_NEED_RECON) {
		spin_unlock(&ses->ses_lock);
		return 0;
	}

	/* only send once per connect */
	spin_lock(&ses->chan_lock);
	if (CIFS_ALL_CHANS_GOOD(ses) ||
	    cifs_chan_in_reconnect(ses, server)) {
		spin_unlock(&ses->chan_lock);
		spin_unlock(&ses->ses_lock);
		return 0;
	}
	is_binding = !CIFS_ALL_CHANS_NEED_RECONNECT(ses);
	cifs_chan_set_in_reconnect(ses, server);
	spin_unlock(&ses->chan_lock);

	if (!is_binding)
		ses->ses_status = SES_IN_SETUP;
	spin_unlock(&ses->ses_lock);

	if (!is_binding) {
		ses->capabilities = server->capabilities;
		if (!linuxExtEnabled)
			ses->capabilities &= (~server->vals->cap_unix);

		if (ses->auth_key.response) {
			cifs_dbg(FYI, "Free previous auth_key.response = %p\n",
				 ses->auth_key.response);
			kfree_sensitive(ses->auth_key.response);
			ses->auth_key.response = NULL;
			ses->auth_key.len = 0;
		}
	}

	cifs_dbg(FYI, "Security Mode: 0x%x Capabilities: 0x%x TimeAdjust: %d\n",
		 server->sec_mode, server->capabilities, server->timeAdj);

	if (server->ops->sess_setup)
		rc = server->ops->sess_setup(xid, ses, server, nls_info);

	if (rc) {
		cifs_server_dbg(VFS, "Send error in SessSetup = %d\n", rc);
		spin_lock(&ses->ses_lock);
		if (ses->ses_status == SES_IN_SETUP)
			ses->ses_status = SES_NEED_RECON;
		spin_lock(&ses->chan_lock);
		cifs_chan_clear_in_reconnect(ses, server);
		spin_unlock(&ses->chan_lock);
		spin_unlock(&ses->ses_lock);
	} else {
		spin_lock(&ses->ses_lock);
		if (ses->ses_status == SES_IN_SETUP)
			ses->ses_status = SES_GOOD;
		spin_lock(&ses->chan_lock);
		cifs_chan_clear_in_reconnect(ses, server);
		cifs_chan_clear_need_reconnect(ses, server);
		spin_unlock(&ses->chan_lock);
		spin_unlock(&ses->ses_lock);
	}

	return rc;
}
