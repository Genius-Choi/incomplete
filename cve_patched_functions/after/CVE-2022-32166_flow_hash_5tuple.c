flow_hash_5tuple(const struct flow *flow, uint32_t basis)
{
    BUILD_ASSERT_DECL(FLOW_WC_SEQ == 41);
    uint32_t hash = basis;

    if (flow) {

        if (flow->dl_type == htons(ETH_TYPE_IPV6)) {
            const uint64_t *flow_u64 = (const uint64_t *)flow;
            int ofs = offsetof(struct flow, ipv6_src) / 8;
            int end = ofs + 2 * sizeof flow->ipv6_src / 8;

            for (;ofs < end; ofs++) {
                hash = hash_add64(hash, flow_u64[ofs]);
            }
        } else if (flow->dl_type == htons(ETH_TYPE_IP)
                   || flow->dl_type == htons(ETH_TYPE_ARP)) {
            hash = hash_add(hash, (OVS_FORCE uint32_t) flow->nw_src);
            hash = hash_add(hash, (OVS_FORCE uint32_t) flow->nw_dst);
        } else {
            goto out;
        }

        hash = hash_add(hash, flow->nw_proto);
        if (flow->nw_proto != IPPROTO_TCP && flow->nw_proto != IPPROTO_UDP
            && flow->nw_proto != IPPROTO_SCTP && flow->nw_proto != IPPROTO_ICMP
            && flow->nw_proto != IPPROTO_ICMPV6) {
            goto out;
        }

        /* Add both ports at once. */
        hash = hash_add(hash,
                        ((const uint32_t *)flow)[offsetof(struct flow, tp_src)
                                                 / sizeof(uint32_t)]);
    }
out:
    return hash_finish(hash, 42); /* Arbitrary number. */
}
