static void async_nb_do_async_transaction(ASYNC_JOB *job, neverbleed_iobuf_t *buf)
{
    struct async_nb_transaction_fd_notify_t transaction = {{.buf = buf, .on_read_complete = async_nb_notify_fd}};
    int readfd;

    /* setup fd to notify OpenSSL; eventfd is used if available, as it is lightweight and uses only one file descriptor */
#if ASYNC_NB_USE_EVENTFD
    if ((transaction.notify_fd = eventfd(0, EFD_CLOEXEC)) == -1) {
        char errbuf[256];
        h2o_fatal("eventfd:%s", h2o_strerror_r(errno, errbuf, sizeof(errbuf)));
    }
    readfd = transaction.notify_fd;
#else
    {
        int pipefds[2];
        if (cloexec_pipe(pipefds) == -1) {
            char errbuf[256];
            h2o_fatal("pipe:%s", h2o_strerror_r(errno, errbuf, sizeof(errbuf)));
        }
        readfd = pipefds[0];
        transaction.notify_fd = pipefds[1];
    }
#endif

    /* register the request and kick the write operation */
    async_nb_push(&async_nb.write_queue, &transaction.super);
    async_nb_submit_write_pending();

    { /* setup file descriptor and call `ASYNC_pause_job`, to yield the operation back to the original fiber, until
       * `nb_read_ready` notifies the this fiber (in paused state) to resume. */
        size_t numfds;
        ASYNC_WAIT_CTX *waitctx = ASYNC_get_wait_ctx(job);
        assert(ASYNC_WAIT_CTX_get_all_fds(waitctx, NULL, &numfds) && numfds == 0);
        if (!ASYNC_WAIT_CTX_set_wait_fd(waitctx, "neverbleed", readfd, NULL, NULL))
            h2o_fatal("could not set async fd");
        ASYNC_pause_job();
        if (!ASYNC_WAIT_CTX_clear_fd(waitctx, "neverbleed"))
            h2o_fatal("could not clear async fd");
    }

    assert(!h2o_linklist_is_linked(&transaction.super.link));

    /* close the notification file descriptors used for notification */
#if !ASYNC_NB_USE_EVENTFD
    close(readfd);
#endif
    close(transaction.notify_fd);
}
