static int sip_endpoint_apply_handler(const struct ast_sorcery *sorcery, void *obj)
{
	struct ast_sip_endpoint *endpoint = obj;

	if (!(endpoint->persistent = persistent_endpoint_find_or_create(endpoint))) {
		return -1;
	}

	if (endpoint->extensions.timer.min_se < 90) {
		ast_log(LOG_ERROR, "Session timer minimum expires time must be 90 or greater on endpoint '%s'\n",
			ast_sorcery_object_get_id(endpoint));
		return -1;
	} else if (endpoint->extensions.timer.sess_expires < endpoint->extensions.timer.min_se) {
		ast_log(LOG_ERROR, "Session timer expires must be greater than minimum session expires time on endpoint '%s'\n",
			ast_sorcery_object_get_id(endpoint));
		return -1;
	}

	if (ast_rtp_dtls_cfg_validate(&endpoint->media.rtp.dtls_cfg)) {
		return -1;
	}

	if (endpoint->preferred_codec_only) {
		if (endpoint->media.incoming_call_offer_pref.flags != (AST_SIP_CALL_CODEC_PREF_LOCAL | AST_SIP_CALL_CODEC_PREF_INTERSECT | AST_SIP_CALL_CODEC_PREF_ALL)) {
			ast_log(LOG_ERROR, "Setting both preferred_codec_only and incoming_call_offer_pref is not supported on endpoint '%s'\n",
				ast_sorcery_object_get_id(endpoint));
			return -1;
		}
		ast_clear_flag(&endpoint->media.incoming_call_offer_pref, AST_SIP_CALL_CODEC_PREF_ALL);
		ast_set_flag(&endpoint->media.incoming_call_offer_pref, AST_SIP_CALL_CODEC_PREF_FIRST);
	}

	endpoint->media.topology = ast_stream_topology_create_from_format_cap(endpoint->media.codecs);
	if (!endpoint->media.topology) {
		return -1;
	}

	endpoint->media.rtcp_mux |= endpoint->media.bundle;

	/*
	 * If webrtc has been enabled then enable those attributes, and default
	 * some, that are needed in order for webrtc to work.
	 */
	endpoint->media.bundle |= endpoint->media.webrtc;
	endpoint->media.rtcp_mux |= endpoint->media.webrtc;
	endpoint->media.rtp.use_avpf |= endpoint->media.webrtc;
	endpoint->media.rtp.ice_support |= endpoint->media.webrtc;
	endpoint->media.rtp.use_received_transport |= endpoint->media.webrtc;

	if (endpoint->media.webrtc) {
		endpoint->media.rtp.encryption = AST_SIP_MEDIA_ENCRYPT_DTLS;
		endpoint->media.rtp.dtls_cfg.enabled = 1;
		endpoint->media.rtp.dtls_cfg.default_setup = AST_RTP_DTLS_SETUP_ACTPASS;
		endpoint->media.rtp.dtls_cfg.verify = AST_RTP_DTLS_VERIFY_FINGERPRINT;

		/* RFC8827 says: Implementations MUST NOT implement DTLS renegotiation
		 * and MUST reject it with a "no_renegotiation" alert if offered. */
		if (endpoint->media.rtp.dtls_cfg.rekey) {
			ast_log(LOG_WARNING, "DTLS renegotiation is not supported with WebRTC. Disabling dtls_rekey.\n");
			endpoint->media.rtp.dtls_cfg.rekey = 0;
		}

		if (ast_strlen_zero(endpoint->media.rtp.dtls_cfg.certfile)) {
			/* If no certificate has been specified, try to automatically create one */
			endpoint->media.rtp.dtls_cfg.ephemeral_cert = 1;
		}
	}

	if (!ast_strlen_zero(endpoint->geoloc_incoming_call_profile) ||
		!ast_strlen_zero(endpoint->geoloc_outgoing_call_profile)) {

		if (!ast_geoloc_is_loaded()) {
			ast_log(LOG_ERROR, "A geoloc incoming and/or outgoing call_profile was specified on endpoint '%s'"
				" but res_geolocation is not loaded.\n", ast_sorcery_object_get_id(endpoint));
			return -1;
		}

		if (!ast_strlen_zero(endpoint->geoloc_incoming_call_profile)) {
			struct ast_geoloc_profile *profile = ast_geoloc_get_profile(endpoint->geoloc_incoming_call_profile);
			if (!profile) {
				ast_log(LOG_ERROR, "geoloc_incoming_call_profile '%s' on endpoint '%s' doesn't exist\n",
					endpoint->geoloc_incoming_call_profile, ast_sorcery_object_get_id(endpoint));
				return -1;
			}
			ao2_cleanup(profile);
		}

		if (!ast_strlen_zero(endpoint->geoloc_outgoing_call_profile)) {
			struct ast_geoloc_profile *profile = ast_geoloc_get_profile(endpoint->geoloc_outgoing_call_profile);
			if (!profile) {
				ast_log(LOG_ERROR, "geoloc_outgoing_call_profile '%s' on endpoint '%s' doesn't exist\n",
					endpoint->geoloc_outgoing_call_profile, ast_sorcery_object_get_id(endpoint));
				return -1;
			}
			ao2_cleanup(profile);
		}
	}

	return 0;
}
