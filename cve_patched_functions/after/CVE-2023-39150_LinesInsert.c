BOOL CEAnsi::LinesInsert(HANDLE hConsoleOutput, const unsigned linesCount) const
{
	CONSOLE_SCREEN_BUFFER_INFO csbi = {};
	if (!GetConsoleScreenBufferInfoCached(hConsoleOutput, &csbi))
	{
		_ASSERTEX(FALSE && "GetConsoleScreenBufferInfoCached failed");
		return FALSE;
	}

	// Apply default color before scrolling!
	ReSetDisplayParm(hConsoleOutput, FALSE, TRUE);

	if (static_cast<int>(linesCount) <= 0)
	{
		_ASSERTEX(static_cast<int>(linesCount) >= 0);
		return FALSE;
	}

	BOOL lbRc = FALSE;

	int TopLine, BottomLine;
	if (gDisplayOpt.ScrollRegion)
	{
		_ASSERTEX(gDisplayOpt.ScrollStart>=0 && gDisplayOpt.ScrollEnd>=gDisplayOpt.ScrollStart);
		if (csbi.dwCursorPosition.Y < gDisplayOpt.ScrollStart || csbi.dwCursorPosition.Y > gDisplayOpt.ScrollEnd)
			return TRUE;
		TopLine = csbi.dwCursorPosition.Y;
		BottomLine = std::max<int>(gDisplayOpt.ScrollEnd, 0);

		if (static_cast<int>(linesCount) <= (BottomLine - TopLine))
		{
			ExtScrollScreenParm scroll = {
				sizeof(scroll), essf_Current|essf_Commit|essf_Region, hConsoleOutput,
				static_cast<int>(linesCount), {}, L' ',
				// region to be scrolled (that is not a clipping region)
				{0, TopLine, csbi.dwSize.X - 1, BottomLine}};
			lbRc |= ExtScrollScreen(&scroll);
		}
		else
		{
			ExtFillOutputParm fill = {
				sizeof(fill), efof_Attribute|efof_Character, hConsoleOutput,
				{}, L' ', {0, MakeShort(TopLine)}, csbi.dwSize.X * linesCount};
			lbRc |= ExtFillOutput(&fill);
		}
	}
	else
	{
		// What we need to scroll? Buffer or visible rect?
		TopLine = csbi.dwCursorPosition.Y;
		BottomLine = (csbi.dwCursorPosition.Y <= csbi.srWindow.Bottom)
			? csbi.srWindow.Bottom
			: csbi.dwSize.Y - 1;

		ExtScrollScreenParm scroll = {
			sizeof(scroll), essf_Current|essf_Commit|essf_Region, hConsoleOutput,
			static_cast<int>(linesCount), {}, L' ', {0, TopLine, csbi.dwSize.X-1, BottomLine}};
		lbRc |= ExtScrollScreen(&scroll);
	}

	return lbRc;
}
