int main(int argc,char**argv) {
	if(argc == 1) return usage(argv[0]);
	min = 127;
	max = -60;
	outfd = -1;
	char errbuf[PCAP_ERRBUF_SIZE];
	pcap_t *foo;
	if(strchr(argv[1], '.') && access(argv[1], R_OK) == 0) {
		filebased = 1;
		foo = pcap_open_offline(argv[1], errbuf);
	} else {
		foo = pcap_create(argv[1], errbuf);
		outfd= open("tmp.pcap", O_WRONLY|O_CREAT|O_TRUNC,0660);
		if(outfd != -1)
			write(outfd, "\xD4\xC3\xB2\xA1" "\x02\x00\x04\x00"
			             "\x00\x00\x00\x00" "\x00\x00\x00\x00"
			             "\x00\x00\x04\x00" "\x7F\x00\x00\x00", 24);
	}
	if(!foo) { dprintf(2, "%s\n", errbuf); return 1; }

	int ret, wasdown, orgmode;

	if(filebased) goto skip;

	if((orgmode = getiwmode(argv[1])) != IW_MODE_MONITOR) {
		if((ret = ifdownup(argv[1], 0, 0)) == -1) {
			iferr:;
			perror("error setting up interface - maybe need to run as root.");
		}
		wasdown = (ret == 2);
		if(setiwmode(argv[1], IW_MODE_MONITOR) == -1) goto iferr;
	} else {
		wasdown = (ifdownup(argv[1], 0, 1) == 2);
	}
	if(ifdownup(argv[1], 1, 0) == -1) goto iferr;

	if(pcap_activate(foo)) {
		dprintf(2, "pcap_activate failed: %s\n", pcap_geterr(foo));
		return 1;
	}

	skip:;

	initconcol();

	signal(SIGINT, sigh);

	int channel = 1;
	long long tm = 0;
	pthread_t bt, wt, ct;
	pthread_create(&wt, 0, chanwalker_thread, argv[1]);
	pthread_create(&ct, 0, capture_thread, foo);

	while(!stop) {
		long long tmp = getutime64();
		if((tmp-tm) >= (1000000 / GUI_FPS)) {
			tm = tmp;
			dump();
		}

		if(selected) calc_bms(selection);
		int k = console_getkey_nb(t);

		switch(k) {
			case '+': case '0': volume_change(+1); break;
			case '-': case '9': volume_change(-1); break;
			case CK_CURSOR_DOWN: selection_move(1);break;
			case CK_CURSOR_UP: selection_move(-1);break;
			case CK_RETURN:
				selected = !selected;
				if(selected) {
					pthread_join(wt, 0);
					draw_bg();
					pthread_create(&bt, 0, blip_thread, 0);
					if(!filebased) set_channel(argv[1], wlans[selection].channel);
				} else {
					pthread_create(&wt, 0, chanwalker_thread, argv[1]);
					pthread_join(bt, 0);
				}
				break;
			case CK_QUIT:
			case CK_ESCAPE: stop = 1; break;
		}
		usleep(1000);
	}

	pcap_breakloop(foo); // this doesn't actually seem to work

	if(selected) {
		selected = 0;
		pthread_join(bt, 0);
	} else {
		selected = 1;
		pthread_join(wt, 0);
	}

	// since our capture_thread uses blocking reads in order to keep CPU usage
	// minimal, we need to get the current read cancelled - and if no packets
	// arrive, this can take a *long* time. since pcap_breakloop() doesn't actually
	// seem to work, the only way i found to break out of the read is to actually
	// bring down the interface - so this must happen before we join the thread
	// and close the pcap handle.
	if(!filebased) {
		if(wasdown || orgmode != IW_MODE_MONITOR) ifdownup(argv[1], 0, 0);
		if(orgmode != IW_MODE_MONITOR) setiwmode(argv[1], orgmode);
		if(!wasdown && orgmode != IW_MODE_MONITOR) ifdownup(argv[1], 1, 0);
	}

	pthread_join(ct, 0);

	pcap_close(foo);
	console_cleanup(t);
	if(outfd != -1) close(outfd);
	return 0;
}
