static void LogPackages(
    __in_opt const BURN_PACKAGE* pUpgradeBundlePackage,
    __in_opt const BURN_PACKAGE* pForwardCompatibleBundlePackage,
    __in const BURN_PACKAGES* pPackages,
    __in const BURN_RELATED_BUNDLES* pRelatedBundles,
    __in const BOOTSTRAPPER_ACTION action
    )
{
    BOOL fUninstalling = BOOTSTRAPPER_ACTION_UNINSTALL == action || BOOTSTRAPPER_ACTION_UNSAFE_UNINSTALL == action;

    if (pUpgradeBundlePackage)
    {
        LogId(REPORT_STANDARD, MSG_PLANNED_UPGRADE_BUNDLE, pUpgradeBundlePackage->sczId, LoggingRequestStateToString(pUpgradeBundlePackage->defaultRequested), LoggingRequestStateToString(pUpgradeBundlePackage->requested), LoggingActionStateToString(pUpgradeBundlePackage->execute), LoggingActionStateToString(pUpgradeBundlePackage->rollback), LoggingDependencyActionToString(pUpgradeBundlePackage->dependencyExecute));
    }
    else if (pForwardCompatibleBundlePackage)
    {
        LogId(REPORT_STANDARD, MSG_PLANNED_FORWARD_COMPATIBLE_BUNDLE, pForwardCompatibleBundlePackage->sczId, LoggingRequestStateToString(pForwardCompatibleBundlePackage->defaultRequested), LoggingRequestStateToString(pForwardCompatibleBundlePackage->requested), LoggingActionStateToString(pForwardCompatibleBundlePackage->execute), LoggingActionStateToString(pForwardCompatibleBundlePackage->rollback), LoggingDependencyActionToString(pForwardCompatibleBundlePackage->dependencyExecute));
    }
    else
    {
        // Display related bundles first if uninstalling.
        if (fUninstalling)
        {
            LogRelatedBundles(pRelatedBundles, TRUE);
        }

        // Display all the packages in the log.
        for (DWORD i = 0; i < pPackages->cPackages; ++i)
        {
            const DWORD iPackage = fUninstalling ? pPackages->cPackages - 1 - i : i;
            const BURN_PACKAGE* pPackage = &pPackages->rgPackages[iPackage];

            if (!fUninstalling && pPackage->pRollbackBoundaryForward)
            {
                LogRollbackBoundary(pPackage->pRollbackBoundaryForward);
            }
            else if (fUninstalling && pPackage->pRollbackBoundaryBackward)
            {
                LogRollbackBoundary(pPackage->pRollbackBoundaryBackward);
            }

            LogId(REPORT_STANDARD, MSG_PLANNED_PACKAGE, pPackage->sczId, LoggingPackageStateToString(pPackage->currentState), LoggingRequestStateToString(pPackage->defaultRequested), LoggingRequestStateToString(pPackage->requested), LoggingActionStateToString(pPackage->execute), LoggingActionStateToString(pPackage->rollback), LoggingCacheTypeToString(pPackage->authoredCacheType), LoggingCacheTypeToString(pPackage->cacheType), LoggingPlannedCacheToString(pPackage), LoggingBoolToString(pPackage->fPlannedUncache), LoggingDependencyActionToString(pPackage->dependencyExecute), LoggingPackageRegistrationStateToString(pPackage->fCanAffectRegistration, pPackage->expectedInstallRegistrationState), LoggingPackageRegistrationStateToString(pPackage->fCanAffectRegistration, pPackage->expectedCacheRegistrationState));

            if (BURN_PACKAGE_TYPE_MSI == pPackage->type)
            {
                if (pPackage->Msi.cFeatures)
                {
                    LogId(REPORT_STANDARD, MSG_PLANNED_MSI_FEATURES, pPackage->Msi.cFeatures, pPackage->sczId);

                    for (DWORD j = 0; j < pPackage->Msi.cFeatures; ++j)
                    {
                        const BURN_MSIFEATURE* pFeature = &pPackage->Msi.rgFeatures[j];

                        LogId(REPORT_STANDARD, MSG_PLANNED_MSI_FEATURE, pFeature->sczId, LoggingMsiFeatureStateToString(pFeature->currentState), LoggingMsiFeatureStateToString(pFeature->defaultRequested), LoggingMsiFeatureStateToString(pFeature->requested), LoggingMsiFeatureActionToString(pFeature->execute), LoggingMsiFeatureActionToString(pFeature->rollback));
                    }
                }

                if (pPackage->Msi.cSlipstreamMspPackages)
                {
                    LogId(REPORT_STANDARD, MSG_PLANNED_SLIPSTREAMED_MSP_TARGETS, pPackage->Msi.cSlipstreamMspPackages, pPackage->sczId);

                    for (DWORD j = 0; j < pPackage->Msi.cSlipstreamMspPackages; ++j)
                    {
                        const BURN_SLIPSTREAM_MSP* pSlipstreamMsp = &pPackage->Msi.rgSlipstreamMsps[j];

                        LogId(REPORT_STANDARD, MSG_PLANNED_SLIPSTREAMED_MSP_TARGET, pSlipstreamMsp->pMspPackage->sczId, LoggingActionStateToString(pSlipstreamMsp->execute), LoggingActionStateToString(pSlipstreamMsp->rollback));
                    }
                }

                if (pPackage->compatiblePackage.fRemove)
                {
                    LogId(REPORT_STANDARD, MSG_PLANNED_ORPHAN_PACKAGE_FROM_PROVIDER, pPackage->sczId, pPackage->compatiblePackage.compatibleEntry.sczId, pPackage->Msi.sczProductCode);
                }
            }
            else if (BURN_PACKAGE_TYPE_MSP == pPackage->type && pPackage->Msp.cTargetProductCodes)
            {
                LogId(REPORT_STANDARD, MSG_PLANNED_MSP_TARGETS, pPackage->Msp.cTargetProductCodes, pPackage->sczId);

                for (DWORD j = 0; j < pPackage->Msp.cTargetProductCodes; ++j)
                {
                    const BURN_MSPTARGETPRODUCT* pTargetProduct = &pPackage->Msp.rgTargetProducts[j];

                    LogId(REPORT_STANDARD, MSG_PLANNED_MSP_TARGET, pTargetProduct->wzTargetProductCode, LoggingPackageStateToString(pTargetProduct->patchPackageState), LoggingRequestStateToString(pTargetProduct->defaultRequested), LoggingRequestStateToString(pTargetProduct->requested), LoggingMspTargetActionToString(pTargetProduct->execute, pTargetProduct->executeSkip), LoggingMspTargetActionToString(pTargetProduct->rollback, pTargetProduct->rollbackSkip));
                }
            }
        }

        // Display related bundles last if not uninstalling.
        if (!fUninstalling)
        {
            LogRelatedBundles(pRelatedBundles, FALSE);
        }
    }
}
