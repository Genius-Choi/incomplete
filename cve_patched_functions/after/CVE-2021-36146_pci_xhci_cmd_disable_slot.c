pci_xhci_cmd_disable_slot(struct pci_xhci_vdev *xdev, uint32_t slot)
{
	struct pci_xhci_dev_emu *dev;
	struct usb_dev *udev;
	struct usb_native_devinfo *di = NULL;
	struct usb_devpath *path;
	uint32_t cmderr;
	int i, j, index;

	UPRINTF(LINF, "pci_xhci disable slot %u\r\n", slot);

	cmderr = XHCI_TRB_ERROR_NO_SLOTS;
	if (xdev->portregs == NULL)
		goto done;

	if (slot > xdev->ndevices) {
		cmderr = XHCI_TRB_ERROR_SLOT_NOT_ON;
		goto done;
	}

	dev = XHCI_SLOTDEV_PTR(xdev, slot);
	if (dev) {
		if (dev->dev_slotstate == XHCI_ST_DISABLED) {
			cmderr = XHCI_TRB_ERROR_SLOT_NOT_ON;
		} else {
			dev->dev_slotstate = XHCI_ST_DISABLED;
			cmderr = XHCI_TRB_ERROR_SUCCESS;
			/* TODO: reset events and endpoints */
		}
	} else {
		UPRINTF(LINF, "disable NULL device, slot %d\r\n", slot);
		goto done;
	}

	for (i = 1; i <= XHCI_MAX_DEVS; ++i)
		if (dev == xdev->devices[i])
			break;

	if (i <= XHCI_MAX_DEVS && XHCI_PORTREG_PTR(xdev, i)) {
		XHCI_PORTREG_PTR(xdev, i)->portsc &= ~(XHCI_PS_CSC |
				XHCI_PS_CCS | XHCI_PS_PED);

		udev = dev->dev_instance;

		xdev->devices[i] = NULL;
		xdev->slots[slot] = NULL;
		xdev->slot_allocated[slot] = false;

		di = &udev->info;
		index = pci_xhci_get_native_port_index_by_path(xdev, &di->path);
		if (index < 0) {
			/*
			 * one possible reason for failing to find the device is
			 * it is plugged out during the resuming process. we
			 * should give the xhci_vbdp_thread an opportunity to
			 * try.
			 */
			sem_post(&xdev->vbdp_sem);
			cmderr = XHCI_TRB_ERROR_SLOT_NOT_ON;
			goto done;
		}

		for (j = 0; j < XHCI_MAX_VIRT_PORTS; ++j) {
			path = &xdev->vbdp_devs[j].path;

			if (!usb_dev_path_cmp(path, &di->path))
				continue;

			xdev->vbdp_devs[j].state = S3_VBDP_END;
			xdev->vbdp_dev_num--;
			sem_post(&xdev->vbdp_sem);
			UPRINTF(LINF, "signal device %d-%s to connect\r\n",
					di->path.bus, usb_dev_path(&di->path));
		}
		UPRINTF(LINF, "disable slot %d for native device %d-%s\r\n",
				slot, di->path.bus, usb_dev_path(&di->path));

		/* release all the resource allocated for virtual device */
		pci_xhci_dev_destroy(dev);
	} else
		UPRINTF(LWRN, "invalid slot %d\r\n", slot);

done:
	return cmderr;
}
