virtio_input_get_config(struct virtio_input *vi, uint8_t select,
			uint8_t subsel, struct virtio_input_config *cfg)
{
	struct input_id dev_ids;
	bool found = false;
	int rc;

	if (!cfg)
		return false;

	memset(cfg, 0, sizeof(*cfg));

	switch (select) {
	case VIRTIO_INPUT_CFG_ID_NAME:
		rc = ioctl(vi->fd, EVIOCGNAME(sizeof(cfg->u.string) - 1),
			cfg->u.string);
		if (rc >= 0) {
			cfg->select = VIRTIO_INPUT_CFG_ID_NAME;
			cfg->size = strnlen(cfg->u.string,
				sizeof(cfg->u.string));
			found = true;
		}
		break;
	case VIRTIO_INPUT_CFG_ID_SERIAL:
		if (vi->serial) {
			cfg->select = VIRTIO_INPUT_CFG_ID_SERIAL;
			cfg->size = snprintf(cfg->u.string,
				sizeof(cfg->u.string), "%s", vi->serial);
			found = true;
		}
		break;
	case VIRTIO_INPUT_CFG_ID_DEVIDS:
		rc = ioctl(vi->fd, EVIOCGID, &dev_ids);
		if (!rc) {
			cfg->u.ids.bustype = dev_ids.bustype;
			cfg->u.ids.vendor  = dev_ids.vendor;
			cfg->u.ids.product = dev_ids.product;
			cfg->u.ids.version = dev_ids.version;
			cfg->select = VIRTIO_INPUT_CFG_ID_DEVIDS;
			cfg->size = sizeof(struct virtio_input_devids);
			found = true;
		}
		break;
	case VIRTIO_INPUT_CFG_PROP_BITS:
		found = virtio_input_get_propbits(vi, cfg);
		break;
	case VIRTIO_INPUT_CFG_EV_BITS:
		found = virtio_input_get_evbits(vi, subsel, cfg);
		break;
	case VIRTIO_INPUT_CFG_ABS_INFO:
		found = virtio_input_get_absinfo(vi, subsel, cfg);
		break;
	default:
		break;
	}

	return found;
}
