fu_plugin_device_add(FuPlugin *self, FuDevice *device)
{
	FuPluginPrivate *priv = GET_PRIVATE(self);
	GPtrArray *children;
	g_autoptr(GError) error = NULL;

	g_return_if_fail(FU_IS_PLUGIN(self));
	g_return_if_fail(FU_IS_DEVICE(device));

	/* ensure the device ID is set from the physical and logical IDs */
	if (!fu_device_ensure_id(device, &error)) {
		g_warning("ignoring add: %s", error->message);
		return;
	}

	/* add to array */
	fu_plugin_ensure_devices(self);
	g_ptr_array_add(priv->devices, g_object_ref(device));

	/* proxy to device where required */
	if (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_CLEAR_UPDATABLE)) {
		if (fu_plugin_has_flag(self, FWUPD_PLUGIN_FLAG_USER_WARNING)) {
			fu_device_inhibit(device,
					  "clear-updatable",
					  fu_plugin_build_device_update_error(self));
		} else {
			fu_device_inhibit(device,
					  "clear-updatable",
					  "Plugin disallowed updates with no user warning");
		}
	}

	g_debug("emit added from %s: %s", fu_plugin_get_name(self), fu_device_get_id(device));
	fu_device_set_created(device, (guint64)g_get_real_time() / G_USEC_PER_SEC);
	fu_device_set_plugin(device, fu_plugin_get_name(self));
	g_signal_emit(self, signals[SIGNAL_DEVICE_ADDED], 0, device);

	/* add children if they have not already been added */
	children = fu_device_get_children(device);
	for (guint i = 0; i < children->len; i++) {
		FuDevice *child = g_ptr_array_index(children, i);
		if (fu_device_get_created(child) == 0)
			fu_plugin_device_add(self, child);
	}

	/* watch to see if children are added or removed at runtime */
	g_signal_connect(FU_DEVICE(device),
			 "child-added",
			 G_CALLBACK(fu_plugin_device_child_added_cb),
			 self);
	g_signal_connect(FU_DEVICE(device),
			 "child-removed",
			 G_CALLBACK(fu_plugin_device_child_removed_cb),
			 self);
}
