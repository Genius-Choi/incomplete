PRV_StateMachine(PRIVATE_NETWORKKEY ** network,
                 PRIVATE_ASSOCIATIONKEY ** association, int event, int state,
                 void *params)
{
    volatile FSM_ENTRY
        * entry;

    /* check if the given event is valid, if not return an error */
    if (event < 0 || event >= DUL_NUMBER_OF_EVENTS)
    {
      char buf1[256];
      sprintf(buf1, "DUL Finite State Machine Error: Bad event, state %d event %d", state, event);
      return makeDcmnetCondition(DULC_FSMERROR, OF_error, buf1);
    }

    /* check if the given state is valid, if not return an error */
    if (state < 1 || state > DUL_NUMBER_OF_STATES)
    {
      char buf1[256];
      sprintf(buf1, "DUL Finite State Machine Error: Bad state, state %d event %d", state, event);
      return makeDcmnetCondition(DULC_FSMERROR, OF_error, buf1);
    }

    /* depending on the given event and state, determine the state table's entry (the state */
    /* table implements the state transition table of DICOM's Upper Layer State Machine which */
    /* in turn implements the DICOM upper layer protocol) (see DICOM standard (year 2000) part */
    /* 8, section 9) (or the corresponding section in a later version of the standard) */
    entry = &StateTable[event][state - 1];

    /* dump information if required */
    DCMNET_TRACE("DUL  FSM Table: State: " << state << " Event: " << event << OFendl
            << "DUL  Event:  " << OFconst_cast(const char *, entry->eventName) << OFendl
            << "DUL  Action: " << OFconst_cast(const char *, entry->actionName));

    /* if the state table's entry specifies an action function, execute this function and return */
    /* it's result value. If there is no action function defined, return a corresponding error. */
    if (entry->actionFunction != NULL)
        return entry->actionFunction(network, association, entry->nextState, params);
    else
    {
      char buf1[256];
      sprintf(buf1, "DUL Finite State Machine Error: No action defined, state %d event %d", state, event);
      return makeDcmnetCondition(DULC_FSMERROR, OF_error, buf1);
    }
}
