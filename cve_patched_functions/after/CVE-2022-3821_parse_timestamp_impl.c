static int parse_timestamp_impl(const char *t, usec_t *usec, bool with_tz) {
        static const struct {
                const char *name;
                const int nr;
        } day_nr[] = {
                { "Sunday",    0 },
                { "Sun",       0 },
                { "Monday",    1 },
                { "Mon",       1 },
                { "Tuesday",   2 },
                { "Tue",       2 },
                { "Wednesday", 3 },
                { "Wed",       3 },
                { "Thursday",  4 },
                { "Thu",       4 },
                { "Friday",    5 },
                { "Fri",       5 },
                { "Saturday",  6 },
                { "Sat",       6 },
        };

        const char *k, *utc = NULL, *tzn = NULL;
        struct tm tm, copy;
        time_t x;
        usec_t x_usec, plus = 0, minus = 0, ret;
        int r, weekday = -1, dst = -1;
        size_t i;

        /* Allowed syntaxes:
         *
         *   2012-09-22 16:34:22
         *   2012-09-22 16:34     (seconds will be set to 0)
         *   2012-09-22           (time will be set to 00:00:00)
         *   16:34:22             (date will be set to today)
         *   16:34                (date will be set to today, seconds to 0)
         *   now
         *   yesterday            (time is set to 00:00:00)
         *   today                (time is set to 00:00:00)
         *   tomorrow             (time is set to 00:00:00)
         *   +5min
         *   -5days
         *   @2147483647          (seconds since epoch)
         */

        assert(t);

        if (t[0] == '@' && !with_tz)
                return parse_sec(t + 1, usec);

        ret = now(CLOCK_REALTIME);

        if (!with_tz) {
                if (streq(t, "now"))
                        goto finish;

                else if (t[0] == '+') {
                        r = parse_sec(t+1, &plus);
                        if (r < 0)
                                return r;

                        goto finish;

                } else if (t[0] == '-') {
                        r = parse_sec(t+1, &minus);
                        if (r < 0)
                                return r;

                        goto finish;

                } else if ((k = endswith(t, " ago"))) {
                        t = strndupa_safe(t, k - t);

                        r = parse_sec(t, &minus);
                        if (r < 0)
                                return r;

                        goto finish;

                } else if ((k = endswith(t, " left"))) {
                        t = strndupa_safe(t, k - t);

                        r = parse_sec(t, &plus);
                        if (r < 0)
                                return r;

                        goto finish;
                }

                /* See if the timestamp is suffixed with UTC */
                utc = endswith_no_case(t, " UTC");
                if (utc)
                        t = strndupa_safe(t, utc - t);
                else {
                        const char *e = NULL;
                        int j;

                        tzset();

                        /* See if the timestamp is suffixed by either the DST or non-DST local timezone. Note
                         * that we only support the local timezones here, nothing else. Not because we
                         * wouldn't want to, but simply because there are no nice APIs available to cover
                         * this. By accepting the local time zone strings, we make sure that all timestamps
                         * written by format_timestamp() can be parsed correctly, even though we don't
                         * support arbitrary timezone specifications. */

                        for (j = 0; j <= 1; j++) {

                                if (isempty(tzname[j]))
                                        continue;

                                e = endswith_no_case(t, tzname[j]);
                                if (!e)
                                        continue;
                                if (e == t)
                                        continue;
                                if (e[-1] != ' ')
                                        continue;

                                break;
                        }

                        if (IN_SET(j, 0, 1)) {
                                /* Found one of the two timezones specified. */
                                t = strndupa_safe(t, e - t - 1);
                                dst = j;
                                tzn = tzname[j];
                        }
                }
        }

        x = (time_t) (ret / USEC_PER_SEC);
        x_usec = 0;

        if (!localtime_or_gmtime_r(&x, &tm, utc))
                return -EINVAL;

        tm.tm_isdst = dst;
        if (!with_tz && tzn)
                tm.tm_zone = tzn;

        if (streq(t, "today")) {
                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;
                goto from_tm;

        } else if (streq(t, "yesterday")) {
                tm.tm_mday--;
                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;
                goto from_tm;

        } else if (streq(t, "tomorrow")) {
                tm.tm_mday++;
                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;
                goto from_tm;
        }

        for (i = 0; i < ELEMENTSOF(day_nr); i++) {
                size_t skip;

                if (!startswith_no_case(t, day_nr[i].name))
                        continue;

                skip = strlen(day_nr[i].name);
                if (t[skip] != ' ')
                        continue;

                weekday = day_nr[i].nr;
                t += skip + 1;
                break;
        }

        copy = tm;
        k = strptime(t, "%y-%m-%d %H:%M:%S", &tm);
        if (k) {
                if (*k == '.')
                        goto parse_usec;
                else if (*k == 0)
                        goto from_tm;
        }

        tm = copy;
        k = strptime(t, "%Y-%m-%d %H:%M:%S", &tm);
        if (k) {
                if (*k == '.')
                        goto parse_usec;
                else if (*k == 0)
                        goto from_tm;
        }

        /* Support OUTPUT_SHORT and OUTPUT_SHORT_PRECISE formats */
        tm = copy;
        k = strptime(t, "%b %d %H:%M:%S", &tm);
        if (k) {
                if (*k == '.')
                        goto parse_usec;
                else if (*k == 0)
                        goto from_tm;
        }

        tm = copy;
        k = strptime(t, "%y-%m-%d %H:%M", &tm);
        if (k && *k == 0) {
                tm.tm_sec = 0;
                goto from_tm;
        }

        tm = copy;
        k = strptime(t, "%Y-%m-%d %H:%M", &tm);
        if (k && *k == 0) {
                tm.tm_sec = 0;
                goto from_tm;
        }

        tm = copy;
        k = strptime(t, "%y-%m-%d", &tm);
        if (k && *k == 0) {
                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;
                goto from_tm;
        }

        tm = copy;
        k = strptime(t, "%Y-%m-%d", &tm);
        if (k && *k == 0) {
                tm.tm_sec = tm.tm_min = tm.tm_hour = 0;
                goto from_tm;
        }

        tm = copy;
        k = strptime(t, "%H:%M:%S", &tm);
        if (k) {
                if (*k == '.')
                        goto parse_usec;
                else if (*k == 0)
                        goto from_tm;
        }

        tm = copy;
        k = strptime(t, "%H:%M", &tm);
        if (k && *k == 0) {
                tm.tm_sec = 0;
                goto from_tm;
        }

        return -EINVAL;

parse_usec:
        {
                unsigned add;

                k++;
                r = parse_fractional_part_u(&k, 6, &add);
                if (r < 0)
                        return -EINVAL;

                if (*k)
                        return -EINVAL;

                x_usec = add;
        }

from_tm:
        if (weekday >= 0 && tm.tm_wday != weekday)
                return -EINVAL;

        x = mktime_or_timegm(&tm, utc);
        if (x < 0)
                return -EINVAL;

        ret = (usec_t) x * USEC_PER_SEC + x_usec;
        if (ret > USEC_TIMESTAMP_FORMATTABLE_MAX)
                return -EINVAL;

finish:
        if (ret + plus < ret) /* overflow? */
                return -EINVAL;
        ret += plus;
        if (ret > USEC_TIMESTAMP_FORMATTABLE_MAX)
                return -EINVAL;

        if (ret >= minus)
                ret -= minus;
        else
                return -EINVAL;

        if (usec)
                *usec = ret;
        return 0;
}
