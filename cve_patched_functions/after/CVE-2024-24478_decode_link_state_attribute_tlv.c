decode_link_state_attribute_tlv(proto_tree *tree, tvbuff_t *tvb, gint offset, packet_info *pinfo, guint8 protocol_id)
{
    guint16 type;
    guint16 length;
    guint8  tmp8;
    guint16 tmp16;
    guint32 tmp32;
    gfloat  tmp_float;
    guint32 mask;
    gint local_offset, local_length;
    int n;
    guint8  sabm_len, udabm_len;
    int     advance;

    proto_item* tlv_item;
    proto_tree* tlv_tree;
    proto_item* tlv_sub_item;
    proto_tree* tlv_sub_tree;
    proto_item* ti;

    type = tvb_get_ntohs(tvb, offset);
    length = tvb_get_ntohs(tvb, offset + 2);

    switch (type) {

        /* NODE ATTRIBUTE TLVs */
        case BGP_NLRI_TLV_MULTI_TOPOLOGY_ID:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_multi_topology_id, tvb, offset, length + 4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);

            for (n = 0; n < (length / BGP_NLRI_TLV_LEN_MULTI_TOPOLOGY_ID); n++) {
                tmp16 = tvb_get_ntohs(tvb, offset + 4 + (n * BGP_NLRI_TLV_LEN_MULTI_TOPOLOGY_ID));
                tmp16 >>= 12;
                if(tmp16){
                    expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Reserved bits of Multi Topology ID must be set to zero! (%u)", tmp16);
                }
                proto_tree_add_item(tlv_tree, hf_bgp_ls_nlri_multi_topology_id, tvb, offset + 4 + (n * BGP_NLRI_TLV_LEN_MULTI_TOPOLOGY_ID),
                                                    BGP_NLRI_TLV_LEN_MULTI_TOPOLOGY_ID, ENC_BIG_ENDIAN);
            }
            break;

        case BGP_NLRI_TLV_NODE_FLAG_BITS:
            {
            static int * const flags[] = {
                &hf_bgp_ls_node_flag_bits_overload,
                &hf_bgp_ls_node_flag_bits_attached,
                &hf_bgp_ls_node_flag_bits_external,
                &hf_bgp_ls_node_flag_bits_abr,
                NULL
            };

            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_node_flags_bits, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            if(length != BGP_NLRI_TLV_LEN_NODE_FLAG_BITS){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected Node Flags Bits TLV's length (%u), it must be %u bytes!",
                                       length, BGP_NLRI_TLV_LEN_NODE_FLAG_BITS);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_bitmask_list(tlv_tree, tvb, offset+4, 1, flags, ENC_NA);
            tmp8 = tvb_get_guint8(tvb, offset+4) & 0x0f;
            if(tmp8){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Reserved flag bits are not set to zero (%u).", tmp8);
            }
            }
            break;

        case BGP_NLRI_TLV_OPAQUE_NODE_PROPERTIES:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_opaque_node_properties, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_opaque_node_properties_value, tvb, offset + 4, length, ENC_NA);
            break;

        case BGP_NLRI_TLV_NODE_NAME:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_node_name, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_node_name_value, tvb, offset + 4, length, ENC_ASCII);
            break;

        case BGP_NLRI_TLV_IS_IS_AREA_IDENTIFIER:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_is_is_area_identifier, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_is_is_area_identifier_value, tvb, offset + 4, length, ENC_NA);
            break;

        case BGP_LS_SR_TLV_SR_CAPABILITY:
            {
                /*
                  0  1  2  3  4  5  6  7
                  +--+--+--+--+--+--+--+--+
                  |I |V |H |  |  |  |  |  |
                  +--+--+--+--+--+--+--+--+
                */
                static int * const sr_capabilities_flags[] = {
                    &hf_bgp_ls_sr_tlv_capabilities_flags_i,
                    &hf_bgp_ls_sr_tlv_capabilities_flags_v,
                    &hf_bgp_ls_sr_tlv_capabilities_flags_h,
                    &hf_bgp_ls_sr_tlv_capabilities_flags_reserved,
                    NULL
                };
                gint offset2;
                gint remaining_data;
                tlv_item = proto_tree_add_item(tree, hf_bgp_ls_sr_tlv_capabilities, tvb, offset, length + 4, ENC_NA);
                tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
                proto_tree_add_bitmask(tlv_tree, tvb, offset + 4, hf_bgp_ls_sr_tlv_capabilities_flags,
                                       ett_bgp_link_state, sr_capabilities_flags, ENC_BIG_ENDIAN);
                /* past flags and reserved byte, we got one or more range + SID/Label Sub-TLV entries */
                offset2 = offset + 4 + 2;
                remaining_data = length - 2;
                while (remaining_data > 0) {
                    guint16 sid_len = 0;
                    /* parse and consume the range field */
                    proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_capabilities_range_size, tvb, offset2, 3, ENC_BIG_ENDIAN);
                    offset2 += 3;
                    /* parse and consume type/len fields */
                    proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset2, 2, ENC_BIG_ENDIAN);
                    offset2 += 2;
                    proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset2, 2, ENC_BIG_ENDIAN);
                    sid_len = tvb_get_ntohs(tvb, offset2);
                    offset2 += 2;
                    if (sid_len == 3) {
                        /* parse and consume the SID/Label field */
                        proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_capabilities_sid_label, tvb, offset2, 3, ENC_BIG_ENDIAN);
                        offset2 += 3;
                        remaining_data -= 10;
                    } else {
                        /* parse and consume the SID/Index field */
                        proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_capabilities_sid_index, tvb, offset2, 4, ENC_BIG_ENDIAN);
                        offset2 += 4;
                        remaining_data -= 11;
                    }
                }
            }
            break;

        case BGP_LS_SR_TLV_SR_LOCAL_BLOCK:
            {
                gint offset2;
                gint remaining_data;
                tlv_item = proto_tree_add_item(tree, hf_bgp_ls_sr_tlv_local_block, tvb, offset, length + 4, ENC_NA);
                tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_local_block_flags, tvb, offset + 4, 1, ENC_NA);
                /* past flags and reserved byte, we got one or more range + SID/Label Sub-TLV entries */
                offset2 = offset + 4 + 2;
                remaining_data = length - 2;
                while (remaining_data > 0) {
                    guint16 sid_len = 0;
                    /* parse and consume the range field */
                    proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_local_block_range_size, tvb, offset2, 3, ENC_BIG_ENDIAN);
                    offset2 += 3;
                    /* parse and consume type/len fields */
                    proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset2, 2, ENC_BIG_ENDIAN);
                    offset2 += 2;
                    proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset2, 2, ENC_BIG_ENDIAN);
                    sid_len = tvb_get_ntohs(tvb, offset2);
                    offset2 += 2;
                    if (sid_len == 3) {
                        /* parse and consume the SID/Label field */
                        proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_local_block_sid_label, tvb, offset2, 3, ENC_BIG_ENDIAN);
                        offset2 += 3;
                        remaining_data -= 10;
                    } else {
                        /* parse and consume the SID/Index field */
                        proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_local_block_sid_index, tvb, offset2, 4, ENC_BIG_ENDIAN);
                        offset2 += 4;
                        remaining_data -= 11;
                    }
                }
            }
            break;

        case BGP_LS_SR_TLV_SR_ALGORITHM:
            {
                gint offset2;
                gint remaining_data;
                tlv_item = proto_tree_add_item(tree, hf_bgp_ls_sr_tlv_algorithm, tvb, offset, length+4, ENC_NA);
                tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
                /* past type-length fields, we got one or more 'Algorithm N' value */
                offset2 = offset + 4;
                remaining_data = length;
                while (remaining_data > 0) {
                    proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_algorithm_value, tvb, offset2, 1, ENC_NA);
                    offset2 += 1;
                    remaining_data -= 1;
                }
            }
            break;

        case BGP_LS_SR_TLV_SRV6_CAPABILITY:
            {
                static int * const srv6_cap_flags[] = {
                    &hf_bgp_ls_sr_tlv_srv6_cap_flags_o,
                    &hf_bgp_ls_sr_tlv_srv6_cap_flags_reserved,
                    NULL
                };
                tlv_item = proto_tree_add_item(tree, hf_bgp_ls_sr_tlv_srv6_cap, tvb, offset, length + 4, ENC_NA);
                tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
                ti = proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
                if (length != 4) {
                    expert_add_info_format(pinfo, ti, &ei_bgp_ls_error,
                                           "Unexpected TLV Length (%u) in BGP-LS %s TLV, it must be %u bytes!",
                                           length, "SRv6 Capabilities", 4);
                    break;
                }
                proto_tree_add_bitmask(tlv_tree, tvb, offset + 4, hf_bgp_ls_sr_tlv_srv6_cap_flags,
                                       ett_bgp_link_state, srv6_cap_flags, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_cap_reserved, tvb, offset + 6, 2, ENC_BIG_ENDIAN);
            }
            break;

        case BGP_LS_SR_TLV_FLEX_ALGO_DEF:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_sr_tlv_flex_algo_def, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_flex_algo_algorithm, tvb, offset + 4, 1, ENC_NA);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_flex_algo_metric_type, tvb, offset + 5, 1, ENC_NA);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_flex_algo_calc_type, tvb, offset + 6, 1, ENC_NA);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_flex_algo_priority, tvb, offset + 7, 1, ENC_NA);
            local_offset = offset + 8;
            while (local_offset < offset + length) {
                advance = decode_link_state_attribute_flex_algo_subtlv(tlv_tree, tvb, local_offset, pinfo, protocol_id);
                if (advance < 0) {
                    break;
                }
                local_offset += advance;
            }
            break;

        /* NODE & LINK ATTRIBUTE TLVs */
        case BGP_NLRI_TLV_NODE_MSD:
        case BGP_NLRI_TLV_LINK_MSD:
            tlv_item = proto_tree_add_item(tree,
                                           (type == BGP_NLRI_TLV_NODE_MSD ?
                                            hf_bgp_ls_tlv_node_msd : hf_bgp_ls_tlv_link_msd),
                                            tvb, offset, length + 4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_mp_reach_nlri);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            local_offset = offset + 4;
            local_length = length;
            while (local_length >= 2) {
                proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_igp_msd_type, tvb, local_offset, 1, ENC_NA);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_igp_msd_value, tvb, local_offset+1, 1, ENC_NA);
                local_length -= 2;
                local_offset += 2;
            }
            break;

        case BGP_NLRI_TLV_IPV4_ROUTER_ID_OF_LOCAL_NODE:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_ipv4_router_id_of_local_node, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            if(length != BGP_NLRI_TLV_LEN_IPV4_ROUTER_ID_OF_LOCAL_NODE){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected IPv4 Router-ID TLV's length (%u), it must be %u bytes!",
                                    length, BGP_NLRI_TLV_LEN_IPV4_ROUTER_ID_OF_LOCAL_NODE);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_ipv4_router_id_value, tvb, offset + 4, 4, ENC_BIG_ENDIAN);
            break;
        case BGP_NLRI_TLV_IPV6_ROUTER_ID_OF_LOCAL_NODE:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_ipv6_router_id_of_local_node, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            if(length != BGP_NLRI_TLV_LEN_IPV6_ROUTER_ID_OF_LOCAL_NODE){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected IPv6 Router-ID TLV's length (%u), it must be %u bytes!",
                                    length, BGP_NLRI_TLV_LEN_IPV6_ROUTER_ID_OF_LOCAL_NODE);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_ipv6_router_id_value, tvb, offset + 4, BGP_NLRI_TLV_LEN_IPV6_ROUTER_ID_OF_LOCAL_NODE, ENC_NA);
            break;

        /* Link Attribute TLVs */
        case BGP_NLRI_TLV_LINK_LOCAL_REMOTE_IDENTIFIERS:
            if (length != BGP_NLRI_TLV_LEN_LINK_LOCAL_REMOTE_IDENTIFIERS) {
                expert_add_info_format(pinfo, tree, &ei_bgp_ls_error,
                                       "Unexpected Link Local/Remote Identifiers TLV's length (%u), it must be %u bytes!",
                                       length, BGP_NLRI_TLV_LEN_LINK_LOCAL_REMOTE_IDENTIFIERS);
                break;
            }
            tlv_item = proto_tree_add_item(tree,
                                           hf_bgp_ls_tlv_link_local_remote_identifiers, tvb, offset,
                                           length + 4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_mp_reach_nlri);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_nlri_link_local_identifier, tvb, offset + 4, 4, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_nlri_link_remote_identifier, tvb, offset + 8, 4, ENC_BIG_ENDIAN);
            break;

        case BGP_NLRI_TLV_IPV4_ROUTER_ID_OF_REMOTE_NODE:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_ipv4_router_id_of_remote_node, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            if(length != BGP_NLRI_TLV_LEN_IPV4_ROUTER_ID_OF_REMOTE_NODE){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected IPv4 Router-ID TLV's length (%u), it must be %u bytes!",
                                    length, BGP_NLRI_TLV_LEN_IPV4_ROUTER_ID_OF_REMOTE_NODE);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_ipv4_router_id_value, tvb, offset + 4, 4, ENC_BIG_ENDIAN);
            break;

        case BGP_NLRI_TLV_IPV6_ROUTER_ID_OF_REMOTE_NODE:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_ipv6_router_id_of_remote_node, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            if(length != BGP_NLRI_TLV_LEN_IPV6_ROUTER_ID_OF_REMOTE_NODE){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected IPv6 Router-ID TLV's length (%u), it must be %u bytes!",
                                    length, BGP_NLRI_TLV_LEN_IPV6_ROUTER_ID_OF_REMOTE_NODE);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_ipv6_router_id_value, tvb, offset + 4, BGP_NLRI_TLV_LEN_IPV6_ROUTER_ID_OF_REMOTE_NODE, ENC_NA);
            break;

        case BGP_NLRI_TLV_ADMINISTRATIVE_GROUP_COLOR:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_administrative_group_color, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            if(length != BGP_NLRI_TLV_LEN_ADMINISTRATIVE_GROUP_COLOR){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected Administrative group (color) TLV's length (%u), it must be %u bytes!",
                                       length, BGP_NLRI_TLV_LEN_ADMINISTRATIVE_GROUP_COLOR);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            tmp32 = tvb_get_ntohl(tvb, offset + 4);
            tlv_sub_item = proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_administrative_group_color_value, tvb, offset + 4, 4, ENC_BIG_ENDIAN);
            tlv_sub_tree = proto_item_add_subtree(tlv_sub_item, ett_bgp_prefix);
            mask = 1;
            for(n = 0; n<32; n++){
                if( tmp32 & mask ) proto_tree_add_uint(tlv_sub_tree, hf_bgp_ls_tlv_administrative_group, tvb, offset + 4, 4, n);
                mask <<= 1;
            }
            break;

        case BGP_NLRI_TLV_MAX_LINK_BANDWIDTH:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_max_link_bandwidth, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            if(length != BGP_NLRI_TLV_LEN_MAX_LINK_BANDWIDTH){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected Maximum link bandwidth TLV's length (%u), it must be %u bytes!",
                                       length, BGP_NLRI_TLV_LEN_MAX_LINK_BANDWIDTH);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            tmp_float = tvb_get_ntohieee_float(tvb, offset + 4)*8/1000000;
            proto_tree_add_float_format(tlv_tree, hf_bgp_ls_bandwidth_value, tvb, offset + 4, 4, tmp_float, "Maximum link bandwidth: %.2f Mbps", tmp_float);
            break;

        case BGP_NLRI_TLV_MAX_RESERVABLE_LINK_BANDWIDTH:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_max_reservable_link_bandwidth, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            if(length != BGP_NLRI_TLV_LEN_MAX_RESERVABLE_LINK_BANDWIDTH){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected Maximum reservable link bandwidth TLV's length (%u), it must be %u bytes!",
                                       length, BGP_NLRI_TLV_LEN_MAX_RESERVABLE_LINK_BANDWIDTH);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            tmp_float = tvb_get_ntohieee_float(tvb, offset + 4)*8/1000000;
            proto_tree_add_float_format(tlv_tree, hf_bgp_ls_bandwidth_value, tvb, offset + 4, 4, tmp_float, "Maximum reservable link bandwidth: %.2f Mbps", tmp_float);
            break;

        case BGP_NLRI_TLV_UNRESERVED_BANDWIDTH:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_unreserved_bandwidth, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            if(length != BGP_NLRI_TLV_LEN_UNRESERVED_BANDWIDTH){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected Unreserved bandwidth TLV's length (%u), it must be %u bytes!",
                                       length, BGP_NLRI_TLV_LEN_UNRESERVED_BANDWIDTH);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            for(n = 0; n<8; n++){
                tmp_float = tvb_get_ntohieee_float(tvb, offset + 4 + (4 * n))*8/1000000;
                tlv_sub_item = proto_tree_add_float_format(tlv_tree, hf_bgp_ls_bandwidth_value, tvb, offset + 4 + (4 * n), 4, tmp_float, "Unreserved Bandwidth: %.2f Mbps", tmp_float);
                proto_item_prepend_text(tlv_sub_item, "Priority %u, ", n);
            }
            break;

        case BGP_NLRI_TLV_TE_DEFAULT_METRIC:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_te_default_metric, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            /* FF: The 'TE Default Metric TLV's length changed. From draft-ietf-idr-ls-distribution-00 to 04
               was 3 bytes as per RFC5305/3.7, since version 05 is 4 bytes. Here we try to parse both formats
               without complain because there are real implementations out there based on the 3 bytes size. At
               the same time we clearly highlight that 3 is "old" and 4 is correct via expert info. */
            if (length == BGP_NLRI_TLV_LEN_TE_DEFAULT_METRIC_OLD) {
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_warn,
                                       "Old TE Default Metric TLV's length (%u), it should be %u bytes!",
                                       length,
                                       BGP_NLRI_TLV_LEN_TE_DEFAULT_METRIC_NEW);
                /* just a warning do not give up dissection */
            }
            if (length != BGP_NLRI_TLV_LEN_TE_DEFAULT_METRIC_OLD && length != BGP_NLRI_TLV_LEN_TE_DEFAULT_METRIC_NEW) {
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error,
                                       "Unexpected TE Default Metric TLV's length (%u), it must be %u or %u bytes!",
                                       length,
                                       BGP_NLRI_TLV_LEN_TE_DEFAULT_METRIC_OLD,
                                       BGP_NLRI_TLV_LEN_TE_DEFAULT_METRIC_NEW);
                /* major error give up dissection */
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            if (length == BGP_NLRI_TLV_LEN_TE_DEFAULT_METRIC_OLD) {
                proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_te_default_metric_value_old, tvb, offset + 4, 3, ENC_BIG_ENDIAN);
            } else if (length == BGP_NLRI_TLV_LEN_TE_DEFAULT_METRIC_NEW) {
                proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_te_default_metric_value, tvb, offset + 4, 4, ENC_BIG_ENDIAN);
            }
            break;

        case BGP_NLRI_TLV_LINK_PROTECTION_TYPE:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_link_protection_type, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            if(length != BGP_NLRI_TLV_LEN_LINK_PROTECTION_TYPE){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected Link Protection Type TLV's length (%u), it must be %u bytes!",
                                       length, BGP_NLRI_TLV_LEN_LINK_PROTECTION_TYPE);
                break;
            }
            else {
                static int * const nlri_flags[] = {
                    &hf_bgp_ls_link_protection_type_extra_traffic,
                    &hf_bgp_ls_link_protection_type_unprotected,
                    &hf_bgp_ls_link_protection_type_shared,
                    &hf_bgp_ls_link_protection_type_dedicated_1to1,
                    &hf_bgp_ls_link_protection_type_dedicated_1plus1,
                    &hf_bgp_ls_link_protection_type_enhanced,
                    NULL
                };

                proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
                tmp8 = tvb_get_guint8(tvb, offset + 4);

                tlv_sub_item = proto_tree_add_bitmask(tlv_tree, tvb, offset + 4, hf_bgp_ls_tlv_link_protection_type_value, ett_bgp_mp_reach_nlri, nlri_flags, ENC_NA);
                tmp8 >>= 6;
                if(tmp8){
                    expert_add_info_format(pinfo, tlv_sub_item, &ei_bgp_ls_error, "Reserved Protection Capabilities bits are not set to zero (%u).", tmp8);
                }
                tmp8 = tvb_get_guint8(tvb, offset + 4 + 1);
                if(tmp8){
                    expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Reserved field is not set to zero. (%u)", tmp8);
                }
            }
            break;
        case BGP_NLRI_TLV_MPLS_PROTOCOL_MASK:
            {
            static int * const flags[] = {
                &hf_bgp_ls_mpls_protocol_mask_flag_l,
                &hf_bgp_ls_mpls_protocol_mask_flag_r,
                NULL
            };

            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_mpls_protocol_mask, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            if(length != BGP_NLRI_TLV_LEN_MPLS_PROTOCOL_MASK){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected MPLS Protocol Mask TLV's length (%u), it must be %u bytes!",
                                       length, BGP_NLRI_TLV_LEN_MPLS_PROTOCOL_MASK);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_bitmask_list(tlv_tree, tvb, offset+4, 1, flags, ENC_NA);
            tmp8 = tvb_get_guint8(tvb, offset + 4) & 0x3f;
            if(tmp8){
                proto_tree_add_expert_format(tlv_tree, pinfo, &ei_bgp_ls_error, tvb, offset + 4, 1,
                                             "Reserved flags are not set to zero (%u).", tmp8);
            }
            }
            break;
        case BGP_NLRI_TLV_METRIC:
            /* FF: The IGP 'Metric TLV's length changed. From draft-ietf-idr-ls-distribution-00 to 02
               was fixed at 3 bytes, since version 03 is variable 1/2/3 bytes. We cannot complain if
               length is not fixed at 3. */
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_metric, tvb, offset, length + 4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            if (length > BGP_NLRI_TLV_LEN_MAX_METRIC) {
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error,
                                       "Unexpected Metric TLV's length (%u), it must be less than %u bytes!",
                                       length, BGP_NLRI_TLV_LEN_MAX_METRIC);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            if (length == 1) {
                proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_metric_value1, tvb, offset + 4, 1, ENC_BIG_ENDIAN);
            } else if (length == 2) {
                proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_metric_value2, tvb, offset + 4, 2, ENC_BIG_ENDIAN);
            } else if (length == 3) {
                proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_metric_value3, tvb, offset + 4, 3, ENC_BIG_ENDIAN);
            }
            break;
        case BGP_NLRI_TLV_SHARED_RISK_LINK_GROUP:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_shared_risk_link_group, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            tmp16 = length;
            n = 0;
            while(tmp16 > 0){
                if(tmp16 < 4) {
                    proto_tree_add_expert_format(tlv_tree, pinfo, &ei_bgp_ls_error,
                                                 tvb, offset + 4 + (n * 4), tmp16,
                                                 "Shared Risk Link Group Value must be 4 bytes long (%u).", tmp16);
                    break;
                }
                proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_shared_risk_link_group_value, tvb, offset + 4 + (n * 4), 4, ENC_BIG_ENDIAN);
                tmp16 -= 4;
                n++;
            }
            break;

        case BGP_NLRI_TLV_OPAQUE_LINK_ATTRIBUTE:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_opaque_link_attribute, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_opaque_link_attribute_value, tvb,  offset + 4, length, ENC_NA);
            break;

        case BGP_NLRI_TLV_LINK_NAME_ATTRIBUTE:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_link_name_attribute, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_link_name_attribute_value, tvb, offset + 4, length, ENC_ASCII);
            break;

        case BGP_LS_SR_TLV_ADJ_SID:
            {
                /*
                   0  1  2  3  4  5  6  7
                  +--+--+--+--+--+--+--+--+
                  |F |B |V |L |S |  |  |  |
                  +--+--+--+--+--+--+--+--+
                */
                static int * const adj_sid_isis_flags[] = {
                    &hf_bgp_ls_sr_tlv_adjacency_sid_flags_fi,
                    &hf_bgp_ls_sr_tlv_adjacency_sid_flags_bi,
                    &hf_bgp_ls_sr_tlv_adjacency_sid_flags_vi,
                    &hf_bgp_ls_sr_tlv_adjacency_sid_flags_li,
                    &hf_bgp_ls_sr_tlv_adjacency_sid_flags_si,
                    NULL
                };
                /*
                   0  1  2  3  4  5  6  7
                  +--+--+--+--+--+--+--+--+
                  |B |V |L |S |  |  |  |  |
                  +--+--+--+--+--+--+--+--+
                */
                static int * const adj_sid_ospf_flags[] = {
                    &hf_bgp_ls_sr_tlv_adjacency_sid_flags_bo,
                    &hf_bgp_ls_sr_tlv_adjacency_sid_flags_vo,
                    &hf_bgp_ls_sr_tlv_adjacency_sid_flags_lo,
                    &hf_bgp_ls_sr_tlv_adjacency_sid_flags_so,
                    NULL
                };

                tlv_item = proto_tree_add_item(tree, hf_bgp_ls_sr_tlv_adjacency_sid, tvb, offset, length + 4, ENC_NA);
                tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
                if (protocol_id == BGP_LS_NLRI_PROTO_ID_OSPF) {
                    proto_tree_add_bitmask(tlv_tree, tvb, offset + 4, hf_bgp_ls_sr_tlv_adjacency_sid_flags,
                                           ett_bgp_link_state, adj_sid_ospf_flags, ENC_BIG_ENDIAN);
                } else {
                    /* FF: most common case is IS-IS, so if it is not OSPF we go that way */
                    proto_tree_add_bitmask(tlv_tree, tvb, offset + 4, hf_bgp_ls_sr_tlv_adjacency_sid_flags,
                                           ett_bgp_link_state, adj_sid_isis_flags, ENC_BIG_ENDIAN);
                }
                proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_adjacency_sid_weight, tvb, offset + 5, 1, ENC_BIG_ENDIAN);
                if (length == 7) {
                    proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_adjacency_sid_label, tvb, offset + 8, 3, ENC_BIG_ENDIAN);
                } else {
                    proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_adjacency_sid_index, tvb, offset + 8, 4, ENC_BIG_ENDIAN);
                }
            }
            break;

        case BGP_LS_SR_TLV_LAN_ADJ_SID:
            break;

        case BGP_LS_SR_TLV_PEER_NODE_SID:
        case BGP_LS_SR_TLV_PEER_ADJ_SID:
        case BGP_LS_SR_TLV_PEER_SET_SID:
            {
                /*
                   0  1  2  3  4  5  6  7
                  +--+--+--+--+--+--+--+--+
                  |V |L |B |P |  |  |  |  | rfc9086
                  +--+--+--+--+--+--+--+--+
                */
                static int * const peer_sid_flags[] = {
                    &hf_bgp_ls_sr_tlv_peer_sid_flags_v,
                    &hf_bgp_ls_sr_tlv_peer_sid_flags_l,
                    &hf_bgp_ls_sr_tlv_peer_sid_flags_b,
                    &hf_bgp_ls_sr_tlv_peer_sid_flags_p,
                    NULL
                };

                tlv_item = proto_tree_add_item(tree,
                                               (type == BGP_LS_SR_TLV_PEER_NODE_SID ?
                                                hf_bgp_ls_sr_tlv_peer_node_sid :
                                                (type == BGP_LS_SR_TLV_PEER_ADJ_SID ?
                                                 hf_bgp_ls_sr_tlv_peer_adj_sid :
                                                 hf_bgp_ls_sr_tlv_peer_set_sid)),
                                               tvb, offset, length + 4, ENC_NA);
                tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
                ti = proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
                if (length != 7 && length != 8) {
                    expert_add_info_format(pinfo, ti, &ei_bgp_ls_error,
                                           "Unexpected TLV Length (%u) in BGP-LS Peer SID TLV, it must be either 7 or 8 bytes!",
                                           length);
                    break;
                }
                proto_tree_add_bitmask(tlv_tree, tvb, offset + 4, hf_bgp_ls_sr_tlv_peer_sid_flags,
                                       ett_bgp_link_state, peer_sid_flags, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_peer_sid_weight, tvb, offset + 5, 1, ENC_BIG_ENDIAN);
                if (length == 7) {
                    proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_peer_sid_label, tvb, offset + 8, 3, ENC_BIG_ENDIAN);
                } else {
                    proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_peer_sid_index, tvb, offset + 8, 4, ENC_BIG_ENDIAN);
                }
            }
            break;

        case BGP_LS_SR_TLV_SRV6_END_X_SID:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_sr_tlv_srv6_endx_sid,
                                           tvb, offset, length + 4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            ti = proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            if (length < 20) {
                expert_add_info_format(pinfo, ti, &ei_bgp_ls_error,
                                       "Unexpected TLV Length (%u) in BGP-LS %s TLV, it must be %u bytes or more!",
                                       length, "SRv6 End.X SID", 20);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endx_sid_endpoint_behavior, tvb, offset + 4, 2, ENC_NA);
            proto_tree_add_bitmask(tlv_tree, tvb, offset + 6,
                                   hf_bgp_ls_sr_tlv_srv6_endx_sid_flags,
                                   ett_bgp_link_state, srv6_endx_sid_flags, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endx_sid_algo, tvb, offset + 7, 1, ENC_NA);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endx_sid_weight, tvb, offset + 8, 1, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endx_sid_reserved, tvb, offset + 9, 1, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endx_sid_sid, tvb, offset + 10, 16, ENC_NA);
            local_offset = offset + 26;
            while (local_offset < offset + length) {
                advance = decode_link_state_attribute_tlv(tlv_tree, tvb, local_offset, pinfo, protocol_id);
                if (advance < 0) {
                    break;
                }
                local_offset += advance;
            }
            break;

        case BGP_LS_SR_TLV_SRV6_LAN_END_X_SID:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_sr_tlv_srv6_lan_endx_sid,
                                           tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            ti = proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            if ((protocol_id == BGP_LS_NLRI_PROTO_ID_OSPF && length < 26) ||
                ((protocol_id == BGP_LS_NLRI_PROTO_ID_IS_IS_LEVEL_1 ||
                  protocol_id == BGP_LS_NLRI_PROTO_ID_IS_IS_LEVEL_2) && length < 28)) {
                expert_add_info_format(pinfo, ti, &ei_bgp_ls_error,
                                       "Unexpected TLV Length (%u) in BGP-LS %s TLV, it must be %u bytes or more!",
                                       length, "SRv6 LAN End.X SID",
                                       protocol_id == BGP_LS_NLRI_PROTO_ID_OSPF ? 26 : 28);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endx_sid_endpoint_behavior, tvb, offset + 4, 2, ENC_NA);
            proto_tree_add_bitmask(tlv_tree, tvb, offset + 6,
                                   hf_bgp_ls_sr_tlv_srv6_endx_sid_flags,
                                   ett_bgp_link_state, srv6_endx_sid_flags, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endx_sid_algo, tvb, offset + 7, 1, ENC_NA);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endx_sid_weight, tvb, offset + 8, 1, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endx_sid_reserved, tvb, offset + 9, 1, ENC_BIG_ENDIAN);
            local_offset = offset + 10;
            if (protocol_id == BGP_LS_NLRI_PROTO_ID_OSPF) {
                proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endx_sid_neighbor_ospf, tvb, local_offset, 6, ENC_BIG_ENDIAN);
                local_offset += 4;
            } else {
                /* FF: most common case is IS-IS, so if it is not OSPF we go that way */
                proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endx_sid_neighbor_isis, tvb, local_offset, 6, ENC_BIG_ENDIAN);
                local_offset += 6;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endx_sid_sid, tvb, local_offset, 16, ENC_NA);
            local_offset += 16;
            while (local_offset < offset + length) {
                advance = decode_link_state_attribute_tlv(tlv_tree, tvb, local_offset, pinfo, protocol_id);
                if (advance < 0) {
                    break;
                }
                local_offset += advance;
            }
            break;

        case BGP_LS_APP_SPEC_LINK_ATTR:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_app_spec_link_attrs, tvb, offset, length + 4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            sabm_len = tvb_get_guint8(tvb, offset + 4);
            ti = proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_app_spec_link_attrs_sabm_len, tvb, offset + 4, 1, ENC_NA);
            if (sabm_len != 0 && sabm_len != 4 && sabm_len != 8) {
                expert_add_info_format(pinfo, ti, &ei_bgp_ls_error,
                                       "Unexpected SABM Length (%u) in BGP-LS Application-Specific Link Attributes TLV, it must be 0/4/8 bytes!",
                                       sabm_len);
                break;
            }
            udabm_len = tvb_get_guint8(tvb, offset + 5);
            ti = proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_app_spec_link_attrs_udabm_len, tvb, offset + 5, 1, ENC_NA);
            if (udabm_len != 0 && udabm_len != 4 && udabm_len != 8) {
                expert_add_info_format(pinfo, ti, &ei_bgp_ls_error,
                                       "Unexpected UDABM Length (%u) in BGP-LS Application Specific Link Attributes TLV, it must be 0/4/8 bytes!",
                                       sabm_len);
                break;
            }
            tmp16 = tvb_get_guint16(tvb, offset + 6, ENC_BIG_ENDIAN);
            ti = proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_app_spec_link_attrs_reserved, tvb, offset + 6, 2, ENC_BIG_ENDIAN);
            if (tmp16 != 0) {
                expert_add_info_format(pinfo, ti, &ei_bgp_ls_warn,
                                       "Reserved field must be 0 in BGP-LS Application-Specific Link Attributes TLV");
            }
            if (sabm_len > 0) {
                static int * const app_spec_link_attrs_sabm[] = {
                    &hf_bgp_ls_tlv_app_spec_link_attrs_sabm_r,
                    &hf_bgp_ls_tlv_app_spec_link_attrs_sabm_s,
                    &hf_bgp_ls_tlv_app_spec_link_attrs_sabm_f,
                    &hf_bgp_ls_tlv_app_spec_link_attrs_sabm_x,
                    NULL
                };
                proto_tree_add_bitmask(tlv_tree, tvb, offset + 8, hf_bgp_ls_tlv_app_spec_link_attrs_sabm,
                                       ett_bgp_link_state, app_spec_link_attrs_sabm, ENC_BIG_ENDIAN);
            }
            if (udabm_len > 0) {
                proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_app_spec_link_attrs_udabm,
                                    tvb, offset + 8 + sabm_len, udabm_len, ENC_NA);
            }
            /* Decode Link Attribute sub-TLVs */
            local_offset = offset + 8 + sabm_len + udabm_len;
            while (local_offset < offset + length) {
                advance = decode_link_state_attribute_tlv(tlv_tree, tvb, local_offset, pinfo, protocol_id);
                if (advance < 0) {
                    break;
                }
                local_offset += advance;
            }
            break;

        /* Prefix Attribute TLVs */
        case BGP_NLRI_TLV_IGP_FLAGS:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_igp_flags, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            if(length != BGP_NLRI_TLV_LEN_IGP_FLAGS){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected IGP Flags TLV's length (%u), it must be %u bytes!",
                                       length, BGP_NLRI_TLV_IGP_FLAGS);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_igp_flags_flag_d, tvb, offset + 4, 1, ENC_NA);
            tmp8 = tvb_get_guint8(tvb, offset + 4) & 0x7F;
            if(tmp8){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Reserved flags are not set to zero (%u).", tmp8);
            }
            break;

        case BGP_NLRI_TLV_ROUTE_TAG:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_route_tag, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            if(length % 4 != 0) {
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected Route Tag TLV's length (%u mod 4 != 0) ",
                                       length);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            tmp16 = length;
            n = 0;
            while(tmp16){
                if(tmp16 < 4) {
                    expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Route Tag must be 4 bytes long (%u).", tmp16);
                    break;
                }
                proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_route_tag_value, tvb, offset + 4 + (n * 4), 4, ENC_BIG_ENDIAN);
                tmp16 -= 4;
                n++;
            }
            break;

        case BGP_NLRI_TLV_EXTENDED_TAG:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_route_extended_tag, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            if(length % 8 != 0) {
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected Route Extended Tag TLV's length (%u mod 8 != 0) ",
                                       length);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            tmp16 = length;
            n = 0;
            while(tmp16){
                if(tmp16 < 8) {
                    expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Route Extended Tag must be 8 bytes long (%u).", tmp16);
                    break;
                }
                proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_route_extended_tag_value, tvb, offset + 4 + (n * 8), 8, ENC_BIG_ENDIAN);
                tmp16 -= 8;
                n++;
            }
            break;

        case BGP_NLRI_TLV_PREFIX_METRIC:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_tlv_prefix_metric, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            if(length != BGP_NLRI_TLV_LEN_PREFIX_METRIC){
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected Prefix Metric TLV's length (%u), it must be %u bytes!",
                                       length, BGP_NLRI_TLV_LEN_PREFIX_METRIC);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_prefix_metric_value, tvb, offset + 4, 4, ENC_BIG_ENDIAN);
            break;

        case BGP_NLRI_TLV_OSPF_FORWARDING_ADDRESS:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_ospf_forwarding_address, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            if (length == 4) {
                proto_tree_add_item(tlv_tree, hf_bgp_ls_ospf_forwarding_address_ipv4_address, tvb, offset + 4, length, ENC_BIG_ENDIAN);
            }
            else if (length == 16) {
                proto_tree_add_item(tlv_tree, hf_bgp_ls_ospf_forwarding_address_ipv6_address, tvb, offset + 4, length,  ENC_NA);
            }
            else {
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected Prefix Metric TLV's length (%u), it must be 4 or 16 bytes!", length);
                break;
            }
            break;

        case BGP_NLRI_TLV_OPAQUE_PREFIX_ATTRIBUTE:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_opaque_prefix_attribute, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_opaque_prefix_attribute_value, tvb, offset + 4, length, ENC_NA);
            break;

        case BGP_NLRI_TLV_EXTENDED_ADMINISTRATIVE_GROUP:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_extended_administrative_group, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            if(length % 4 != 0) {
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_error, "Unexpected Extended Administrative Group TLV's length (%u mod 4 != 0)",
                                       length);
                break;
            }
            tmp16 = length;
            while(tmp16){
                proto_tree_add_item(tlv_tree, hf_bgp_ls_extended_administrative_group_value, tvb, offset + 4 + (length - tmp16), 4, ENC_NA);
                tmp16 -= 4;
            }
            break;

        case BGP_LS_SR_TLV_PREFIX_SID:
            {
                /*
                   0  1  2  3  4  5  6  7
                  +--+--+--+--+--+--+--+--+
                  |R |N |P |E |V |L |  |  |
                  +--+--+--+--+--+--+--+--+
                */
                static int * const prefix_sid_isis_flags[] = {
                    &hf_bgp_ls_sr_tlv_prefix_sid_flags_r,
                    &hf_bgp_ls_sr_tlv_prefix_sid_flags_n,
                    &hf_bgp_ls_sr_tlv_prefix_sid_flags_p,
                    &hf_bgp_ls_sr_tlv_prefix_sid_flags_e,
                    &hf_bgp_ls_sr_tlv_prefix_sid_flags_v,
                    &hf_bgp_ls_sr_tlv_prefix_sid_flags_l,
                    NULL
                };
                /*
                   0  1  2  3  4  5  6  7
                  +--+--+--+--+--+--+--+--+
                  |  |NP|M |E |V |L |  |  |
                  +--+--+--+--+--+--+--+--+
                */
                static int * const prefix_sid_ospf_flags[] = {
                    &hf_bgp_ls_sr_tlv_prefix_sid_flags_np,
                    &hf_bgp_ls_sr_tlv_prefix_sid_flags_m,
                    &hf_bgp_ls_sr_tlv_prefix_sid_flags_e,
                    &hf_bgp_ls_sr_tlv_prefix_sid_flags_v,
                    &hf_bgp_ls_sr_tlv_prefix_sid_flags_l,
                    NULL
                };

                tlv_item = proto_tree_add_item(tree, hf_bgp_ls_sr_tlv_prefix_sid, tvb, offset, length + 4, ENC_NA);
                tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
                if (protocol_id == BGP_LS_NLRI_PROTO_ID_OSPF) {
                    proto_tree_add_bitmask(tlv_tree, tvb, offset + 4, hf_bgp_ls_sr_tlv_prefix_sid_flags,
                                           ett_bgp_link_state, prefix_sid_ospf_flags, ENC_BIG_ENDIAN);
                } else {
                    /* FF: most common case is IS-IS, so if it is not OSPF we go that way */
                    proto_tree_add_bitmask(tlv_tree, tvb, offset + 4, hf_bgp_ls_sr_tlv_prefix_sid_flags,
                                           ett_bgp_link_state, prefix_sid_isis_flags, ENC_BIG_ENDIAN);
                }
                proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_prefix_sid_algo, tvb, offset + 5, 1, ENC_BIG_ENDIAN);
                if (length == 7) {
                    proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_prefix_sid_label, tvb, offset + 8, 3, ENC_BIG_ENDIAN);
                } else {
                    proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_prefix_sid_index, tvb, offset + 8, 4, ENC_BIG_ENDIAN);
                }
            }
            break;

        case BGP_LS_SR_TLV_RANGE:
            break;

        case BGP_LS_SR_TLV_SRV6_LOCATOR:
            {
                static int * const srv6_locator_flags[] = {
                    &hf_bgp_ls_sr_tlv_srv6_locator_flags_d,
                    &hf_bgp_ls_sr_tlv_srv6_locator_flags_reserved,
                    NULL
                };
                tlv_item = proto_tree_add_item(tree, hf_bgp_ls_sr_tlv_srv6_locator, tvb, offset, length+4, ENC_NA);
                tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
                ti = proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
                if (length < 8) {
                    expert_add_info_format(pinfo, ti, &ei_bgp_ls_error,
                                           "Unexpected TLV Length (%u) in BGP-LS %s TLV, it must be %u bytes or more!",
                                           length, "SRv6 Locator", 8);
                    break;
                }
                proto_tree_add_bitmask(tlv_tree, tvb, offset + 4, hf_bgp_ls_sr_tlv_srv6_locator_flags,
                                       ett_bgp_link_state, srv6_locator_flags, ENC_NA);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_locator_algo, tvb, offset + 5, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_locator_reserved, tvb, offset + 6, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_locator_metric, tvb, offset + 8, 4, ENC_BIG_ENDIAN);
            }
            break;

        case BGP_LS_SR_TLV_PREFIX_ATTR_FLAGS:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_sr_tlv_prefix_attr_flags, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            if (protocol_id == BGP_LS_NLRI_PROTO_ID_OSPF) {
                /* rfc7684, rfc9089 */
                static int * const prefix_attr_ospf_flags[] = {
                    &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_ao,
                    &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_no,
                    &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_eo,
                    NULL
                };
                proto_tree_add_bitmask(tlv_tree, tvb, offset + 4, hf_bgp_ls_sr_tlv_prefix_attr_flags_flags,
                                       ett_bgp_link_state, prefix_attr_ospf_flags, ENC_BIG_ENDIAN);
            } else if (protocol_id == BGP_LS_NLRI_PROTO_ID_IS_IS_LEVEL_1 ||
                       protocol_id == BGP_LS_NLRI_PROTO_ID_IS_IS_LEVEL_2) {
                /* rfc7794, rfc9088 */
                static int * const prefix_attr_isis_flags[] = {
                    &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_xi,
                    &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_ri,
                    &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_ni,
                    &hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_ei,
                    NULL
                };
                proto_tree_add_bitmask(tlv_tree, tvb, offset + 4, hf_bgp_ls_sr_tlv_prefix_attr_flags_flags,
                                       ett_bgp_link_state, prefix_attr_isis_flags, ENC_BIG_ENDIAN);
            } else {
                proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_prefix_attr_flags_flags_unknown,
                                    tvb, offset + 4, tvb_get_guint16(tvb, offset + 2, ENC_BIG_ENDIAN), ENC_NA);
                expert_add_info_format(pinfo, tlv_tree, &ei_bgp_ls_warn,
                                       "Unknown Protocol-ID (%u) for Prefix Attribute Flags TLV",
                                       protocol_id);
            }
            break;

        case BGP_LS_SR_TLV_SOURCE_ROUTER_ID:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_sr_tlv_source_router_id, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            ti = proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            if (length == BGP_NLRI_TLV_LEN_IPV4_ROUTER_ID) {
                proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_ipv4_router_id_value, tvb, offset + 4, BGP_NLRI_TLV_LEN_IPV4_ROUTER_ID, ENC_NA);
            } else if (length == BGP_NLRI_TLV_LEN_IPV6_ROUTER_ID) {
                proto_tree_add_item(tlv_tree, hf_bgp_ls_tlv_ipv6_router_id_value, tvb, offset + 4, BGP_NLRI_TLV_LEN_IPV6_ROUTER_ID, ENC_NA);
            } else {
                expert_add_info_format(pinfo, ti, &ei_bgp_ls_error,
                                       "Unexpected TLV Length (%u) in BGP-LS %s TLV, it must be either %u or %u bytes!",
                                       length, "Source Router-ID",
                                       BGP_NLRI_TLV_LEN_IPV4_ROUTER_ID,
                                       BGP_NLRI_TLV_LEN_IPV6_ROUTER_ID);
            }
            break;

        /* SID Attribute TLVs */
        case BGP_LS_SR_TLV_SRV6_ENDPOINT_BEHAVIOR:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_sr_tlv_srv6_endpoint_behavior, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            ti = proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            if (length != 4) {
                expert_add_info_format(pinfo, ti, &ei_bgp_ls_error,
                                       "Unexpected TLV Length (%u) in BGP-LS %s TLV, it must be %u bytes!",
                                       length, "SRv6 Endpoint Behavior", 4);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endpoint_behavior_endpoint_behavior, tvb, offset + 4, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endpoint_behavior_flags, tvb, offset + 6, 1, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_endpoint_behavior_algo, tvb, offset + 7, 1, ENC_BIG_ENDIAN);
            break;

        case BGP_LS_SR_TLV_SRV6_SID_STRUCT:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_sr_tlv_srv6_sid_struct, tvb, offset, length + 4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            ti = proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            if (length != 4) {
                expert_add_info_format(pinfo, ti, &ei_bgp_ls_error,
                                       "Unexpected TLV Length (%u) in BGP-LS %s TLV, it must be %u bytes!",
                                       length, "SRv6 SID Structure", 4);
                break;
            }
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_sid_struct_lb_len, tvb, offset + 4, 1, ENC_NA);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_sid_struct_ln_len, tvb, offset + 5, 1, ENC_NA);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_sid_struct_fun_len, tvb, offset + 6, 1, ENC_NA);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_sr_tlv_srv6_sid_struct_arg_len, tvb, offset + 7, 1, ENC_NA);
            break;

        case BGP_LS_IGP_TE_METRIC_DELAY:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_igp_te_metric_delay, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_bitmask(tlv_tree, tvb, offset + 4, hf_bgp_ls_igp_te_metric_flags,
                                   ett_bgp_link_state, ls_igp_te_metric_flags, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_igp_te_metric_delay_value, tvb, offset + 5, 3, ENC_BIG_ENDIAN);
            break;
        case BGP_LS_IGP_TE_METRIC_DELAY_MIN_MAX:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_igp_te_metric_delay_min_max, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_bitmask(tlv_tree, tvb, offset + 4, hf_bgp_ls_igp_te_metric_flags,
                                   ett_bgp_link_state, ls_igp_te_metric_flags, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_igp_te_metric_delay_min, tvb, offset + 5, 3, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_igp_te_metric_reserved, tvb, offset + 8, 1, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_igp_te_metric_delay_max, tvb, offset + 9, 3, ENC_BIG_ENDIAN);
            break;
        case BGP_LS_IGP_TE_METRIC_DELAY_VARIATION:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_igp_te_metric_delay_variation, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_igp_te_metric_reserved, tvb, offset + 4, 1, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_igp_te_metric_delay_variation_value, tvb, offset + 5, 3, ENC_BIG_ENDIAN);
            break;
        case BGP_LS_IGP_TE_METRIC_LOSS:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_igp_te_metric_link_loss, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_bitmask(tlv_tree, tvb, offset + 4, hf_bgp_ls_igp_te_metric_flags,
                                   ett_bgp_link_state, ls_igp_te_metric_flags, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_igp_te_metric_link_loss_value, tvb, offset + 5, 3, ENC_BIG_ENDIAN);
            break;
        case BGP_LS_IGP_TE_METRIC_BANDWIDTH_RESIDUAL:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_igp_te_metric_bandwidth_residual, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_igp_te_metric_bandwidth_residual_value, tvb, offset + 4, 4, ENC_BIG_ENDIAN);
            break;
        case BGP_LS_IGP_TE_METRIC_BANDWIDTH_AVAILABLE:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_igp_te_metric_bandwidth_available, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_igp_te_metric_bandwidth_available_value, tvb, offset + 4, 4, ENC_BIG_ENDIAN);
            break;
        case BGP_LS_IGP_TE_METRIC_BANDWIDTH_UTILIZED:
            tlv_item = proto_tree_add_item(tree, hf_bgp_ls_igp_te_metric_bandwidth_utilized, tvb, offset, length+4, ENC_NA);
            tlv_tree = proto_item_add_subtree(tlv_item, ett_bgp_link_state);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_type, tvb, offset, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_length, tvb, offset + 2, 2, ENC_BIG_ENDIAN);
            proto_tree_add_item(tlv_tree, hf_bgp_ls_igp_te_metric_bandwidth_utilized_value, tvb, offset + 4, 4, ENC_BIG_ENDIAN);
            break;

        default:
            expert_add_info_format(pinfo, tree, &ei_bgp_ls_warn,
                "Unknown BGP-LS Attribute TLV Code (%u)!", type);
            break;
    }
    return length + 4;
}
