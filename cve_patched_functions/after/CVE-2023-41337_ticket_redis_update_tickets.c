static int ticket_redis_update_tickets(redisContext *ctx, h2o_iovec_t key, time_t now)
{
    redisReply *reply;
    session_ticket_vector_t tickets = {NULL};
    h2o_iovec_t tickets_serialized = {NULL};
    int retry = 0;
    char errbuf[256];

    if ((reply = redisCommand(ctx, "GET %s", key.base)) == NULL) {
        fprintf(stderr, "[lib/ssl.c] %s:redisCommand GET failed:%s\n", __func__, ctx->errstr);
        goto Exit;
    }
    if (reply->type == REDIS_REPLY_STRING) {
        int r = parse_tickets(&tickets, reply->str, reply->len, errbuf);
        freeReplyObject(reply);
        if (r != 0) {
            fprintf(stderr, "[lib/ssl.c] %s:failed to parse response:%s\n", __func__, errbuf);
            goto Exit;
        }
    }
    if (tickets.size > 1)
        qsort(tickets.entries, tickets.size, sizeof(tickets.entries[0]), ticket_sort_compare);

    if (update_tickets(&tickets, now) != 0) {
        tickets_serialized = serialize_tickets(&tickets);
        if ((reply = redisCommand(ctx, "SETEX %s %d %s", key.base, conf.lifetime, tickets_serialized.base)) == NULL) {
            fprintf(stderr, "[lib/ssl.c] %s:redisCommand SETEX failed:%s\n", __func__, ctx->errstr);
            goto Exit;
        }
        freeReplyObject(reply);

        retry = 1;
        goto Exit;
    }

    /* store the results */
    swap_register_session_tickets(&tickets);

Exit:
    free(tickets_serialized.base);
    free_tickets(&tickets);
    return retry;
}
