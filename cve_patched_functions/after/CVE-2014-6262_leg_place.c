int leg_place(
    image_desc_t *im,
    int calc_width)
{
    /* graph labels */
    int       interleg = im->text_prop[TEXT_PROP_LEGEND].size * 2.0;
    int       border = im->text_prop[TEXT_PROP_LEGEND].size * 2.0;
    int       fill = 0, fill_last;
    double    legendwidth; // = im->ximg - 2 * border;
    int       leg_c = 0;
    double    leg_x = border;
    int       leg_y = 0; //im->yimg;
    int       leg_cc;
    double    glue = 0;
    int       i, ii, mark = 0;
    char      default_txtalign = TXA_JUSTIFIED; /*default line orientation */
    int      *legspace;
    char     *tab;
    char      saved_legend[FMT_LEG_LEN + 5];

    if(calc_width){
        legendwidth = 0;
    }
    else{
        legendwidth = im->legendwidth - 2 * border;
    }


    if (!(im->extra_flags & NOLEGEND) && !(im->extra_flags & ONLY_GRAPH)) {
        if ((legspace = (int*)malloc(im->gdes_c * sizeof(int))) == NULL) {
            rrd_set_error("malloc for legspace");
            return -1;
        }

        for (i = 0; i < im->gdes_c; i++) {
            char      prt_fctn; /*special printfunctions */
            if(calc_width){
                strcpy(saved_legend, im->gdes[i].legend);
            }

            fill_last = fill;
            /* hide legends for rules which are not displayed */
            if (im->gdes[i].gf == GF_TEXTALIGN) {
                default_txtalign = im->gdes[i].txtalign;
            }

            if (!(im->extra_flags & FORCE_RULES_LEGEND)) {
                if (im->gdes[i].gf == GF_HRULE
                    && (im->gdes[i].yrule <
                        im->minval || im->gdes[i].yrule > im->maxval))
                    im->gdes[i].legend[0] = '\0';
                if (im->gdes[i].gf == GF_VRULE
                    && (im->gdes[i].xrule <
                        im->start || im->gdes[i].xrule > im->end))
                    im->gdes[i].legend[0] = '\0';
            }

            /* turn \\t into tab */
            while ((tab = strstr(im->gdes[i].legend, "\\t"))) {
                memmove(tab, tab + 1, strlen(tab));
                tab[0] = (char) 9;
            }

            leg_cc = strlen(im->gdes[i].legend);
            /* is there a controle code at the end of the legend string ? */
            if (leg_cc >= 2 && im->gdes[i].legend[leg_cc - 2] == '\\') {
                prt_fctn = im->gdes[i].legend[leg_cc - 1];
                leg_cc -= 2;
                im->gdes[i].legend[leg_cc] = '\0';
            } else {
                prt_fctn = '\0';
            }
            /* only valid control codes */
            if (prt_fctn != 'l' && prt_fctn != 'n' &&   /* a synonym for l */
                prt_fctn != 'r' &&
                prt_fctn != 'j' &&
                prt_fctn != 'c' &&
                prt_fctn != 'u' &&
                prt_fctn != '.' &&
                prt_fctn != 's' && prt_fctn != '\0' && prt_fctn != 'g') {
                free(legspace);
                rrd_set_error
                    ("Unknown control code at the end of '%s\\%c'",
                     im->gdes[i].legend, prt_fctn);
                return -1;
            }
            /* \n -> \l */
            if (prt_fctn == 'n') {
                prt_fctn = 'l';
            }
            /* \. is a null operation to allow strings ending in \x */
            if (prt_fctn == '.') {
                prt_fctn = '\0';
            }

            /* remove exess space from the end of the legend for \g */
            while (prt_fctn == 'g' &&
                   leg_cc > 0 && im->gdes[i].legend[leg_cc - 1] == ' ') {
                leg_cc--;
                im->gdes[i].legend[leg_cc] = '\0';
            }

            if (leg_cc != 0) {

                /* no interleg space if string ends in \g */
                legspace[i] = (prt_fctn == 'g' ? 0 : interleg);
                if (fill > 0) {
                    fill += legspace[i];
                }
                fill +=
                    gfx_get_text_width(im,
                                       fill + border,
                                       im->
                                       text_prop
                                       [TEXT_PROP_LEGEND].
                                       font_desc,
                                       im->tabwidth, im->gdes[i].legend);
                leg_c++;
            } else {
                legspace[i] = 0;
            }
            /* who said there was a special tag ... ? */
            if (prt_fctn == 'g') {
                prt_fctn = '\0';
            }

            if (prt_fctn == '\0') {
                if(calc_width && (fill > legendwidth)){
                    legendwidth = fill;
                }
                if (i == im->gdes_c - 1 || fill > legendwidth) {
                    /* just one legend item is left right or center */
                    switch (default_txtalign) {
                    case TXA_RIGHT:
                        prt_fctn = 'r';
                        break;
                    case TXA_CENTER:
                        prt_fctn = 'c';
                        break;
                    case TXA_JUSTIFIED:
                        prt_fctn = 'j';
                        break;
                    default:
                        prt_fctn = 'l';
                        break;
                    }
                }
                /* is it time to place the legends ? */
                if (fill > legendwidth) {
                    if (leg_c > 1) {
                        /* go back one */
                        i--;
                        fill = fill_last;
                        leg_c--;
                    }
                }
                if (leg_c == 1 && prt_fctn == 'j') {
                    prt_fctn = 'l';
                }
            }

            if (prt_fctn != '\0') {
                leg_x = border;
                if (leg_c >= 2 && prt_fctn == 'j') {
                    glue = (double)(legendwidth - fill) / (double)(leg_c - 1);
                } else {
                    glue = 0;
                }
                if (prt_fctn == 'c')
                    leg_x = border + (double)(legendwidth - fill) / 2.0;
                if (prt_fctn == 'r')
                    leg_x = legendwidth - fill + border;
                for (ii = mark; ii <= i; ii++) {
                    if (im->gdes[ii].legend[0] == '\0')
                        continue;   /* skip empty legends */
                    im->gdes[ii].leg_x = leg_x;
                    im->gdes[ii].leg_y = leg_y + border;
                    leg_x +=
                        (double)gfx_get_text_width(im, leg_x,
                                           im->
                                           text_prop
                                           [TEXT_PROP_LEGEND].
                                           font_desc,
                                           im->tabwidth, im->gdes[ii].legend)
                        +(double)legspace[ii]
                        + glue;
                }
                if (leg_x > border || prt_fctn == 's')
                    leg_y += im->text_prop[TEXT_PROP_LEGEND].size * 1.8;
                if (prt_fctn == 's')
                    leg_y -= im->text_prop[TEXT_PROP_LEGEND].size;
                if (prt_fctn == 'u')
                    leg_y -= im->text_prop[TEXT_PROP_LEGEND].size *1.8;

                if(calc_width && (fill > legendwidth)){
                    legendwidth = fill;
                }
                fill = 0;
                leg_c = 0;
                mark = ii;
            }

            if(calc_width){
                strcpy(im->gdes[i].legend, saved_legend);
            }
        }

        if(calc_width){
            im->legendwidth = legendwidth + 2 * border;
        }
        else{
            im->legendheight = leg_y + border * 0.6;
        }
        free(legspace);
    }
    return 0;
}
