static pj_status_t pack_amr ( codec_private_t *codec_data,
			      const struct pjmedia_frame_ext *input,
			      unsigned output_buf_len, 
			      struct pjmedia_frame *output)
{
    enum {MAX_FRAMES_PER_PACKET = PJMEDIA_MAX_FRAME_DURATION_MS / 20};

    pjmedia_frame frames[MAX_FRAMES_PER_PACKET];
    amr_settings_t* setting = (amr_settings_t*)codec_data->codec_setting;
    pjmedia_codec_amr_pack_setting *enc_setting = &setting->enc_setting;
    pj_uint8_t SID_FT;
    unsigned i;

    pj_assert(input->subframe_cnt <= MAX_FRAMES_PER_PACKET);

    SID_FT = (pj_uint8_t)(enc_setting->amr_nb? 8 : 9);

    /* Get frames */
    for (i = 0; i < input->subframe_cnt; ++i) {
	pjmedia_frame_ext_subframe *sf;
	pjmedia_codec_amr_bit_info *info;
	unsigned len;
	
	sf = pjmedia_frame_ext_get_subframe(input, i);
	len = (sf->bitlen + 7) >> 3;
	
	info = (pjmedia_codec_amr_bit_info*) &frames[i].bit_info;
	pj_bzero(info, sizeof(*info));
	
	if (len == 0) {
	    /* DTX */
	    info->frame_type = 15;
	} else {
	    info->frame_type = pjmedia_codec_amr_get_mode2(enc_setting->amr_nb, 
							   len);
	}
	info->good_quality = 1;
	info->mode = setting->enc_mode;
	if (info->frame_type == SID_FT)
	    info->STI = (sf->data[4] >> 4) & 1;

	frames[i].buf = sf->data;
	frames[i].size = len;
    }

    output->size = output_buf_len;

    return pjmedia_codec_amr_pack(frames, input->subframe_cnt, enc_setting, 
				  output->buf, &output->size);
}
