void __fastcall TSessionData::DoSave(THierarchicalStorage * Storage,
  bool PuttyExport, const TSessionData * Default, bool DoNotEncryptPasswords)
{
  // Same as in TCopyParamType::Save
  #define WRITE_DATA_EX(TYPE, NAME, PROPERTY, CONV) \
    if ((Default != NULL) && (CONV(Default->PROPERTY) == CONV(PROPERTY))) \
    { \
      Storage->DeleteValue(NAME); \
    } \
    else \
    { \
      Storage->Write ## TYPE(NAME, CONV(PROPERTY)); \
    }
  #define WRITE_DATA_CONV(TYPE, NAME, PROPERTY) WRITE_DATA_EX(TYPE, NAME, PROPERTY, WRITE_DATA_CONV_FUNC)
  #define WRITE_DATA(TYPE, PROPERTY) WRITE_DATA_EX(TYPE, TEXT(#PROPERTY), PROPERTY, )

  WRITE_DATA(String, HostName);
  WRITE_DATA(Integer, PortNumber);
  WRITE_DATA_EX(Integer, L"PingInterval", PingInterval / SecsPerMin, );
  WRITE_DATA_EX(Integer, L"PingIntervalSecs", PingInterval % SecsPerMin, );
  Storage->DeleteValue(L"PingIntervalSec"); // obsolete
  WRITE_DATA(Integer, PingType);
  WRITE_DATA(Integer, Timeout);
  WRITE_DATA(Bool, TryAgent);
  WRITE_DATA(Bool, AgentFwd);
  WRITE_DATA(Bool, AuthTIS);
  WRITE_DATA(Bool, AuthKI);
  WRITE_DATA(Bool, AuthKIPassword);
  WRITE_DATA(String, Note);

  WRITE_DATA(Bool, AuthGSSAPI);
  WRITE_DATA(Bool, GSSAPIFwdTGT);
  Storage->DeleteValue(L"TryGSSKEX");
  Storage->DeleteValue(L"UserNameFromEnvironment");
  Storage->DeleteValue("GSSAPIServerChoosesUserName");
  Storage->DeleteValue(L"GSSAPITrustDNS");
  WRITE_DATA(String, LogicalHostName);
  if (PuttyExport)
  {
    // duplicate kerberos setting with keys of the vintela quest putty
    WRITE_DATA_EX(Bool, L"AuthSSPI", AuthGSSAPI, );
    WRITE_DATA_EX(Bool, L"SSPIFwdTGT", GSSAPIFwdTGT, );
    WRITE_DATA_EX(String, L"KerbPrincipal", LogicalHostName, );
    // duplicate kerberos setting with keys of the official putty
    WRITE_DATA_EX(Bool, L"GssapiFwd", GSSAPIFwdTGT, );
  }

  WRITE_DATA(Bool, ChangeUsername);
  WRITE_DATA(Bool, Compression);
  WRITE_DATA(Integer, SshProt);
  WRITE_DATA(Bool, Ssh2DES);
  WRITE_DATA(Bool, SshNoUserAuth);
  WRITE_DATA_EX(String, L"Cipher", CipherList, );
  WRITE_DATA_EX(String, L"KEX", KexList, );
  WRITE_DATA_EX(String, L"HostKey", HostKeyList, );
  WRITE_DATA_EX(String, L"GSSLibs", GssLibList, );
  WRITE_DATA_EX(String, L"GSSCustom", GssLibCustom, );
  WRITE_DATA(Integer, AddressFamily);
  WRITE_DATA_EX(String, L"RekeyBytes", RekeyData, );
  WRITE_DATA(Integer, RekeyTime);

  WRITE_DATA(Bool, TcpNoDelay);

  if (PuttyExport)
  {
    WRITE_DATA(StringRaw, UserName);
    // PuTTY is started in its binary directory to allow relative paths when opening PuTTY's own stored session.
    // To allow relative paths in our sessions, we have to expand them for PuTTY.
    WRITE_DATA_EX(StringRaw, L"PublicKeyFile", PublicKeyFile, ExpandFileName);
  }
  else
  {
    WRITE_DATA(String, UserName);
    WRITE_DATA(String, PublicKeyFile);
    WRITE_DATA(Integer, FSProtocol);
    WRITE_DATA(String, LocalDirectory);
    WRITE_DATA(String, RemoteDirectory);
    WRITE_DATA(Bool, SynchronizeBrowsing);
    WRITE_DATA(Bool, UpdateDirectories);
    WRITE_DATA(Bool, CacheDirectories);
    WRITE_DATA(Bool, CacheDirectoryChanges);
    WRITE_DATA(Bool, PreserveDirectoryChanges);

    WRITE_DATA(Bool, ResolveSymlinks);
    WRITE_DATA(Bool, FollowDirectorySymlinks);
    WRITE_DATA_EX(Integer, L"ConsiderDST", DSTMode, );
    WRITE_DATA(Bool, LockInHome);
    // Special is never stored (if it would, login dialog must be modified not to
    // duplicate Special parameter when Special session is loaded and then stored
    // under different name)
    // WRITE_DATA(Bool, Special);
    WRITE_DATA(String, Shell);
    WRITE_DATA(Bool, ClearAliases);
    WRITE_DATA(Bool, UnsetNationalVars);
    WRITE_DATA(String, ListingCommand);
    WRITE_DATA(Bool, IgnoreLsWarnings);
    WRITE_DATA(Integer, SCPLsFullTime);
    WRITE_DATA(Bool, Scp1Compatibility);
    // TimeDifferenceAuto is valid for FTP protocol only.
    // For other protocols it's typically true (default value),
    // but ignored so TimeDifference is still taken into account (SCP only actually)
    if (TimeDifferenceAuto && (FSProtocol == fsFTP))
    {
      // Have to delete it as TimeDifferenceAuto is not saved when enabled,
      // but the default is derived from value of TimeDifference.
      Storage->DeleteValue(L"TimeDifference");
    }
    else
    {
      WRITE_DATA(Float, TimeDifference);
    }
    WRITE_DATA(Bool, TimeDifferenceAuto);
    WRITE_DATA(Bool, DeleteToRecycleBin);
    WRITE_DATA(Bool, OverwrittenToRecycleBin);
    WRITE_DATA(String, RecycleBinPath);
    WRITE_DATA(String, PostLoginCommands);

    WRITE_DATA(String, ReturnVar);
    WRITE_DATA(Bool, ExitCode1IsError);
    WRITE_DATA_EX(Integer, L"LookupUserGroups2", LookupUserGroups, );
    WRITE_DATA(Integer, EOLType);
    WRITE_DATA(Bool, TrimVMSVersions);
    Storage->DeleteValue(L"SFTPUtfBug");
    WRITE_DATA_EX(Integer, L"Utf", NotUtf, );
    WRITE_DATA(Integer, InternalEditorEncoding);
    WRITE_DATA(String, S3DefaultRegion);
    WRITE_DATA(Integer, S3UrlStyle);
    WRITE_DATA(Integer, SendBuf);
    WRITE_DATA(String, SourceAddress);
    WRITE_DATA(Bool, SshSimple);
  }

  WRITE_DATA(Integer, ProxyMethod);
  WRITE_DATA(String, ProxyHost);
  WRITE_DATA(Integer, ProxyPort);
  WRITE_DATA(String, ProxyUsername);
  if (ProxyMethod == pmCmd)
  {
    WRITE_DATA_EX(StringRaw, L"ProxyTelnetCommand", ProxyLocalCommand, );
  }
  else
  {
    WRITE_DATA(StringRaw, ProxyTelnetCommand);
  }
  #define WRITE_DATA_CONV_FUNC(X) (((X) + 2) % 3)
  WRITE_DATA_CONV(Integer, L"ProxyDNS", ProxyDNS);
  #undef WRITE_DATA_CONV_FUNC
  WRITE_DATA(Bool, ProxyLocalhost);

  #define WRITE_DATA_CONV_FUNC(X) (2 - (X))
  #define WRITE_BUG(BUG) WRITE_DATA_CONV(Integer, L"Bug" #BUG, Bug[sb##BUG]);
  WRITE_BUG(Ignore1);
  WRITE_BUG(PlainPW1);
  WRITE_BUG(RSA1);
  WRITE_BUG(HMAC2);
  WRITE_BUG(DeriveKey2);
  WRITE_BUG(RSAPad2);
  WRITE_BUG(PKSessID2);
  WRITE_BUG(Rekey2);
  WRITE_BUG(MaxPkt2);
  WRITE_BUG(Ignore2);
  WRITE_BUG(OldGex2);
  WRITE_BUG(WinAdj);
  WRITE_BUG(ChanReq);
  #undef WRITE_BUG
  #undef WRITE_DATA_CONV_FUNC

  Storage->DeleteValue(L"BuggyMAC");
  Storage->DeleteValue(L"AliasGroupList");

  if (PuttyExport)
  {
    WRITE_DATA_EX(String, L"Protocol", GetNormalizedPuttyProtocol(), );
    WRITE_DATA(String, WinTitle);
  }

  if (!PuttyExport)
  {
    WRITE_DATA(String, SftpServer);

    #define WRITE_SFTP_BUG(BUG) WRITE_DATA_EX(Integer, L"SFTP" #BUG "Bug", SFTPBug[sb##BUG], );
    WRITE_SFTP_BUG(Symlink);
    WRITE_SFTP_BUG(SignedTS);
    #undef WRITE_SFTP_BUG

    WRITE_DATA(Integer, SFTPMaxVersion);
    WRITE_DATA(Integer, SFTPMaxPacketSize);
    WRITE_DATA(Integer, SFTPDownloadQueue);
    WRITE_DATA(Integer, SFTPUploadQueue);
    WRITE_DATA(Integer, SFTPListingQueue);

    WRITE_DATA(Integer, Color);

    WRITE_DATA(Bool, Tunnel);
    WRITE_DATA(String, TunnelHostName);
    WRITE_DATA(Integer, TunnelPortNumber);
    WRITE_DATA(String, TunnelUserName);
    WRITE_DATA(String, TunnelPublicKeyFile);
    WRITE_DATA(Integer, TunnelLocalPortNumber);

    WRITE_DATA(Bool, FtpPasvMode);
    WRITE_DATA_EX(Integer, L"FtpForcePasvIp2", FtpForcePasvIp, );
    WRITE_DATA(Integer, FtpUseMlsd);
    WRITE_DATA(String, FtpAccount);
    WRITE_DATA(Integer, FtpPingInterval);
    WRITE_DATA(Integer, FtpPingType);
    WRITE_DATA_EX(Integer, L"FtpTransferActiveImmediately2", FtpTransferActiveImmediately, );
    WRITE_DATA(Integer, Ftps);
    WRITE_DATA(Integer, FtpListAll);
    WRITE_DATA(Integer, FtpHost);
    WRITE_DATA(Integer, FtpDeleteFromCwd);
    WRITE_DATA(Bool, SslSessionReuse);
    WRITE_DATA(String, TlsCertificateFile);

    WRITE_DATA(Integer, FtpProxyLogonType);

    WRITE_DATA(Integer, MinTlsVersion);
    WRITE_DATA(Integer, MaxTlsVersion);

    WRITE_DATA(Bool, IsWorkspace);
    WRITE_DATA(String, Link);
    WRITE_DATA(String, NameOverride);

    WRITE_DATA(String, PuttySettings);

    WRITE_DATA(String, CustomParam1);
    WRITE_DATA(String, CustomParam2);
  }

  // This is for collecting all keys for TSiteRawDialog::AddButtonClick.
  // It should be enough to test for (Default == NULL),
  // the DoNotEncryptPasswords and PuttyExport were added to limit a possible unintended impact.
  bool SaveAll = (Default == NULL) && DoNotEncryptPasswords && !PuttyExport;

  SavePasswords(Storage, PuttyExport, DoNotEncryptPasswords, SaveAll);

  if (PuttyExport)
  {
    WritePuttySettings(Storage, PuttySettings);
  }
}
