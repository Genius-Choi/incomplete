impl::Authenticode_SpcIndirectDataContent *SignedData::get_indirect_data() const {
  auto *contents = p7_->d.sign->contents;
  if (contents == nullptr) {
    return nullptr;
  }

  /* We're expecting a sequence whose type is SPC_INDIRECT_DATA_OID.
   */
  OBJ_create(impl::SPC_INDIRECT_DATA_OID, NULL, NULL);
  auto *spc_indir_oid_ptr = OBJ_txt2obj(impl::SPC_INDIRECT_DATA_OID, 1);
  if (spc_indir_oid_ptr == nullptr) {
    return nullptr;
  }
  impl::ASN1_OBJECT_ptr spc_indir_oid(spc_indir_oid_ptr, ASN1_OBJECT_free);

  if (ASN1_TYPE_get(contents->d.other) != V_ASN1_SEQUENCE ||
      OBJ_cmp(contents->type, spc_indir_oid.get())) {
    return nullptr;
  }

  /* TODO: Could probably use a BIO here instead of the direct-from-buffer API.
   */
  const auto *indir_data_inc_ptr = contents->d.other->value.sequence->data;
  auto *indir_data = impl::d2i_Authenticode_SpcIndirectDataContent(
      nullptr, &indir_data_inc_ptr, contents->d.other->value.sequence->length);
  if (indir_data == nullptr) {
    return nullptr;
  }

  /* Sanity checks against SpcIndirectDataContent. It's not clear to me
   * whether a non-nullptr above guarantees any of these fields, so check
   * them manually.
   */
  if (indir_data->messageDigest->digest->data == nullptr ||
      indir_data->messageDigest->digest->length >= contents->d.other->value.sequence->length) {
    return nullptr;
  }

  return indir_data;
}
