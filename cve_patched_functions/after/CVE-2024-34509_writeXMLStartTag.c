void DcmElement::writeXMLStartTag(STD_NAMESPACE ostream &out,
                                  const size_t flags,
                                  const char *attrText)
{
    OFString xmlString;
    DcmVR vr(getTag().getVR());
    DcmTag tag = getTag();
    const OFBool isPrivate = tag.isPrivate();

    /* write XML start tag for attribute */
    if (flags & DCMTypes::XF_useNativeModel)
    {
        out << "<DicomAttribute";
        out << STD_NAMESPACE uppercase;
    } else
        out << "<element";

    /* write attribute tag */
    out << " tag=\"";
    out << STD_NAMESPACE hex << STD_NAMESPACE setfill('0')
        << STD_NAMESPACE setw(4) << tag.getGTag();
    /* in Native DICOM Model, write "ggggeeee" (no comma, upper case!) */
    if (flags & DCMTypes::XF_useNativeModel)
    {
        /* for private element numbers, zero out 2 first element digits */
        if (isPrivate)
        {
            out << STD_NAMESPACE setw(4) << (tag.getETag() & 0x00FF) << "\""
                << STD_NAMESPACE dec << STD_NAMESPACE setfill(' ');
        }
        else  /* output full element number "eeee" */
        {
            out << STD_NAMESPACE setw(4) << tag.getETag() << "\""
                << STD_NAMESPACE dec << STD_NAMESPACE setfill(' ');
        }
        out << STD_NAMESPACE nouppercase;
    }
    else  /* in DCMTK-specific format, write "gggg,eeee" */
    {
        out << "," << STD_NAMESPACE setw(4) << tag.getETag() << "\""
            << STD_NAMESPACE dec << STD_NAMESPACE setfill(' ');
    }

    /* value representation = VR */
    out << " vr=\"" << vr.getValidVRName() << "\"";

    if (flags & DCMTypes::XF_useNativeModel)
    {
        if (isPrivate)
        {
            /* output the creator of this private tag (but not for the creator tag itself) */
            if (!tag.isPrivateReservation())
            {
                const char *creator = tag.getPrivateCreator();
                if (creator != NULL)
                {
                    out << " privateCreator=\"";
                    out << creator << "\"";
                } else {
                    DCMDATA_WARN("Cannot write private creator for group 0x"
                        << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(4)
                        << tag.getGTag() << STD_NAMESPACE dec << STD_NAMESPACE setfill(' ')
                        << " to XML output: Not present in data set");
                }
            }
        } else {
            /* write attribute keyword if known (and the official name is used in the data dictionary) */
            const OFString tagName = getTagName();
            if ((tagName != DcmTag_ERROR_TagName) &&
                /* check for DCMTK-specific name prefixes used for old ACR NEMA and retired tags */
                (tagName.substr(0, 8) != "RETIRED_") && (tagName.substr(0, 9) != "ACR_NEMA_"))
            {
                out << " keyword=\"" << OFStandard::convertToMarkupString(tagName, xmlString) << "\"";
            }
        }
        /* close XML start tag */
        out << ">" << OFendl;
    } else {
        /* value multiplicity = 1..n */
        out << " vm=\"" << getVM() << "\"";
        /* value length in bytes = 0..max */
        out << " len=\"" << getLengthField() << "\"";
        /* tag name (if known and not suppressed) */
        if (!(flags & DCMTypes::XF_omitDataElementName))
            out << " name=\"" << OFStandard::convertToMarkupString(getTagName(), xmlString) << "\"";
        /* value loaded = no (or absent)*/
        if (!valueLoaded())
            out << " loaded=\"no\"";
        /* write additional attributes (if any) */
        if ((attrText != NULL) && (attrText[0] != '\0'))
            out << " " << attrText;
        /* close XML start tag */
        out << ">";
    }
}
