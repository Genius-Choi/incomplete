TEST_P(ProxyFilterIntegrationTest, StreamPersistAcrossShortTtlResFail) {
  setDownstreamProtocol(Http::CodecType::HTTP2);
  setUpstreamProtocol(Http::CodecType::HTTP2);

  upstream_tls_ = false; // avoid cert errors for unknown hostname
  use_cache_file_ = true;
  dns_cache_ttl_ = 2;

  dns_hostname_ = "not_actually_localhost"; // Set to a name that won't resolve.
  initializeWithArgs();
  std::string host =
      fmt::format("{}:{}", dns_hostname_, fake_upstreams_[0]->localAddress()->ip()->port());
  codec_client_ = makeHttpConnection(lookupPort("http"));
  const Http::TestRequestHeaderMapImpl request_headers{
      {":method", "POST"}, {":path", "/test/long/url"}, {":scheme", "http"}, {":authority", host}};

  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);
  waitForNextUpstreamRequest();

  // When the TTL is hit, the host will be removed from the DNS cache. This
  // won't break the outstanding connection.
  test_server_->waitForCounterGe("dns_cache.foo.host_removed", 1);

  // Kick off a new request before the first is served.
  auto response2 = codec_client_->makeHeaderOnlyRequest(request_headers);

  // Make sure response 1 is served.
  upstream_request_->encodeHeaders(default_response_headers_, true);
  ASSERT_TRUE(response->waitForEndStream());
  EXPECT_EQ("200", response->headers().getStatusValue());

  // Because request 2 started after DNS entry eviction it will fail due to DNS lookup failure.
  ASSERT_TRUE(response2->waitForEndStream());
  EXPECT_EQ("503", response2->headers().getStatusValue());
}
