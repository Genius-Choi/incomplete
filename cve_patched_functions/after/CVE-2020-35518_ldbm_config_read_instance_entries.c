ldbm_config_read_instance_entries(struct ldbminfo *li, const char *backend_type)
{
    Slapi_PBlock *tmp_pb;
    Slapi_Entry **entries = NULL;
    char *basedn = NULL;
    int rc = 0;

    /* Construct the base dn of the subtree that holds the instance entries. */
    basedn = slapi_create_dn_string("cn=%s,cn=plugins,cn=config", backend_type);
    if (NULL == basedn) {
        slapi_log_err(SLAPI_LOG_ERR,
                      "ldbm_config_read_instance_entries",
                      "failed to create backend dn for %s\n", backend_type);
        return 1;
    }

    /* Do a search of the subtree containing the instance entries */
    tmp_pb = slapi_pblock_new();
    slapi_search_internal_set_pb(tmp_pb, basedn, LDAP_SCOPE_SUBTREE, "(objectclass=nsBackendInstance)", NULL, 0, NULL, NULL, li->li_identity, 0);
    slapi_search_internal_pb(tmp_pb);
    slapi_pblock_get(tmp_pb, SLAPI_PLUGIN_INTOP_SEARCH_ENTRIES, &entries);
    if (entries != NULL) {
        int i;
        for (i = 0; entries[i] != NULL; i++) {
            rc = ldbm_instance_add_instance_entry_callback(NULL,
                                                           entries[i], NULL, NULL, NULL, li);
            if (SLAPI_DSE_CALLBACK_ERROR == rc) {
                slapi_log_err(SLAPI_LOG_ERR,
                              "ldbm_config_read_instance_entries",
                              "Failed to add instance entry %s\n",
                              slapi_entry_get_dn_const(entries[i]));
                break;
            }
            rc = 0;
        }
    }

    slapi_free_search_results_internal(tmp_pb);
    slapi_pblock_destroy(tmp_pb);
    slapi_ch_free_string(&basedn);

    return rc;
}
