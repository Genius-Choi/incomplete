DltReturnValue dlt_message_payload(DltMessage *msg, char *text, size_t textlength, int type, int verbose)
{
    uint32_t id = 0, id_tmp = 0;
    uint8_t retval = 0;

    uint8_t *ptr;
    int32_t datalength;

    /* Pointer to ptr and datalength */
    uint8_t **pptr;
    int32_t *pdatalength;

    int ret = 0;

    int num;
    uint32_t type_info = 0, type_info_tmp = 0;
    int text_offset = 0;

    PRINT_FUNCTION_VERBOSE(verbose);

    if ((msg == NULL) || (msg->databuffer == NULL) || (text == NULL) ||
        (type < DLT_OUTPUT_HEX) || (type > DLT_OUTPUT_ASCII_LIMITED))
        return DLT_RETURN_WRONG_PARAMETER;

    if (textlength <= 0) {
        dlt_log(LOG_WARNING, "String does not fit binary data!\n");
        return DLT_RETURN_WRONG_PARAMETER;
    }

    /* start with empty string */
    text[0] = 0;

    /* print payload only as hex */
    if (type == DLT_OUTPUT_HEX)
        return dlt_print_hex_string(text, (int)textlength, msg->databuffer, (int)msg->datasize);

    /* print payload as mixed */
    if (type == DLT_OUTPUT_MIXED_FOR_PLAIN)
        return dlt_print_mixed_string(text, (int)textlength, msg->databuffer, (int)msg->datasize, 0);

    if (type == DLT_OUTPUT_MIXED_FOR_HTML)
        return dlt_print_mixed_string(text, (int)textlength, msg->databuffer, (int)msg->datasize, 1);

    ptr = msg->databuffer;
    datalength = (int32_t)msg->datasize;

    /* Pointer to ptr and datalength */
    pptr = &ptr;
    pdatalength = &datalength;

    /* non-verbose mode */

    /* print payload as hex */
    if (DLT_MSG_IS_NONVERBOSE(msg)) {

        DLT_MSG_READ_VALUE(id_tmp, ptr, datalength, uint32_t);
        id = DLT_ENDIAN_GET_32(msg->standardheader->htyp, id_tmp);

        if (textlength < (((unsigned int)datalength * 3) + 20)) {
            dlt_vlog(LOG_WARNING,
                     "String does not fit binary data (available=%d, required=%d) !\n",
                     (int) textlength, (datalength * 3) + 20);
            return DLT_RETURN_ERROR;
        }

        /* process message id / service id */
        if (DLT_MSG_IS_CONTROL(msg)) {
            if ((id > 0) && (id < DLT_SERVICE_ID_LAST_ENTRY))
                snprintf(text + strlen(text), textlength - strlen(text), "%s",
                         service_id_name[id]); /* service id */
            else if (!(DLT_MSG_IS_CONTROL_TIME(msg)))
                snprintf(text + strlen(text), textlength - strlen(text), "service(%u)", id); /* service id */

            if (datalength > 0)
                snprintf(text + strlen(text), textlength - strlen(text), ", ");
        }
        else {
            snprintf(text + strlen(text), textlength - strlen(text), "%u, ", id); /* message id */
        }

        /* process return value */
        if (DLT_MSG_IS_CONTROL_RESPONSE(msg)) {
            if (datalength > 0) {
                DLT_MSG_READ_VALUE(retval, ptr, datalength, uint8_t); /* No endian conversion necessary */

                if ((retval < DLT_SERVICE_RESPONSE_LAST) || (retval == 8))
                    snprintf(text + strlen(text), textlength - strlen(text), "%s", return_type[retval]);
                else
                    snprintf(text + strlen(text), textlength - strlen(text), "%.2x", retval);

                if (datalength >= 1)
                    snprintf(text + strlen(text), textlength - strlen(text), ", ");
            }
        }

        if (type == DLT_OUTPUT_ASCII_LIMITED) {
            ret = dlt_print_hex_string(text + strlen(text),
                                       (int)(textlength - strlen(
                                                 text)),
                                       ptr,
                                       (datalength >
                                        DLT_COMMON_ASCII_LIMIT_MAX_CHARS ? DLT_COMMON_ASCII_LIMIT_MAX_CHARS : datalength));

            if ((datalength > DLT_COMMON_ASCII_LIMIT_MAX_CHARS) &&
                ((textlength - strlen(text)) > 4))
                snprintf(text + strlen(text), textlength - strlen(text), " ...");
        }
        else {
            ret = dlt_print_hex_string(text + strlen(text), (int)(textlength - strlen(text)), ptr, datalength);
        }

        return ret;
    }

    /* At this point, it is ensured that a extended header is available */

    /* verbose mode */
    type_info = 0;
    type_info_tmp = 0;

    for (num = 0; num < (int)(msg->extendedheader->noar); num++) {
        if (num != 0) {
            text_offset = (int)strlen(text);
            snprintf(text + text_offset, textlength - (size_t)text_offset, " ");
        }

        /* first read the type info of the argument */
        DLT_MSG_READ_VALUE(type_info_tmp, ptr, datalength, uint32_t);
        type_info = DLT_ENDIAN_GET_32(msg->standardheader->htyp, type_info_tmp);

        /* print out argument */
        text_offset = (int)strlen(text);

        if (dlt_message_argument_print(msg, type_info, pptr, pdatalength,
                                       (text + text_offset), (textlength - (size_t)text_offset), -1,
                                       0) == DLT_RETURN_ERROR)
            return DLT_RETURN_ERROR;
    }

    return DLT_RETURN_OK;
}
