static void bgp_dynamic_capability_fqdn(uint8_t *pnt, int action,
					struct capability_header *hdr,
					struct peer *peer)
{
	uint8_t *data = pnt + 3;
	uint8_t *end = data + hdr->length;
	char str[BGP_MAX_HOSTNAME + 1] = {};
	uint8_t len;

	if (action == CAPABILITY_ACTION_SET) {
		/* hostname */
		if (data + 1 > end) {
			zlog_err("%pBP: Received invalid FQDN capability (host name length)",
				 peer);
			return;
		}

		len = *data;
		if (data + len > end) {
			zlog_err("%pBP: Received invalid FQDN capability length (host name) %d",
				 peer, hdr->length);
			return;
		}
		data++;

		if (len > BGP_MAX_HOSTNAME) {
			memcpy(&str, data, BGP_MAX_HOSTNAME);
			str[BGP_MAX_HOSTNAME] = '\0';
		} else if (len) {
			memcpy(&str, data, len);
			str[len] = '\0';
		}
		data += len;

		if (len) {
			XFREE(MTYPE_BGP_PEER_HOST, peer->hostname);
			XFREE(MTYPE_BGP_PEER_HOST, peer->domainname);

			peer->hostname = XSTRDUP(MTYPE_BGP_PEER_HOST, str);
		}

		if (data + 1 > end) {
			zlog_err("%pBP: Received invalid FQDN capability (domain name length)",
				 peer);
			return;
		}

		/* domainname */
		len = *data;
		if (data + len > end) {
			zlog_err("%pBP: Received invalid FQDN capability length (domain name) %d",
				 peer, len);
			return;
		}
		data++;

		if (len > BGP_MAX_HOSTNAME) {
			memcpy(&str, data, BGP_MAX_HOSTNAME);
			str[BGP_MAX_HOSTNAME] = '\0';
		} else if (len) {
			memcpy(&str, data, len);
			str[len] = '\0';
		}
		data += len;

		if (len) {
			str[len] = '\0';

			XFREE(MTYPE_BGP_PEER_HOST, peer->domainname);

			peer->domainname = XSTRDUP(MTYPE_BGP_PEER_HOST, str);
		}

		SET_FLAG(peer->cap, PEER_CAP_HOSTNAME_RCV);
	} else {
		UNSET_FLAG(peer->cap, PEER_CAP_HOSTNAME_RCV);
		XFREE(MTYPE_BGP_PEER_HOST, peer->hostname);
		XFREE(MTYPE_BGP_PEER_HOST, peer->domainname);
	}
}
