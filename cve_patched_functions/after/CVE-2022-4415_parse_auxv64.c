static int parse_auxv64(
                const uint64_t *auxv,
                size_t size_bytes,
                int *at_secure,
                uid_t *uid,
                uid_t *euid,
                gid_t *gid,
                gid_t *egid) {

        assert(auxv || size_bytes == 0);

        if (size_bytes % (2 * sizeof(uint64_t)) != 0)
                return log_warning_errno(SYNTHETIC_ERRNO(EIO), "Incomplete auxv structure (%zu bytes).", size_bytes);

        size_t words = size_bytes / sizeof(uint64_t);

        /* Note that we set output variables even on error. */

        for (size_t i = 0; i + 1 < words; i += 2)
                switch (auxv[i]) {
                case AT_SECURE:
                        *at_secure = auxv[i + 1] != 0;
                        break;
                case AT_UID:
                        *uid = auxv[i + 1];
                        break;
                case AT_EUID:
                        *euid = auxv[i + 1];
                        break;
                case AT_GID:
                        *gid = auxv[i + 1];
                        break;
                case AT_EGID:
                        *egid = auxv[i + 1];
                        break;
                case AT_NULL:
                        if (auxv[i + 1] != 0)
                                goto error;
                        return 0;
                }
 error:
        return log_warning_errno(SYNTHETIC_ERRNO(ENODATA),
                                 "AT_NULL terminator not found, cannot parse auxv structure.");
}
