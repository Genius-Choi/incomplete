char* decode_mime_type(char *start, char *end, unsigned int *mime_type, content_t * con)
{
	int node;
	char *mark;
	char *p;

	p = start;

	LM_DBG("Decoding MIME type for:[%.*s]\n",(int)(end-start),start);

	/* search the beginning of the type */
	while ( p<end && (*p==' ' || *p=='\t' || (*p=='\r' && *(p+1)=='\n') ||
	(*p=='\n' && (*(p+1)==' '||*(p+1)=='\t')) ))
		p++;
	if (p==end)
		goto error;

	/* parse the type */
	if (*p=='*') {
		*mime_type = TYPE_ALL<<16;
		p++;
	} else {
		node = 0;
		mark = p;
		while (p<end && is_mime_char(*p)  ) {
			while ( node!=-1 && !is_char_equal(*p,type_tree[node].c) ){
				node = type_tree[node].next;
			}
			if (node!=-1 && type_tree[node].nr_sons)
				node++;
			p++;
		}
		if (p==end || mark==p)
			goto error;
		if (node!=-1)
			*mime_type = type_tree[node].final<<16;
		else
			*mime_type = TYPE_UNKNOWN<<16;
	}

	/* search the '/' separator */
	while ( p<end && (*p==' ' || *p=='\t' ||
	(*p=='\n' && (*(p+1)==' '||*(p+1)=='\t')) ))
		p++;
	if ( p==end || *(p++)!='/')
		goto error;

	/* search the beginning of the sub-type */
	while ( p<end && (*p==' ' || *p=='\t' ||
	(*p=='\n' && (*(p+1)==' '||*(p+1)=='\t')) ))
		p++;
	if (p==end)
		goto error;

	/* parse the sub-type */
	if (*p=='*') {
		*mime_type |= SUBTYPE_ALL;
		p++;
	} else {
		node = 0;
		mark = p;
		while (p<end && (is_mime_char(*p) || *p == '_')) {
			while(node!=-1 && !is_char_equal(*p,subtype_tree[node].c) )
				node = subtype_tree[node].next;
			if (node!=-1 && subtype_tree[node].nr_sons)
				node++;
			p++;
		}
		if (p==mark)
			goto error;
		if (node!=-1)
			*mime_type |= subtype_tree[node].final;
		else
			*mime_type |= SUBTYPE_UNKNOWN;
	}

	/* now its possible to have some spaces */
	while ( p<end && (*p==' ' || *p=='\t' ||
	(*p=='\n' && (*(p+1)==' '||*(p+1)=='\t')) ))
		p++;

	/* if there are params, ignore them!! -> eat everything to
	 * the end or to the first ',' */
	if ( p<end && *p==';' )
	{
		if( con == NULL)
			for(p++; p<end && *p!=','; p++);
		else
		{
			str params_str;
			param_hooks_t phooks;
			param_t * cur;

			params_str.s = p;
			params_str.len = end - p ;

			if (parse_params(&params_str, CLASS_ANY, &phooks, &con->params) < 0)
				goto error;

			p = params_str.s;

			cur = con->params;

			while(cur)
			{
				if( cur->name.len == 8 && !strncasecmp(cur->name.s,"boundary",cur->name.len ) )
					con->boundary = cur->body;

				if( cur->name.len == 5 && !strncasecmp(cur->name.s,"start",cur->name.len ) )
					con->start = cur->body;

				cur = cur ->next;
			}

		}
	}

	/* is this the correct end? */
	if (p!=end && *p!=',' )
		goto error;

	/* check the format of the decoded mime */
	if ((*mime_type)>>16==TYPE_ALL && ((*mime_type)&0x00ff)!=SUBTYPE_ALL) {
		LM_ERR("invalid mime format found "
			" <*/submime> in [%.*s]!!\n", (int)(end-start),start);
		return 0;
	}

	return p;
error:
	LM_ERR("parse error near in [%.*s] char"
		"[%d][%c] offset=%d\n", (int)(end-start),start,*p,*p,(int)(p-start));
	return 0;
}
