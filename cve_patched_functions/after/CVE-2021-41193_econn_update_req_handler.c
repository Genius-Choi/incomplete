static void econn_update_req_handler(struct econn *econn,
				     const char *userid_sender,
				     const char *clientid_sender,
				     const char *sdp,
				     struct econn_props *props,
				     bool should_reset,
				     void *arg)
{
	struct ecall *ecall = arg;
	int err = 0;
	bool strm_chg;
	bool muted;
	//char userid_anon[ANON_ID_LEN];
	//char clientid_anon[ANON_CLIENT_LEN];

	assert(ECALL_MAGIC == ecall->magic);

	ecall->update = true;

	strm_chg = strstr(sdp, "x-streamchange") != NULL;

	muted = msystem_get_muted();
	
	if (ecall->flow && strm_chg) {
		info("ecall(%p): update: x-streamchange\n", ecall);
		IFLOW_CALL(ecall->flow, stop_media);
	}
	else {
		err = alloc_flow(ecall, ASYNC_ANSWER, ecall->call_type, ecall->audio_cbr);
		if (err)
			goto error;

		//if (ecall->conf_part)
		//	ecall->conf_part->data = ecall->flow;

		IFLOW_CALL(ecall->flow, set_remote_userclientid,
			userid_sender,
			econn_clientid_remote(econn));
	}

	msystem_set_muted(muted);
/*
	if (!IFLOW_CALLE(ecall->flow, has_data)) {
		warning("ecall: update_req_handler: remote peer does not"
			" support datachannels (%s|%s)\n",
			anon_id(userid_anon, userid_sender),
			anon_client(clientid_anon, clientid_sender));
		return;
	}
*/
	ecall->props_remote = mem_deref(ecall->props_remote);
	ecall->props_remote = mem_ref(props);

	propsync_handler(ecall);
	
	ecall->sdp.async = ASYNC_NONE;
	set_offer_sdp(ecall, sdp);
	err = generate_or_gather_answer(ecall, econn);
	if (err) {
		warning("ecall(%p): generate_or_gather_answer failed (%m)\n",
			ecall, err);
		goto error;
	}

	return;

 error:
	ecall_close(ecall, err, ECONN_MESSAGE_TIME_UNKNOWN);
}
