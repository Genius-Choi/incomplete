static int find_pos(struct apply_state *state,
		    struct image *img,
		    struct image *preimage,
		    struct image *postimage,
		    int line,
		    unsigned ws_rule,
		    int match_beginning, int match_end)
{
	int i;
	unsigned long backwards, forwards, current;
	int backwards_lno, forwards_lno, current_lno;

	/*
	 * When running with --allow-overlap, it is possible that a hunk is
	 * seen that pretends to start at the beginning (but no longer does),
	 * and that *still* needs to match the end. So trust `match_end` more
	 * than `match_beginning`.
	 */
	if (state->allow_overlap && match_beginning && match_end &&
	    img->nr - preimage->nr != 0)
		match_beginning = 0;

	/*
	 * If match_beginning or match_end is specified, there is no
	 * point starting from a wrong line that will never match and
	 * wander around and wait for a match at the specified end.
	 */
	if (match_beginning)
		line = 0;
	else if (match_end)
		line = img->nr - preimage->nr;

	/*
	 * Because the comparison is unsigned, the following test
	 * will also take care of a negative line number that can
	 * result when match_end and preimage is larger than the target.
	 */
	if ((size_t) line > img->nr)
		line = img->nr;

	current = 0;
	for (i = 0; i < line; i++)
		current += img->line[i].len;

	/*
	 * There's probably some smart way to do this, but I'll leave
	 * that to the smart and beautiful people. I'm simple and stupid.
	 */
	backwards = current;
	backwards_lno = line;
	forwards = current;
	forwards_lno = line;
	current_lno = line;

	for (i = 0; ; i++) {
		if (match_fragment(state, img, preimage, postimage,
				   current, current_lno, ws_rule,
				   match_beginning, match_end))
			return current_lno;

	again:
		if (backwards_lno == 0 && forwards_lno == img->nr)
			break;

		if (i & 1) {
			if (backwards_lno == 0) {
				i++;
				goto again;
			}
			backwards_lno--;
			backwards -= img->line[backwards_lno].len;
			current = backwards;
			current_lno = backwards_lno;
		} else {
			if (forwards_lno == img->nr) {
				i++;
				goto again;
			}
			forwards += img->line[forwards_lno].len;
			forwards_lno++;
			current = forwards;
			current_lno = forwards_lno;
		}

	}
	return -1;
}
