    void SipDialogController::doSendRequestInsideDialog( SipMessageData* pData ) {                
        nta_leg_t* leg = NULL ;
        nta_outgoing_t* orq = NULL ;
        string myHostport ;
        string requestUri ;
        string name ;
        string routeUri;
        bool destroyOrq = false;
        tagi_t* tags = nullptr;

        DR_LOG(log_debug) << "SipDialogController::doSendRequestInsideDialog dialog id: " << pData->getDialogId()  ;

        sip_method_t method = parseStartLine( pData->getStartLine(), name, requestUri ) ;

        std::shared_ptr<SipDialog> dlg ;
 
        assert( pData->getDialogId() ) ;

        try {
            if (!SD_FindByDialogId(m_dialogs, pData->getDialogId(), dlg ) ) {
                if( sip_method_ack == method ) {
                    DR_LOG(log_debug) << "Can't send ACK for dialog id " << pData->getDialogId() 
                        << "; likely because stack already ACK'ed non-success final response" ;
                    throw std::runtime_error("ACK for non-success final response is automatically generated by server") ;
                }
                DR_LOG(log_debug) << "Can't find dialog for dialog id " << pData->getDialogId() ;
                //assert(false) ;
                throw std::runtime_error("unable to find dialog for dialog id provided") ;
            }

            string transport ;
            dlg->getTransportDesc(transport) ;
            tags = makeTags( pData->getHeaders(), transport) ;

            tport_t* tp = dlg->getTport() ; 
            bool forceTport = NULL != tp ;  

            nta_leg_t *leg = const_cast<nta_leg_t *>(dlg->getNtaLeg());
            if( !leg ) {
                assert( leg ) ;
                throw std::runtime_error("unable to find active leg for dialog") ;
            }

            const sip_contact_t *target ;
            if( (sip_method_ack == method || string::npos != requestUri.find("placeholder")) && nta_leg_get_route( leg, NULL, &target ) >=0 ) {
                char buffer[256];

                if (nullptr ==target) {
                    throw std::runtime_error("unable to find route for dialog when sending ACK") ;
                }
                url_e( buffer, 255, target->m_url ) ;
                requestUri = buffer ;
                DR_LOG(log_debug) << "SipDialogController::doSendRequestInsideDialog - defaulting request uri to " << requestUri  ;

                // we need to check if there was a mid-call network handoff, where this client jumped networks
                std::shared_ptr<UaInvalidData> pData = m_pController->findTportForSubscription( target->m_url->url_user, target->m_url->url_host ) ;
                if( NULL != pData ) {
                    DR_LOG(log_debug) << "SipDialogController::doSendRequestInsideDialog found cached tport for this client " << std::hex << (void *) pData->getTport();
                    if (pData->getTport() != tp) {
                        DR_LOG(log_info) << "SipDialogController::doSendRequestInsideDialog client has done a mid-call handoff; tp is now " << std::hex << (void *) pData->getTport();
                        tp = pData->getTport();
                        forceTport = true ;
                    }
               }
            }

            if( method == sip_method_invalid || method == sip_method_unknown ) {
                throw std::runtime_error(string("invalid or missing method supplied on start line: ") + pData->getStartLine() ) ;
            }

            //set content-type if not supplied and body contains SDP
            string body = pData->getBody() ;
            string contentType ;
            if( body.length() && !searchForHeader( tags, siptag_content_type_str, contentType ) ) {
                if( 0 == body.find("v=0") ) {
                    contentType = "application/sdp" ;
                    DR_LOG(log_debug) << "SipDialogController::doSendRequestInsideDialog - automatically detecting content-type as application/sdp"  ;
                }
                else {
                    throw std::runtime_error("missing content-type") ;                   
                }
            }
            if( sip_method_invite == method && body.length() && 0 == contentType.compare("application/sdp")) {
                DR_LOG(log_debug) << "SipDialogController::doSendRequestInsideDialog - updating local sdp to " << body ;
                dlg->setLocalSdp( body.c_str() ) ;
                dlg->setLocalContentType(contentType);
            }

            if (dlg->getRouteUri(routeUri)) {
                DR_LOG(log_debug) << "SipDialogController::doSendRequestInsideDialog - sending request to nat'ed address using route " << routeUri ;
            }

            if( sip_method_ack == method ) {
                if( 200 == dlg->getSipStatus() ) {
                    char cseq[32];
                    memset(cseq, 0, 32);
                    uint32_t seq = dlg->getSeq();
                    dlg->clearSeq();
                    if (seq > 0) {
                        snprintf(cseq, 31, "%u ACK", seq);
                        DR_LOG(log_debug) << "SipDialogController::doSendRequestInsideDialog - setting CSeq to  " << seq ;
                    }
                    orq = nta_outgoing_tcreate(leg, NULL, NULL, 
                        routeUri.empty() ? NULL : URL_STRING_MAKE(routeUri.c_str()),                     
                        method, name.c_str(),
                        URL_STRING_MAKE(requestUri.c_str()),
                        TAG_IF( *cseq, SIPTAG_CSEQ_STR(cseq)),
                        TAG_IF( body.length(), SIPTAG_PAYLOAD_STR(body.c_str())),
                        TAG_IF( contentType.length(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str())),
                        TAG_IF(forceTport, NTATAG_TPORT(tp)),
                        TAG_NEXT(tags) ) ;
                    
                    tport_t* orq_tp = nta_outgoing_transport( orq );  // takes a reference on the tport
                    if (tport_is_dgram(orq_tp)) m_timerDHandler.addAck(orq);
                    else if (orq_tp) destroyOrq = true;
                    if (orq_tp) {
                        dlg->setTport(orq_tp) ;
                        // tport reference will be release in SipDialog dtor
                    }
                    else {
                        DR_LOG(log_debug) << "SipDialogController::doSendRequestInsideDialog - sending ACK but nta_outgoing_transport is null, delayed for DNS resolver";
                        dlg->setOrqAck(orq, !tport_is_dgram(orq_tp));
                        destroyOrq = false;
                        tport_unref(orq_tp);  // release the reference
                    }
                    DR_LOG(log_debug) << "SipDialogController::doSendRequestInsideDialog - clearing IIP that we generated as uac" ;
                    IIP_Clear(m_invitesInProgress, leg);  

                    DR_LOG(log_info) << "SipDialogController::doSendRequestInsideDialog (ack) - created orq " << std::hex << (void *) orq;

                }
            }
            else if( sip_method_prack == method ) {
                std::shared_ptr<IIP> iip;
                if(!IIP_FindByLeg(m_invitesInProgress, leg, iip)) {
                    throw std::runtime_error("unable to find IIP when sending PRACK") ;
                }
                orq = nta_outgoing_prack(leg, const_cast<nta_outgoing_t *>(iip->orq()), response_to_request_inside_dialog, (nta_outgoing_magic_t*) m_pController, 
                    //NULL, 
                    routeUri.empty() ? NULL : URL_STRING_MAKE(routeUri.c_str()),
                    NULL, TAG_NEXT(tags) ) ;
                DR_LOG(log_info) << "SipDialogController::doSendRequestInsideDialog (prack) - created orq " << std::hex << (void *) orq;

            }
            else {
                string contact ;
                bool addContact = false ;
                if( (method == sip_method_invite || method == sip_method_subscribe || method == sip_method_refer) && !searchForHeader( tags, siptag_contact_str, contact ) ) {
                    contact = dlg->getLocalContactHeader();
                    addContact = true ;
                }
                orq = nta_outgoing_tcreate( leg, response_to_request_inside_dialog, (nta_outgoing_magic_t*) m_pController, 
                    routeUri.empty() ? NULL : URL_STRING_MAKE(routeUri.c_str()),                     
                    method, name.c_str()
                    ,URL_STRING_MAKE(requestUri.c_str())
                    ,TAG_IF( addContact, SIPTAG_CONTACT_STR( contact.c_str() ) )
                    ,TAG_IF( body.length(), SIPTAG_PAYLOAD_STR(body.c_str()))
                    ,TAG_IF( contentType.length(), SIPTAG_CONTENT_TYPE_STR(contentType.c_str()))
                    ,TAG_IF(forceTport, NTATAG_TPORT(tp))
                    ,TAG_NEXT(tags) ) ;

                if( orq ) {
                    DR_LOG(log_info) << "SipDialogController::doSendRequestInsideDialog - created orq " << std::hex << (void *) orq << " sending " << nta_outgoing_method_name(orq) << " to " << requestUri ;
                }
            }

            if( NULL == orq && sip_method_ack != method ) {
                throw std::runtime_error("Error creating sip transaction for request") ;               
            }

            if( sip_method_ack == method && 200 != dlg->getSipStatus() ) {
                DR_LOG(log_debug) << "SipDialogController::doSendRequestInsideDialog - clearing uac dialog that had final response " <<  dlg->getSipStatus() ;
                SD_Clear(m_dialogs, dlg->getDialogId()) ;
                m_pController->getClientController()->route_api_response( pData->getClientMsgId(), "NOK", 
                    "ACK for non-success responses is automatically generated by the stack" ) ;
            }
            else {
                msg_t* m = nta_outgoing_getrequest(orq) ;  // adds a reference
                sip_t* sip = sip_object( m ) ;

                STATS_COUNTER_INCREMENT(STATS_COUNTER_SIP_REQUESTS_OUT, {{"method", sip->sip_request->rq_method_name}})

                string encodedMessage ;
                EncodeStackMessage( sip, encodedMessage ) ;
                SipMsgData_t meta(m, orq) ;
                string s ;
                meta.toMessageFormat(s) ;
                string data = s + "|" + pData->getTransactionId() + "|Msg sent:|" + DR_CRLF + encodedMessage ;

                if( sip_method_ack == method ) {
                    if( dlg->getSipStatus() > 200 ) {
                        m_pClientController->removeDialog( dlg->getDialogId() ) ;
                    }
                }
                else {
                    bool clearDialogOnResponse = false ;
                    if( sip_method_bye == method || 
                        ( !dlg->isInviteDialog() && sip_method_notify == method && NULL != sip->sip_subscription_state && NULL != sip->sip_subscription_state->ss_substate &&
                            NULL != strstr(sip->sip_subscription_state->ss_substate, "terminated") ) ) {
                        clearDialogOnResponse = true ;
                    }

                    std::shared_ptr<RIP> p = std::make_shared<RIP>( pData->getTransactionId(), pData->getDialogId(), dlg, clearDialogOnResponse ) ;
                    addRIP( orq, p ) ;       
                }
                if( sip_method_invite == method ) {
                    addOutgoingInviteTransaction( leg, orq, sip, dlg ) ;
                }

                if (sip_method_bye == method) {
                  Cdr::postCdr( std::make_shared<CdrStop>( m, "application", Cdr::normal_release ) );
                }
     
                msg_destroy(m) ; //releases reference
                m_pController->getClientController()->route_api_response( pData->getClientMsgId(), "OK", data ) ; 
            }

            if (sip_method_ack == method && dlg->getSipStatus() == 200 && dlg->isAckBye()) {
                this->notifyTerminateStaleDialog(dlg, true);
            }
        } catch( std::runtime_error& err ) {
            DR_LOG(log_error) << "SipDialogController::doSendRequestInsideDialog - Error: " << err.what() ;
            string msg = string("Server error: ") + err.what() ;
            m_pController->getClientController()->route_api_response( pData->getClientMsgId(), "NOK", msg ) ;
            m_pController->getClientController()->removeAppTransaction( pData->getTransactionId() ) ;
        }                       

        /* we must explicitly delete an object allocated with placement new */
        pData->~SipMessageData() ;
        if (orq && destroyOrq) nta_outgoing_destroy(orq);
        deleteTags( tags ) ;
    }
