static int decrypt_tail(struct ceph_connection *con)
{
	struct sg_table enc_sgt = {};
	struct sg_table sgt = {};
	int tail_len;
	int ret;

	tail_len = tail_onwire_len(con->in_msg, true);
	ret = sg_alloc_table_from_pages(&enc_sgt, con->v2.in_enc_pages,
					con->v2.in_enc_page_cnt, 0, tail_len,
					GFP_NOIO);
	if (ret)
		goto out;

	ret = setup_message_sgs(&sgt, con->in_msg, FRONT_PAD(con->v2.in_buf),
			MIDDLE_PAD(con->v2.in_buf), DATA_PAD(con->v2.in_buf),
			con->v2.in_buf, true);
	if (ret)
		goto out;

	dout("%s con %p msg %p enc_page_cnt %d sg_cnt %d\n", __func__, con,
	     con->in_msg, con->v2.in_enc_page_cnt, sgt.orig_nents);
	ret = gcm_crypt(con, false, enc_sgt.sgl, sgt.sgl, tail_len);
	if (ret)
		goto out;

	WARN_ON(!con->v2.in_enc_page_cnt);
	ceph_release_page_vector(con->v2.in_enc_pages,
				 con->v2.in_enc_page_cnt);
	con->v2.in_enc_pages = NULL;
	con->v2.in_enc_page_cnt = 0;

out:
	sg_free_table(&sgt);
	sg_free_table(&enc_sgt);
	return ret;
}
