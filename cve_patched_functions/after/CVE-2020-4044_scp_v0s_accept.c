scp_v0s_accept(struct SCP_CONNECTION *c, struct SCP_SESSION **s, int skipVchk)
{
    enum SCP_SERVER_STATES_E result = SCP_SERVER_STATE_OK;
    struct SCP_SESSION *session = NULL;
    tui32 version = 0;

    if (!skipVchk)
    {
        LOG_DBG("[v0:%d] starting connection", __LINE__);

        if (0 == scp_tcp_force_recv(c->in_sck, c->in_s->data, 8))
        {
            c->in_s->end = c->in_s->data + 8;
            in_uint32_be(c->in_s, version);

            if (version != 0)
            {
                log_message(LOG_LEVEL_WARNING, "[v0:%d] connection aborted: version error", __LINE__);
                result = SCP_SERVER_STATE_VERSION_ERR;
            }
        }
        else
        {
            log_message(LOG_LEVEL_WARNING, "[v0:%d] connection aborted: network error", __LINE__);
            result = SCP_SERVER_STATE_NETWORK_ERR;
        }
    }

    if (result == SCP_SERVER_STATE_OK)
    {
        session = scp_session_create();
        if (NULL == session)
        {
            log_message(LOG_LEVEL_WARNING,
                        "[v0:%d] connection aborted: no memory",
                        __LINE__);
            result = SCP_SERVER_STATE_INTERNAL_ERR;
        }
        else
        {
            result = scp_v0s_init_session(c, session);
            if (result != SCP_SERVER_STATE_OK)
            {
                scp_session_destroy(session);
                session = NULL;
            }
        }
    }

    (*s) = session;

    return result;
}
