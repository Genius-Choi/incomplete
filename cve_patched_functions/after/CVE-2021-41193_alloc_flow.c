static int alloc_flow(struct ecall *ecall, enum async_sdp role,
		      enum icall_call_type call_type,
		      bool audio_cbr)
{
	//struct sa laddr;
	char tag[64] = "";
	char userid_anon[ANON_ID_LEN];
	char clientid_anon[ANON_CLIENT_LEN];
	size_t i;
	int err;

	IFLOW_CALL(ecall->oldflow, close);
	ecall->oldflow = ecall->flow;
	ecall->flow = NULL;
	ecall->established = false;

	err = iflow_alloc(&ecall->flow,
			  ecall->convid,
			  ecall->userid_self,
			  ecall->clientid_self,
			  ecall->conv_type,
			  call_type,
			  ecall->vstate,
			  ecall->icall.arg);

	if (err) {
		warning("ecall(%p): failed to alloc mediaflow (%m)\n",
			ecall, err);
		goto out;
	}

	iflow_set_callbacks(ecall->flow,
			    mf_estab_handler,
			    mf_close_handler,
			    mf_stopped_handler,
			    rtp_start_handler,
			    mf_restart_handler,
			    mf_gather_handler,
			    channel_estab_handler,
			    data_channel_handler,
			    channel_close_handler,
			    acbr_detect_handler,
			    norelay_handler,
			    ecall);
	info("ecall(%p): alloc_flow: user=%s client=%s mediaflow=%p "
	     "call_type=%d audio_cbr=%d\n",
	     ecall,
	     anon_id(userid_anon, ecall->userid_peer),
	     anon_client(clientid_anon, ecall->clientid_peer),
	     ecall->flow, call_type, audio_cbr);

	ecall->audio_cbr = audio_cbr;
	IFLOW_CALL(ecall->flow, set_audio_cbr, audio_cbr);

	if (str_isset(ecall->userid_peer) || str_isset(ecall->clientid_peer)) {
		IFLOW_CALL(ecall->flow, set_remote_userclientid,
			   ecall->userid_peer, ecall->clientid_peer);
	}
	IFLOW_CALL(ecall->flow, set_video_state, ecall->vstate);
	
	for(i = 0; i < ecall->turnc; ++i) {
		struct zapi_ice_server *t = &ecall->turnv[i];

		IFLOW_CALL(ecall->flow, add_turnserver,
			t->url,
			t->username,
			t->credential);
	}

	if (ecall->keystore) {
		IFLOW_CALL(ecall->flow, set_keystore,
			   ecall->keystore);
	}
	re_snprintf(tag, sizeof(tag), "%s.%s",
		    ecall->userid_self, ecall->clientid_self);
	//mediaflow_set_tag(ecall->flow, tag);

	//mediaflow_set_rtpstate_handler(ecall->flow, rtp_start_handler);

	if (msystem_get_privacy(ecall->msys)) {
		info("ecall(%p): alloc_flow: enable mediaflow privacy\n",
		     ecall);
		IFLOW_CALL(ecall->flow, enable_privacy, true);
	}

	/* DataChannel is mandatory in Calling 3.0 */
/*
	err = mediaflow_add_data(ecall->flow);
	if (err) {
		warning("ecall(%p): mediaflow add data failed (%m)\n",
			ecall, err);
		goto out;
	}

	if (ecall->media_laddr) {
		info("ecall(%p): overriding interface with: %j\n",
		     ecall, ecall->media_laddr);
		mediaflow_set_media_laddr(ecall->flow, ecall->media_laddr);
	}
*/	/* populate all network interfaces */
	ecall->turn_added = true;
	if (role == ASYNC_OFFER)
		gather_all(ecall, true);
 out:
	if (err) {
		struct iflow *flow = ecall->flow;
		
		ecall->flow = NULL;
		IFLOW_CALL(flow, close);
	}

	return err;
}
