PGTYPEStimestamp_defmt_scan(char **str, char *fmt, timestamp * d,
							int *year, int *month, int *day,
							int *hour, int *minute, int *second,
							int *tz)
{
	union un_fmt_comb scan_val;
	int			scan_type;

	char	   *pstr,
			   *pfmt,
			   *tmp;
	int			err = 1;
	unsigned int j;
	struct tm	tm;

	pfmt = fmt;
	pstr = *str;

	while (*pfmt)
	{
		err = 0;
		while (*pfmt == ' ')
			pfmt++;
		while (*pstr == ' ')
			pstr++;
		if (*pfmt != '%')
		{
			if (*pfmt == *pstr)
			{
				pfmt++;
				pstr++;
			}
			else
			{
				/* Error: no match */
				err = 1;
				return err;
			}
			continue;
		}
		/* here *pfmt equals '%' */
		pfmt++;
		switch (*pfmt)
		{
			case 'a':
				pfmt++;

				/*
				 * we parse the day and see if it is a week day but we do not
				 * check if the week day really matches the date
				 */
				err = 1;
				j = 0;
				while (pgtypes_date_weekdays_short[j])
				{
					if (strncmp(pgtypes_date_weekdays_short[j], pstr,
								strlen(pgtypes_date_weekdays_short[j])) == 0)
					{
						/* found it */
						err = 0;
						pstr += strlen(pgtypes_date_weekdays_short[j]);
						break;
					}
					j++;
				}
				break;
			case 'A':
				/* see note above */
				pfmt++;
				err = 1;
				j = 0;
				while (days[j])
				{
					if (strncmp(days[j], pstr, strlen(days[j])) == 0)
					{
						/* found it */
						err = 0;
						pstr += strlen(days[j]);
						break;
					}
					j++;
				}
				break;
			case 'b':
			case 'h':
				pfmt++;
				err = 1;
				j = 0;
				while (months[j])
				{
					if (strncmp(months[j], pstr, strlen(months[j])) == 0)
					{
						/* found it */
						err = 0;
						pstr += strlen(months[j]);
						*month = j + 1;
						break;
					}
					j++;
				}
				break;
			case 'B':
				/* see note above */
				pfmt++;
				err = 1;
				j = 0;
				while (pgtypes_date_months[j])
				{
					if (strncmp(pgtypes_date_months[j], pstr, strlen(pgtypes_date_months[j])) == 0)
					{
						/* found it */
						err = 0;
						pstr += strlen(pgtypes_date_months[j]);
						*month = j + 1;
						break;
					}
					j++;
				}
				break;
			case 'c':
				/* XXX */
				break;
			case 'C':
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				*year = scan_val.uint_val * 100;
				break;
			case 'd':
			case 'e':
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				*day = scan_val.uint_val;
				break;
			case 'D':

				/*
				 * we have to concatenate the strings in order to be able to
				 * find the end of the substitution
				 */
				pfmt++;
				tmp = pgtypes_alloc(strlen("%m/%d/%y") + strlen(pstr) + 1);
				strcpy(tmp, "%m/%d/%y");
				strcat(tmp, pfmt);
				err = PGTYPEStimestamp_defmt_scan(&pstr, tmp, d, year, month, day, hour, minute, second, tz);
				free(tmp);
				return err;
			case 'm':
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				*month = scan_val.uint_val;
				break;
			case 'y':
			case 'g':			/* XXX difference to y (ISO) */
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				if (*year < 0)
				{
					/* not yet set */
					*year = scan_val.uint_val;
				}
				else
					*year += scan_val.uint_val;
				if (*year < 100)
					*year += 1900;
				break;
			case 'G':
				/* XXX difference to %V (ISO) */
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				*year = scan_val.uint_val;
				break;
			case 'H':
			case 'I':
			case 'k':
			case 'l':
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				*hour += scan_val.uint_val;
				break;
			case 'j':
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);

				/*
				 * XXX what should we do with that? We could say that it's
				 * sufficient if we have the year and the day within the year
				 * to get at least a specific day.
				 */
				break;
			case 'M':
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				*minute = scan_val.uint_val;
				break;
			case 'n':
				pfmt++;
				if (*pstr == '\n')
					pstr++;
				else
					err = 1;
				break;
			case 'p':
				err = 1;
				pfmt++;
				if (strncmp(pstr, "am", 2) == 0)
				{
					*hour += 0;
					err = 0;
					pstr += 2;
				}
				if (strncmp(pstr, "a.m.", 4) == 0)
				{
					*hour += 0;
					err = 0;
					pstr += 4;
				}
				if (strncmp(pstr, "pm", 2) == 0)
				{
					*hour += 12;
					err = 0;
					pstr += 2;
				}
				if (strncmp(pstr, "p.m.", 4) == 0)
				{
					*hour += 12;
					err = 0;
					pstr += 4;
				}
				break;
			case 'P':
				err = 1;
				pfmt++;
				if (strncmp(pstr, "AM", 2) == 0)
				{
					*hour += 0;
					err = 0;
					pstr += 2;
				}
				if (strncmp(pstr, "A.M.", 4) == 0)
				{
					*hour += 0;
					err = 0;
					pstr += 4;
				}
				if (strncmp(pstr, "PM", 2) == 0)
				{
					*hour += 12;
					err = 0;
					pstr += 2;
				}
				if (strncmp(pstr, "P.M.", 4) == 0)
				{
					*hour += 12;
					err = 0;
					pstr += 4;
				}
				break;
			case 'r':
				pfmt++;
				tmp = pgtypes_alloc(strlen("%I:%M:%S %p") + strlen(pstr) + 1);
				strcpy(tmp, "%I:%M:%S %p");
				strcat(tmp, pfmt);
				err = PGTYPEStimestamp_defmt_scan(&pstr, tmp, d, year, month, day, hour, minute, second, tz);
				free(tmp);
				return err;
			case 'R':
				pfmt++;
				tmp = pgtypes_alloc(strlen("%H:%M") + strlen(pstr) + 1);
				strcpy(tmp, "%H:%M");
				strcat(tmp, pfmt);
				err = PGTYPEStimestamp_defmt_scan(&pstr, tmp, d, year, month, day, hour, minute, second, tz);
				free(tmp);
				return err;
			case 's':
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT_LONG;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				/* number of seconds in scan_val.luint_val */
				{
					struct tm  *tms;
					time_t		et = (time_t) scan_val.luint_val;

					tms = gmtime(&et);

					if (tms)
					{
						*year = tms->tm_year + 1900;
						*month = tms->tm_mon + 1;
						*day = tms->tm_mday;
						*hour = tms->tm_hour;
						*minute = tms->tm_min;
						*second = tms->tm_sec;
					}
					else
						err = 1;
				}
				break;
			case 'S':
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				*second = scan_val.uint_val;
				break;
			case 't':
				pfmt++;
				if (*pstr == '\t')
					pstr++;
				else
					err = 1;
				break;
			case 'T':
				pfmt++;
				tmp = pgtypes_alloc(strlen("%H:%M:%S") + strlen(pstr) + 1);
				strcpy(tmp, "%H:%M:%S");
				strcat(tmp, pfmt);
				err = PGTYPEStimestamp_defmt_scan(&pstr, tmp, d, year, month, day, hour, minute, second, tz);
				free(tmp);
				return err;
			case 'u':
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				if (scan_val.uint_val < 1 || scan_val.uint_val > 7)
					err = 1;
				break;
			case 'U':
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				if (scan_val.uint_val > 53)
					err = 1;
				break;
			case 'V':
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				if (scan_val.uint_val < 1 || scan_val.uint_val > 53)
					err = 1;
				break;
			case 'w':
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				if (scan_val.uint_val > 6)
					err = 1;
				break;
			case 'W':
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				if (scan_val.uint_val > 53)
					err = 1;
				break;
			case 'x':
			case 'X':
				/* XXX */
				break;
			case 'Y':
				pfmt++;
				scan_type = PGTYPES_TYPE_UINT;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				*year = scan_val.uint_val;
				break;
			case 'z':
				pfmt++;
				scan_type = PGTYPES_TYPE_STRING_MALLOCED;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);
				if (!err)
				{
					err = DecodeTimezone(scan_val.str_val, tz);
					free(scan_val.str_val);
				}
				break;
			case 'Z':
				pfmt++;
				scan_type = PGTYPES_TYPE_STRING_MALLOCED;
				err = pgtypes_defmt_scan(&scan_val, scan_type, &pstr, pfmt);

				/*
				 * XXX use DecodeSpecial instead ? - it's declared static but
				 * the arrays as well. :-(
				 */
				for (j = 0; !err && j < szdatetktbl; j++)
				{
					if (pg_strcasecmp(datetktbl[j].token, scan_val.str_val) == 0)
					{
						/*
						 * tz calculates the offset for the seconds, the
						 * timezone value of the datetktbl table is in quarter
						 * hours
						 */
						*tz = -15 * MINS_PER_HOUR * datetktbl[j].value;
						break;
					}
				}
				free(scan_val.str_val);
				break;
			case '+':
				/* XXX */
				break;
			case '%':
				pfmt++;
				if (*pstr == '%')
					pstr++;
				else
					err = 1;
				break;
			default:
				err = 1;
		}
	}
	if (!err)
	{
		if (*second < 0)
			*second = 0;
		if (*minute < 0)
			*minute = 0;
		if (*hour < 0)
			*hour = 0;
		if (*day < 0)
		{
			err = 1;
			*day = 1;
		}
		if (*month < 0)
		{
			err = 1;
			*month = 1;
		}
		if (*year < 0)
		{
			err = 1;
			*year = 1970;
		}

		if (*second > 59)
		{
			err = 1;
			*second = 0;
		}
		if (*minute > 59)
		{
			err = 1;
			*minute = 0;
		}
		if (*hour > 24 ||		/* test for > 24:00:00 */
			(*hour == 24 && (*minute > 0 || *second > 0)))
		{
			err = 1;
			*hour = 0;
		}
		if (*month > MONTHS_PER_YEAR)
		{
			err = 1;
			*month = 1;
		}
		if (*day > day_tab[isleap(*year)][*month - 1])
		{
			*day = day_tab[isleap(*year)][*month - 1];
			err = 1;
		}

		tm.tm_sec = *second;
		tm.tm_min = *minute;
		tm.tm_hour = *hour;
		tm.tm_mday = *day;
		tm.tm_mon = *month;
		tm.tm_year = *year;

		tm2timestamp(&tm, 0, tz, d);
	}
	return err;
}
