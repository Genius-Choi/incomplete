ExecutionStatus iteratorClose(
    Runtime &runtime,
    Handle<JSObject> iterator,
    Handle<> completion) {
  ExecutionStatus completionStatus = completion->isEmpty()
      ? ExecutionStatus::RETURNED
      : ExecutionStatus::EXCEPTION;

  // 4. Let innerResult be GetMethod(iterator, "return").
  // Do this lazily: innerResult is only actually used if GetMethod returns
  // a callable which, when called, doesn't throw. Defer storing to innerResult
  // until that point.
  auto returnRes = getMethod(
      runtime,
      iterator,
      runtime.makeHandle(Predefined::getSymbolID(Predefined::returnStr)));

  MutableHandle<> innerResult{runtime};
  if (LLVM_LIKELY(returnRes != ExecutionStatus::EXCEPTION)) {
    if (!vmisa<Callable>(returnRes->getHermesValue())) {
      runtime.setThrownValue(*completion);
      return completionStatus;
    }
    Handle<Callable> returnFn =
        runtime.makeHandle(vmcast<Callable>(returnRes->getHermesValue()));
    auto innerResultRes = Callable::executeCall0(returnFn, runtime, iterator);
    if (LLVM_UNLIKELY(innerResultRes == ExecutionStatus::EXCEPTION)) {
      if (isUncatchableError(runtime.getThrownValue())) {
        // If the call to return threw an uncatchable exception, that overrides
        // the completion, since the point of an uncatchable exception is to
        // prevent more JS from executing.
        return ExecutionStatus::EXCEPTION;
      }
      // If the error is catchable, suppress it temporarily below in lieu
      // of the returnRes exception by writing to innerResultException.
      // Spec text overwrites the value in `innerResult`.
    } else {
      innerResult = std::move(*innerResultRes);
    }
  }
  // Runtime::thrownValue now contains the innerResult's exception if it
  // was thrown.
  // GetMethod error here is deliberately suppressed (no "?" in the spec).
  if (completionStatus == ExecutionStatus::EXCEPTION) {
    // 6. If completion.[[Type]] is throw, return Completion(completion).
    // Note: Overrides the innerResult exception.
    runtime.setThrownValue(*completion);
    return ExecutionStatus::EXCEPTION;
  }
  if (LLVM_UNLIKELY(!runtime.getThrownValue().isEmpty())) {
    // 7. If innerResult.[[Type]] is throw, return Completion(innerResult).
    // Note: innerResult exception is still in Runtime::thrownValue,
    // so there is no need to set it again.
    return ExecutionStatus::EXCEPTION;
  }
  if (!innerResult->isObject()) {
    // 8. If Type(innerResult.[[Value]]) is not Object,
    //    throw a TypeError exception.
    return runtime.raiseTypeError("iterator.return() did not return an object");
  }
  return ExecutionStatus::RETURNED;
}
