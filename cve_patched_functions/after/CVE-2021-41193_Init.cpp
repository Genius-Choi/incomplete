    int32_t audio_io_osx::Init() {
        int32_t ret = 0;
        
        pthread_mutex_lock(&mutex_);
        
        if (initialized_) {
            pthread_mutex_unlock(&mutex_);
            return 0;
        }
        
        is_shut_down_ = false;
        
        // Create and start capture thread
        if (!rec_tid_) {
            pthread_create(&rec_tid_, NULL, rec_thread, this);
            
            is_running_ = true;
                        
            pthread_cond_init(&cond_, NULL);
            
            int max_prio = sched_get_priority_max(SCHED_RR);
            int min_prio = sched_get_priority_min(SCHED_RR);
            if (max_prio - min_prio <= 2){
                max_prio = 0;
            }
            if(max_prio > 0){
                sched_param param;
                param.sched_priority = max_prio;
                info("audio_io_ios: Setting thread prio to %d \n", max_prio);
                int ret = pthread_setschedparam(rec_tid_, SCHED_RR, &param);
                if(ret != 0){
                    error("audio_io_ios: Failed to set thread priority \n");
                }
            }
        } else {
            warning("Thread already created \n");
        }
        
        AudioObjectPropertyAddress propertyAddress = {
            kAudioHardwarePropertyRunLoop,
            kAudioObjectPropertyScopeGlobal,
            kAudioObjectPropertyElementMaster };
        CFRunLoopRef runLoop = NULL;
        OSStatus err = noErr;
        UInt32 size = sizeof(CFRunLoopRef);
        err = AudioObjectSetPropertyData(kAudioObjectSystemObject,
                                                           &propertyAddress, 0, NULL, size, &runLoop);
        if(err != noErr){
            error("AudioObjectSetPropertyData returned %d \n", err);
            ret= -1;
            goto out;
        }
        
        // Listen for any device changes.
        propertyAddress.mSelector = kAudioHardwarePropertyDevices;
        err = AudioObjectAddPropertyListener(kAudioObjectSystemObject,
                                                         &propertyAddress, &object_listener_proc, this);
        if(err != noErr){
            error("AudioObjectAddPropertyListener returned %d \n", err);
            ret= -1;
            goto out;
        }
        
        propertyAddress.mSelector = kAudioHardwarePropertyDefaultOutputDevice;
        err = AudioObjectAddPropertyListener(kAudioObjectSystemObject,
                                                         &propertyAddress, &object_listener_proc, this);
        if(err != noErr){
            error("AudioObjectAddPropertyListener returned %d \n", err);
            ret= -1;
            goto out;
        }
        
        propertyAddress.mSelector = kAudioHardwarePropertyDefaultInputDevice;
        err = AudioObjectAddPropertyListener(kAudioObjectSystemObject,
                                                         &propertyAddress, &object_listener_proc, this);
        if(err != noErr){
            error("AudioObjectAddPropertyListener returned %d \n", err);
            ret= -1;
            goto out;
        }
        initialized_ = true;

        init_microphone();
        init_speaker();
        
    out:
        pthread_mutex_unlock(&mutex_);
        return 0;
    }
