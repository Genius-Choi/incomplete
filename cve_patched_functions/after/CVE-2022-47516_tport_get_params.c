int tport_get_params(tport_t const *self,
		     tag_type_t tag, tag_value_t value, ...)
{
  ta_list ta;
  int n;
  tport_params_t const *tpp;
  int connect;
  tport_master_t *mr = self->tp_master;

  if (self == NULL)
    return su_seterrno(EINVAL);

  tpp = self->tp_params;
  ta_start(ta, tag, value);

  connect = tpp->tpp_conn_orient
    /* Only dgram primary is *not* connection-oriented */
    || !tport_is_primary(self) || !tport_is_dgram(self);

  n = tl_tgets(ta_args(ta),
	       TPTAG_MTU((usize_t)tpp->tpp_mtu),
	       TPTAG_REUSE(self->tp_reusable),
	       TPTAG_CONNECT(connect),
	       TPTAG_QUEUESIZE(tpp->tpp_qsize),
	       TPTAG_IDLE(tpp->tpp_idle),
	       TPTAG_TIMEOUT(tpp->tpp_timeout),
	       TPTAG_SOCKET_KEEPALIVE(tpp->tpp_socket_keepalive),
	       TPTAG_KEEPALIVE(tpp->tpp_keepalive),
	       TPTAG_PINGPONG(tpp->tpp_pingpong),
	       TPTAG_PONG2PING(tpp->tpp_pong2ping),
	       TPTAG_SDWN_ERROR(tpp->tpp_sdwn_error),
	       TPTAG_DEBUG_DROP(tpp->tpp_drop),
	       TPTAG_THRPSIZE(tpp->tpp_thrpsize),
	       TPTAG_THRPRQSIZE(tpp->tpp_thrprqsize),
	       TPTAG_SIGCOMP_LIFETIME(tpp->tpp_sigcomp_lifetime),
	       TPTAG_STUN_SERVER(tpp->tpp_stun_server),
	       TAG_IF(self->tp_pri,
		      TPTAG_PUBLIC(self->tp_pri ?
				   self->tp_pri->pri_public : 0)),
	       TPTAG_TOS(tpp->tpp_tos),
	       TAG_IF((void *)self == (void *)mr,
		      TPTAG_LOG(mr->mr_log != 0)),
	       TAG_IF((void *)self == (void *)mr,
		      TPTAG_DUMP(mr->mr_dump)),
	       TAG_END());

  ta_end(ta);

  return n;
}
