ipv6address(pbelle_sip_messageParser ctx)
{
    belle_sip_messageParser_ipv6address_return retval;


    /* Initialize rule variables
     */

    retval.start = LT(1); retval.stop = retval.start;


    {
        {
            //  ../grammars/belle_sip_message.g:1940:16: ( hexpart ( COLON ipv4address )? | ( hexseq )? COLON COLON ipv4address )

            ANTLR3_UINT32 alt183;

            alt183=2;

            alt183 = cdfa183.predict(ctx, RECOGNIZER, ISTREAM, &cdfa183);
            if  (HASEXCEPTION())
            {
                goto ruleipv6addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            switch (alt183)
            {
        	case 1:
        	    // ../grammars/belle_sip_message.g:1940:19: hexpart ( COLON ipv4address )?
        	    {
        	        FOLLOWPUSH(FOLLOW_hexpart_in_ipv6address7853);
        	        hexpart(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleipv6addressEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        // ../grammars/belle_sip_message.g:1940:27: ( COLON ipv4address )?
        	        {
        	            int alt181=2;
        	            switch ( LA(1) )
        	            {
        	                case COLON:
        	                	{
        	                		alt181=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt181)
        	            {
        	        	case 1:
        	        	    // ../grammars/belle_sip_message.g:1940:29: COLON ipv4address
        	        	    {
        	        	         MATCHT(COLON, &FOLLOW_COLON_in_ipv6address7857);
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleipv6addressEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_ipv4address_in_ipv6address7859);
        	        	        ipv4address(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleipv6addressEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // ../grammars/belle_sip_message.g:1940:52: ( hexseq )? COLON COLON ipv4address
        	    {
        	        // ../grammars/belle_sip_message.g:1940:52: ( hexseq )?
        	        {
        	            int alt182=2;
        	            switch ( LA(1) )
        	            {
        	                case DIGIT:
        	                case HEX_CHAR:
        	                	{
        	                		alt182=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt182)
        	            {
        	        	case 1:
        	        	    // ../grammars/belle_sip_message.g:1940:54: hexseq
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_hexseq_in_ipv6address7868);
        	        	        hexseq(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleipv6addressEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	         MATCHT(COLON, &FOLLOW_COLON_in_ipv6address7873);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleipv6addressEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	         MATCHT(COLON, &FOLLOW_COLON_in_ipv6address7875);
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleipv6addressEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	        FOLLOWPUSH(FOLLOW_ipv4address_in_ipv6address7877);
        	        ipv4address(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleipv6addressEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleipv6addressEx; /* Prevent compiler warnings */
    ruleipv6addressEx: ;
    retval.stop = LT(-1);



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
