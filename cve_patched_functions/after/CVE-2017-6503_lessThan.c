        bool lessThan(const QString &left, const QString &right) const
        {
            // Return value `false` indicates `right` should go before `left`, otherwise, after
            int posL = 0;
            int posR = 0;
            while (true) {
                while (true) {
                    if ((posL == left.size()) || (posR == right.size()))
                        return (left.size() < right.size());  // when a shorter string is another string's prefix, shorter string place before longer string

                    QChar leftChar = m_caseSensitive ? left[posL] : left[posL].toLower();
                    QChar rightChar = m_caseSensitive ? right[posR] : right[posR].toLower();
                    if (leftChar == rightChar)
                        ;  // compare next character
                    else if (leftChar.isDigit() && rightChar.isDigit())
                        break; // Both are digits, break this loop and compare numbers
                    else
                        return leftChar < rightChar;

                    ++posL;
                    ++posR;
                }

                int startL = posL;
                while ((posL < left.size()) && left[posL].isDigit())
                    ++posL;
#ifdef QBT_USES_QT5
                int numL = left.midRef(startL, posL - startL).toInt();
#else
                int numL = left.mid(startL, posL - startL).toInt();
#endif

                int startR = posR;
                while ((posR < right.size()) && right[posR].isDigit())
                    ++posR;
#ifdef QBT_USES_QT5
                int numR = right.midRef(startR, posR - startR).toInt();
#else
                int numR = right.mid(startR, posR - startR).toInt();
#endif

                if (numL != numR)
                    return (numL < numR);

                // Strings + digits do match and we haven't hit string end
                // Do another round
            }
            return false;
        }
