ipf_clean_thread_main(void *f)
{
    struct ipf *ipf = f;

    enum {
        IPF_FRAG_LIST_CLEAN_TIMEOUT = 60000,
    };

    while (!latch_is_set(&ipf->ipf_clean_thread_exit)) {

        long long now = time_msec();

        if (!ovs_list_is_empty(&ipf->frag_exp_list) ||
            !ovs_list_is_empty(&ipf->frag_complete_list)) {

            ovs_mutex_lock(&ipf->ipf_lock);

            struct ipf_list *ipf_list, *next;
            LIST_FOR_EACH_SAFE (ipf_list, next, list_node,
                                &ipf->frag_exp_list) {
                if (ipf_purge_list_check(ipf, ipf_list, now)) {
                    ipf_expiry_list_clean(&ipf->frag_lists, ipf_list);
                }
            }

            LIST_FOR_EACH_SAFE (ipf_list, next, list_node,
                                &ipf->frag_complete_list) {
                if (ipf_purge_list_check(ipf, ipf_list, now)) {
                    ipf_completed_list_clean(&ipf->frag_lists, ipf_list);
                }
            }

            ovs_mutex_unlock(&ipf->ipf_lock);
        }

        poll_timer_wait_until(now + IPF_FRAG_LIST_CLEAN_TIMEOUT);
        latch_wait(&ipf->ipf_clean_thread_exit);
        poll_block();
    }

    return NULL;
}
