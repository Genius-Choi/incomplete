void DCR_CLASS dcr_sony_load_raw(DCRAW* p)
{
	uchar head[40];
	ushort *pixel;
	unsigned i, key, row, col;

	dcr_fseek(p->obj_, 200896, SEEK_SET);
	dcr_fseek(p->obj_, (unsigned) dcr_fgetc(p->obj_)*4 - 1, SEEK_CUR);
	p->order = 0x4d4d;
	key = dcr_get4(p);
	dcr_fseek(p->obj_, 164600, SEEK_SET);
	dcr_fread(p->obj_, head, 1, 40);
	dcr_sony_decrypt ((unsigned int *) head, 10, 1, key);
	for (i=26; i-- > 22; )
		key = key << 8 | head[i];
	dcr_fseek(p->obj_, p->data_offset, SEEK_SET);
	pixel = (ushort *) calloc (p->raw_width, sizeof *pixel);
	dcr_merror (p, pixel, "sony_load_raw()");
	for (row=0; row < p->height; row++) {
		if (dcr_fread(p->obj_, pixel, 2, p->raw_width) < p->raw_width) dcr_derror(p);
		dcr_sony_decrypt ((unsigned int *) pixel, p->raw_width/2, !row, key);
		for (col=9; col < p->left_margin; col++)
			p->black += ntohs(pixel[col]);
		for (col=0; col < p->width; col++)
			if ((BAYER(row,col) = ntohs(pixel[col+p->left_margin])) >> 14)
				dcr_derror(p);
	}
	free (pixel);
	if (p->left_margin > 9)
		p->black /= (p->left_margin-9) * p->height;
	p->maximum = 0x3ff0;
}
