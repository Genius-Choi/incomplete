static GF_Err mp4_mux_cenc_update(GF_MP4MuxCtx *ctx, TrackWriter *tkw, GF_FilterPacket *pck, u32 act_type, u32 pck_size, u32 injected_hdr_size)
{
	const GF_PropertyValue *p;
	GF_Err e;
	Bool pck_is_encrypted;
	u32 IV_size=0;
	u8 *fake_sai = NULL;
	u8 *sai = NULL;
	u32 sai_size = 0;
	Bool needs_seig = GF_FALSE;
	u32 sample_num;

	if (tkw->cenc_state == CENC_SETUP_ERROR)
		return GF_SERVICE_ERROR;


	if (pck) {
		p = gf_filter_pck_get_property(pck, GF_PROP_PCK_CENC_SAI);
		if (p) {
			sai = p->value.data.ptr;
			sai_size = p->value.data.size;
		}
	}


	//initial setup
	if (tkw->cenc_state==CENC_NEED_SETUP) {
		u32 scheme_type=0;
		u32 scheme_version=0;
		u32 cenc_stsd_mode=0;
		u32 container_type = GF_ISOM_BOX_TYPE_SENC;

		p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_TYPE);
		if (p) scheme_type = p->value.uint;
		p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_PROTECTION_SCHEME_VERSION);
		if (p) scheme_version = p->value.uint;

		p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_STSD_MODE);
		if (p) cenc_stsd_mode = p->value.uint;

		p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_ENCRYPTED);
		if (p) pck_is_encrypted = p->value.boolean;
		else pck_is_encrypted = GF_FALSE;


		p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_STORE);
		if (p && p->value.uint) container_type = p->value.uint;

		tkw->clear_stsd_idx = 0;
		if (cenc_stsd_mode) {
			u32 clone_stsd_idx;
			e = gf_isom_clone_sample_description(ctx->file, tkw->track_num, ctx->file, tkw->track_num, tkw->stsd_idx, NULL, NULL, &clone_stsd_idx);
			if (e) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to clone sample description: %s\n", gf_error_to_string(e) ));
				return e;
			}
			//current stsd reused, use clone one for encrypted stsd
			if (tkw->reused_stsd) {
				tkw->clear_stsd_idx = tkw->stsd_idx;
				tkw->stsd_idx = clone_stsd_idx;
			}
			//before
			else if (cenc_stsd_mode==1) {
				tkw->clear_stsd_idx = tkw->stsd_idx;
				tkw->stsd_idx = clone_stsd_idx;
			}
			//after
			else {
				tkw->clear_stsd_idx = clone_stsd_idx;
			}
		}
		tkw->def_crypt_byte_block = tkw->crypt_byte_block;
		tkw->def_skip_byte_block = tkw->skip_byte_block;

		tkw->cenc_state = CENC_SETUP_DONE;
		tkw->def_cenc_key_info_crc = tkw->cenc_key_info_crc;
		if (tkw->cenc_ki) {
			e = gf_isom_set_cenc_protection(ctx->file, tkw->track_num, tkw->stsd_idx, scheme_type, scheme_version, pck_is_encrypted, tkw->def_crypt_byte_block, tkw->def_skip_byte_block, tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size);
		} else {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Missing CENC Key config, cannot mux\n"));
			tkw->cenc_state = CENC_SETUP_ERROR;
			return GF_NON_COMPLIANT_BITSTREAM;
		}
		if (e) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to setup CENC information: %s\n", gf_error_to_string(e) ));
			tkw->cenc_state = CENC_SETUP_ERROR;
			return e;
		}

		//purge duplicates
		u32 k, nb_sdesc = gf_isom_get_sample_description_count(ctx->file, tkw->track_num);
		if (nb_sdesc>2) {
			for (k=0; k<nb_sdesc; k++) {
				if (k+1 == tkw->stsd_idx) continue;

				if (gf_isom_is_same_sample_description(ctx->file, tkw->track_num, tkw->stsd_idx, ctx->file, tkw->track_num, k+1) ) {
					gf_isom_remove_stream_description(ctx->file, tkw->track_num, tkw->stsd_idx);
					tkw->stsd_idx = k+1;
					break;
				}
			}
		}

		if ((ctx->psshs == MP4MX_PSSH_MOOV) || (ctx->psshs == MP4MX_PSSH_BOTH))
			mp4_mux_cenc_insert_pssh(ctx, tkw, NULL, 0);

		if (!tkw->has_brands && (scheme_type==GF_ISOM_OMADRM_SCHEME))
			gf_isom_modify_alternate_brand(ctx->file, GF_ISOM_BRAND_OPF2, GF_TRUE);

		if (container_type) {
			if (container_type==GF_ISOM_BOX_UUID_PSEC) {
				e = gf_isom_piff_allocate_storage(ctx->file, tkw->track_num, 0, 0, NULL);
			} else {
				e = gf_isom_cenc_allocate_storage(ctx->file, tkw->track_num);
			}
			if (e) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to setup CENC storage: %s\n", gf_error_to_string(e) ));
				tkw->cenc_state = CENC_SETUP_ERROR;
				return e;
			}
		}
	}
	if (act_type==CENC_CONFIG) return GF_OK;

	pck_is_encrypted = GF_FALSE;
	if (pck)
		pck_is_encrypted = gf_filter_pck_get_crypt_flags(pck);

	//!! tkw->nb_samples / tkw->samples_in_frag not yet incremented !!
	if (act_type == CENC_ADD_FRAG) {
		sample_num = tkw->samples_in_frag + 1;

		if (ctx->cmaf) {
			if (!tkw->samples_in_frag) {
				tkw->cenc_frag_protected = pck_is_encrypted;
			} else {
				if (tkw->cenc_frag_protected != pck_is_encrypted) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] CMAF forbids mixing protected and unprotected samples in a single fragment, please re-encrypt or change target segment duration\n"));
					return GF_NON_COMPLIANT_BITSTREAM;
				}
			}
		}
	} else {
		sample_num = tkw->nb_samples + 1;
	}
	if (!pck_is_encrypted) {
		if (tkw->clear_stsd_idx) {
			if (act_type==CENC_ADD_FRAG) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
				return gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, NULL, 0, GF_FALSE, ctx->saio32, tkw->cenc_multikey);
#else
				return GF_NOT_SUPPORTED;
#endif
			} else {
				return gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, NULL, 0, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);
			}
		} else {
			char dumb_key[20];
			memset(dumb_key, 0, 20); //dumb key, IV size 0, not protected
			e = gf_isom_set_sample_cenc_group(ctx->file, tkw->track_num, sample_num, GF_FALSE, 0, 0, dumb_key, 20);
			IV_size = 0;
			tkw->has_seig = GF_TRUE;
		}
	} else {

		e = GF_OK;
		//multikey ALWAYS uses seig
		if (tkw->cenc_ki->value.data.ptr[0])
			needs_seig = GF_TRUE;
		else if (tkw->def_crypt_byte_block != tkw->crypt_byte_block)
			needs_seig = GF_TRUE;
		else if (tkw->def_skip_byte_block != tkw->skip_byte_block)
			needs_seig = GF_TRUE;
		else if (tkw->def_cenc_key_info_crc != tkw->cenc_key_info_crc)
			needs_seig = GF_TRUE;

		if (needs_seig) {
			e = gf_isom_set_sample_cenc_group(ctx->file, tkw->track_num, sample_num, 1, tkw->crypt_byte_block, tkw->skip_byte_block, tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size);
			tkw->has_seig = GF_TRUE;
		} else if (tkw->has_seig) {
			e = gf_isom_set_sample_cenc_default_group(ctx->file, tkw->track_num, sample_num);
		}
	}
	if (e) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Failed to set sample encryption group entry: %s)\n", gf_error_to_string(e) ));
		return e;
	}

	p = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);
	if (p && (p->type == GF_PROP_DATA) && p->value.data.ptr) {
		if (ctx->store>=MP4MX_MODE_FRAG) {
			mp4_mux_cenc_insert_pssh(ctx, tkw, p, 0);
		} else {
			gf_isom_set_sample_group_description(ctx->file, tkw->track_num, sample_num, GF_4CC('P','S','S','H'), 0, p->value.data.ptr, p->value.data.size, 0);
		}
	}

	if (!sai) {
		if (tkw->constant_IV_size && !tkw->cenc_subsamples)
			return GF_OK;

		if (IV_size) {
			//generate clear SAI data with a non-0 IV
			u32 olen = pck_size;
			GF_BitStream *bs = gf_bs_new(NULL, 9, GF_BITSTREAM_WRITE);
			if (tkw->cenc_multikey) {
				gf_bs_write_u16(bs, 0);
			} else {
				gf_bs_write_long_int(bs, 0, IV_size*8);
			}

			if (tkw->cenc_subsamples) {
				u32 i;
				u32 subsample_count = 1;
				while (olen>0xFFFF) {
					olen -= 0xFFFF;
					subsample_count ++;
				}
				gf_bs_write_u16(bs, subsample_count);
				olen = pck_size;
				for (i = 0; i < subsample_count; i++) {
					u32 clear_size;
					if (olen<0xFFFF) {
						clear_size = olen;
					} else {
						clear_size = 0xFFFF;
						olen -= 0xFFFF;
					}

					if (tkw->cenc_multikey)
						gf_bs_write_u16(bs, 0);
					gf_bs_write_u16(bs, clear_size);
					gf_bs_write_u32(bs, 0);
				}
			}
			gf_bs_get_content(bs, &fake_sai, &sai_size);
			gf_bs_del(bs);
			sai = fake_sai;
		}
	}
	//we injected xPS at the beginning of the sample (AVC/HEVC/VVC), we must patch the first subsample
	//of SAI data
	else if (injected_hdr_size) {
		u32 offset = 0;
		u32 first_sub_clear, sub_count_size;
		u8 *sai_d;
		u8 key_info_get_iv_size(const u8 *key_info, u32 nb_keys, u32 idx, u8 *const_iv_size, const u8 **const_iv);

		assert(tkw->cenc_subsamples);

		//multi-key skip all IV inits
		if (tkw->cenc_ki->value.data.ptr[0]) {
			u32 remain;
			u32 j, nb_iv_init = sai[0];
			nb_iv_init <<= 8;
			nb_iv_init |= sai[1];
			u8 *sai_p = sai + 2;
			remain = sai_size-2;

			for (j=0; j<nb_iv_init; j++) {
				u32 mk_iv_size;
				u32 idx = sai_p[0];
				idx<<=8;
				idx |= sai_p[1];

				mk_iv_size = key_info_get_iv_size(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size, idx, NULL, NULL);
				mk_iv_size += 2; //idx
				if (mk_iv_size > remain) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Invalid multi-key CENC SAI, cannot modify first subsample !\n"));
					return GF_NON_COMPLIANT_BITSTREAM;
				}
				sai_p += mk_iv_size;
				remain -= mk_iv_size;
				if (remain && (remain<=2)) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Invalid multi-key CENC SAI, cannot modify first subsample !\n"));
					return GF_NON_COMPLIANT_BITSTREAM;
				}
			}
			offset = (u32) (sai_p - sai);
			sub_count_size = 4; //32bit sub count

		} else {
			offset = key_info_get_iv_size(tkw->cenc_ki->value.data.ptr, tkw->cenc_ki->value.data.size, 1, NULL, NULL);
			sub_count_size = 2; //16bit sub count
		}
		if (sai_size < offset + sub_count_size + 6) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Invalid CENC SAI !\n"));
			return GF_NON_COMPLIANT_BITSTREAM;
		}
		//get size of first subsample
		offset += sub_count_size;
		sai_d = sai + offset;
		first_sub_clear = sai_d[0];
		first_sub_clear<<=8;
		first_sub_clear |= sai_d[1];
		first_sub_clear += injected_hdr_size;
		//fits, only patch first subsample size
		if (first_sub_clear < 0xFFFF) {
			fake_sai = gf_malloc(sizeof(u8) * sai_size);
			if (!fake_sai) return GF_OUT_OF_MEM;
			memcpy(fake_sai, sai, sizeof(u8) * sai_size);
			sai_d = fake_sai + offset;
			sai_d[0] = (first_sub_clear>>8) & 0xFF;
			sai_d[1] = (first_sub_clear) & 0xFF;
			sai = fake_sai;
		}
		//injected header size does not fit in first subsample, add a new subsample
		else {
			fake_sai = gf_malloc(sizeof(u8) * (sai_size+6));
			if (!fake_sai) return GF_OUT_OF_MEM;
			//copy till start of first subsample (including subsample_count)
			memcpy(fake_sai, sai, sizeof(u8) * offset);
			//copy all subsamples
			memcpy(fake_sai+offset+6, sai+offset, sizeof(u8) * (sai_size - offset) );
			//insert subsample
			sai_d = fake_sai + offset;
			sai_d[0] = (injected_hdr_size>>8) & 0xFF;
			sai_d[1] = (injected_hdr_size) & 0xFF;
			sai_d[2] = sai_d[3] = sai_d[4] = sai_d[5] = 0;
			//update subsample count
			sai_d = fake_sai + offset - sub_count_size;
			if (sub_count_size==2) {
				u32 cnt = ((u32) sai_d[0]) << 8 | (u32) sai_d[1];
				cnt++;
				sai_d[0] = (cnt>>8) & 0xFF;
				sai_d[1] = (cnt) & 0xFF;
			} else {
				u32 cnt = GF_4CC( sai_d[0], sai_d[1], sai_d[2], sai_d[3]);
				cnt++;
				sai_d[0] = (cnt>>24) & 0xFF;
				sai_d[1] = (cnt>>16) & 0xFF;
				sai_d[2] = (cnt>>8) & 0xFF;
				sai_d[3] = (cnt) & 0xFF;
			}
			sai = fake_sai;
			sai_size += 6;
		}
	}

	if (act_type==CENC_ADD_FRAG) {
#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
		if (pck_is_encrypted) {
			e = gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, sai, sai_size, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);
		} else {
			e = gf_isom_fragment_set_cenc_sai(ctx->file, tkw->track_id, NULL, 0, GF_FALSE, ctx->saio32, tkw->cenc_multikey);
		}
#else
		e = GF_NOT_SUPPORTED;
#endif
	} else {
		if (sai) {
			e = gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, sai, sai_size, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);
		} else if (!pck_is_encrypted) {
			e = gf_isom_track_cenc_add_sample_info(ctx->file, tkw->track_num, GF_ISOM_BOX_TYPE_SENC, NULL, 0, tkw->cenc_subsamples, ctx->saio32, tkw->cenc_multikey);
		}
	}
	if (fake_sai) gf_free(fake_sai);
	return e;
}
