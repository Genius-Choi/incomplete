zfs_zaccess_common(znode_t *zp, uint32_t v4_mode, uint32_t *working_mode,
    boolean_t *check_privs, boolean_t skipaclchk, cred_t *cr)
{
	zfsvfs_t *zfsvfs = zp->z_zfsvfs;
	int err;

	*working_mode = v4_mode;
	*check_privs = B_TRUE;

	/*
	 * Short circuit empty requests
	 */
	if (v4_mode == 0 || zfsvfs->z_replay) {
		*working_mode = 0;
		return (0);
	}

	if ((err = zfs_zaccess_dataset_check(zp, v4_mode)) != 0) {
		*check_privs = B_FALSE;
		return (err);
	}

	/*
	 * The caller requested that the ACL check be skipped.  This
	 * would only happen if the caller checked VOP_ACCESS() with a
	 * 32 bit ACE mask and already had the appropriate permissions.
	 */
	if (skipaclchk) {
		*working_mode = 0;
		return (0);
	}

	/*
	 * Note: ZFS_READONLY represents the "DOS R/O" attribute.
	 * When that flag is set, we should behave as if write access
	 * were not granted by anything in the ACL.  In particular:
	 * We _must_ allow writes after opening the file r/w, then
	 * setting the DOS R/O attribute, and writing some more.
	 * (Similar to how you can write after fchmod(fd, 0444).)
	 *
	 * Therefore ZFS_READONLY is ignored in the dataset check
	 * above, and checked here as if part of the ACL check.
	 * Also note: DOS R/O is ignored for directories.
	 */
	if ((v4_mode & WRITE_MASK_DATA) &&
	    (ZTOV(zp)->v_type != VDIR) &&
	    (zp->z_pflags & ZFS_READONLY)) {
		return (SET_ERROR(EPERM));
	}

	return (zfs_zaccess_aces_check(zp, working_mode, B_FALSE, cr));
}
