static int ast_rtcp_generate_nack(struct ast_rtp_instance *instance, unsigned char *rtcpheader)
{
	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
	int packet_len;
	int blp_index = -1;
	int current_seqno;
	unsigned int fci = 0;
	size_t remaining_missing_seqno;

	if (!rtp || !rtp->rtcp) {
		return 0;
	}

	if (ast_sockaddr_isnull(&rtp->rtcp->them)) {
		return 0;
	}

	current_seqno = rtp->expectedrxseqno;
	remaining_missing_seqno = AST_VECTOR_SIZE(&rtp->missing_seqno);
	packet_len = 12; /* The header length is 12 (version line, packet source SSRC, media source SSRC) */

	/* If there are no missing sequence numbers then don't bother sending a NACK needlessly */
	if (!remaining_missing_seqno) {
		return 0;
	}

	/* This iterates through the possible forward sequence numbers seeing which ones we
	 * have no packet for, adding it to the NACK until we are out of missing packets.
	 */
	while (remaining_missing_seqno) {
		int *missing_seqno;

		/* On the first entry to this loop blp_index will be -1, so this will become 0
		 * and the sequence number will be placed into the packet as the PID.
		 */
		blp_index++;

		missing_seqno = AST_VECTOR_GET_CMP(&rtp->missing_seqno, current_seqno,
				find_by_value);
		if (missing_seqno) {
			/* We hit the max blp size, reset */
			if (blp_index >= 17) {
				put_unaligned_uint32(rtcpheader + packet_len, htonl(fci));
				fci = 0;
				blp_index = 0;
				packet_len += 4;
			}

			if (blp_index == 0) {
				fci |= (current_seqno << 16);
			} else {
				fci |= (1 << (blp_index - 1));
			}

			/* Since we've used a missing sequence number, we're down one */
			remaining_missing_seqno--;
		}

		/* Handle cycling of the sequence number */
		current_seqno++;
		if (current_seqno == SEQNO_CYCLE_OVER) {
			current_seqno = 0;
		}
	}

	put_unaligned_uint32(rtcpheader + packet_len, htonl(fci));
	packet_len += 4;

	/* Length MUST be 2+n, where n is the number of NACKs. Same as length in words minus 1 */
	put_unaligned_uint32(rtcpheader, htonl((2 << 30) | (AST_RTP_RTCP_FMT_NACK << 24)
				| (AST_RTP_RTCP_RTPFB << 16) | ((packet_len / 4) - 1)));
	put_unaligned_uint32(rtcpheader + 4, htonl(rtp->ssrc));
	put_unaligned_uint32(rtcpheader + 8, htonl(rtp->themssrc));

	return packet_len;
}
