static GF_Err mp4_mux_initialize(GF_Filter *filter)
{
	GF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);
	gf_filter_set_max_extra_input_pids(filter, -1);
	ctx->filter = filter;
#ifdef GPAC_DISABLE_ISOM_FRAGMENTS
	if (ctx->store>=MP4MX_MODE_FRAG) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Cannot use fragmented mode, disabled in build\n"));
		return GF_NOT_SUPPORTED;
	}
#endif
	if (ctx->file) {
		if (gf_isom_get_mode(ctx->file) < GF_ISOM_OPEN_WRITE) return GF_BAD_PARAM;
		if (ctx->store>=MP4MX_MODE_FRAG) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[MP4Mux] Cannot use fragmented output on already opened ISOBMF file\n"));
			return GF_BAD_PARAM;
		}
		ctx->owns_mov = GF_FALSE;
		gf_filter_act_as_sink(filter);
	} else {
		u32 open_mode = GF_ISOM_OPEN_WRITE;
		ctx->owns_mov = GF_TRUE;

		switch (ctx->store) {
		case MP4MX_MODE_INTER:
		case MP4MX_MODE_TIGHT:
			open_mode = GF_ISOM_WRITE_EDIT;
			break;
		}
		ctx->file = gf_isom_open("_gpac_isobmff_redirect", open_mode, NULL);
		if (!ctx->file) return GF_OUT_OF_MEM;

		gf_isom_set_write_callback(ctx->file, mp4_mux_on_data, mp4_mux_on_data_patch, mp4_mux_on_last_block_start, ctx, ctx->block_size);

		gf_isom_set_progress_callback(ctx->file, mp4_mux_progress_cbk, filter);

		if (ctx->dref && (ctx->store>=MP4MX_MODE_FRAG)) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[MP4Mux] Cannot use data reference in movie fragments, not supported. Ignoring it\n"));
			ctx->dref = GF_FALSE;
		}

		if (ctx->store==MP4MX_MODE_FASTSTART) {
			gf_isom_set_storage_mode(ctx->file, GF_ISOM_STORE_FASTSTART);
		}
	}

	if (!ctx->moovts)
		ctx->moovts=600;

	if ((ctx->store==MP4MX_MODE_FASTSTART) && (!ctx->cdur.num || !ctx->cdur.den)) {
		ctx->cdur.num = 1;
		ctx->cdur.den = 1;
	}
	if (!ctx->cdur.den) {
		ctx->cdur.num = 0;
		ctx->cdur.den = 1000;
	}
	//we need at least ms precision for sfrag mode
	if (ctx->cdur.den < 1000) {
		ctx->cdur.num = (s32) ( ((s64)ctx->cdur.num) * 1000 / ctx->cdur.den);
		ctx->cdur.den = 1000;
	}

#ifndef GPAC_DISABLE_ISOM_FRAGMENTS
	if (ctx->mfra && (ctx->store>=MP4MX_MODE_FRAG)) {
		GF_Err e = gf_isom_enable_mfra(ctx->file);
		if (e) return e;
	}
#endif

	if (!ctx->tracks)
		ctx->tracks = gf_list_new();

	if (!ctx->ref_pcks)
		ctx->ref_pcks = gf_list_new();

#ifdef GF_ENABLE_CTRN
	if (ctx->ctrni)
		ctx->ctrn = GF_TRUE;
#endif

	if (ctx->m4cc) {
		if (strlen(ctx->m4cc)==4)
			ctx->eos_marker = GF_4CC(ctx->m4cc[0], ctx->m4cc[1], ctx->m4cc[2], ctx->m4cc[3]);
		else {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[MP4Mux] Invalid segment marker 4cc %s, ignoring\n", ctx->m4cc));
		}
	}
	if (ctx->compress) {
		u32 flags = 0;
		if (ctx->fcomp) flags |= GF_ISOM_COMP_FORCE_ALL;
		if (ctx->otyp) flags |= GF_ISOM_COMP_WRAP_FTYPE;
		gf_isom_enable_compression(ctx->file, ctx->compress, flags);
	}

	if ((ctx->store>=MP4MX_MODE_FRAG) && !ctx->tsalign)
		ctx->insert_tfdt = GF_TRUE;

	if (ctx->cmaf) {
		//cf table 3, 4, 5 of CMAF
		ctx->mvex = GF_TRUE;
		ctx->truns_first = GF_TRUE;
		//single trun, single traf (table 5 of CMAF)
		ctx->strun = GF_TRUE;
		ctx->straf = GF_TRUE;
		//7.5.16 Every TrackFragmentBox shall contain a TrackFragmentBaseMediaDecodeTimeBox
		ctx->tfdt_traf = GF_TRUE;
		//7.3.3 : If SegmentIndexBoxes exist, each subsegment referenced in the SegmentIndexBox shall be a single CMAF fragment
		ctx->chain_sidx = GF_FALSE;
		if (ctx->subs_sidx>0)
			ctx->subs_sidx = 0;

		if (ctx->cmaf==MP4MX_CMAF_CMF2) {
			/*7.7 cmf2
- default_sample_flags, sample_flags and first_sample_flags shall be set in the TrackFragmentHeaderBox and/or TrackRunBox to provide sample dependency information within each CMAF chunk and CMAF fragment.
- Default values or per sample values of sample duration and sample size shall be stored in each CMAF chunkâ€™s TrackRunBox and/or TrackFragmentHeaderBox
			*/
			ctx->nofragdef = GF_TRUE;
		}
	}
	return GF_OK;
}
