Array ObjectData::toArray(bool pubOnly /* = false */,
                          bool ignoreLateInit /* = false */) const {
  assertx(kindIsValid());

  // We can quickly tell if this object is a collection, which lets us avoid
  // checking for each class in turn if it's not one.
  if (isCollection()) {
    return collections::toArray<IC>(this);
  } else if (UNLIKELY(m_cls->rtAttribute(Class::CallToImpl))) {
    // If we end up with other classes that need special behavior, turn the
    // assert into an if and add cases.
    assertx(instanceof(SimpleXMLElement_classof()));
    if (RuntimeOption::EvalNoticeOnSimpleXMLBehavior) {
      raise_notice("SimpleXMLElement to array cast");
    }
    return SimpleXMLElement_objectCast(this, KindOfArray).toArray();
  } else if (UNLIKELY(instanceof(SystemLib::s_ArrayIteratorClass))) {
    auto const flags = getProp(SystemLib::s_ArrayIteratorClass, s_flags.get());
    assertx(flags.is_set());
    if (UNLIKELY(flags.type() == KindOfInt64 &&
                 flags.val().num == ARRAY_OBJ_ITERATOR_STD_PROP_LIST)) {
      auto ret = Array::CreateDArray();
      o_getArray(ret, true, ignoreLateInit);
      return ret;
    }

    check_recursion_throw();

    auto const storage = getProp(SystemLib::s_ArrayIteratorClass, s_storage.get());
    assertx(storage.is_set());
    return tvCastToArrayLike(storage.tv());
  } else if (UNLIKELY(instanceof(c_Closure::classof()))) {
    return make_varray(Object(const_cast<ObjectData*>(this)));
  } else if (UNLIKELY(instanceof(DateTimeData::getClass()))) {
    return Native::data<DateTimeData>(this)->getDebugInfo();
  } else {
    auto ret = Array::CreateDArray();
    o_getArray(ret, pubOnly, ignoreLateInit);
    return ret;
  }
}
