CIccCLUT *icCLutFromXml(xmlNode *pNode, int nIn, int nOut, icConvertType nType,  std::string &parseStr)
{
  CIccCLUT *pCLUT = NULL;

  int nPrecision = 2;
  if (nType == icConvert8Bit)
    nPrecision = 1;  

  icUInt8Number nInput = (icUInt8Number)nIn;
  icUInt16Number nOutput = (icUInt16Number)nOut;

  pCLUT = new CIccCLUT(nInput, nOutput, nPrecision);

  if (!pCLUT){
    parseStr += "Error in creating CLUT Table. Check values of Precision, InputChannel, or OutputChannels.\n";
    return NULL;
  }

  xmlNode *grid = icXmlFindNode(pNode->children, "GridPoints");
  if (grid) {
    CIccUInt8Array points;

    if (points.ParseArray(grid->children)) {
      if (!pCLUT->Init(points.GetBuf())) {
        parseStr += "Error in setting the size of GridPoints. Check values of GridPoints, InputChannel, or OutputChannels.\n";
        delete pCLUT;
        return NULL;
      }
    }
    else {
      parseStr += "Error parsing GridPoints.\n";
      delete pCLUT;
      return NULL;
    }
  }
  else {
    icUInt8Number nGridGranularity;

    xmlAttr *gridGranularity = icXmlFindAttr(pNode, "GridGranularity");

    if (gridGranularity) {
      nGridGranularity = (icUInt8Number)atoi(icXmlAttrValue(gridGranularity));
    }
    else {
      delete pCLUT;
      return NULL;
    }
    if (!pCLUT->Init(nGridGranularity)) {
      parseStr += "Error in setting the size of GridGranularity. Check values of GridGranularity, InputChannel, or OutputChannels.\n";
      delete pCLUT;
      return NULL;
    }
  }

  xmlNode *table = icXmlFindNode(pNode->children, "TableData");

  if (table) {
    if (nType == icConvertVariable) {
      const char *precision = icXmlAttrValue(table, "Precision");
      if (precision && atoi(precision) == 1) {
        nType = icConvert8Bit;
        pCLUT->SetPrecision(1);
      }
      else {
        nType = icConvert16Bit;
        pCLUT->SetPrecision(2);
      }
    }

    const char *filename = icXmlAttrValue(table, "Filename");
    if (!filename || !filename[0]) {
      filename = icXmlAttrValue(table, "File");
    }

    if (filename[0]) {
      CIccIO *file = IccOpenFileIO(filename, "rb");

      if (!file) {
        // added error message
        parseStr += "Error! - File '";
        parseStr += filename;
        parseStr +="' not found.\n";
        delete pCLUT;
        return NULL;
      }

      const char *format = icXmlAttrValue(table, "Format");

      if (!strcmp(format, "text")) {
        icUInt32Number num = file->GetLength();
        char *buf = (char *)malloc(num);

        if (!buf) {  
          perror("Memory Error");
          parseStr += "'";
          parseStr += filename;
          parseStr += "' may not be a valid text file.\n";
          delete file;
          delete pCLUT;
          return NULL;
        }

        //Allow for different encoding in text file than implied by the table type
        const char *encoding = icXmlAttrValue(table, "FileEncoding");

        if (!strcmp(encoding, "int8"))
          nType = icConvert8Bit;
        else if (!strcmp(encoding, "int16"))
          nType = icConvert16Bit;
        else if (!strcmp(encoding, "float"))
          nType = icConvertFloat;
        else if (encoding[0]) {
          parseStr+= "Unknown encoding \"";
          parseStr+= encoding;
          parseStr+= "\" - using default encoding\n";
        }

        if (file->Read8(buf, num)!=num) { 
          perror("Read-File Error");
          parseStr += "'";
          parseStr += filename;
          parseStr += "' may not be a valid text file.\n";
          free(buf);
          delete file;
          delete pCLUT;
          return NULL;
        }

        if (nType == icConvert8Bit) {
          CIccUInt8Array data;

          if (!data.ParseTextArrayNum(buf, num, parseStr)) {
            parseStr += "File '";
            parseStr += filename;
            parseStr += "' is not a valid text file.\n";
            free(buf);
            delete file;
            delete pCLUT;
            return NULL;
          }

          if (data.GetSize()!=pCLUT->NumPoints()*pCLUT->GetOutputChannels()) {     
            parseStr += "Error! - Number of entries in file '";
            parseStr += filename;
            parseStr += "'is not equal to the size of the CLUT Table.\n";  
            parseStr += "    a. Check values of GridGranularity/GridPoints, InputChannel, or OutputChannels.\n";
            parseStr += "    b. File may not be a valid text file.\n";
            free(buf);
            delete file;
            delete pCLUT;
            return NULL;
          }
          icUInt8Number *src = data.GetBuf();
          icFloatNumber *dst = pCLUT->GetData(0);

          icUInt32Number i;
          for (i=0; i<data.GetSize(); i++) {
            *dst++ = (icFloatNumber)(*src++) / 255.0f;
          }
        }
        else if (nType == icConvert16Bit) {
          CIccUInt16Array data;

          if (!data.ParseTextArrayNum(buf, num, parseStr)) {
            parseStr += "File '";
            parseStr += filename;
            parseStr += "' is not a valid text file.\n";      
            free(buf);
            delete file;
            delete pCLUT;
            return NULL;
          }

          if (data.GetSize()!=pCLUT->NumPoints()*pCLUT->GetOutputChannels()) {
            parseStr += "Error! - Number of entries in file '";
            parseStr += filename;
            parseStr += "'is not equal to the size of the CLUT Table.\n";  
            parseStr += "    a. Check values of GridGranularity/GridPoints, InputChannel, or OutputChannels.\n";
            parseStr += "    b. File may not be a valid text file.\n";
            free(buf);
            delete file;
            delete pCLUT;
            return NULL;
          }
          icUInt16Number *src = data.GetBuf();
          icFloatNumber *dst = pCLUT->GetData(0);

          icUInt32Number i;
          for (i=0; i<data.GetSize(); i++) {
            *dst++ = (icFloatNumber)(*src++) / 65535.0f;
          }
        }
        else if (nType == icConvertFloat) {
          CIccFloatArray data;

          if (!data.ParseTextArrayNum(buf, num, parseStr)) {
            parseStr += "File '";
            parseStr += filename;
            parseStr += "' is not a valid text file.\n";
            free(buf);
            delete file;
            delete pCLUT;
            return NULL;
          }

          if (data.GetSize()!=pCLUT->NumPoints()*pCLUT->GetOutputChannels()) {
            parseStr += "Error! - Number of entries in file '";
            parseStr += filename;
            parseStr += "'is not equal to the size of the CLUT Table.\n";  
            parseStr += "    a. Check values of GridGranularity/GridPoints, InputChannel, or OutputChannels.\n";
            parseStr += "    b. File may not be a valid text file.\n";
            free(buf);
            delete file;
            delete pCLUT;
            return NULL;
          }
          icFloatNumber *src = data.GetBuf();
          icFloatNumber *dst = pCLUT->GetData(0);

          icUInt32Number i;
          for (i=0; i<data.GetSize(); i++) {
            *dst++ = *src++;
          }
        }
        else {
          parseStr += "Error! Unknown text data type.\n";
          free(buf);
          delete file;
          delete pCLUT;
          return NULL;
        }
        free(buf);
      }
      else if (!strcmp(format, "binary")) {
        const char *order = icXmlAttrValue(table, "Endian");
        bool little_endian = !strcmp(order, "little");

        if (nType==icConvertVariable) {
          //Allow encoding to be defined
          const char *encoding = icXmlAttrValue(table, "FileEncoding");

          if (!strcmp(encoding, "int8"))
            nType = icConvert8Bit;
          else if (!strcmp(encoding, "int16"))
            nType = icConvert16Bit;
          else if (!strcmp(encoding, "float"))
            nType = icConvertFloat;
          else if (encoding[0]) {
            parseStr+= "Unknown encoding \"";
            parseStr+= encoding;
            parseStr+= "\" - using int16.\n";
            nType = icConvert16Bit;
          }
          else {
            parseStr+= "CLUT TableData Encoding type not specified.\n";
          }
        }

        if (nType == icConvert8Bit){
          icUInt32Number num = file->GetLength();
          icUInt8Number value;      
          // if number of entries in file is not equal to size of CLUT table, flag as error
          if (num!=pCLUT->NumPoints()*pCLUT->GetOutputChannels()) {
            parseStr += "Error! - Number of entries in file '";
            parseStr += filename;
            parseStr += "'is not equal to the size of the CLUT Table.\n";  
            parseStr += "    a. Check values of GridGranularity/GridPoints, InputChannel, or OutputChannels.\n";
            parseStr += "    b. File may not be a valid binary file.\n";
            delete file;
            delete pCLUT;
            return NULL;
          }
          icFloatNumber *dst = pCLUT->GetData(0);
          icUInt32Number i;
          for (i=0; i<num; i++) {
            if (!file->Read8(&value)) {
              perror("Read-File Error");
              parseStr += "'";
              parseStr += filename;
              parseStr += "' may not be a valid binary file.\n";
              delete file;
              delete pCLUT;
              return NULL;
            }      
            *dst++ = (icFloatNumber)value / 255.0f;
          }
        }
        else if (nType == icConvert16Bit){
          icUInt32Number num = file->GetLength() / sizeof(icUInt16Number);
          icUInt16Number value;
          icUInt8Number *ptr = (icUInt8Number*)&value;

          if (num<pCLUT->NumPoints()*pCLUT->GetOutputChannels()) {
            parseStr += "Error! - Number of entries in file '";
            parseStr += filename;
            parseStr += "'is not equal to the size of the CLUT Table.\n";
            parseStr += "    a. Check values of GridGranularity/GridPoints, InputChannel, or OutputChannels.\n";
            parseStr += "    b. File may not be a valid binary file.\n";
            delete file;
            delete pCLUT;
            return NULL;
          }
          icFloatNumber *dst = pCLUT->GetData(0);

          icUInt32Number i;
          for (i=0; i<num; i++) {
            if (!file->Read16(&value)) {  //this assumes data is big endian
              perror("Read-File Error");
              parseStr += "'";
              parseStr += filename;
              parseStr += "' may not be a valid binary file.\n";
              delete file;
              delete pCLUT;
              return NULL;
            }
#ifdef ICC_BYTE_ORDER_LITTLE_ENDIAN
            if (little_endian) {
#else
            if (!little_endian) {
#endif
              icUInt8Number t = ptr[0];
              ptr[0] = ptr[1];
              ptr[1] = t;
            }
            *dst++ = (icFloatNumber)value / 65535.0f;
          }
        }
        else if (nType == icConvertFloat){
          icUInt32Number num = file->GetLength()/sizeof(icFloat32Number);
          icFloat32Number value;
          icUInt8Number *ptr = (icUInt8Number*)&value;

          if (num<pCLUT->NumPoints()*pCLUT->GetOutputChannels()) {
            parseStr += "Error! - Number of entries in file '";
            parseStr += filename;
            parseStr += "'is not equal to the size of the CLUT Table.\n";  
            parseStr += "    a. Check values of GridGranularity/GridPoints, InputChannel, or OutputChannels.\n";
            parseStr += "    b. File may not be a valid binary file.\n";
            delete file;
            delete pCLUT;
            return NULL;
          }
          icFloatNumber *dst = pCLUT->GetData(0);

          icUInt32Number i;
          for (i=0; i<num; i++) {
            if (!file->ReadFloat32Float(&value)) {  //this assumes data is big endian
              perror("Read-File Error");
              parseStr += "'";
              parseStr += filename;
              parseStr += "' may not be a valid binary file.\n";
              delete file;
              delete pCLUT;
              return NULL;
            }
#ifdef ICC_BYTE_ORDER_LITTLE_ENDIAN
            if (little_endian) {
#else
            if (!little_endian) {
#endif
              icUInt8Number tmp;
              tmp = ptr[0]; ptr[0] = ptr[3]; ptr[3] = tmp;
              tmp = ptr[1]; ptr[1] = ptr[2]; ptr[2] = tmp;
            }
            *dst++ = value;
          }
        }
        else {
          parseStr += "Error! Unknown binary data type.\n";
          delete file;
          delete pCLUT;
          return NULL;
        }

      }
      else {
        parseStr += "Error! Unknown Format type.\n";
        delete pCLUT;
        return NULL;
      }

      delete file;
    }
    else { // no file
      if (nType == icConvert8Bit) {
        CIccUInt8Array data;

        if (!data.ParseArray(table->children)) {
          parseStr += "Error! - unable to parse data in CLUT.\n";
          delete pCLUT;
          return NULL;
        }

        if (data.GetSize()!=pCLUT->NumPoints()*pCLUT->GetOutputChannels()) {
          parseStr += "Error! - Number of entries is not equal to the size of the CLUT Table.\n";  
          delete pCLUT;
          return NULL;
        }
        icUInt8Number *src = data.GetBuf();
        icFloatNumber *dst = pCLUT->GetData(0);

        icUInt32Number i;
        for (i=0; i<data.GetSize(); i++) {
          *dst++ = (icFloatNumber)(*src++) / 255.0f;
        }
      }
      else if (nType == icConvert16Bit || nType==icConvertVariable) {
        CIccUInt16Array data;

        if (!data.ParseArray(table->children)) {
          parseStr += "Error! - unable to parse data in CLUT.\n";
          delete pCLUT;
          return NULL;
        }

        if (data.GetSize()!=pCLUT->NumPoints()*pCLUT->GetOutputChannels()) {
          parseStr += "Error! - Number of entries is not equal to the size of the CLUT Table.\n";  
          delete pCLUT;
          return NULL;
        }
        icUInt16Number *src = data.GetBuf();
        icFloatNumber *dst = pCLUT->GetData(0);

        icUInt32Number i;
        for (i=0; i<data.GetSize(); i++) {
          *dst++ = (icFloatNumber)(*src++) / 65535.0f;
        }    
      }      
      else if (nType == icConvertFloat){
        CIccFloatArray data;

        if (!data.ParseArray(table->children)) {
          parseStr += "Error! - unable to parse data in CLUT.\n";
          delete pCLUT;
          return NULL;
        }

        if (data.GetSize()!=pCLUT->NumPoints()*pCLUT->GetOutputChannels()) {
          parseStr += "Error! - Number of entries is not equal to the size of the CLUT Table.\n";  
          delete pCLUT;
          return NULL;
        }
        icFloatNumber *src = data.GetBuf();
        icFloatNumber *dst = pCLUT->GetData(0);

        icUInt32Number i;
        for (i=0; i<data.GetSize(); i++) {
          *dst++ = *src++;
        }
      }
      else {
        parseStr += "Error! Unknown table data type.";
        delete pCLUT;
        return NULL;
      }
    }
  }
  else {
    parseStr += "Error! Cannot find table data.";
    delete pCLUT;
    return NULL;
  }

  return pCLUT;
}
