static int handle_payload(quicly_conn_t *conn, size_t epoch, const uint8_t *_src, size_t _len, uint64_t *offending_frame_type,
                          int *is_ack_only)
{
    /* clang-format off */

    /* `frame_handlers` is an array of frame handlers and the properties of the frames, indexed by the ID of the frame. */
    static const struct st_quicly_frame_handler_t {
        int (*cb)(quicly_conn_t *, struct st_quicly_handle_payload_state_t *); /* callback function that handles the frame */
        uint8_t permitted_epochs;  /* the epochs the frame can appear, calculated as bitwise-or of `1 << epoch` */
        uint8_t ack_eliciting;     /* boolean indicating if the frame is ack-eliciting */
        size_t counter_offset;     /* offset of corresponding `conn->super.stats.num_frames_received.type` within quicly_conn_t */
    } frame_handlers[] = {
#define FRAME(n, i, z, h, o, ae)                                                                                                   \
    {                                                                                                                              \
        handle_##n##_frame,                                                                                                        \
        (i << QUICLY_EPOCH_INITIAL) | (z << QUICLY_EPOCH_0RTT) | (h << QUICLY_EPOCH_HANDSHAKE) | (o << QUICLY_EPOCH_1RTT),         \
        ae,                                                                                                                        \
        offsetof(quicly_conn_t, super.stats.num_frames_received.n)                                                                 \
    }
        /*   +----------------------+-------------------+---------------+
         *   |                      |  permitted epochs |               |
         *   |        frame         +----+----+----+----+ ack-eliciting |
         *   |                      | IN | 0R | HS | 1R |               |
         *   +----------------------+----+----+----+----+---------------+ */
        FRAME( padding              ,  1 ,  1 ,  1 ,  1 ,             0 ), /* 0 */
        FRAME( ping                 ,  1 ,  1 ,  1 ,  1 ,             1 ),
        FRAME( ack                  ,  1 ,  0 ,  1 ,  1 ,             0 ),
        FRAME( ack                  ,  1 ,  0 ,  1 ,  1 ,             0 ),
        FRAME( reset_stream         ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( stop_sending         ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( crypto               ,  1 ,  0 ,  1 ,  1 ,             1 ),
        FRAME( new_token            ,  0 ,  0 ,  0 ,  1 ,             1 ),
        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ), /* 8 */
        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( stream               ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( max_data             ,  0 ,  1 ,  0 ,  1 ,             1 ), /* 16 */
        FRAME( max_stream_data      ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( max_streams_bidi     ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( max_streams_uni      ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( data_blocked         ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( stream_data_blocked  ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( streams_blocked      ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( streams_blocked      ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( new_connection_id    ,  0 ,  1 ,  0 ,  1 ,             1 ), /* 24 */
        FRAME( retire_connection_id ,  0 ,  0 ,  0 ,  1 ,             1 ),
        FRAME( path_challenge       ,  0 ,  1 ,  0 ,  1 ,             1 ),
        FRAME( path_response        ,  0 ,  0 ,  0 ,  1 ,             1 ),
        FRAME( transport_close      ,  1 ,  1 ,  1 ,  1 ,             0 ),
        FRAME( application_close    ,  0 ,  1 ,  0 ,  1 ,             0 ),
        FRAME( handshake_done       ,  0,   0 ,  0 ,  1 ,             1 ),
        /*   +----------------------+----+----+----+----+---------------+ */
#undef FRAME
    };
    static const struct {
        uint64_t type;
        struct st_quicly_frame_handler_t _;
    } ex_frame_handlers[] = {
#define FRAME(uc, lc, i, z, h, o, ae)                                                                                              \
    {                                                                                                                              \
        QUICLY_FRAME_TYPE_##uc,                                                                                                    \
        {                                                                                                                          \
            handle_##lc##_frame,                                                                                                   \
            (i << QUICLY_EPOCH_INITIAL) | (z << QUICLY_EPOCH_0RTT) | (h << QUICLY_EPOCH_HANDSHAKE) | (o << QUICLY_EPOCH_1RTT),     \
            ae,                                                                                                                    \
            offsetof(quicly_conn_t, super.stats.num_frames_received.lc) \
        },                                                                                                                         \
    }
        /*   +----------------------------------+-------------------+---------------+
         *   |               frame              |  permitted epochs |               |
         *   |------------------+---------------+----+----+----+----+ ack-eliciting |
         *   |    upper-case    |  lower-case   | IN | 0R | HS | 1R |               |
         *   +------------------+---------------+----+----+----+----+---------------+ */
        FRAME( DATAGRAM_NOLEN   , datagram      ,  0 ,  1,   0,   1 ,             1 ),
        FRAME( DATAGRAM_WITHLEN , datagram      ,  0 ,  1,   0,   1 ,             1 ),
        FRAME( ACK_FREQUENCY    , ack_frequency ,  0 ,  0 ,  0 ,  1 ,             1 ),
        /*   +------------------+---------------+-------------------+---------------+ */
#undef FRAME
        {UINT64_MAX},
    };
    /* clang-format on */

    struct st_quicly_handle_payload_state_t state = {_src, _src + _len, epoch};
    size_t num_frames_ack_eliciting = 0;
    int ret;

    do {
        /* determine the frame type; fast path is available for frame types below 64 */
        const struct st_quicly_frame_handler_t *frame_handler;
        state.frame_type = *state.src++;
        if (state.frame_type < PTLS_ELEMENTSOF(frame_handlers)) {
            frame_handler = frame_handlers + state.frame_type;
        } else {
            /* slow path */
            --state.src;
            if ((state.frame_type = quicly_decodev(&state.src, state.end)) == UINT64_MAX) {
                state.frame_type =
                    QUICLY_FRAME_TYPE_PADDING; /* we cannot signal the offending frame type when failing to decode the frame type */
                ret = QUICLY_TRANSPORT_ERROR_FRAME_ENCODING;
                break;
            }
            size_t i;
            for (i = 0; ex_frame_handlers[i].type < state.frame_type; ++i)
                ;
            if (ex_frame_handlers[i].type != state.frame_type) {
                ret = QUICLY_TRANSPORT_ERROR_FRAME_ENCODING; /* not found */
                break;
            }
            frame_handler = &ex_frame_handlers[i]._;
        }
        /* check if frame is allowed, then process */
        if ((frame_handler->permitted_epochs & (1 << epoch)) == 0) {
            ret = QUICLY_TRANSPORT_ERROR_PROTOCOL_VIOLATION;
            break;
        }
        ++*(uint64_t *)((uint8_t *)conn + frame_handler->counter_offset);
        num_frames_ack_eliciting += frame_handler->ack_eliciting;
        if ((ret = frame_handler->cb(conn, &state)) != 0)
            break;
    } while (state.src != state.end);

    *is_ack_only = num_frames_ack_eliciting == 0;
    if (ret != 0)
        *offending_frame_type = state.frame_type;
    return ret;
}
