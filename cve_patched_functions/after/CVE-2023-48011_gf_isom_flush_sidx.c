GF_Err gf_isom_flush_sidx(GF_ISOFile *movie, u32 sidx_max_size, Bool force_v1)
{
	GF_BitStream *bs;
	GF_Err e;
	u32 size;
	//and only at setup
	if (!movie || !(movie->FragmentsFlags & GF_ISOM_FRAG_WRITE_READY) ) return GF_BAD_PARAM;
	if (movie->openMode != GF_ISOM_OPEN_WRITE) return GF_ISOM_INVALID_MODE;

	if (! movie->on_block_out) return GF_BAD_PARAM;
	if (! movie->root_sidx) return GF_BAD_PARAM;

	if (!movie->block_buffer_size) movie->block_buffer_size = movie->on_block_out_block_size;
	bs = gf_bs_new_cbk_buffer(isom_on_block_out, movie, movie->block_buffer, movie->block_buffer_size);
	gf_bs_prevent_dispatch(bs, GF_TRUE);
	
	assert(movie->root_sidx_index == movie->root_sidx->nb_refs);

	if (force_v1)
		movie->root_sidx->version = 1;
		
	e = gf_isom_box_size((GF_Box*)movie->root_sidx);
	size = (u32) movie->root_sidx->size;
	if (movie->root_ssix) {
		e = gf_isom_box_size((GF_Box*)movie->root_ssix);
		size += (u32) movie->root_ssix->size;
		movie->root_sidx->first_offset = (u32) movie->root_ssix->size;
	}

	if (sidx_max_size && (size > sidx_max_size) ) {
#ifndef GPAC_DISABLE_LOG
		u32 orig_seg_count = movie->root_sidx->nb_refs;
#endif
		//trash 8 bytes to be able to write a free box before
		sidx_max_size -= 8;
		GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[iso fragment] SIDX size %d is larger than allocated SIDX block %d, merging final segments\n", movie->root_sidx->size, sidx_max_size));
		while (movie->root_sidx->nb_refs>2) {
			movie->root_sidx->refs[movie->root_sidx->nb_refs-2].subsegment_duration += movie->root_sidx->refs[movie->root_sidx->nb_refs-1].subsegment_duration;
			movie->root_sidx->refs[movie->root_sidx->nb_refs-2].reference_size += movie->root_sidx->refs[movie->root_sidx->nb_refs-1].reference_size;
			movie->root_sidx->nb_refs--;
			if (movie->root_ssix) {
				movie->root_ssix->subsegments[movie->root_ssix->subsegment_count-2].ranges[1].range_size += movie->root_ssix->subsegments[movie->root_ssix->subsegment_count-1].ranges[0].range_size;
				movie->root_ssix->subsegments[movie->root_ssix->subsegment_count-2].ranges[1].range_size += movie->root_ssix->subsegments[movie->root_ssix->subsegment_count-1].ranges[1].range_size;
				movie->root_ssix->subsegment_count--;
			}

			e = gf_isom_box_size((GF_Box*)movie->root_sidx);
			size = (u32) movie->root_sidx->size;
			if (movie->root_ssix) {
				e = gf_isom_box_size((GF_Box*)movie->root_ssix);
				size += (u32) movie->root_ssix->size;
				movie->root_sidx->first_offset = (u32) movie->root_ssix->size;
			}

			if (size < sidx_max_size) break;
		}
		if (size > sidx_max_size) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("[iso fragment] SIDX size %d is larger than allocated SIDX block and no more segments to merge\n", size, sidx_max_size));
			return GF_IO_ERR;
		} else {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, ("[iso fragment] Merged %d segments in SIDX to fit allocated block, remaining segments %d\n", orig_seg_count - movie->root_sidx->nb_refs, movie->root_sidx->nb_refs));
		}
	}
	if (!e) {
		if (movie->root_ssix) {
			gf_isom_box_size((GF_Box *) movie->root_ssix);

			if (movie->compress_mode>=GF_ISOM_COMP_MOOF_SSIX) {
				u32 ssix_comp_size;
				//compute ssix compressed size by using NULL destination bitstream
				//not really optimum since we compress twice the ssix, to optimize ...
				e = gf_isom_write_compressed_box(movie, (GF_Box *) movie->root_ssix, GF_4CC('!', 's', 's', 'x'), NULL, &ssix_comp_size);
				movie->root_sidx->first_offset = ssix_comp_size;
			} else {
				movie->root_sidx->first_offset = (u32) movie->root_ssix->size;
			}
		}
		if (!e) {
			if (movie->compress_mode>=GF_ISOM_COMP_MOOF_SIDX) {
				e = gf_isom_write_compressed_box(movie, (GF_Box *) movie->root_sidx, GF_4CC('!', 's', 'i', 'x'), bs, NULL);
			} else {
				e = gf_isom_box_write((GF_Box *) movie->root_sidx, bs);
			}
		}

		if (!e && movie->root_ssix) {
			if (movie->compress_mode>=GF_ISOM_COMP_MOOF_SSIX) {
				e = gf_isom_write_compressed_box(movie, (GF_Box *) movie->root_ssix, GF_4CC('!', 's', 's', 'x'), bs, NULL);
			} else {
				e = gf_isom_box_write((GF_Box *) movie->root_ssix, bs);
			}
		}
	}

	gf_isom_box_del((GF_Box*) movie->root_sidx);
	movie->root_sidx = NULL;
	if (movie->root_ssix) {
		gf_isom_box_del((GF_Box*) movie->root_ssix);
		movie->root_ssix = NULL;
	}

	gf_bs_get_content_no_truncate(bs, &movie->block_buffer, &size, &movie->block_buffer_size);
	gf_bs_del(bs);
	return e;
}
