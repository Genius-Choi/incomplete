flatpak_dir_remote_load_cached_summary (FlatpakDir   *self,
                                        const char   *basename,
                                        const char   *checksum,
                                        const char   *main_ext,
                                        const char   *sig_ext,
                                        GBytes      **out_main,
                                        GBytes      **out_sig,
                                        GCancellable *cancellable,
                                        GError      **error)
{
  g_autofree char *main_file_name = g_strconcat (basename, main_ext, NULL);
  g_autofree char *sig_file_name = g_strconcat (basename, sig_ext, NULL);
  g_autoptr(GFile) main_cache_file = flatpak_build_file (self->cache_dir, "summaries", main_file_name, NULL);
  g_autoptr(GFile) sig_cache_file = flatpak_build_file (self->cache_dir, "summaries", sig_file_name, NULL);
  g_autoptr(GMappedFile) mfile = NULL;
  g_autoptr(GMappedFile) sig_mfile = NULL;
  g_autoptr(GBytes) mfile_bytes = NULL;
  g_autofree char *sha256 = NULL;

  mfile = g_mapped_file_new (flatpak_file_get_path_cached (main_cache_file), FALSE, NULL);
  if (mfile == NULL)
    {
      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_NOT_CACHED,
                   _("No cached summary for remote '%s'"), basename);
      return FALSE;
    }

  if (out_sig)
    sig_mfile = g_mapped_file_new (flatpak_file_get_path_cached (sig_cache_file), FALSE, NULL);

  mfile_bytes = g_mapped_file_get_bytes (mfile);

  /* The checksum would've already been verified before the file was written,
   * but check again in case something went wrong during disk I/O. This is
   * especially important since the variant-schema-compiler code assumes the
   * GVariant data is well formed and asserts otherwise.
   */
  if (checksum != NULL)
    {
      sha256 = g_compute_checksum_for_bytes (G_CHECKSUM_SHA256, mfile_bytes);
      if (strcmp (sha256, checksum) != 0)
        {
          g_autoptr(GError) local_error = NULL;

          if (!g_file_delete (main_cache_file, NULL, &local_error) &&
              !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
            {
              g_autofree char *path = g_file_get_path (main_cache_file);
              g_info ("Unable to delete file %s: %s", path, local_error->message);
              g_clear_error (&local_error);
            }

          if (sig_ext)
            {
              if (!g_file_delete (sig_cache_file, NULL, &local_error) &&
                  !g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND))
                {
                  g_autofree char *path = g_file_get_path (sig_cache_file);
                  g_info ("Unable to delete file %s: %s", path, local_error->message);
                  g_clear_error (&local_error);
                }
            }

          return flatpak_fail_error (error, FLATPAK_ERROR_INVALID_DATA,
                                     _("Invalid checksum for indexed summary %s read from %s"),
                                     checksum, flatpak_file_get_path_cached (main_cache_file));
        }
    }

  *out_main = g_steal_pointer (&mfile_bytes);
  if (sig_mfile)
    *out_sig = g_mapped_file_get_bytes (sig_mfile);

  return TRUE;
}
