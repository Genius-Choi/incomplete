xrdp_mm_egfx_caps_advertise(void *user, int caps_count,
                            int *versions, int *flagss)
{
    struct xrdp_mm *self;
    struct xrdp_bitmap *screen;
    int index;
    int best_index;
    int best_h264_index;
    int best_pro_index;
    int error;
    int version;
    int flags;
    struct ver_flags_t *ver_flags;

    LOG(LOG_LEVEL_INFO, "xrdp_mm_egfx_caps_advertise:");
    self = (struct xrdp_mm *) user;
    screen = self->wm->screen;
    if (screen->data == NULL)
    {
        LOG(LOG_LEVEL_INFO, "xrdp_mm_egfx_caps_advertise: can not do gfx");
    }
    /* create copy for sorting */
    ver_flags = g_new(struct ver_flags_t, caps_count);
    if (ver_flags == NULL)
    {
        return 1;
    }
    for (index = 0; index < caps_count; index++)
    {
        ver_flags[index].version = versions[index];
        ver_flags[index].flags = flagss[index];
    }
    /* sort by version */
    g_qsort(ver_flags, caps_count, sizeof(struct ver_flags_t), cmpverfunc);
    best_index = -1;
    best_h264_index = -1;
    best_pro_index = -1;
    for (index = 0; index < caps_count; index++)
    {
        version = ver_flags[index].version;
        flags = ver_flags[index].flags;
        LOG(LOG_LEVEL_INFO, "  version 0x%8.8x flags 0x%8.8x (index: %d)",
            version, flags, index);
        switch (version)
        {
            case XR_RDPGFX_CAPVERSION_8: /* FALLTHROUGH */
            case XR_RDPGFX_CAPVERSION_101:
                best_pro_index = index;
                break;
            case XR_RDPGFX_CAPVERSION_81:
                if (flags & XR_RDPGFX_CAPS_FLAG_AVC420_ENABLED)
                {
                    best_h264_index = index;
                }
                best_pro_index = index;
                break;
            case XR_RDPGFX_CAPVERSION_10:
                if (!(flags & XR_RDPGFX_CAPS_FLAG_AVC_DISABLED))
                {
                    best_h264_index = index;
                }
                best_pro_index = index;
                break;
            case XR_RDPGFX_CAPVERSION_102: /* FALLTHROUGH */
            case XR_RDPGFX_CAPVERSION_103: /* FALLTHROUGH */
            case XR_RDPGFX_CAPVERSION_104: /* FALLTHROUGH */
            case XR_RDPGFX_CAPVERSION_105: /* FALLTHROUGH */
            case XR_RDPGFX_CAPVERSION_106: /* FALLTHROUGH */
            case XR_RDPGFX_CAPVERSION_107:
                if (!(flags & XR_RDPGFX_CAPS_FLAG_AVC_DISABLED))
                {
                    best_h264_index = index;
                }
                best_pro_index = index;
                break;
            default:
                /* just skip unknwown */
                LOG(LOG_LEVEL_INFO, "unknown version 0x%8.8x", version);
                break;
        }
    }
    if (best_pro_index >= 0)
    {
        best_index = best_pro_index;
        self->egfx_flags = XRDP_EGFX_RFX_PRO;
    }
    /* prefer h264, todo use setting in xrdp.ini for this */
    if (best_h264_index >= 0)
    {
#if defined(XRDP_X264) || defined(XRDP_NVENC)
        best_index = best_h264_index;
        self->egfx_flags = XRDP_EGFX_H264;
#endif
    }
    if (best_index >= 0)
    {
        LOG(LOG_LEVEL_INFO, "  replying version 0x%8.8x flags 0x%8.8x",
            ver_flags[best_index].version, ver_flags[best_index].flags);
        error = xrdp_egfx_send_capsconfirm(self->egfx,
                                           ver_flags[best_index].version,
                                           ver_flags[best_index].flags);
        LOG(LOG_LEVEL_INFO, "xrdp_mm_egfx_caps_advertise: xrdp_egfx_send_capsconfirm "
            "error %d best_index %d", error, best_index);
        error = xrdp_egfx_send_reset_graphics(self->egfx,
                                              screen->width, screen->height,
                                              self->wm->client_info->display_sizes.monitorCount,
                                              self->wm->client_info->display_sizes.minfo);
        LOG(LOG_LEVEL_INFO, "xrdp_mm_egfx_caps_advertise: xrdp_egfx_send_reset_graphics "
            "error %d monitorCount %d",
            error, self->wm->client_info->display_sizes.monitorCount);
        self->egfx_up = 1;
        xrdp_mm_egfx_create_surfaces(self);
        self->encoder = xrdp_encoder_create(self);
        xrdp_mm_egfx_invalidate_wm_screen(self);

        if (self->resize_data != NULL
                && self->resize_data->state == WMRZ_EGFX_INITALIZING)
        {
            advance_resize_state_machine(self, WMRZ_EGFX_INITIALIZED);
        }
        LOG(LOG_LEVEL_INFO, "xrdp_mm_egfx_caps_advertise: egfx created.");
        if (self->gfx_delay_autologin)
        {
            self->gfx_delay_autologin = 0;
            xrdp_wm_set_login_state(self->wm, WMLS_START_CONNECT);
        }
    }
    else
    {
        struct xrdp_rect lrect;

        LOG(LOG_LEVEL_INFO, "xrdp_mm_egfx_caps_advertise: no good gfx, canceling");
        lrect.left = 0;
        lrect.top = 0;
        lrect.right = screen->width;
        lrect.bottom = screen->height;
        self->wm->client_info->gfx = 0;
        xrdp_encoder_delete(self->encoder);
        self->encoder = xrdp_encoder_create(self);
        xrdp_bitmap_invalidate(screen, &lrect);
    }
    g_free(ver_flags);
    return 0;
}
