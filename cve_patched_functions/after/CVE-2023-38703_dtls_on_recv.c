static pj_status_t dtls_on_recv(pjmedia_transport *tp, unsigned idx,     
                                const void *pkt, pj_size_t size)
{
    dtls_srtp *ds = (dtls_srtp*)tp;

    DTLS_LOCK(ds);

    /* Destroy the retransmission clock if handshake has been completed. */
    if (ds->clock[idx] && ds->nego_completed[idx]) {
        pjmedia_clock_destroy(ds->clock[idx]);
        ds->clock[idx] = NULL;
    }

    if (size < 1 || !IS_DTLS_PKT(pkt, size) || ds->is_destroying) {
        DTLS_UNLOCK(ds);
        return PJ_EIGNORED;
    }

#if DTLS_DEBUG
    PJ_LOG(2,(ds->base.name, "DTLS-SRTP %s receiving %lu bytes",
                             CHANNEL_TO_STRING(idx), size));
#endif

    /* This is DTLS packet, let's process it. Note that if DTLS nego has
     * been completed, this may be a retransmission (e.g: remote didn't
     * receive our last handshake packet) or just a stray.
     */

    /* Check remote address info, reattach member tp if changed */
    if (idx == RTP_CHANNEL && !ds->use_ice && !ds->nego_completed[idx]) {
        pjmedia_transport_info info;
        pjmedia_transport_get_info(ds->srtp->member_tp, &info);
        if (pj_sockaddr_cmp(&ds->rem_addr, &info.src_rtp_name)) {
            pjmedia_transport_attach_param ap;
            pj_status_t status;

            pj_bzero(&ap, sizeof(ap));
            ap.user_data = ds->srtp;
            pj_sockaddr_cp(&ds->rem_addr, &info.src_rtp_name);
            pj_sockaddr_cp(&ap.rem_addr, &ds->rem_addr);
            ap.addr_len = pj_sockaddr_get_len(&ap.rem_addr);
            if (pj_sockaddr_cmp(&info.sock_info.rtp_addr_name,
                                &info.sock_info.rtcp_addr_name) == 0)
            {
                /* Using RTP & RTCP multiplexing */
                pj_sockaddr_cp(&ds->rem_rtcp, &ds->rem_addr);
                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_rtcp);
            } else if (pj_sockaddr_has_addr(&ds->rem_rtcp)) {
                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_rtcp);
            } else {
                pj_sockaddr_cp(&ap.rem_rtcp, &ds->rem_addr);
                pj_sockaddr_set_port(&ap.rem_rtcp,
                                     pj_sockaddr_get_port(&ds->rem_addr)+1);
            }

            status = pjmedia_transport_attach2(&ds->srtp->base, &ap);
            if (status != PJ_SUCCESS) {
                DTLS_UNLOCK(ds);
                return status;
            }

#if DTLS_DEBUG
            {
                char addr[PJ_INET6_ADDRSTRLEN];
                PJ_LOG(2,(ds->base.name, "Re-attached transport to update "
                          "remote addr=%s:%d",
                          pj_sockaddr_print(&ap.rem_addr, addr,
                                            sizeof(addr), 2),
                          pj_sockaddr_get_port(&ap.rem_addr)));
            }
#endif
        }
    }

    /* If our setup is ACTPASS, incoming packet may be a client hello,
     * so let's update setup to PASSIVE and initiate DTLS handshake.
     */
    if (!ds->nego_started[idx] &&
        (ds->setup == DTLS_SETUP_ACTPASS || ds->setup == DTLS_SETUP_PASSIVE))
    {
        pj_status_t status;
        ds->setup = DTLS_SETUP_PASSIVE;
        status = ssl_handshake_channel(ds, idx);
        if (status != PJ_SUCCESS) {
            DTLS_UNLOCK(ds);
            return status;
        }
    }

    /* Send it to OpenSSL */
    ssl_on_recv_packet(ds, idx, pkt, size);

    DTLS_UNLOCK(ds);

    return PJ_SUCCESS;
}
