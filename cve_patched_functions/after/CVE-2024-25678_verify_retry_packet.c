verify_retry_packet (struct ietf_full_conn *conn,
                                    const struct lsquic_packet_in *packet_in)
{
    unsigned char *pseudo_packet;
    size_t out_len, ad_len;
    unsigned ret_ver;
    int verified;

    if (1 + CUR_DCID(conn)->len + packet_in->pi_data_sz > 0x1000)
    {
        /* Cover the theoretical possibility that we cannot fit the pseudo-
         * packet and 16-byte decrypted output into 4 KB:
         */
        LSQ_INFO("%s: Retry packet is too long: %hu bytes", __func__,
                                                        packet_in->pi_data_sz);
        return -1;
    }

    pseudo_packet = lsquic_mm_get_4k(conn->ifc_pub.mm);
    if (!pseudo_packet)
    {
        LSQ_INFO("%s: cannot allocate memory", __func__);
        return -1;
    }

    pseudo_packet[0] = CUR_DCID(conn)->len;
    memcpy(pseudo_packet + 1, CUR_DCID(conn)->idbuf, CUR_DCID(conn)->len);
    memcpy(pseudo_packet + 1 + CUR_DCID(conn)->len, packet_in->pi_data,
                                                    packet_in->pi_data_sz);

    ret_ver = lsquic_version_2_retryver(conn->ifc_conn.cn_version);
    out_len = 0;
    ad_len = 1 + CUR_DCID(conn)->len + packet_in->pi_data_sz - 16;
    verified = 1 == EVP_AEAD_CTX_open(
                    &conn->ifc_enpub->enp_retry_aead_ctx[ret_ver],
                    pseudo_packet + ad_len, &out_len, out_len,
                    lsquic_retry_nonce_buf[ret_ver], IETF_RETRY_NONCE_SZ,
                    pseudo_packet + ad_len, 16, pseudo_packet, ad_len)
            && out_len == 0;

    lsquic_mm_put_4k(conn->ifc_pub.mm, pseudo_packet);
    return verified ? 0 : -1;
}
