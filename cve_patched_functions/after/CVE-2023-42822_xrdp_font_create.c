xrdp_font_create(struct xrdp_wm *wm, unsigned int dpi)
{
    struct xrdp_font *self;
    struct stream *s;
    int fd;
    int b;
    int i;
    unsigned int char_count;
    unsigned int datasize; // Size of glyph data on disk
    int file_size;
    struct xrdp_font_char *f;
    const char *file_path;
    char file_path_buff[256];
    int min_descender;
    char font_name[256];
    const struct xrdp_cfg_globals *globals = &wm->xrdp_config->cfg_globals;
    LOG_DEVEL(LOG_LEVEL_TRACE, "in xrdp_font_create");

    if (dpi == 0)
    {
        LOG(LOG_LEVEL_WARNING, "No DPI value is available to find login font");
        dpi = globals->default_dpi;
        LOG(LOG_LEVEL_WARNING, "Using the default_dpi of %u", dpi);
    }
    get_font_name_from_dpi(globals, dpi, font_name, sizeof(font_name));

    if (font_name[0] == '/')
    {
        /* User specified absolute path */
        file_path = font_name;
    }
    else
    {
        g_snprintf(file_path_buff, sizeof(file_path_buff),
                   XRDP_SHARE_PATH "/%s",
                   font_name);
        file_path = file_path_buff;
    }

    if (!g_file_exist(file_path))
    {
        /* Try to fall back to the default */
        const char *default_file_path = XRDP_SHARE_PATH "/" DEFAULT_FONT_NAME;
        if (g_file_exist(default_file_path))
        {
            LOG(LOG_LEVEL_WARNING,
                "xrdp_font_create: font file [%s] does not exist - using [%s]",
                file_path, default_file_path);
            file_path = default_file_path;
        }
        else
        {
            LOG(LOG_LEVEL_ERROR,
                "xrdp_font_create: Can't load either [%s] or [%s]",
                file_path, default_file_path);
            return 0;
        }
    }

    file_size = g_file_get_size(file_path);

    if (file_size < 1)
    {
        LOG(LOG_LEVEL_ERROR, "xrdp_font_create: error reading font from file [%s]",
            file_path);
        return 0;
    }

    self = (struct xrdp_font *)g_malloc(sizeof(struct xrdp_font), 1);
    if (self == NULL)
    {
        LOG(LOG_LEVEL_ERROR, "xrdp_font_create: "
            "Can't allocate memory for font");
        return self;
    }
    self->wm = wm;
    make_stream(s);
    init_stream(s, file_size + 1024);
    fd = g_file_open_ro(file_path);

    if (fd < 0)
    {
        LOG(LOG_LEVEL_ERROR,
            "xrdp_font_create: Can't open %s - %s", file_path,
            g_get_strerror());
        g_free(self);
        self = NULL;
    }
    else
    {
        b = g_file_read(fd, s->data, file_size + 1024);
        g_file_close(fd);

        // Got at least a header?
        if (b < (4 + 32 + 2 + 2 + 2 + 2 + 4))
        {
            LOG(LOG_LEVEL_ERROR,
                "xrdp_font_create: Font %s is truncated", file_path);
            g_free(self);
            self = NULL;
        }
        else
        {
            s->end = s->data + b;
            in_uint8s(s, 4);
            in_uint8a(s, self->name, 32);
            in_uint16_le(s, self->size);
            in_uint16_le(s, self->style);
            in_uint16_le(s, self->body_height);
            in_sint16_le(s, min_descender);
            in_uint8s(s, 4);
            char_count = FIRST_CHAR;

            while (!s_check_end(s))
            {
                if (!s_check_rem(s, 16))
                {
                    LOG(LOG_LEVEL_WARNING,
                        "xrdp_font_create: "
                        "Can't parse header for character U+%X", char_count);
                    break;
                }

                if (char_count >= MAX_FONT_CHARS)
                {
                    LOG(LOG_LEVEL_WARNING,
                        "xrdp_font_create: "
                        "Ignoring characters >= U+%x", MAX_FONT_CHARS);
                    break;
                }

                f = self->chars + char_count;
                in_sint16_le(s, i);
                f->width = i;
                in_sint16_le(s, i);
                f->height = i;
                in_sint16_le(s, i);
                /* Move the glyph up so there are no descenders */
                f->baseline = i + min_descender;
                in_sint16_le(s, i);
                f->offset = i;
                in_sint16_le(s, i);
                f->incby = i;
                in_uint8s(s, 6);
                datasize = FONT_DATASIZE(f);

                if (datasize < 0 || datasize > 512)
                {
                    /* shouldn't happen */
                    LOG(LOG_LEVEL_ERROR,
                        "xrdp_font_create: "
                        "datasize for U+%x wrong "
                        "width %d, height %d, datasize %d",
                        char_count, f->width, f->height, datasize);
                    break;
                }

                if (!s_check_rem(s, datasize))
                {
                    LOG(LOG_LEVEL_ERROR,
                        "xrdp_font_create: "
                        "Not enough data for character U+%X", char_count);
                    break;
                }

                if (datasize == 0)
                {
                    /* Allocate a single blank pixel for the glyph, so
                     * that it can be added to the glyph cache if required */
                    f->width = 1;
                    f->height = 1;

                    /* GOTCHA - we need to allocate more than one byte in
                     * memory for this glyph */
                    f->data = (char *)g_malloc(FONT_DATASIZE(f), 1);
                }
                else
                {
                    f->data = (char *)g_malloc(datasize, 0);
                }

                if (f->data == NULL)
                {
                    LOG(LOG_LEVEL_ERROR,
                        "xrdp_font_create: "
                        "Allocation error for character U+%X", char_count);
                    break;
                }
                in_uint8a(s, f->data, datasize);

                ++char_count;
            }

            self->char_count = char_count;
            if (char_count <= FIRST_CHAR)
            {
                /* We read no characters from the font */
                xrdp_font_delete(self);
                self = NULL;
            }
            else
            {
                if (self->body_height == 0)
                {
                    /* Older font made for xrdp v0.9.x. Synthesise this
                     * value from the first glyph */
                    self->body_height = -self->chars[FIRST_CHAR].baseline + 1;
                }

                // Find a default glyph
                if (char_count > UNICODE_WHITE_SQUARE)
                {
                    self->default_char = &self->chars[UNICODE_WHITE_SQUARE];
                }
                else if (char_count > '?')
                {
                    self->default_char = &self->chars['?'];
                }
                else
                {
                    self->default_char = &self->chars[FIRST_CHAR];
                }
            }
        }
    }

    free_stream(s);
    /*
      self->font_items[0].offset = -4;
      self->font_items[0].baseline = -16;
      self->font_items[0].width = 24;
      self->font_items[0].height = 16;
      self->font_items[0].data = g_malloc(3 * 16, 0);
      g_memcpy(self->font_items[0].data, w_char, 3 * 16);
    */
    LOG_DEVEL(LOG_LEVEL_TRACE, "out xrdp_font_create");
    return self;
}
