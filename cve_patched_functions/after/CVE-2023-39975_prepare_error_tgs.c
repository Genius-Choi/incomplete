prepare_error_tgs(struct kdc_request_state *state, krb5_kdc_req *request,
                  krb5_ticket *ticket, krb5_error_code code,
                  krb5_principal canon_server, krb5_data **response,
                  const char *status, krb5_pa_data **e_data)
{
    krb5_context context = state->realm_data->realm_context;
    krb5_error errpkt;
    krb5_error_code retval = 0;
    krb5_data *scratch, *e_data_asn1 = NULL, *fast_edata = NULL;

    errpkt.magic = KV5M_ERROR;
    errpkt.ctime = 0;
    errpkt.cusec = 0;

    retval = krb5_us_timeofday(context, &errpkt.stime, &errpkt.susec);
    if (retval)
        return(retval);
    errpkt.error = errcode_to_protocol(code);
    errpkt.server = request->server;
    if (ticket && ticket->enc_part2)
        errpkt.client = ticket->enc_part2->client;
    else
        errpkt.client = NULL;
    errpkt.text.length = strlen(status);
    if (!(errpkt.text.data = strdup(status)))
        return ENOMEM;

    if (!(scratch = (krb5_data *)malloc(sizeof(*scratch)))) {
        free(errpkt.text.data);
        return ENOMEM;
    }

    if (e_data != NULL) {
        retval = encode_krb5_padata_sequence(e_data, &e_data_asn1);
        if (retval) {
            free(scratch);
            free(errpkt.text.data);
            return retval;
        }
        errpkt.e_data = *e_data_asn1;
    } else
        errpkt.e_data = empty_data();

    retval = kdc_fast_handle_error(context, state, request, e_data,
                                   &errpkt, &fast_edata);
    if (retval) {
        free(scratch);
        free(errpkt.text.data);
        krb5_free_data(context, e_data_asn1);
        return retval;
    }
    if (fast_edata)
        errpkt.e_data = *fast_edata;
    if (kdc_fast_hide_client(state) && errpkt.client != NULL)
        errpkt.client = (krb5_principal)krb5_anonymous_principal();
    retval = krb5_mk_error(context, &errpkt, scratch);
    free(errpkt.text.data);
    krb5_free_data(context, e_data_asn1);
    krb5_free_data(context, fast_edata);
    if (retval)
        free(scratch);
    else
        *response = scratch;

    return retval;
}
