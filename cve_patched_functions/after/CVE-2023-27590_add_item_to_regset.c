static void add_item_to_regset(RZ_BORROW RzReg *reg, RZ_BORROW RzRegItem *item) {
	rz_return_if_fail(reg && item);
	RzRegisterType t = item->arena;

	if (!reg->regset[t].regs) {
		reg->regset[t].regs = rz_list_newf((RzListFree)rz_reg_item_free);
	}
	if (!reg->regset[t].ht_regs) {
		reg->regset[t].ht_regs = ht_pp_new0();
	}

	// Dynamically update the list of supported bit sizes
	reg->bits |= item->size;
	rz_list_append(reg->regset[t].regs, item);
	ht_pp_insert(reg->regset[t].ht_regs, item->name, item);

	// Update the overall type of registers into a regset
	if (item->type == RZ_REG_TYPE_ANY) {
		reg->regset[t].maskregstype = UT32_MAX;
		return;
	}
	reg->regset[t].maskregstype |= ((int)1 << item->type);
}
