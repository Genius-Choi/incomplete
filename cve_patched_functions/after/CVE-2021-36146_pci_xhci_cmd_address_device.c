pci_xhci_cmd_address_device(struct pci_xhci_vdev *xdev,
			    uint32_t slot,
			    struct xhci_trb *trb)
{
	struct pci_xhci_dev_emu	*dev;
	struct xhci_input_dev_ctx *input_ctx;
	struct xhci_slot_ctx *islot_ctx;
	struct xhci_dev_ctx *dev_ctx;
	struct xhci_endp_ctx *ep0_ctx;
	struct usb_native_devinfo *di;
	uint32_t cmderr;
	uint8_t rh_port;

	input_ctx = XHCI_GADDR(xdev, trb->qwTrb0 & ~0xFUL);
	if (!input_ctx) {
		UPRINTF(LFTL, "Invalid gpa 0x%lx in address device!\r\n",
			trb->qwTrb0 & ~0xFUL);
		cmderr = XHCI_TRB_ERROR_TRB;
		goto done;
	}
	islot_ctx = &input_ctx->ctx_slot;
	ep0_ctx = &input_ctx->ctx_ep[1];

	cmderr = XHCI_TRB_ERROR_SUCCESS;

	UPRINTF(LINF, "address device, input ctl: D 0x%08x A 0x%08x,\r\n"
		 "          slot %08x %08x %08x %08x\r\n"
		 "          ep0  %08x %08x %016lx %08x\r\n",
		input_ctx->ctx_input.dwInCtx0, input_ctx->ctx_input.dwInCtx1,
		islot_ctx->dwSctx0, islot_ctx->dwSctx1,
		islot_ctx->dwSctx2, islot_ctx->dwSctx3,
		ep0_ctx->dwEpCtx0, ep0_ctx->dwEpCtx1, ep0_ctx->qwEpCtx2,
		ep0_ctx->dwEpCtx4);

	/* when setting address: drop-ctx=0, add-ctx=slot+ep0 */
	if ((input_ctx->ctx_input.dwInCtx0 != 0) ||
	    (input_ctx->ctx_input.dwInCtx1 & 0x03) != 0x03) {
		UPRINTF(LWRN, "address device, input ctl invalid\r\n");
		cmderr = XHCI_TRB_ERROR_TRB;
		goto done;
	}

	if (slot <= 0 || slot > XHCI_MAX_SLOTS ||
			xdev->slot_allocated[slot] == false) {
		UPRINTF(LWRN, "address device, invalid slot %d\r\n", slot);
		cmderr = XHCI_TRB_ERROR_SLOT_NOT_ON;
		goto done;
	}

	dev = xdev->slots[slot];
	if (!dev) {
		int index;

		rh_port = XHCI_SCTX_1_RH_PORT_GET(islot_ctx->dwSctx1);
		index = pci_xhci_get_native_port_index_by_vport(xdev, rh_port);
		if (index < 0) {
			cmderr = XHCI_TRB_ERROR_TRB;
			UPRINTF(LFTL, "invalid root hub port %d\r\n", rh_port);
			goto done;
		}

		di = &xdev->native_ports[index].info;
		UPRINTF(LINF, "create virtual device for %d-%s on virtual "
				"port %d\r\n", di->path.bus,
				usb_dev_path(&di->path), rh_port);

		dev = pci_xhci_dev_create(xdev, di);
		if (!dev) {
			UPRINTF(LFTL, "fail to create device for %d-%s\r\n",
					di->path.bus,
					usb_dev_path(&di->path));
			cmderr = XHCI_TRB_ERROR_XACT;
			goto done;
		}

		xdev->native_ports[index].state = VPORT_EMULATED;
		xdev->devices[rh_port] = dev;
		xdev->ndevices++;
		xdev->slots[slot] = dev;
		dev->hci.hci_address = slot;
	}

	/* assign address to slot */
	dev_ctx = pci_xhci_get_dev_ctx(xdev, slot);
	if (!dev_ctx) {
		cmderr = XHCI_TRB_ERROR_CONTEXT_STATE;
		goto done;
	}
	UPRINTF(LDBG, "address device, dev ctx\r\n"
		 "      slot %08x %08x %08x %08x\r\n",
		dev_ctx->ctx_slot.dwSctx0, dev_ctx->ctx_slot.dwSctx1,
		dev_ctx->ctx_slot.dwSctx2, dev_ctx->ctx_slot.dwSctx3);

	dev = XHCI_SLOTDEV_PTR(xdev, slot);

	dev->hci.hci_address = slot;
	dev->dev_ctx = dev_ctx;

	if (dev->dev_ue->ue_reset == NULL ||
	    dev->dev_ue->ue_reset(dev->dev_instance) < 0) {
		cmderr = XHCI_TRB_ERROR_ENDP_NOT_ON;
		goto done;
	}

	memcpy(&dev_ctx->ctx_slot, islot_ctx, sizeof(struct xhci_slot_ctx));

	dev_ctx->ctx_slot.dwSctx3 =
		XHCI_SCTX_3_SLOT_STATE_SET(XHCI_ST_SLCTX_ADDRESSED) |
		XHCI_SCTX_3_DEV_ADDR_SET(slot);

	memcpy(&dev_ctx->ctx_ep[1], ep0_ctx, sizeof(struct xhci_endp_ctx));
	ep0_ctx = &dev_ctx->ctx_ep[1];
	ep0_ctx->dwEpCtx0 = (ep0_ctx->dwEpCtx0 & ~0x7) |
		XHCI_EPCTX_0_EPSTATE_SET(XHCI_ST_EPCTX_RUNNING);

	if (pci_xhci_init_ep(dev, 1, slot)) {
		cmderr = XHCI_TRB_ERROR_INCOMPAT_DEV;
		goto done;
	}

	dev->dev_slotstate = XHCI_ST_ADDRESSED;

	UPRINTF(LINF, "address device, output ctx\r\n"
		 "      slot %08x %08x %08x %08x\r\n"
		 "      ep0  %08x %08x %016lx %08x\r\n",
		dev_ctx->ctx_slot.dwSctx0, dev_ctx->ctx_slot.dwSctx1,
		dev_ctx->ctx_slot.dwSctx2, dev_ctx->ctx_slot.dwSctx3,
		ep0_ctx->dwEpCtx0, ep0_ctx->dwEpCtx1, ep0_ctx->qwEpCtx2,
		ep0_ctx->dwEpCtx4);

done:
	return cmderr;
}
