conn_handler(uint8_t *packet, conn_param *cparam, size_t max)
{
	uint32_t len, tmp, pos = 0, len_of_var = 0;
	int      len_of_str = 0;
	int32_t  rv         = 0;

	if (packet[pos] != CMD_CONNECT) {
		return (-1);
	} else {
		pos++;
	}

	// remaining length
	len = (uint32_t) get_var_integer(packet + pos, &len_of_var);
	pos += len_of_var;
	log_trace("fix header length: %d", len_of_str);
	// protocol name
	cparam->pro_name.body =
	    (char *) copyn_utf8_str(packet, &pos, &len_of_str, max-pos);
	cparam->pro_name.len = len_of_str;
	rv                   = len_of_str < 0 ? PROTOCOL_ERROR : 0;
	log_trace("pro_name: %s", cparam->pro_name.body);
	// protocol ver
	cparam->pro_ver = packet[pos];
	pos++;
	// connect flag
	cparam->con_flag    = packet[pos];
	cparam->clean_start = (cparam->con_flag & 0x02) >> 1;
	cparam->will_flag   = (cparam->con_flag & 0x04) >> 2;
	cparam->will_qos    = (cparam->con_flag & 0x18) >> 3;
	cparam->will_retain = (cparam->con_flag & 0x20) >> 5;
	log_trace("conn flag:%x", cparam->con_flag);
	pos++;
	// keepalive
	NNI_GET16(packet + pos, tmp);
	cparam->keepalive_mqtt = tmp;
	pos += 2;
	// properties

	if (cparam->pro_ver == MQTT_PROTOCOL_VERSION_v5) {
		// check length
		log_trace("MQTT V5 Properties");
		len_of_var = 0;
		cparam->prop_len = (uint32_t) get_var_integer(packet + pos, &len_of_var);
		if (cparam->prop_len > (max - pos - 1 - cparam->will_flag*2 ))
			return PROTOCOL_ERROR;
		log_debug("remain len %d max len %d prop len %d pos %d", len, max, cparam->prop_len, pos);
		cparam->properties = decode_buf_properties(
		    packet, len, &pos, &cparam->prop_len, true);
		if (cparam->properties) {
			conn_param_set_property(cparam, cparam->properties);
			if ((rv = check_properties(cparam->properties)) !=
			    SUCCESS) {
				return rv;
			}
		}
	}
	log_trace("pos after property: [%d]", pos);

	// here starts payload: client_id
	cparam->clientid.body =
	    (char *) copyn_utf8_str(packet, &pos, &len_of_str, max-pos);
	cparam->clientid.len = len_of_str;

	if (len_of_str == 0) {
		char clientid_r[20] = {0};
		snprintf(clientid_r, 20, "nanomq-%08x", nni_random());
		clientid_r[19]        = '\0';
		cparam->clientid.body = nng_strdup(clientid_r);
		cparam->clientid.len  = strlen(clientid_r);
		cparam->assignedid    = true;
	} else if (len_of_str < 0) {
		return (PROTOCOL_ERROR);
	}
	log_trace("clientid: [%s] [%d]", cparam->clientid.body, len_of_str);
	log_trace("pos after clientid: [%d]", pos);

	if (cparam->pro_ver == MQTT_PROTOCOL_VERSION_v5 && cparam->assignedid) {
		property *assigned_cid =
		    property_set_value_str(ASSIGNED_CLIENT_IDENTIFIER,
		        cparam->clientid.body, cparam->clientid.len, false);
		if (cparam->properties == NULL) {
			cparam->properties = property_alloc();
		}
		property_append(cparam->properties, assigned_cid);
	}
	// will topic
	if (rv == 0 && cparam->will_flag != 0) {
		if (cparam->pro_ver == MQTT_PROTOCOL_VERSION_v5) {
			cparam->will_properties = decode_buf_properties(
			    packet, len, &pos, &cparam->will_prop_len, true);
			if (cparam->will_properties) {
				conn_param_set_will_property(
				    cparam, cparam->will_properties);
				if ((rv = check_properties(
				         cparam->will_properties)) !=
				    SUCCESS) {
					return PROTOCOL_ERROR;
				}
			}
			log_trace("pos after will property: [%d]", pos);
		}
		cparam->will_topic.body =
		    (char *) copyn_utf8_str(packet, &pos, &len_of_str, max-pos);
		cparam->will_topic.len = len_of_str;
		rv                     = len_of_str <= 0 ? 1 : 0;

		if (cparam->will_topic.body == NULL || rv != 0) {
			return PROTOCOL_ERROR;
		}
		log_trace("will_topic: %s %d", cparam->will_topic.body, rv);
		log_trace("pos after will topic body: [%d]", pos);
		// will msg
		if (rv == 0 && cparam->payload_format_indicator == 0) {
			cparam->will_msg.body = (char *) copyn_str(
			    packet, &pos, &len_of_str, max - pos);
		} else if (rv == 0 &&
		    cparam->payload_format_indicator == 0x01) {
			cparam->will_msg.body = (char *) copyn_utf8_str(
			    packet, &pos, &len_of_str, max - pos);
		}
		rv = len_of_str <= 0 ? PAYLOAD_FORMAT_INVALID : 0;
		if (cparam->will_msg.body == NULL || rv != 0) {
			return PROTOCOL_ERROR;
		}
		cparam->will_msg.len = len_of_str;
		log_trace("will_msg: %s %d", cparam->will_msg.body, rv);
		log_trace("pos after will msg: [%d]", pos);
	}

	// username
	if (rv == 0 && (cparam->con_flag & 0x80) > 0) {
		cparam->username.body =
		    (char *) copyn_utf8_str(packet, &pos, &len_of_str, max-pos);
		cparam->username.len = len_of_str;
		rv                   = len_of_str <= 0 ? PAYLOAD_FORMAT_INVALID : 0;
		if (rv != 0) {
			return rv;
		}
		log_trace(
		    "username: %s %d", cparam->username.body, len_of_str);
		log_trace("pos after username: [%d]", pos);
	}
	// password
	if (rv == 0 && (cparam->con_flag & 0x40) > 0) {
		cparam->password.body =
		    copyn_utf8_str(packet, &pos, &len_of_str, max-pos);
		cparam->password.len = len_of_str;
		rv                   = len_of_str <= 0 ? PAYLOAD_FORMAT_INVALID : 0;
		if (rv != 0) {
			log_warn("MQTT Packet parsing error!");
			return rv;
		}
		log_trace(
		    "password: %s [%d]", cparam->password.body, len_of_str);
		log_trace("pos after password: [%d]", pos);
	}
	log_trace("pos: [%d] len: [%d]", pos, len);
	if (len + len_of_var + 1 != pos) {
		log_error("inconnect handler");
		rv = PROTOCOL_ERROR;
	}
	return rv;
}
