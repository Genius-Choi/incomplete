RTPSParticipantImpl::RTPSParticipantImpl(const RTPSParticipantAttributes& PParam,
        const GuidPrefix_t& guidP,
        RTPSParticipant* par,
        RTPSParticipantListener* plisten):	m_att(PParam), m_guid(guidP ,c_EntityId_RTPSParticipant),
    mp_event_thr(nullptr),
    mp_builtinProtocols(nullptr),
    mp_ResourceSemaphore(new boost::interprocess::interprocess_semaphore(0)),
    IdCounter(0),
    mp_participantListener(plisten),
    mp_userParticipant(par),
    mp_mutex(new boost::recursive_mutex())

{
    // Builtin transport by default
    if (PParam.useBuiltinTransports)
    {
        UDPv4TransportDescriptor descriptor; 
        descriptor.sendBufferSize = m_att.sendSocketBufferSize;
        descriptor.receiveBufferSize = m_att.listenSocketBufferSize;
        m_network_Factory.RegisterTransport(&descriptor);
    }

    // User defined transports
    for (const auto& transportDescriptor : PParam.userTransports)
        m_network_Factory.RegisterTransport(transportDescriptor.get());

    boost::lock_guard<boost::recursive_mutex> guard(*mp_mutex);
    mp_userParticipant->mp_impl = this;
    Locator_t loc;
    loc.port = PParam.defaultSendPort;
    mp_event_thr = new ResourceEvent();
    mp_event_thr->init_thread(this);


    // Throughput controller, if the descriptor has valid values
    if (PParam.throughputController.bytesPerPeriod != UINT32_MAX &&
            PParam.throughputController.periodMillisecs != 0)
    {
        std::unique_ptr<FlowController> controller(new ThroughputController(PParam.throughputController, this));
        m_controllers.push_back(std::move(controller));
    }

    bool hasLocatorsDefined = true;
    //If no default locators are defined we define some.
    /* The reasoning here is the following.
       If the parameters of the RTPS Participant don't hold default listening locators for the creation
       of Endpoints, we make some for Unicast only.
       If there is at least one listen locator of any kind, we do not create any default ones.
       If there are no sending locators defined, we create default ones for the transports we implement.
       */
    if(m_att.defaultUnicastLocatorList.empty() && m_att.defaultMulticastLocatorList.empty())
    {
        //Default Unicast Locators in case they have not been provided
        /* INSERT DEFAULT UNICAST LOCATORS FOR THE PARTICIPANT */
        hasLocatorsDefined = false;
        Locator_t loc2;

        LocatorList_t loclist;
        IPFinder::getIP4Address(&loclist);
        for(auto it=loclist.begin();it!=loclist.end();++it){
            (*it).port=m_att.port.portBase+
                m_att.port.domainIDGain*PParam.builtin.domainId+
                m_att.port.offsetd3+
                m_att.port.participantIDGain*m_att.participantID;
            (*it).kind = LOCATOR_KIND_UDPv4;

            m_att.defaultUnicastLocatorList.push_back((*it));
        }
        // FIXME -- We have to  discuss the rules for deafult locator assignment for each transport
        loc2.port= m_att.port.portBase+
            m_att.port.domainIDGain*PParam.builtin.domainId+
            m_att.port.offsetd2+
            m_att.port.participantIDGain*m_att.participantID;
        loc2.set_IP4_address(239,255,1,4);
        m_att.defaultMulticastLocatorList.push_back(loc2);
        /* INSERT DEFAULT MULTICAST LOCATORS FOR THE PARTICIPANT */
    }
    else
    {
        // Normalize unicast locators.
        m_network_Factory.NormalizeLocators(m_att.defaultUnicastLocatorList);
    }

    /*	
        Since nothing guarantees the correct creation of the Resources on the Locators we have specified, and 
        in order to maintain synchrony between the defaultLocator list and the actuar ReceiveResources,
        We create the resources for these Locators now. Furthermore, in case these resources are taken, 
        we create them on another Locator and then update de defaultList.
        */
    createReceiverResources(m_att.defaultUnicastLocatorList, true);

    if(!hasLocatorsDefined){
        logInfo(RTPS_PARTICIPANT,m_att.getName()<<" Created with NO default Unicast Locator List, adding Locators: "<<m_att.defaultUnicastLocatorList);
    }
    //Multicast
    createReceiverResources(m_att.defaultMulticastLocatorList, true);

    //Check if defaultOutLocatorsExist, create some if they don't
    hasLocatorsDefined = true;
    if (m_att.defaultOutLocatorList.empty()){
        hasLocatorsDefined = false;
        Locator_t SendLocator;
        /*TODO - Fill with desired default Send Locators for our transports*/
        //Warning - Mock rule being used (and only for IPv4)!
        SendLocator.kind = LOCATOR_KIND_UDPv4;
        m_att.defaultOutLocatorList.push_back(SendLocator);
    }
    //Create the default sendResources - For the same reason as in the ReceiverResources
    std::vector<SenderResource > newSenders;
    std::vector<SenderResource > newSendersBuffer;
    LocatorList_t defcopy = m_att.defaultOutLocatorList;
    for (auto it = defcopy.begin(); it != defcopy.end(); ++it){
        /* Try to build resources with that specific Locator*/
        newSendersBuffer = m_network_Factory.BuildSenderResources((*it));
        uint32_t tries = 100;
        while(newSendersBuffer.empty() && tries != 0)
        {
            //No ReceiverResources have been added, therefore we have to change the Locator 
            (*it) = applyLocatorAdaptRule(*it); //Mutate the Locator to find a suitable rule. Overwrite the old one as it is useless now.
            newSendersBuffer = m_network_Factory.BuildSenderResources((*it));
            --tries;
        }
        //Now we DO have resources, and the new locator is already replacing the old one.
        for(auto mit= newSendersBuffer.begin(); mit!= newSendersBuffer.end(); ++mit){
            newSenders.push_back(std::move(*mit));	
        }

        //newSenders.insert(newSenders.end(), newSendersBuffer.begin(), newSendersBuffer.end());
        newSendersBuffer.clear();
    }

    m_send_resources_mutex.lock();
    for(auto mit=newSenders.begin(); mit!=newSenders.end();++mit){
        m_senderResource.push_back(std::move(*mit));
    }
    m_send_resources_mutex.unlock();
    m_att.defaultOutLocatorList = defcopy;

    if (!hasLocatorsDefined){
        logInfo(RTPS_PARTICIPANT, m_att.getName() << " Created with NO default Send Locator List, adding Locators: " << m_att.defaultOutLocatorList);
    }
    logInfo(RTPS_PARTICIPANT,"RTPSParticipant \"" <<  m_att.getName() << "\" with guidPrefix: " <<m_guid.guidPrefix);
    //START BUILTIN PROTOCOLS
    mp_builtinProtocols = new BuiltinProtocols();
    if(!mp_builtinProtocols->initBuiltinProtocols(this,m_att.builtin))
    {
        logWarning(RTPS_PARTICIPANT, "The builtin protocols were not corecctly initialized");
    }
    //eClock::my_sleep(300);
}
