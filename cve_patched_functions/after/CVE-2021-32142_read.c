int LibRaw_bigfile_buffered_datastream::read(void *data, size_t size, size_t nmemb)
{
    if (size < 1 || nmemb < 1)
        return 0;
    LR_BF_CHK();
    INT64 count = size * nmemb;
    INT64 partbytes = 0;
    if (!buffered)
    {
        INT64 r = readAt(data, count, _fpos);
        _fpos += r;
        return r / size;
    }

    unsigned char *fBuffer = (unsigned char*)iobuffers[0].data();
    while (count)
    {
        INT64 inbuffer = 0;
        // See if the request is totally inside buffer.
        if (iobuffers[0].contains(_fpos, inbuffer))
        {
            if (inbuffer >= count)
            {
                memcpy(data, fBuffer + (unsigned)(_fpos - iobuffers[0]._bstart), count);
                _fpos += count;
                return (count + partbytes) / size;
            }
            memcpy(data, fBuffer + (_fpos - iobuffers[0]._bstart), inbuffer);
            partbytes += inbuffer;
            count -= inbuffer;
            data = (void *)(((char *)data) + inbuffer);
            _fpos += inbuffer;
        }
        if (count > iobuffers[0].size())
        {
        fallback:
            if (_fpos + count > _fsize)
                count = MAX(0, _fsize - _fpos);
            if (count > 0)
            {
                INT64 r = readAt(data, count, _fpos);
                _fpos += r;
                return (r + partbytes) / size;
            }
            else
                return 0;
        }

        if (!fillBufferAt(0, _fpos))
            goto fallback;
    }
    return 0;
}
