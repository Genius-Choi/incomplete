bool RTPSParticipantImpl::createReader(RTPSReader** ReaderOut,
        ReaderAttributes& param,ReaderHistory* hist,ReaderListener* listen, const EntityId_t& entityId,bool isBuiltin, bool enable)
{
    std::string type = (param.endpoint.reliabilityKind == RELIABLE) ? "RELIABLE" :"BEST_EFFORT";
    logInfo(RTPS_PARTICIPANT," of type " << type);
    EntityId_t entId;
    if(entityId== c_EntityId_Unknown)
    {
        if(param.endpoint.topicKind == NO_KEY)
            entId.value[3] = 0x04;
        else if(param.endpoint.topicKind == WITH_KEY)
            entId.value[3] = 0x07;
        uint32_t idnum;
        if(param.endpoint.getEntityID()>0)
            idnum = param.endpoint.getEntityID();
        else
        {
            IdCounter++;
            idnum = IdCounter;
        }

        octet* c = (octet*)&idnum;
        entId.value[2] = c[0];
        entId.value[1] = c[1];
        entId.value[0] = c[2];
        if(this->existsEntityId(entId,WRITER))
        {
            logError(RTPS_PARTICIPANT,"A reader with the same entityId already exists in this RTPSParticipant");
            return false;
        }
    }
    else
    {
        entId = entityId;
    }
    if(!param.endpoint.unicastLocatorList.isValid())
    {
        logError(RTPS_PARTICIPANT,"Unicast Locator List for Reader contains invalid Locator");
        return false;
    }
    if(!param.endpoint.multicastLocatorList.isValid())
    {
        logError(RTPS_PARTICIPANT,"Multicast Locator List for Reader contains invalid Locator");
        return false;
    }
    if(!param.endpoint.outLocatorList.isValid())
    {
        logError(RTPS_PARTICIPANT,"Output Locator List for Reader contains invalid Locator");
        return false;
    }

    // Normalize unicast locators
    if (!param.endpoint.unicastLocatorList.empty())
        m_network_Factory.NormalizeLocators(param.endpoint.unicastLocatorList);

    RTPSReader* SReader = nullptr;
    GUID_t guid(m_guid.guidPrefix,entId);
    if(param.endpoint.reliabilityKind == BEST_EFFORT)
        SReader = (RTPSReader*)new StatelessReader(this,guid,param,hist,listen);
    else if(param.endpoint.reliabilityKind == RELIABLE)
        SReader = (RTPSReader*)new StatefulReader(this,guid,param,hist,listen);

    if(SReader==nullptr)
        return false;

    //SReader->setListener(inlisten);
    //SReader->setQos(param.qos,true);
    if (param.endpoint.reliabilityKind == RELIABLE)
        createSendResources((Endpoint *)SReader);

    if(isBuiltin)
    {
        SReader->setTrustedWriter(TrustedWriter(SReader->getGuid().entityId));
    }

    if(enable)
    {
        if (!createAndAssociateReceiverswithEndpoint((Endpoint *)SReader))
        {
            delete(SReader);
            return false;
        }
    }

    boost::lock_guard<boost::recursive_mutex> guard(*mp_mutex);
    m_allReaderList.push_back(SReader);
    if(!isBuiltin)
        m_userReaderList.push_back(SReader);
    *ReaderOut = SReader;
    return true;
}
