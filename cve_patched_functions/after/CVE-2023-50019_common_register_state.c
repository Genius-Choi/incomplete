static void common_register_state(ogs_fsm_t *s, amf_event_t *e,
        gmm_common_state_e state)
{
    int r, xact_count = 0;
    ogs_nas_5gmm_cause_t gmm_cause;

    amf_ue_t *amf_ue = NULL;
    amf_sess_t *sess = NULL;
    ran_ue_t *ran_ue = NULL;
    ogs_nas_5gs_message_t *nas_message = NULL;
    ogs_nas_security_header_type_t h;

    ogs_assert(e);

    if (e->sess) {
        sess = e->sess;
        amf_ue = sess->amf_ue;
        ogs_assert(amf_ue);
    } else {
        amf_ue = e->amf_ue;
        ogs_assert(amf_ue);
    }

    switch (e->h.id) {
    case AMF_EVENT_5GMM_MESSAGE:
        nas_message = e->nas.message;
        ogs_assert(nas_message);

        ran_ue = ran_ue_cycle(amf_ue->ran_ue);
        ogs_assert(ran_ue);

        h.type = e->nas.type;

        xact_count = amf_sess_xact_count(amf_ue);

        switch (nas_message->gmm.h.message_type) {
        case OGS_NAS_5GS_REGISTRATION_REQUEST:
            ogs_info("Registration request");
            gmm_cause = gmm_handle_registration_request(
                    amf_ue, h, e->ngap.code,
                    &nas_message->gmm.registration_request);

            switch (amf_ue->nas.registration.value) {
            case OGS_NAS_5GS_REGISTRATION_TYPE_INITIAL:
                amf_metrics_inst_global_inc(AMF_METR_GLOB_CTR_RM_REG_INIT_REQ);
                break;
            case OGS_NAS_5GS_REGISTRATION_TYPE_MOBILITY_UPDATING:
                amf_metrics_inst_global_inc(AMF_METR_GLOB_CTR_RM_REG_MOB_REQ);
                break;
            case OGS_NAS_5GS_REGISTRATION_TYPE_PERIODIC_UPDATING:
                amf_metrics_inst_global_inc(AMF_METR_GLOB_CTR_RM_REG_PERIOD_REQ);
                break;
            case OGS_NAS_5GS_REGISTRATION_TYPE_EMERGENCY:
                amf_metrics_inst_global_inc(AMF_METR_GLOB_CTR_RM_REG_EMERG_REQ);
                break;
            default:
                ogs_error("Unknown reg_type[%d]", amf_ue->nas.registration.value);
            }

            if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {
                ogs_error("gmm_handle_registration_request() failed [%d]",
                            gmm_cause);
                r = nas_5gs_send_registration_reject(amf_ue, gmm_cause);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
                OGS_FSM_TRAN(s, gmm_state_exception);
                break;
            }

            if (!AMF_UE_HAVE_SUCI(amf_ue)) {
                CLEAR_AMF_UE_TIMER(amf_ue->t3570);
                r = nas_5gs_send_identity_request(amf_ue);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
                break;
            }

            if (h.integrity_protected && SECURITY_CONTEXT_IS_VALID(amf_ue)) {

                gmm_cause = gmm_handle_registration_update(
                        amf_ue, &nas_message->gmm.registration_request);
                if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {
                    ogs_error("[%s] gmm_handle_registration_update() "
                                "failed [%d]", amf_ue->suci, gmm_cause);
                    r = nas_5gs_send_registration_reject(amf_ue, gmm_cause);
                    ogs_expect(r == OGS_OK);
                    ogs_assert(r != OGS_ERROR);
                    OGS_FSM_TRAN(s, gmm_state_exception);
                    break;
                }

                if (amf_sess_xact_count(amf_ue) == xact_count) {

                    if (amf_update_allowed_nssai(amf_ue) == false) {
                        ogs_error("No Allowed-NSSAI");
                        r = nas_5gs_send_gmm_reject(
                                amf_ue,
                                OGS_5GMM_CAUSE_NO_NETWORK_SLICES_AVAILABLE);
                        ogs_expect(r == OGS_OK);
                        ogs_assert(r != OGS_ERROR);
                        OGS_FSM_TRAN(s, gmm_state_exception);
                        break;
                    }

                    if (!PCF_AM_POLICY_ASSOCIATED(amf_ue)) {
                        r = amf_ue_sbi_discover_and_send(
                                OGS_SBI_SERVICE_TYPE_NPCF_AM_POLICY_CONTROL,
                                NULL,
                                amf_npcf_am_policy_control_build_create,
                                amf_ue, 0, NULL);
                        ogs_expect(r == OGS_OK);
                        ogs_assert(r != OGS_ERROR);
                        OGS_FSM_TRAN(s, &gmm_state_initial_context_setup);
                        break;
                    }

                    CLEAR_AMF_UE_TIMER(amf_ue->t3550);
                    r = nas_5gs_send_registration_accept(amf_ue);
                    ogs_expect(r == OGS_OK);
                    ogs_assert(r != OGS_ERROR);
                }

                if (amf_ue->next.m_tmsi)
                    OGS_FSM_TRAN(s, &gmm_state_initial_context_setup);
                else
                    OGS_FSM_TRAN(s, &gmm_state_registered);

            } else {

                amf_sbi_send_release_all_sessions(
                        amf_ue, AMF_RELEASE_SM_CONTEXT_NO_STATE);

                if (!AMF_SESSION_RELEASE_PENDING(amf_ue) &&
                    amf_sess_xact_count(amf_ue) == xact_count) {
                    r = amf_ue_sbi_discover_and_send(
                            OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,
                            amf_nausf_auth_build_authenticate,
                            amf_ue, 0, NULL);
                    ogs_expect(r == OGS_OK);
                    ogs_assert(r != OGS_ERROR);
                }

                OGS_FSM_TRAN(s, &gmm_state_authentication);
            }
            break;

        case OGS_NAS_5GS_SERVICE_REQUEST:
            ogs_info("Service request");

            if (state != GMM_COMMON_STATE_REGISTERED) {
                ogs_info("[%s] Handling service request failed [Not registered]",
                            amf_ue->suci);
                r = nas_5gs_send_service_reject(amf_ue,
                    OGS_5GMM_CAUSE_UE_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
                OGS_FSM_TRAN(s, gmm_state_exception);
                break;
            }

            gmm_cause = gmm_handle_service_request(
                    amf_ue, h, e->ngap.code, &nas_message->gmm.service_request);
            if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {
                ogs_error("[%s] gmm_handle_service_request() failed [%d]",
                            amf_ue->suci, gmm_cause);
                r = nas_5gs_send_service_reject(amf_ue, gmm_cause);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
                OGS_FSM_TRAN(s, gmm_state_exception);
                break;
            }

            if (!AMF_UE_HAVE_SUCI(amf_ue)) {
                ogs_info("Service request : Unknown UE");
                r = nas_5gs_send_service_reject(amf_ue,
                    OGS_5GMM_CAUSE_UE_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
                OGS_FSM_TRAN(s, gmm_state_exception);
                break;
            }

            if (!h.integrity_protected || !SECURITY_CONTEXT_IS_VALID(amf_ue)) {
                ogs_error("No Security Context");
                r = nas_5gs_send_service_reject(amf_ue,
                    OGS_5GMM_CAUSE_UE_IDENTITY_CANNOT_BE_DERIVED_BY_THE_NETWORK);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
                OGS_FSM_TRAN(s, gmm_state_exception);
                break;
            }

            gmm_cause = gmm_handle_service_update(
                    amf_ue, &nas_message->gmm.service_request);
            if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {
                ogs_error("[%s] gmm_handle_service_update() failed [%d]",
                            amf_ue->suci, gmm_cause);
                r = nas_5gs_send_service_reject(amf_ue, gmm_cause);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
                OGS_FSM_TRAN(s, gmm_state_exception);
                break;
            }

            OGS_FSM_TRAN(s, gmm_state_registered);
            break;

        case OGS_NAS_5GS_IDENTITY_RESPONSE:
            CLEAR_AMF_UE_TIMER(amf_ue->t3570);

            ogs_info("Identity response");
            gmm_cause = gmm_handle_identity_response(amf_ue,
                    &nas_message->gmm.identity_response);
            if (gmm_cause != OGS_5GMM_CAUSE_REQUEST_ACCEPTED) {
                ogs_error("gmm_handle_identity_response() "
                            "failed [%d] in type [%d]",
                            gmm_cause, amf_ue->nas.message_type);
                r = nas_5gs_send_gmm_reject(amf_ue, gmm_cause);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
                OGS_FSM_TRAN(s, gmm_state_exception);
                break;
            }

            if (!AMF_UE_HAVE_SUCI(amf_ue)) {
                ogs_error("No SUCI");
                r = nas_5gs_send_gmm_reject(amf_ue, gmm_cause);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
                OGS_FSM_TRAN(s, gmm_state_exception);
                break;
            }

            amf_sbi_send_release_all_sessions(
                    amf_ue, AMF_RELEASE_SM_CONTEXT_NO_STATE);

            if (!AMF_SESSION_RELEASE_PENDING(amf_ue) &&
                amf_sess_xact_count(amf_ue) == xact_count) {
                r = amf_ue_sbi_discover_and_send(
                        OGS_SBI_SERVICE_TYPE_NAUSF_AUTH, NULL,
                        amf_nausf_auth_build_authenticate,
                        amf_ue, 0, NULL);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
            }

            OGS_FSM_TRAN(s, &gmm_state_authentication);
            break;

        case OGS_NAS_5GS_5GMM_STATUS:
            ogs_warn("[%s] 5GMM STATUS : Cause[%d]", amf_ue->suci,
                    nas_message->gmm.gmm_status.gmm_cause);
            OGS_FSM_TRAN(s, &gmm_state_exception);
            break;

        case OGS_NAS_5GS_DEREGISTRATION_REQUEST_FROM_UE:
            ogs_info("[%s] Deregistration request", amf_ue->supi);

            gmm_handle_deregistration_request(
                    amf_ue, &nas_message->gmm.deregistration_request_from_ue);
            OGS_FSM_TRAN(s, &gmm_state_de_registered);
            break;

        case OGS_NAS_5GS_DEREGISTRATION_ACCEPT_TO_UE:
            ogs_info("[%s] Deregistration accept", amf_ue->supi);
            CLEAR_AMF_UE_TIMER(amf_ue->t3522);

            amf_ue->explict_de_registered.n1_done = true;

            if (amf_ue->explict_de_registered.sbi_done == true) {
                r = ngap_send_ran_ue_context_release_command(amf_ue->ran_ue,
                        NGAP_Cause_PR_misc, NGAP_CauseMisc_om_intervention,
                        NGAP_UE_CTX_REL_UE_CONTEXT_REMOVE, 0);
                ogs_expect(r == OGS_OK);
                ogs_assert(r != OGS_ERROR);
            }
            break;

        case OGS_NAS_5GS_CONFIGURATION_UPDATE_COMPLETE:
            ogs_debug("[%s] Configuration update complete", amf_ue->supi);

            amf_metrics_inst_global_inc(AMF_METR_GLOB_CTR_MM_CONF_UPDATE_SUCC);

            /*
             * TS24.501
             * 5.3.3 Temporary identities
             *
             * The AMF shall assign a new 5G-GUTI for a particular UE:
             *
             * a) during a successful initial registration procedure;
             * b) during a successful registration procedure
             *    for mobility registration update; and
             * c) after a successful service request procedure invoked
             *    as a response to a paging request from the network and
             *    before the release of the N1 NAS signalling connection
             *    as specified in subclause 5.4.4.1.
             *
             * The AMF should assign a new 5G-GUTI for a particular UE
             * during a successful registration procedure
             * for periodic registration update.
             *
             * The AMF may assign a new 5G-GUTI at any time for a particular UE
             * by performing the generic UE configuration update procedure.
             */
            if (amf_ue->next.m_tmsi) {
                amf_ue_confirm_guti(amf_ue);
            } else {
                ogs_info("[%s] No GUTI allocated", amf_ue->supi);
            }

            CLEAR_AMF_UE_TIMER(amf_ue->t3555);
            break;

        case OGS_NAS_5GS_UL_NAS_TRANSPORT:
            if (!h.integrity_protected || !SECURITY_CONTEXT_IS_VALID(amf_ue)) {
                ogs_error("No Security Context");
                OGS_FSM_TRAN(s, gmm_state_exception);
                break;
            }

            gmm_handle_ul_nas_transport(
                    amf_ue, &nas_message->gmm.ul_nas_transport);
            break;

        case OGS_NAS_5GS_REGISTRATION_COMPLETE:
            ogs_error("[%s] Registration complete in INVALID-STATE",
                        amf_ue->supi);
            break;

        default:
            ogs_error("Unknown message [%d]", nas_message->gmm.h.message_type);
        }
        break;

    default:
        ogs_fatal("Unknown event[%s]", amf_event_get_name(e));
        ogs_assert_if_reached();
    }
}
