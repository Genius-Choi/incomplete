static int ecies(void) {
	int code = RLC_ERR;
	ec_t r;
	bn_t da, d_b;
	ec_t qa, q_b;
	size_t l, in_len, out_len;
	uint8_t in[RLC_BC_LEN - 1], out[RLC_BC_LEN + RLC_MD_LEN];

	ec_null(r);
	bn_null(da);
	bn_null(d_b);
	ec_null(qa);
	ec_null(q_b);

	RLC_TRY {
		ec_new(r);
		bn_new(da);
		bn_new(d_b);
		ec_new(qa);
		ec_new(q_b);

		l = ec_param_level();
		if (l == 80 || l == 128 || l == 192 || l == 256) {
			TEST_CASE("ecies encryption/decryption is correct") {
				TEST_ASSERT(cp_ecies_gen(da, qa) == RLC_OK, end);
				in_len = RLC_BC_LEN - 1;
				out_len = RLC_BC_LEN + RLC_MD_LEN;
				rand_bytes(in, in_len);
				TEST_ASSERT(cp_ecies_enc(r, out, &out_len, in, in_len, qa)
						== RLC_OK, end);
				TEST_ASSERT(cp_ecies_dec(out, &out_len, r, out, out_len, da)
						== RLC_OK, end);
				TEST_ASSERT(memcmp(in, out, out_len) == 0, end);
			}
			TEST_END;
		}
#if MD_MAP == SH256
		uint8_t msg[RLC_BC_LEN + RLC_MD_LEN];
		char str[2 * RLC_FC_BYTES + 1];

		switch (ec_param_get()) {

#if defined(EP_PLAIN) && FP_PRIME == 256
			case NIST_P256:
				ASSIGNP(NIST_P256);
				memcpy(msg, result, sizeof(result));
				break;
#endif
			default:
				(void)str;
				code = RLC_OK;
				break;
		}

		if (code != RLC_OK) {

			TEST_ONCE("ecies satisfies test vectors") {
				uint8_t in[] = {
					0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF
				};
				TEST_ASSERT(ec_on_curve(qa) == 1, end);
				TEST_ASSERT(ec_on_curve(q_b) == 1, end);
				out_len = 16;
				TEST_ASSERT(cp_ecies_dec(out, &out_len, q_b, msg, sizeof(msg),
								da) == RLC_OK, end);
				TEST_ASSERT(out_len == sizeof(in), end);
				TEST_ASSERT(memcmp(out, in, sizeof(in)) == RLC_OK, end);
				out_len = 16;
				TEST_ASSERT(cp_ecies_dec(out, &out_len, qa, msg, sizeof(msg),
								d_b) == RLC_OK, end);
				TEST_ASSERT(out_len == sizeof(in), end);
				TEST_ASSERT(memcmp(out, in, sizeof(in)) == RLC_OK, end);
			}
			TEST_END;
		}
#endif
	}
	RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;

  end:
	ec_free(r);
	bn_free(da);
	bn_free(d_b);
	ec_free(qa);
	ec_free(q_b);
	return code;
}
