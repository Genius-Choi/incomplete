int ast_hook_send_action(struct manager_custom_hook *hook, const char *msg)
{
	const char *action;
	int ret = 0;
	struct manager_action *act_found;
	struct mansession s = {.session = NULL, };
	struct message m = { 0 };
	char *dup_str;
	char *src;
	int x = 0;
	int curlen;

	if (hook == NULL) {
		return -1;
	}

	/* Create our own copy of the AMI action msg string. */
	src = dup_str = ast_strdup(msg);
	if (!dup_str) {
		return -1;
	}

	/* convert msg string to message struct */
	curlen = strlen(src);
	for (x = 0; x < curlen; x++) {
		int cr;	/* set if we have \r */
		if (src[x] == '\r' && x+1 < curlen && src[x+1] == '\n')
			cr = 2;	/* Found. Update length to include \r\n */
		else if (src[x] == '\n')
			cr = 1;	/* also accept \n only */
		else
			continue;
		/* don't keep empty lines */
		if (x && m.hdrcount < ARRAY_LEN(m.headers)) {
			/* ... but trim \r\n and terminate the header string */
			src[x] = '\0';
			m.headers[m.hdrcount++] = src;
		}
		x += cr;
		curlen -= x;		/* remaining size */
		src += x;		/* update pointer */
		x = -1;			/* reset loop */
	}

	action = astman_get_header(&m, "Action");

	do {
		if (!strcasecmp(action, "login")) {
			break;
		}

		act_found = action_find(action);
		if (!act_found) {
			break;
		}

		/*
		 * we have to simulate a session for this action request
		 * to be able to pass it down for processing
		 * This is necessary to meet the previous design of manager.c
		 */
		s.hook = hook;

		ret = -1;
		ao2_lock(act_found);
		if (act_found->registered && act_found->func) {
			struct ast_module *mod_ref = ast_module_running_ref(act_found->module);

			ao2_unlock(act_found);
			/* If the action is in a module it must be running. */
			if (!act_found->module || mod_ref) {
				ret = act_found->func(&s, &m);
				ast_module_unref(mod_ref);
			}
		} else {
			ao2_unlock(act_found);
		}
		ao2_t_ref(act_found, -1, "done with found action object");
	} while (0);

	ast_free(dup_str);
	return ret;
}
