modify_unswitch_entries(modify_context *mc,backend *be)
{
	struct backentry *tmp_be;
	ldbm_instance *inst = (ldbm_instance *) be->be_instance_info;
	int ret = 0;

	if (mc->old_entry && mc->new_entry && 
	    cache_is_in_cache(&inst->inst_cache, mc->new_entry)) {
		/* switch the entries, and reset the new, new, entry */
		tmp_be = mc->new_entry;
		mc->new_entry = mc->old_entry;
		mc->new_entry->ep_state = 0;
		if (cache_has_otherref(&(inst->inst_cache), mc->new_entry)) {
			/* some other thread refers the entry */
			CACHE_RETURN(&(inst->inst_cache), &(mc->new_entry));
		} else {
			/* don't call CACHE_RETURN, that frees the entry!  */
			mc->new_entry->ep_refcnt = 0;
		}
		mc->old_entry = tmp_be;

		ret = cache_replace(&(inst->inst_cache), mc->old_entry, mc->new_entry);
		if (ret == 0) {
			/*
			 * The new entry was originally locked, so since we did the
			 * switch we need to unlock the "new" entry, and return the
			 * "old" one.  modify_term() will then return the "new" entry.
			 */
			cache_unlock_entry(&inst->inst_cache, mc->new_entry);
			cache_lock_entry(&inst->inst_cache, mc->old_entry);
		} else {
			LDAPDebug(LDAP_DEBUG_CACHE, "modify_unswitch_entries: replacing %s with %s failed (%d)\n",
			          slapi_entry_get_dn(mc->old_entry->ep_entry), 
			          slapi_entry_get_dn(mc->new_entry->ep_entry), ret);
		}
	}

	return ret;
}
