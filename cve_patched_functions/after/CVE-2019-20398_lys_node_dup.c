lys_node_dup(struct lys_module *module, struct lys_node *parent, const struct lys_node *node,
             struct unres_schema *unres, int shallow)
{
    struct lys_node *p = NULL;
    int finalize = 0;
    struct lys_node *result, *iter, *next;

    if (!shallow) {
        /* get know where in schema tree we are to know what should be done during instantiation of the grouping */
        for (p = parent;
             p && !(p->nodetype & (LYS_NOTIF | LYS_INPUT | LYS_OUTPUT | LYS_RPC | LYS_ACTION | LYS_GROUPING));
             p = lys_parent(p));
        finalize = p ? ((p->nodetype == LYS_GROUPING) ? 0 : 2) : 1;
    }

    result = lys_node_dup_recursion(module, parent, node, unres, shallow, finalize);
    if (finalize) {
        /* check xpath expressions in the instantiated tree */
        for (iter = next = result; iter; iter = next) {
            if (lys_has_xpath(iter) && unres_schema_add_node(module, unres, iter, UNRES_XPATH, NULL) == -1) {
                /* invalid xpath */
                return NULL;
            }

            /* select next item */
            if (iter->nodetype & (LYS_LEAF | LYS_LEAFLIST | LYS_ANYDATA | LYS_GROUPING)) {
                /* child exception for leafs, leaflists and anyxml without children, ignore groupings */
                next = NULL;
            } else {
                next = iter->child;
            }
            if (!next) {
                /* no children, try siblings */
                if (iter == result) {
                    /* we are done, no next element to process */
                    break;
                }
                next = iter->next;
            }
            while (!next) {
                /* parent is already processed, go to its sibling */
                iter = lys_parent(iter);
                if (lys_parent(iter) == lys_parent(result)) {
                    /* we are done, no next element to process */
                    break;
                }
                next = iter->next;
            }
        }
    }

    return result;
}
