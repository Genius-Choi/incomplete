int main(int argc, char* argv[])
{
    string *arg = new string[argc];
    for(int i = 0; i < argc; i++)
        arg[i] = argv[i];

    parse_flags(argc, argv);

    tty_stderr = isatty(fileno(stderr));



#ifdef WINDOWS
    setmode(fileno(stdin), _O_BINARY);
    setmode(fileno(stdout), _O_BINARY);
    pthread_win32_process_attach_np ();
#endif

// In-memory benchmark
// =================================================================================================
    if (benchmark_flag && (!input_pipe) && argc == 3)
    {
        benchmark(argv[2]);
    }

// Decompress and Recover
// =================================================================================================
    else if ((decompress_flag || recover_flag) && argc == 2 + (!input_pipe) + (1 - output_pipe))
    {
        if(recover_flag)
            threads = 1;

        aio_init(compress_chunk_size + QLZ_SIZE_OVERHEAD, cache_flag);
        if(!input_pipe)
        {
            try_aopen(arg[2].c_str(), 'r');
            aread(tmp, 8);
            compress_chunk_size = fread64();
            aclose_read();
            aio_init(compress_chunk_size + QLZ_SIZE_OVERHEAD, cache_flag);
            try_aopen(arg[2].c_str(), 'r');
            aread(tmp, 16);
        }
        else
        {
            try_aopen("<stdin>", 'r');
            aread(tmp, 8);
            compress_chunk_size = fread64();
            aio_init(compress_chunk_size + QLZ_SIZE_OVERHEAD, cache_flag);
        }

        if(strncmp(tmp, "qpress", 6) != 0)
            abort("Source file was not compressed with qpress");

        if(tmp[6] != '1')
            abort("Version %d.x.x is required to decompress this file", tmp[6] - 48);

        if(compress_chunk_size > 512*1024*1024)
            abort("Source file is corrupted - try the -R flag to recover");

        mem_init(compress_chunk_size);

        if(output_pipe)
            decompress_directory("", true);
        else
        {
            string s = remove_delimitor(arg[2 + (!input_pipe)]);
            decompress_directory(s, false);
        }

        aclose_read();
        if(recover_flag)
        {
            PRINT(RESULT, "%sWrote %s bytes in %s file(s) of which %s bytes are bad\n", BLANK_LINE, delimiter(payload_counter + recovery_bad_bytes).c_str(), delimiter(files).c_str(), delimiter(recovery_bad_bytes).c_str());
            PRINT(RESULT, "\nNote: There may be more errors than listed. Files may be missing or placed\nin wrong directories and files may contain fragments of other files.");
        }
        else
            PRINT(RESULT, "%sWrote %s bytes in %s file(s).", BLANK_LINE, delimiter(payload_counter).c_str(), delimiter(files).c_str());
    }

// Compress
// =================================================================================================
    else if(!decompress_flag && argc >= 2 + flags_exist + (1 - output_pipe))
    {
        string output_file;

        mem_init(compress_chunk_size);
        aio_init(compress_chunk_size + QLZ_SIZE_OVERHEAD, cache_flag);

        if(output_pipe)
            try_aopen("<stdout>", 'w');
        else
        {
			output_file = arg[argc - 1];
            if(exists(output_file) && !force_flag)
                abort("Destination file '%s' already exists", output_file.c_str());

            try_aopen(output_file.c_str(), 'w');
        }

        try_awrite("qpress10", 8);
		fwrite64(compress_chunk_size);

        if(!input_pipe)
        {
			absolute_path((char *)output_file.c_str(), tmp);
			destination_file = string(tmp);
#ifdef WINDOWS
			if(split(arg[1 + flags_exist]).pattern != "")
				compress_directory(split(arg[1 + flags_exist]).path, split(arg[1 + flags_exist]).pattern);
#else
			for(int i = 1 + flags_exist; i < argc - ((!output_pipe) == true ? 1 : 0); i++)
			{
				if (!is_dir(arg[i]))
					compress_file(arg[i], filenamepart(arg[i]));
			}

			if(recursive_flag)
			{
				for(int i = 1 + flags_exist; i < argc - ((!output_pipe)== true ? 1 : 0); i++)
				{
					if(is_dir(arg[i]))
					{
						arg[i] = remove_delimitor(arg[i]);
						if(filenamepart(arg[i]) == "." || filenamepart(arg[i]) == "..")
							compress_directory(arg[i], "*");
						else
						{
							godown(filenamepart(arg[i]).c_str());
							compress_directory(arg[i], "*");
							goup();
						}
					}
				}
			}
#endif
        }
        else
        {
            compress_file("<stdin>", arg[1 + flags_exist]);
        }

		if(files == 0)
			abort("0 files found. Are you missing a search pattern such as '*'?");
		else
		{
	        PRINT(RESULT, "%sCompressed %s bytes in %s file(s) into %s bytes", BLANK_LINE, delimiter(payload_counter).c_str(), delimiter(files).c_str(), delimiter(awritten()).c_str());
		    aclose_write();
		}
    }
    else
        print_usage();

    PRINT(RESULT, "\n");
}
