void ServerContextImpl::populateServerNamesMap(Ssl::TlsContext& ctx, int pkey_id) {
  if (ctx.cert_chain_ == nullptr) {
    return;
  }

  auto populate = [&](const std::string& sn) {
    std::string sn_pattern = sn;
    if (absl::StartsWith(sn, "*.")) {
      sn_pattern = sn.substr(1);
    }
    PkeyTypesMap pkey_types_map;
    // Multiple certs with different key type are allowed for one server name pattern.
    auto sn_match = server_names_map_.try_emplace(sn_pattern, pkey_types_map).first;
    auto pt_match = sn_match->second.find(pkey_id);
    if (pt_match != sn_match->second.end()) {
      // When there are duplicate names, prefer the earlier one.
      //
      // If all of the SANs in a certificate are unused due to duplicates, it could be useful
      // to issue a warning, but that would require additional tracking that hasn't been
      // implemented.
      return;
    }
    sn_match->second.emplace(std::pair<int, std::reference_wrapper<Ssl::TlsContext>>(pkey_id, ctx));
  };

  bssl::UniquePtr<GENERAL_NAMES> san_names(static_cast<GENERAL_NAMES*>(
      X509_get_ext_d2i(ctx.cert_chain_.get(), NID_subject_alt_name, nullptr, nullptr)));
  if (san_names != nullptr) {
    auto dns_sans = Utility::getSubjectAltNames(*ctx.cert_chain_, GEN_DNS);
    // https://www.rfc-editor.org/rfc/rfc6066#section-3
    // Currently, the only server names supported are DNS hostnames, so we
    // only save dns san entries to match SNI.
    for (const auto& san : dns_sans) {
      populate(san);
    }
  } else {
    // https://www.rfc-editor.org/rfc/rfc6125#section-6.4.4
    // As noted, a client MUST NOT seek a match for a reference identifier
    // of CN-ID if the presented identifiers include a DNS-ID, SRV-ID,
    // URI-ID, or any application-specific identifier types supported by the
    // client.
    X509_NAME* cert_subject = X509_get_subject_name(ctx.cert_chain_.get());
    const int cn_index = X509_NAME_get_index_by_NID(cert_subject, NID_commonName, -1);
    if (cn_index >= 0) {
      X509_NAME_ENTRY* cn_entry = X509_NAME_get_entry(cert_subject, cn_index);
      if (cn_entry) {
        ASN1_STRING* cn_asn1 = X509_NAME_ENTRY_get_data(cn_entry);
        if (ASN1_STRING_length(cn_asn1) > 0) {
          std::string subject_cn(reinterpret_cast<const char*>(ASN1_STRING_data(cn_asn1)),
                                 ASN1_STRING_length(cn_asn1));
          populate(subject_cn);
        }
      }
    }
  }
}
