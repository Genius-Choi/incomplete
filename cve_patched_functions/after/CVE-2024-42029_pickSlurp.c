void pickSlurp(sdbus::MethodCall& call) {
    const std::string PICK_COLOR_CMD = "grim -g \"$(slurp -p)\" -t ppm -";
    std::string       ppmColor       = execAndGet(PICK_COLOR_CMD.c_str());

    // unify whitespace
    ppmColor = std::regex_replace(ppmColor, std::regex("\\s+"), std::string(" "));

    // check if we got a 1x1 PPM Image
    if (!ppmColor.starts_with("P6 1 1 ")) {
        Debug::log(ERR, "grim did not return a PPM Image for us.");
        sendEmptyDbusMethodReply(call, 1);
        return;
    }

    // convert it to a rgb value
    try {
        std::string maxValString = ppmColor.substr(7, ppmColor.size());
        maxValString             = maxValString.substr(0, maxValString.find(' '));
        uint32_t maxVal          = std::stoi(maxValString);

        double   r, g, b;

        // 1 byte per triplet
        if (maxVal < 256) {
            std::string byteString = ppmColor.substr(11, 14);

            r = (uint8_t)byteString[0] / (maxVal * 1.0);
            g = (uint8_t)byteString[1] / (maxVal * 1.0);
            b = (uint8_t)byteString[2] / (maxVal * 1.0);
        } else {
            // 2 byte per triplet (MSB first)
            std::string byteString = ppmColor.substr(11, 17);

            r = ((byteString[0] << 8) | byteString[1]) / (maxVal * 1.0);
            g = ((byteString[2] << 8) | byteString[3]) / (maxVal * 1.0);
            b = ((byteString[4] << 8) | byteString[5]) / (maxVal * 1.0);
        }

        auto                                            reply = call.createReply();

        std::unordered_map<std::string, sdbus::Variant> results;
        results["color"] = sdbus::Struct(std::tuple{r, g, b});

        reply << (uint32_t)0;
        reply << results;
        reply.send();
    } catch (...) {
        Debug::log(ERR, "Converting PPM to RGB failed. This is likely a string to integer error.");
        sendEmptyDbusMethodReply(call, 1);
    }
}
