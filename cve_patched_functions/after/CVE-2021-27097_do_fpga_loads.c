int do_fpga_loads(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
{
	size_t data_size = 0;
	long fpga_data, dev;
	int ret;
	struct fpga_secure_info fpga_sec_info;

	memset(&fpga_sec_info, 0, sizeof(fpga_sec_info));

	if (argc < 5) {
		debug("fpga: incorrect parameters passed\n");
		return CMD_RET_USAGE;
	}

	if (argc == 6)
		fpga_sec_info.userkey_addr = (u8 *)(uintptr_t)
					      simple_strtoull(argv[5],
							      NULL, 16);
	else
		/*
		 * If 6th parameter is not passed then do_fpga_check_params
		 * will get 5 instead of expected 6 which means that function
		 * return CMD_RET_USAGE. Increase number of params +1 to pass
		 * this.
		 */
		argc++;

	fpga_sec_info.encflag = (u8)simple_strtoul(argv[4], NULL, 16);
	fpga_sec_info.authflag = (u8)simple_strtoul(argv[3], NULL, 16);

	if (fpga_sec_info.authflag >= FPGA_NO_ENC_OR_NO_AUTH &&
	    fpga_sec_info.encflag >= FPGA_NO_ENC_OR_NO_AUTH) {
		debug("fpga: Use <fpga load> for NonSecure bitstream\n");
		return CMD_RET_USAGE;
	}

	if (fpga_sec_info.encflag == FPGA_ENC_USR_KEY &&
	    !fpga_sec_info.userkey_addr) {
		debug("fpga: User key not provided\n");
		return CMD_RET_USAGE;
	}

	ret = do_fpga_check_params(&dev, &fpga_data, &data_size,
				   cmdtp, argc, argv);
	if (ret)
		return ret;

	return fpga_loads(dev, (void *)fpga_data, data_size, &fpga_sec_info);
}
