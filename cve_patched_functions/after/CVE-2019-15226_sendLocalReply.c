void ConnectionManagerImpl::ActiveStream::sendLocalReply(
    bool is_grpc_request, Code code, absl::string_view body,
    const std::function<void(HeaderMap& headers)>& modify_headers, bool is_head_request,
    const absl::optional<Grpc::Status::GrpcStatus> grpc_status, absl::string_view details) {
  ENVOY_STREAM_LOG(debug, "Sending local reply with details {}", *this, details);
  ASSERT(response_headers_ == nullptr);
  // For early error handling, do a best-effort attempt to create a filter chain
  // to ensure access logging.
  if (!state_.created_filter_chain_) {
    createFilterChain();
  }
  stream_info_.setResponseCodeDetails(details);
  Utility::sendLocalReply(
      is_grpc_request,
      [this, modify_headers](HeaderMapPtr&& headers, bool end_stream) -> void {
        if (modify_headers != nullptr) {
          modify_headers(*headers);
        }
        response_headers_ = std::move(headers);
        // TODO: Start encoding from the last decoder filter that saw the
        // request instead.
        encodeHeaders(nullptr, *response_headers_, end_stream);
      },
      [this](Buffer::Instance& data, bool end_stream) -> void {
        // TODO: Start encoding from the last decoder filter that saw the
        // request instead.
        encodeData(nullptr, data, end_stream, FilterIterationStartState::CanStartFromCurrent);
      },
      state_.destroyed_, code, body, grpc_status, is_head_request);
}
