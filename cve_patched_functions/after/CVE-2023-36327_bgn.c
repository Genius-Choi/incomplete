static int bgn(void) {
	int result, code = RLC_ERR;
	g1_t c[2], d[2];
	g2_t e[2], f[2];
	gt_t g[4];
	bgn_t pub, prv;
	dig_t in, out, t;

	g1_null(c[0]);
	g1_null(c[1]);
	g1_null(d[0]);
	g1_null(d[1]);
	g2_null(e[0]);
	g2_null(e[1]);
	g2_null(f[0]);
	g2_null(f[1]);
	bgn_null(pub);
	bgn_null(prv);

	RLC_TRY {
		g1_new(c[0]);
		g1_new(c[1]);
		g1_new(d[0]);
		g1_new(d[1]);
		g2_new(e[0]);
		g2_new(e[1]);
		g2_new(f[0]);
		g2_new(f[1]);
		bgn_new(pub);
		bgn_new(prv);
		for (int i = 0; i < 4; i++) {
			gt_null(g[i]);
			gt_new(g[i]);
		}

		result = cp_bgn_gen(pub, prv);

		TEST_CASE("boneh-go-nissim encryption/decryption is correct") {
			TEST_ASSERT(result == RLC_OK, end);

			rand_bytes((unsigned char *)&in, sizeof(dig_t));
			in = in % 11;

			TEST_ASSERT(cp_bgn_enc1(c, in, pub) == RLC_OK, end);
			TEST_ASSERT(cp_bgn_dec1(&out, c, prv) == RLC_OK, end);
			TEST_ASSERT(in == out, end);
			TEST_ASSERT(cp_bgn_enc2(e, in, pub) == RLC_OK, end);
			TEST_ASSERT(cp_bgn_dec2(&out, e, prv) == RLC_OK, end);
			TEST_ASSERT(in == out, end);
		} TEST_END;

		TEST_CASE("boneh-go-nissim encryption is additively homomorphic") {
			rand_bytes((unsigned char *)&in, sizeof(dig_t));
			in = in % 11;
			out = in % 7;
			TEST_ASSERT(cp_bgn_enc1(c, in, pub) == RLC_OK, end);
			TEST_ASSERT(cp_bgn_enc1(d, out, pub) == RLC_OK, end);
			g1_add(c[0], c[0], d[0]);
			g1_add(c[1], c[1], d[1]);
			g1_norm(c[0], c[0]);
			g1_norm(c[1], c[1]);
			TEST_ASSERT(cp_bgn_dec1(&t, c, prv) == RLC_OK, end);
			TEST_ASSERT(in + out == t, end);
			TEST_ASSERT(cp_bgn_enc2(e, in, pub) == RLC_OK, end);
			TEST_ASSERT(cp_bgn_enc2(f, out, pub) == RLC_OK, end);
			g2_add(e[0], e[0], f[0]);
			g2_add(e[1], e[1], f[1]);
			g2_norm(e[0], e[0]);
			g2_norm(e[1], e[1]);
			TEST_ASSERT(cp_bgn_dec2(&t, e, prv) == RLC_OK, end);
			TEST_ASSERT(in + out == t, end);
		} TEST_END;

		TEST_CASE("boneh-go-nissim encryption is multiplicatively homomorphic") {
			rand_bytes((unsigned char *)&in, sizeof(dig_t));
			in = in % 11;
			out = in % 17;
			TEST_ASSERT(cp_bgn_enc1(c, in, pub) == RLC_OK, end);
			TEST_ASSERT(cp_bgn_enc2(e, out, pub) == RLC_OK, end);
			TEST_ASSERT(cp_bgn_enc1(d, out, pub) == RLC_OK, end);
			TEST_ASSERT(cp_bgn_enc2(f, in, pub) == RLC_OK, end);
			in = in * out;
			TEST_ASSERT(cp_bgn_mul(g, c, e) == RLC_OK, end);
			TEST_ASSERT(cp_bgn_dec(&t, g, prv) == RLC_OK, end);
			TEST_ASSERT(in == t, end);
			TEST_ASSERT(cp_bgn_mul(g, d, f) == RLC_OK, end);
			TEST_ASSERT(cp_bgn_dec(&t, g, prv) == RLC_OK, end);
			TEST_ASSERT(in == t, end);
			TEST_ASSERT(cp_bgn_add(g, g, g) == RLC_OK, end);
			TEST_ASSERT(cp_bgn_dec(&t, g, prv) == RLC_OK, end);
			TEST_ASSERT(in + in == t, end);
		} TEST_END;

	} RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;

  end:
	g1_free(c[0]);
	g1_free(c[1]);
	g1_free(d[0]);
	g1_free(d[1]);
	g2_free(e[0]);
	g2_free(e[1]);
	g2_free(f[0]);
	g2_free(f[1]);
	bgn_free(pub);
	bgn_free(prv);
	for (int i = 0; i < 4; i++) {
		gt_free(g[i]);
	}
	return code;
}
