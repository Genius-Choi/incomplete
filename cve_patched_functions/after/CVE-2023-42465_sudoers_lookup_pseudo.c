sudoers_lookup_pseudo(struct sudo_nss_list *snl, struct sudoers_context *ctx,
    time_t now, sudoers_lookup_callback_fn_t callback, void *cb_data,
    int pwflag)
{
    char *saved_runchroot;
    struct passwd *root_pw = NULL;
    struct sudo_nss *nss;
    struct cmndspec *cs;
    struct privilege *priv;
    struct userspec *us;
    struct defaults *def;
    int nopass, match = DENY;
    unsigned int validated = 0;
    enum def_tuple pwcheck;
    debug_decl(sudoers_lookup_pseudo, SUDOERS_DEBUG_PARSER);

    pwcheck = (pwflag == -1) ? never : sudo_defs_table[pwflag].sd_un.tuple;
    nopass = (pwcheck == never || pwcheck == all) ? true : false;

    if (ctx->runas.list_pw != NULL) {
	root_pw = sudo_getpwuid(ROOT_UID);
	if (root_pw == NULL)
	    sudo_warnx(U_("unknown uid %u"), ROOT_UID);
    } else {
	SET(validated, FLAG_NO_CHECK);
    }

    /* Don't use chroot setting for pseudo-commands. */
    saved_runchroot = def_runchroot;
    def_runchroot = NULL;

    TAILQ_FOREACH(nss, snl, entries) {
	if (nss->query(ctx, nss, ctx->user.pw) == -1) {
	    /* The query function should have printed an error message. */
	    SET(validated, VALIDATE_ERROR);
	    break;
	}

	/*
	 * We have to traverse the policy forwards, not in reverse,
	 * to support the "pwcheck == all" case.
	 */
	TAILQ_FOREACH(us, &nss->parse_tree->userspecs, entries) {
	    int user_match = userlist_matches(nss->parse_tree, ctx->user.pw,
		&us->users);
	    if (user_match != ALLOW) {
		if (callback != NULL && user_match == DENY) {
		    callback(nss->parse_tree, us, user_match, NULL, UNSPEC,
			NULL, UNSPEC, UNSPEC, UNSPEC, cb_data);
		}
		continue;
	    }
	    TAILQ_FOREACH(priv, &us->privileges, entries) {
		int priv_nopass = UNSPEC;
		int host_match = hostlist_matches(nss->parse_tree, ctx->user.pw,
		    &priv->hostlist);
		if (host_match != ALLOW) {
		    if (callback != NULL) {
			callback(nss->parse_tree, us, user_match, priv,
			    host_match, NULL, UNSPEC, UNSPEC, UNSPEC, cb_data);
		    }
		    continue;
		}
		TAILQ_FOREACH(def, &priv->defaults, entries) {
		    if (strcmp(def->var, "authenticate") == 0) {
			priv_nopass = !def->op;
			break;
		    }
		}
		TAILQ_FOREACH(cs, &priv->cmndlist, entries) {
		    int cmnd_match = UNSPEC;
		    int date_match = UNSPEC;
		    int runas_match = UNSPEC;

		    if (pwcheck == any) {
			if (cs->tags.nopasswd == true || priv_nopass == true)
			    nopass = true;
		    } else if (pwcheck == all) {
			if (cs->tags.nopasswd != true && priv_nopass != true)
			    nopass = false;
		    }

		    if (cs->notbefore != UNSPEC) {
			date_match = now < cs->notbefore ? DENY : ALLOW;
		    }
		    if (cs->notafter != UNSPEC) {
			date_match = now > cs->notafter ? DENY : ALLOW;
		    }
		    /*
		     * Root can list any user's privileges.
		     * A user may always list their own privileges.
		     */
		    if (ctx->user.uid == 0 || ctx->runas.list_pw == NULL ||
			    ctx->user.uid == ctx->runas.list_pw->pw_uid) {
			cmnd_match = ALLOW;
			runas_match = ALLOW;
		    } else if (date_match != DENY) {
			/*
			 * To list another user's prilileges, the runas
			 * user must match the list user or root.
			 */
			runas_match = runas_matches_pw(nss->parse_tree, cs,
			    ctx->runas.list_pw);
			switch (runas_match) {
			case DENY:
			    break;
			case ALLOW:
			    /*
			     * RunAs user matches list user.
			     * Match on command "list" or ALL.
			     */
			    cmnd_match = cmnd_matches(nss->parse_tree,
				cs->cmnd, cs->runchroot, NULL);
			    break;
			default:
			    /*
			     * RunAs user doesn't match list user.
			     * Only allow listing if the user has
			     * "sudo ALL" for root.
			     */
			    if (root_pw != NULL &&
				    runas_matches_pw(nss->parse_tree, cs,
				    root_pw) == ALLOW) {
				runas_match = ALLOW;
				cmnd_match = cmnd_matches_all(nss->parse_tree,
				    cs->cmnd, cs->runchroot, NULL);
			    }
			    break;
			}
		    }
		    if (callback != NULL) {
			callback(nss->parse_tree, us, user_match, priv,
			    host_match, cs, date_match, runas_match,
			    cmnd_match, cb_data);
		    }
		    if (SPECIFIED(cmnd_match)) {
			/*
			 * We take the last match but must process
			 * the entire policy for pwcheck == all.
			 */
			match = cmnd_match;
		    }
		}
	    }
	}
	if (!sudo_nss_can_continue(nss, match))
	    break;
    }
    if (root_pw != NULL)
	sudo_pw_delref(root_pw);
    if (match == ALLOW || ctx->user.uid == 0) {
	/* User has an entry for this host. */
	SET(validated, VALIDATE_SUCCESS);
    } else if (match == DENY)
	SET(validated, VALIDATE_FAILURE);
    if (pwcheck == always && def_authenticate)
	SET(validated, FLAG_CHECK_USER);
    else if (nopass == true)
	def_authenticate = false;

    /* Restore original def_runchroot. */
    def_runchroot = saved_runchroot;

    debug_return_uint(validated);
}
