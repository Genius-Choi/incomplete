sesman_listen_conn_in(struct trans *self, struct trans *new_self)
{
    struct sesman_con *sc;
    if (g_con_list->count >= MAX_SHORT_LIVED_CONNECTIONS)
    {
        LOG(LOG_LEVEL_ERROR, "sesman_data_in: error, too many "
            "connections, rejecting");
        trans_delete(new_self);
    }
    else if ((sc = alloc_connection(new_self)) == NULL)
    {
        LOG(LOG_LEVEL_ERROR, "sesman_data_in: No memory to allocate "
            "new connection");
        trans_delete(new_self);
    }
    else
    {
        new_self->header_size = 8;
        new_self->trans_data_in = sesman_data_in;
        new_self->no_stream_init_on_data_in = 1;
        new_self->extra_flags = 0;
        list_add_item(g_con_list, (intptr_t) sc);
    }

    return 0;
}
