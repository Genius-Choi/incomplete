    Type1Charstring CFontFileType1::DecodeCharString(unsigned char *sString, int nLen)
    {
        CArray<Type1CharstringItem> sCharString;

        int nLSB = 0, nWidth = 0;

        for ( int nIndex = 0; nIndex < nLen; nIndex++ )
        {
            int nValue = sString[nIndex];

            if ( nValue < 32 ) // команда
            {
                int nCommand = 0;

                if ( 12 == nValue )
                {
                    int nNextValue = sString[++nIndex];

                    if ( 16 == nNextValue )
                    {
                        if ( sCharString.GetSize() <= 0 )
                            continue;

                        int nInd = sCharString[sCharString.GetSize() - 1].nValue;
                        sCharString.RemoveAt( sCharString.GetSize() - 1 );

                        while ( sCharString.GetSize() > 0 && false == sCharString[sCharString.GetSize() - 1].bCommand )
                            sCharString.RemoveAt( sCharString.GetSize() - 1 );

                        // If the flex mechanishm is not used in a font program, Adobe
                        // state that that entries 0, 1 and 2 can simply be replace by
                        // {}, which means that we can simply ignore them.
                        if ( nInd < 3 )
                            continue;

                        // This is the same things about hint replacement, if it is not used
                        // entry 3 can be replaced by {3}
                        if ( 3 == nInd )
                        {
                            sCharString.Add( Type1CharstringItem( 3, true ) );
                            nIndex++;
                            continue;
                        }
                    }

                    nCommand = 12 + ( nNextValue << 8 );
                }
                else
                {
                    if ( 13 == nValue )
                    {
                        if ( 2 == sCharString.GetSize() )
                            nWidth = sCharString[1].nValue;
                        else if ( 4 == sCharString.GetSize() && 0x0C0C == sCharString[3].nValue && sCharString[3].bCommand )
                            nWidth = sCharString[1].nValue / sCharString[2].nValue;
                        else
                        {
                            // TO DO: обработать ошибку
                            nWidth = 0;
                        }

                        if ( sCharString.GetSize() > 0 )
                        {
                            nLSB = sCharString[0].nValue;
                            sCharString.Add( Type1CharstringItem( nLSB, false ) );
                            sCharString.Add( Type1CharstringItem( c_nType1hmoveto, true ) );
                            sCharString.RemoveAt( 0 );
                        }
                        else
                        {
                            nLSB = 0;
                            sCharString.Add( Type1CharstringItem( nLSB, false ) );
                            sCharString.Add( Type1CharstringItem( c_nType1hmoveto, true ) );
                        }

                        continue;
                    }

                    nCommand = nValue;
                }

                // Some charstring commands are meaningless in Type2 and will return
                // a null, let's just ignored them
                if ( !nCommand && nIndex < nLen )
                    continue;
                else if ( !nCommand )
                    break;
                else if ( c_nType1seac == nCommand || c_nType1sbw == nCommand )
                {
                    // TO DO: обработать ошибку
                }

                sCharString.Add( Type1CharstringItem( nCommand, true ) );
            }
            else
            {
                if ( nValue <= 246 )
                    nValue = nValue - 139;
                else if ( nValue <= 250 )
                    nValue =  ( ( nValue - 247 ) * 256 ) + (int)( sString[++nIndex] ) + 108;
                else if ( nValue <= 254 )
                    nValue = -( ( nValue - 251 ) * 256 ) - (int)( sString[++nIndex] ) - 108;
                else
                    nValue = ( sString[++nIndex] & 0xff ) << 24 | ( sString[++nIndex] & 0xff ) << 16 | ( sString[++nIndex] & 0xff ) << 8 | ( sString[++nIndex] & 0xff ) << 0;

                sCharString.Add( Type1CharstringItem( nValue, false ) );
            }
        }

        return Type1Charstring( sCharString, nWidth, nLSB );
    }
