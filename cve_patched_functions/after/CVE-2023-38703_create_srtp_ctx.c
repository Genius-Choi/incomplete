static pj_status_t create_srtp_ctx(transport_srtp *srtp,
                                   srtp_context *ctx,
                                   const pjmedia_srtp_setting *setting,
                                   const pjmedia_srtp_crypto *tx,
                                   const pjmedia_srtp_crypto *rx)
{
    srtp_policy_t    tx_;
    srtp_policy_t    rx_;
    srtp_err_status_t err;
    int              cr_tx_idx = 0;
    int              au_tx_idx = 0;
    int              cr_rx_idx = 0;
    int              au_rx_idx = 0;
    pj_status_t      status = PJ_SUCCESS;

    pj_lock_acquire(srtp->mutex);

    if (ctx->srtp_tx_ctx || ctx->srtp_rx_ctx)
        destroy_srtp_ctx(srtp, ctx);

    /* Get encryption and authentication method */
    cr_tx_idx = au_tx_idx = get_crypto_idx(&tx->name);
    if (tx->flags & PJMEDIA_SRTP_NO_ENCRYPTION)
        cr_tx_idx = 0;
    if (tx->flags & PJMEDIA_SRTP_NO_AUTHENTICATION)
        au_tx_idx = 0;

    cr_rx_idx = au_rx_idx = get_crypto_idx(&rx->name);
    if (rx->flags & PJMEDIA_SRTP_NO_ENCRYPTION)
        cr_rx_idx = 0;
    if (rx->flags & PJMEDIA_SRTP_NO_AUTHENTICATION)
        au_rx_idx = 0;

    /* Check whether the crypto-suite requested is supported */
    if (cr_tx_idx == -1 || cr_rx_idx == -1 || au_tx_idx == -1 ||
        au_rx_idx == -1)
    {
        status = PJMEDIA_SRTP_ENOTSUPCRYPTO;
        goto on_return;
    }

    /* If all options points to 'NULL' method, just bypass SRTP */
    if (cr_tx_idx == 0 && cr_rx_idx == 0 && au_tx_idx == 0 && au_rx_idx == 0) {
        /* To bypass SRTP: we return PJ_SUCCESS without allocating SRTP
         * contexts.
         */
        goto on_return;
    }

    /* Check key length */
    if (tx->key.slen != (pj_ssize_t)crypto_suites[cr_tx_idx].cipher_key_len ||
        rx->key.slen != (pj_ssize_t)crypto_suites[cr_rx_idx].cipher_key_len)
    {
        status = PJMEDIA_SRTP_EINKEYLEN;
        goto on_return;
    }

    /* Init transmit direction */
    pj_bzero(&tx_, sizeof(srtp_policy_t));
    pj_memmove(ctx->tx_key, tx->key.ptr, tx->key.slen);
    if (cr_tx_idx && au_tx_idx)
        tx_.rtp.sec_serv    = sec_serv_conf_and_auth;
    else if (cr_tx_idx)
        tx_.rtp.sec_serv    = sec_serv_conf;
    else if (au_tx_idx)
        tx_.rtp.sec_serv    = sec_serv_auth;
    else
        tx_.rtp.sec_serv    = sec_serv_none;
    tx_.key                 = (uint8_t*)ctx->tx_key;
    if (setting->tx_roc.roc != 0 &&
        setting->tx_roc.ssrc != 0)
    {
        tx_.ssrc.type       = ssrc_specific;
        tx_.ssrc.value      = setting->tx_roc.ssrc;
    } else {
        tx_.ssrc.type       = ssrc_any_outbound;
        tx_.ssrc.value      = 0;
    }
    tx_.rtp.cipher_type     = crypto_suites[cr_tx_idx].cipher_type;
    tx_.rtp.cipher_key_len  = crypto_suites[cr_tx_idx].cipher_key_len;
    tx_.rtp.auth_type       = crypto_suites[au_tx_idx].auth_type;
    tx_.rtp.auth_key_len    = crypto_suites[au_tx_idx].auth_key_len;
    tx_.rtp.auth_tag_len    = crypto_suites[au_tx_idx].srtp_auth_tag_len;
    tx_.rtcp                = tx_.rtp;
    tx_.rtcp.auth_tag_len   = crypto_suites[au_tx_idx].srtcp_auth_tag_len;
    tx_.next                = NULL;
    err = srtp_create(&ctx->srtp_tx_ctx, &tx_);
    if (err != srtp_err_status_ok) {
        status = PJMEDIA_ERRNO_FROM_LIBSRTP(err);
        goto on_return;
    }
    if (setting->tx_roc.roc != 0 &&
        setting->tx_roc.ssrc != 0)
    {
        err = srtp_set_stream_roc(ctx->srtp_tx_ctx,
                                  setting->tx_roc.ssrc,
                                  setting->tx_roc.roc);
        PJ_LOG(4, (THIS_FILE, "Initializing SRTP TX ROC to SSRC %d with "
                   "ROC %d %s\n", setting->tx_roc.ssrc,
                   setting->tx_roc.roc,
                   (err == srtp_err_status_ok)? "succeeded": "failed"));
    }
    ctx->tx_policy = *tx;
    pj_strset(&ctx->tx_policy.key,  ctx->tx_key, tx->key.slen);
    ctx->tx_policy.name=pj_str(crypto_suites[get_crypto_idx(&tx->name)].name);


    /* Init receive direction */
    pj_bzero(&rx_, sizeof(srtp_policy_t));
    pj_memmove(ctx->rx_key, rx->key.ptr, rx->key.slen);
    if (cr_rx_idx && au_rx_idx)
        rx_.rtp.sec_serv    = sec_serv_conf_and_auth;
    else if (cr_rx_idx)
        rx_.rtp.sec_serv    = sec_serv_conf;
    else if (au_rx_idx)
        rx_.rtp.sec_serv    = sec_serv_auth;
    else
        rx_.rtp.sec_serv    = sec_serv_none;
    rx_.key                 = (uint8_t*)ctx->rx_key;
    if (setting->rx_roc.roc != 0 &&
        setting->rx_roc.ssrc != 0)
    {
        rx_.ssrc.type       = ssrc_specific;
        rx_.ssrc.value      = setting->rx_roc.ssrc;
    } else {
        rx_.ssrc.type       = ssrc_any_inbound;
        rx_.ssrc.value      = 0;
    }
    rx_.rtp.sec_serv        = crypto_suites[cr_rx_idx].service;
    rx_.rtp.cipher_type     = crypto_suites[cr_rx_idx].cipher_type;
    rx_.rtp.cipher_key_len  = crypto_suites[cr_rx_idx].cipher_key_len;
    rx_.rtp.auth_type       = crypto_suites[au_rx_idx].auth_type;
    rx_.rtp.auth_key_len    = crypto_suites[au_rx_idx].auth_key_len;
    rx_.rtp.auth_tag_len    = crypto_suites[au_rx_idx].srtp_auth_tag_len;
    rx_.rtcp                = rx_.rtp;
    rx_.rtcp.auth_tag_len   = crypto_suites[au_rx_idx].srtcp_auth_tag_len;
    rx_.next                = NULL;
    err = srtp_create(&ctx->srtp_rx_ctx, &rx_);
    if (err != srtp_err_status_ok) {
        srtp_dealloc(ctx->srtp_tx_ctx);
        status = PJMEDIA_ERRNO_FROM_LIBSRTP(err);
        goto on_return;
    }
    if (setting->rx_roc.roc != 0 &&
        setting->rx_roc.ssrc != 0)
    {
        err = srtp_set_stream_roc(ctx->srtp_rx_ctx,
                                  setting->rx_roc.ssrc,
                                  setting->rx_roc.roc);
        PJ_LOG(4, (THIS_FILE, "Initializing SRTP RX ROC from SSRC %d with "
                   "ROC %d %s\n",
                   setting->rx_roc.ssrc, setting->rx_roc.roc,
                   (err == srtp_err_status_ok)? "succeeded": "failed"));
    }
    ctx->rx_policy = *rx;
    pj_strset(&ctx->rx_policy.key,  ctx->rx_key, rx->key.slen);
    ctx->rx_policy.name=pj_str(crypto_suites[get_crypto_idx(&rx->name)].name);

    /* Logging stuffs */
#if PJ_LOG_MAX_LEVEL >= 5
    {
        char b64[PJ_BASE256_TO_BASE64_LEN(MAX_KEY_LEN)];
        int b64_len;

        /* TX crypto and key */
        b64_len = sizeof(b64);
        status = pj_base64_encode((pj_uint8_t*)tx->key.ptr, (int)tx->key.slen,
                                  b64, &b64_len);
        if (status != PJ_SUCCESS)
            b64_len = pj_ansi_snprintf(b64, sizeof(b64), "--key too long--");
        else
            b64[b64_len] = '\0';

        PJ_LOG(5, (srtp->pool->obj_name, "TX: %s key=%s",
                   ctx->tx_policy.name.ptr, b64));
        if (ctx->tx_policy.flags) {
            PJ_LOG(5,(srtp->pool->obj_name, "TX: disable%s%s",
                      (cr_tx_idx?"":" enc"),
                      (au_tx_idx?"":" auth")));
        }

        /* RX crypto and key */
        b64_len = sizeof(b64);
        status = pj_base64_encode((pj_uint8_t*)rx->key.ptr, (int)rx->key.slen,
                                  b64, &b64_len);
        if (status != PJ_SUCCESS)
            b64_len = pj_ansi_snprintf(b64, sizeof(b64), "--key too long--");
        else
            b64[b64_len] = '\0';

        PJ_LOG(5, (srtp->pool->obj_name, "RX: %s key=%s",
                   ctx->rx_policy.name.ptr, b64));
        if (ctx->rx_policy.flags) {
            PJ_LOG(5,(srtp->pool->obj_name,"RX: disable%s%s",
                      (cr_rx_idx?"":" enc"),
                      (au_rx_idx?"":" auth")));
        }
    }
#endif

on_return:
    pj_lock_release(srtp->mutex);
    return status;
}
