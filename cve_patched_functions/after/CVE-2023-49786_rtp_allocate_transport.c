static int rtp_allocate_transport(struct ast_rtp_instance *instance, struct ast_rtp *rtp)
{
	int x, startplace, i, maxloops;

	rtp->strict_rtp_state = (strictrtp ? STRICT_RTP_CLOSED : STRICT_RTP_OPEN);

	/* Create a new socket for us to listen on and use */
	if ((rtp->s =
	     create_new_socket("RTP",
			       ast_sockaddr_is_ipv4(&rtp->bind_address) ? AF_INET  :
			       ast_sockaddr_is_ipv6(&rtp->bind_address) ? AF_INET6 : -1)) < 0) {
		ast_log(LOG_WARNING, "Failed to create a new socket for RTP instance '%p'\n", instance);
		return -1;
	}

	/* Now actually find a free RTP port to use */
	x = (ast_random() % (rtpend - rtpstart)) + rtpstart;
	x = x & ~1;
	startplace = x;

	/* Protection against infinite loops in the case there is a potential case where the loop is not broken such as an odd
	   start port sneaking in (even though this condition is checked at load.) */
	maxloops = rtpend - rtpstart;
	for (i = 0; i <= maxloops; i++) {
		ast_sockaddr_set_port(&rtp->bind_address, x);
		/* Try to bind, this will tell us whether the port is available or not */
		if (!ast_bind(rtp->s, &rtp->bind_address)) {
			ast_debug_rtp(1, "(%p) RTP allocated port %d\n", instance, x);
			ast_rtp_instance_set_local_address(instance, &rtp->bind_address);
			ast_test_suite_event_notify("RTP_PORT_ALLOCATED", "Port: %d", x);
			break;
		}

		x += 2;
		if (x > rtpend) {
			x = (rtpstart + 1) & ~1;
		}

		/* See if we ran out of ports or if the bind actually failed because of something other than the address being in use */
		if (x == startplace || (errno != EADDRINUSE && errno != EACCES)) {
			ast_log(LOG_ERROR, "Oh dear... we couldn't allocate a port for RTP instance '%p'\n", instance);
			close(rtp->s);
			rtp->s = -1;
			return -1;
		}
	}

#ifdef HAVE_PJPROJECT
	/* Initialize synchronization aspects */
	ast_cond_init(&rtp->cond, NULL);

	generate_random_string(rtp->local_ufrag, sizeof(rtp->local_ufrag));
	generate_random_string(rtp->local_passwd, sizeof(rtp->local_passwd));

	/* Create an ICE session for ICE negotiation */
	if (icesupport) {
		rtp->ice_num_components = 2;
		ast_debug_ice(2, "(%p) ICE creating session %s (%d)\n", instance,
			ast_sockaddr_stringify(&rtp->bind_address), x);
		if (ice_create(instance, &rtp->bind_address, x, 0)) {
			ast_log(LOG_NOTICE, "(%p) ICE failed to create session\n", instance);
		} else {
			rtp->ice_port = x;
			ast_sockaddr_copy(&rtp->ice_original_rtp_addr, &rtp->bind_address);
		}
	}
#endif

#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)
	rtp->rekeyid = -1;
	rtp->dtls.timeout_timer = -1;
#endif

	return 0;
}
