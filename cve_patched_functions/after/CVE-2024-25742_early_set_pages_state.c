static void early_set_pages_state(unsigned long vaddr, unsigned long paddr,
				  unsigned long npages, enum psc_op op)
{
	unsigned long paddr_end;
	u64 val;
	int ret;

	vaddr = vaddr & PAGE_MASK;

	paddr = paddr & PAGE_MASK;
	paddr_end = paddr + (npages << PAGE_SHIFT);

	while (paddr < paddr_end) {
		if (op == SNP_PAGE_STATE_SHARED) {
			/* Page validation must be rescinded before changing to shared */
			ret = pvalidate(vaddr, RMP_PG_SIZE_4K, false);
			if (WARN(ret, "Failed to validate address 0x%lx ret %d", paddr, ret))
				goto e_term;
		}

		/*
		 * Use the MSR protocol because this function can be called before
		 * the GHCB is established.
		 */
		sev_es_wr_ghcb_msr(GHCB_MSR_PSC_REQ_GFN(paddr >> PAGE_SHIFT, op));
		VMGEXIT();

		val = sev_es_rd_ghcb_msr();

		if (WARN(GHCB_RESP_CODE(val) != GHCB_MSR_PSC_RESP,
			 "Wrong PSC response code: 0x%x\n",
			 (unsigned int)GHCB_RESP_CODE(val)))
			goto e_term;

		if (WARN(GHCB_MSR_PSC_RESP_VAL(val),
			 "Failed to change page state to '%s' paddr 0x%lx error 0x%llx\n",
			 op == SNP_PAGE_STATE_PRIVATE ? "private" : "shared",
			 paddr, GHCB_MSR_PSC_RESP_VAL(val)))
			goto e_term;

		if (op == SNP_PAGE_STATE_PRIVATE) {
			/* Page validation must be performed after changing to private */
			ret = pvalidate(vaddr, RMP_PG_SIZE_4K, true);
			if (WARN(ret, "Failed to validate address 0x%lx ret %d", paddr, ret))
				goto e_term;
		}

		vaddr += PAGE_SIZE;
		paddr += PAGE_SIZE;
	}

	return;

e_term:
	sev_es_terminate(SEV_TERM_SET_LINUX, GHCB_TERM_PSC);
}
