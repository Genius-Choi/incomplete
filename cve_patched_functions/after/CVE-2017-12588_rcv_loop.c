static rsRetVal rcv_loop(thrdInfo_t* pThrd){
    size_t          n_items = 0;
    size_t          i;
    int             rv;
    zmq_pollitem_t* items = NULL;
    poller_data*    pollerData = NULL;
    struct lstn_s*  current;
    instanceConf_t* inst;
    DEFiRet;

    /* now add listeners. This actually creates the sockets, etc... */
    for (inst = runModConf->root; inst != NULL; inst=inst->next) {
        addListener(inst);
    }
    if (lcnfRoot == NULL) {
        errmsg.LogError(0, NO_ERRCODE, "imzmq3: no listeners were "
                        "started, input not activated.\n");
        ABORT_FINALIZE(RS_RET_NO_RUN);
    }

    /* count the # of items first */
    for(current=lcnfRoot;current!=NULL;current=current->next)
        n_items++;

    /* make arrays of pollitems, pollerdata so they are easy to delete later */
    
    /* create the poll items*/ 
    CHKmalloc(items = (zmq_pollitem_t*)MALLOC(sizeof(zmq_pollitem_t)*n_items));
    
    /* create poller data (stuff to pass into the zmq closure called when we get a message)*/
    CHKmalloc(pollerData = (poller_data*)MALLOC(sizeof(poller_data)*n_items));

    /* loop through and initialize the poll items and poller_data arrays...*/
    for(i=0, current = lcnfRoot; current != NULL; current = current->next, i++) {
        /* create the socket, update items.*/
        items[i].socket=current->sock;
        items[i].events = ZMQ_POLLIN;
        
        /* now update the poller_data for this item */
        pollerData[i].thread  = pThrd;
        pollerData[i].ruleset = current->pRuleset;
    }

    s_zloop = zloop_new();
    for(i=0; i<n_items; ++i) {
        
        rv = zloop_poller(s_zloop, &items[i], handlePoll, &pollerData[i]);
        if (rv) {
            errmsg.LogError(0, NO_ERRCODE, "imzmq3: zloop_poller failed for item %zu: %s", i, zmq_strerror(errno));
        } 
    }
    DBGPRINTF("imzmq3: zloop_poller starting...");
    zloop_start(s_zloop);   
    zloop_destroy(&s_zloop);
    DBGPRINTF("imzmq3: zloop_poller stopped.");
finalize_it:
    zctx_destroy(&s_context);

    free(items);
    free(pollerData);
    RETiRet;
}
