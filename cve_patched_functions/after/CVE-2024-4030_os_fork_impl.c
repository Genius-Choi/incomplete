os_fork_impl(PyObject *module)
/*[clinic end generated code: output=3626c81f98985d49 input=13c956413110eeaa]*/
{
    pid_t pid;
    PyInterpreterState *interp = _PyInterpreterState_GET();
    if (_PyInterpreterState_GetFinalizing(interp) != NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                        "can't fork at interpreter shutdown");
        return NULL;
    }
    if (!_PyInterpreterState_HasFeature(interp, Py_RTFLAGS_FORK)) {
        PyErr_SetString(PyExc_RuntimeError,
                        "fork not supported for isolated subinterpreters");
        return NULL;
    }
    if (PySys_Audit("os.fork", NULL) < 0) {
        return NULL;
    }
    PyOS_BeforeFork();
    pid = fork();
    int saved_errno = errno;
    if (pid == 0) {
        /* child: this clobbers and resets the import lock. */
        PyOS_AfterFork_Child();
    } else {
        warn_about_fork_with_threads("fork");
        /* parent: release the import lock. */
        PyOS_AfterFork_Parent();
    }
    if (pid == -1) {
        errno = saved_errno;
        return posix_error();
    }
    return PyLong_FromPid(pid);
}
