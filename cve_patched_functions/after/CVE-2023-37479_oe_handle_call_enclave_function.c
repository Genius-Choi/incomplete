oe_result_t oe_handle_call_enclave_function(uint64_t arg_in)
{
    oe_call_enclave_function_args_t args = {0}, *args_host_ptr = NULL;
    oe_call_function_return_args_t* return_args_ptr = NULL;
    oe_result_t result = OE_OK;
    oe_ecall_func_t func = NULL;
    uint8_t* buffer = NULL;
    uint8_t* input_buffer = NULL;
    uint8_t* output_buffer = NULL;
    size_t buffer_size = 0;
    size_t output_bytes_written = 0;
    ecall_table_t ecall_table;

    // Ensure that args lies outside the enclave and is 8-byte aligned
    // (against the xAPIC vulnerability).
    // The size of oe_call_enclave_function_args_t is guaranteed to be
    // 8-byte aligned via compile-time checks.
    if (!oe_is_outside_enclave(
            (void*)arg_in, sizeof(oe_call_enclave_function_args_t)) ||
        (arg_in % 8) != 0)
        OE_RAISE(OE_INVALID_PARAMETER);

    // Copy args to enclave memory to avoid TOCTOU issues.
    args_host_ptr = (oe_call_enclave_function_args_t*)arg_in;
    oe_memcpy_aligned(
        &args, args_host_ptr, sizeof(oe_call_enclave_function_args_t));

    // Ensure that input buffer is valid (oe_is_outside_enclave ensures
    // the buffer is not NULL).
    // The buffer size must at least equal to oe_call_function_args_t
    if (!oe_is_outside_enclave(args.input_buffer, args.input_buffer_size) ||
        args.input_buffer_size < sizeof(oe_call_function_return_args_t))
        OE_RAISE(OE_INVALID_PARAMETER);

    // Ensure that output buffer is valid (oe_is_outside_enclave ensures
    // the buffer is not NULL).
    // The buffer size must at least equal to oe_call_function_return_args_t
    if (!oe_is_outside_enclave(args.output_buffer, args.output_buffer_size) ||
        args.output_buffer_size < sizeof(oe_call_function_return_args_t))
        OE_RAISE(OE_INVALID_PARAMETER);

    // Validate output and input buffer addresses and sizes.
    // Both of them must be correctly aligned (against the xAPIC vulnerability).
    if ((args.input_buffer_size % OE_EDGER8R_BUFFER_ALIGNMENT) != 0 ||
        ((uint64_t)args.input_buffer % 8) != 0)
        OE_RAISE(OE_INVALID_PARAMETER);

    if ((args.output_buffer_size % OE_EDGER8R_BUFFER_ALIGNMENT) != 0 ||
        ((uint64_t)args.output_buffer % 8) != 0)
        OE_RAISE(OE_INVALID_PARAMETER);

    OE_CHECK(oe_safe_add_u64(
        args.input_buffer_size, args.output_buffer_size, &buffer_size));

    // The __oe_ecall_table is defined in the oeedger8r-generated
    // code.
    ecall_table.ecalls = oe_ecalls_table;
    ecall_table.num_ecalls = oe_ecalls_table_size;

    // Fetch matching function.
    if (args.function_id >= ecall_table.num_ecalls)
        OE_RAISE(OE_NOT_FOUND);

    func = ecall_table.ecalls[args.function_id];

    if (func == NULL)
        OE_RAISE(OE_NOT_FOUND);

    // Allocate buffers in enclave memory
    buffer = input_buffer = oe_malloc(buffer_size);
    if (buffer == NULL)
        OE_RAISE(OE_OUT_OF_MEMORY);

    // Copy input buffer from the host to enclave buffer.
    oe_memcpy_aligned(input_buffer, args.input_buffer, args.input_buffer_size);

    // Clear out output buffer.
    // This ensures reproducible behavior if say the function is reading from
    // output buffer.
    output_buffer = buffer + args.input_buffer_size;
    memset(output_buffer, 0, args.output_buffer_size);

    // Call the function.
    func(
        input_buffer,
        args.input_buffer_size,
        output_buffer,
        args.output_buffer_size,
        &output_bytes_written);

    /*
     * The output_buffer is expected to point to a marshaling struct.
     * The function is expected to fill the struct.
     */
    return_args_ptr = (oe_call_function_return_args_t*)output_buffer;

    result = return_args_ptr->result;
    if (result == OE_OK)
    {
        /*
         * Error out the case if the deepcopy_out_buffer is NULL but the
         * deepcopy_out_buffer_size is not zero or if the deepcopy_out_buffer is
         * not NULL but the deepcopy_out_buffer_size is zero. Note that this
         * should only occur if the oeedger8r was not used or if
         * oeedger8r-generated routine is modified.
         */
        if ((!return_args_ptr->deepcopy_out_buffer &&
             return_args_ptr->deepcopy_out_buffer_size) ||
            (return_args_ptr->deepcopy_out_buffer &&
             !return_args_ptr->deepcopy_out_buffer_size))
            OE_RAISE(OE_UNEXPECTED);

        /*
         * Nonzero deepcopy_out_buffer and deepcopy_out_buffer_size fields
         * indicate that there is deep-copied content that needs to be
         * transmitted to the host.
         */
        if (return_args_ptr->deepcopy_out_buffer &&
            return_args_ptr->deepcopy_out_buffer_size)
        {
            /*
             * Ensure that the content lies in enclave memory.
             * Note that this should only fail if oeedger8r was not used or if
             * the oeedger8r-generated routine is modified.
             */
            if (!oe_is_within_enclave(
                    return_args_ptr->deepcopy_out_buffer,
                    return_args_ptr->deepcopy_out_buffer_size))
                OE_RAISE(OE_UNEXPECTED);

            void* host_buffer =
                oe_host_malloc(return_args_ptr->deepcopy_out_buffer_size);

            /* Copy the deep-copied content to host memory. */
            OE_CHECK(oe_memcpy_s_with_barrier(
                host_buffer,
                return_args_ptr->deepcopy_out_buffer_size,
                return_args_ptr->deepcopy_out_buffer,
                return_args_ptr->deepcopy_out_buffer_size));

            /* Release the memory on the enclave heap. */
            oe_free(return_args_ptr->deepcopy_out_buffer);

            return_args_ptr->deepcopy_out_buffer = host_buffer;
        }

        // Copy outputs to host memory.
        OE_CHECK(oe_memcpy_s_with_barrier(
            args.output_buffer,
            args.output_buffer_size,
            output_buffer,
            args.output_buffer_size));

        // The ecall succeeded.
        OE_WRITE_VALUE_WITH_BARRIER(
            &args_host_ptr->output_bytes_written, output_bytes_written);
        OE_WRITE_VALUE_WITH_BARRIER(&args_host_ptr->result, OE_OK);
    }

done:
    if (result != OE_OK && return_args_ptr && args.output_buffer)
    {
        return_args_ptr->result = result;
        return_args_ptr->deepcopy_out_buffer = NULL;
        return_args_ptr->deepcopy_out_buffer_size = 0;

        oe_memcpy_s_with_barrier(
            args.output_buffer,
            args.output_buffer_size,
            return_args_ptr,
            sizeof(oe_call_function_return_args_t));
    }

    if (buffer)
        oe_free(buffer);

    return result;
}
