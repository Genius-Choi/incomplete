static std::pair<ECHStatus, ECHState> processECH(
    const Optional<CookieState>& cookieState,
    const State& state,
    ClientHello& chlo) {
  // First, fetch current state (if any).
  ECHState echState;
  ECHStatus echStatus = state.echStatus();
  auto decrypter = state.context()->getECHDecrypter();

  if (state.handshakeContext() || cookieState) {
    // Process ECH for HRR (if any)
    std::tie(echStatus, echState.configId) =
        processECHHRR(cookieState, state, chlo);
    // Populate ECH state for saving
    if (state.echState().has_value()) {
      echState.hpkeContext = std::move(state.echState()->hpkeContext);
      echState.cipherSuite = state.echState()->cipherSuite;
    }
  } else {
    bool requestedECH =
        findExtension(chlo.extensions, ExtensionType::encrypted_client_hello) !=
        chlo.extensions.end();
    if (requestedECH && decrypter) {
      auto gotChlo = decrypter->decryptClientHello(chlo);
      if (gotChlo.has_value()) {
        auto echExt = getExtension<ech::OuterECHClientHello>(chlo.extensions);
        echStatus = ECHStatus::Accepted;
        echState.hpkeContext = std::move(gotChlo->context);
        echState.configId = gotChlo->configId;
        echState.cipherSuite = echExt->cipher_suite;
        chlo = std::move(gotChlo->chlo);
      } else if (requestedECH) {
        echStatus = ECHStatus::Rejected;
      }
    }
  }

  if (echStatus == ECHStatus::Accepted &&
      getExtension<ech::InnerECHClientHello>(chlo.extensions) == folly::none) {
    throw FizzException(
        "inner clienthello missing encrypted_client_hello",
        AlertDescription::missing_extension);
  }

  return std::make_pair(echStatus, std::move(echState));
}
