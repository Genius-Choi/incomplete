delete_flows_finish__(struct ofproto *ofproto,
                      struct rule_collection *rules,
                      enum ofp_flow_removed_reason reason,
                      const struct openflow_mod_requester *req)
    OVS_REQUIRES(ofproto_mutex)
{
    if (rule_collection_n(rules)) {
        struct ovs_list dead_cookies = OVS_LIST_INITIALIZER(&dead_cookies);
        struct rule *rule;

        RULE_COLLECTION_FOR_EACH (rule, rules) {
            /* This value will be used to send the flow removed message right
             * before the rule is actually destroyed. */
            rule->removed_reason = reason;

            ofmonitor_report(ofproto->connmgr, rule, NXFME_DELETED, reason,
                             req ? req->ofconn : NULL,
                             req ? req->request->xid : 0, NULL);

            /* Send Vacancy Event for OF1.4+. */
            send_table_status(ofproto, rule->table_id);

            learned_cookies_dec(ofproto, rule_get_actions(rule),
                                &dead_cookies);
        }
        remove_rules_postponed(rules);

        learned_cookies_flush(ofproto, &dead_cookies);
    }
}
