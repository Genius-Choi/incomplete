GF_Err gf_filter_pid_resolve_file_template_ex(GF_FilterPid *pid, char szTemplate[GF_MAX_PATH], char szFinalName[GF_MAX_PATH], u32 file_idx, const char *file_suffix, const char *filename)
{
	u32 k;
	GF_FilterPacket *pck;
	char szFormat[30], szTemplateVal[GF_MAX_PATH], szPropVal[GF_PROP_DUMP_ARG_SIZE];
	char *name = szTemplate;
	if (!strchr(szTemplate, '$')) {
		strcpy(szFinalName, szTemplate);
		return GF_OK;
	}
	pck = gf_filter_pid_get_packet(pid);
	
	k = 0;
	while (name[0]) {
		char *sep=NULL;
		char *fsep=NULL;
		const char *str_val = NULL;
		s64 value = 0;
		Bool is_ok = GF_TRUE;
		Bool do_skip = GF_FALSE;
		Bool has_val = GF_FALSE;
		Bool is_file_str = GF_FALSE;
		u32 prop_4cc = 0;
		GF_PropertyValue prop_val_patched;
		const GF_PropertyValue *prop_val = NULL;

		if (k+1==GF_MAX_PATH) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, ("[Filter] Not enough memory to solve file template %s\n", szTemplate));
			return GF_OUT_OF_MEM;
		}
		if (name[0] != '$') {
			szFinalName[k] = name[0];
			k++;
			name++;
			continue;
		}
		if (name[1]=='$') {
			szFinalName[k] = '$';
			name++;
			k++;
			continue;
		}
		sep = strchr(name+1, '$');
		if (!sep) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, ("[Filter] broken file template expecting $KEYWORD$, couldn't find second '$'\n", szTemplate));
			strcpy(szFinalName, szTemplate);
			return GF_BAD_PARAM;
		}
		szFormat[0] = '%';
		szFormat[1] = 'd';
		szFormat[2] = 0;

		szFinalName[k] = 0;
		name++;
		sep[0]=0;
		fsep = strchr(name, '%');
		if (fsep) {
			strcpy(szFormat, fsep);
			fsep[0]=0;
		}

		if (!strcmp(name, "num")) {
			name += 3;
			value = file_idx;
			has_val = GF_TRUE;
		} else if (!strcmp(name, "URL")) {
			if (!filename)
				prop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_URL);
			is_file_str = GF_TRUE;
		} else if (!strcmp(name, "File")) {
			if (!filename) {
				prop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_FILEPATH);
				//if filepath is a gmem:// wrapped, don't use it !
				if (prop_val && !strncmp(prop_val->value.string, "gmem://", 7))
					prop_val = NULL;

				if (!prop_val)
					prop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_URL);

				if (!prop_val && pid->pid->name) {
					prop_val_patched.type = GF_PROP_STRING;
					prop_val_patched.value.string = pid->pid->name;
					prop_val = &prop_val_patched;
				}
			}
			is_file_str = GF_TRUE;
		} else if (!strcmp(name, "PID")) {
			prop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_ID);
		} else if (!strcmp(name, "FS")) {
			str_val = file_suffix ? file_suffix : "";
			is_ok = GF_TRUE;
		} else if (!strcmp(name, "Type")) {
			prop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_STREAM_TYPE);
			if (prop_val) {
				str_val = gf_stream_type_short_name(prop_val->value.uint);
				is_ok = GF_TRUE;
			}
			prop_val = NULL;
		} else if (!strncmp(name, "p4cc=", 5)) {
			if (strlen(name) != 9) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, ("[Filter] wrong length in 4CC template, expecting 4cc=ABCD\n", name));
				is_ok = GF_FALSE;
			} else {
				prop_4cc = GF_4CC(name[5],name[6],name[7],name[8]);
				prop_val = gf_filter_pid_get_property_first(pid, prop_4cc);
				if (!prop_val && pck) {
					prop_val = gf_filter_pck_get_property(pck, prop_4cc);
				}
				if (!prop_val) {
					GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, ("[Filter] no pid property of type %s\n", name+5));
					is_ok = GF_FALSE;
				}
			}
		} else if (!strncmp(name, "pname=", 6)) {
			prop_val = gf_filter_pid_get_property_str_first(pid, name+6);
			if (!prop_val && pck) {
				prop_val = gf_filter_pck_get_property_str(pck, name+6);
			}
			if (!prop_val) {
				GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, ("[Filter] no pid property named %s\n", name+6));
				is_ok = GF_FALSE;
			}
		}
		//DASH reserved
		else if (!strcmp(name, "Number")) {
			do_skip = GF_TRUE;
		} else if (!strcmp(name, "Time")) {
			do_skip = GF_TRUE;
		} else if (!strcmp(name, "RepresentationID")) {
			do_skip = GF_TRUE;
		} else if (!strcmp(name, "Bandwidth")) {
			do_skip = GF_TRUE;
		} else if (!strcmp(name, "SubNumber")) {
			do_skip = GF_TRUE;
		} else if (!strncmp(name, "Init", 4) && (name[4]=='=')) {
			do_skip = GF_TRUE;
		} else if (!strncmp(name, "XInit", 5) && (name[5]=='=')) {
			do_skip = GF_TRUE;
		} else if (!strncmp(name, "Path", 4) && (name[4]=='=')) {
			do_skip = GF_TRUE;
		} else {
			char *next_eq = strchr(name, '=');
			char *next_sep = strchr(name, '$');
			if (!next_eq || (next_eq - name < next_sep - name)) {
				prop_4cc = gf_props_get_id(name);
				//not matching, try with name
				if (!prop_4cc) {
					prop_val = gf_filter_pid_get_property_str_first(pid, name);
					if (!prop_val && pck)
						prop_val = gf_filter_pck_get_property_str(pck, name);
				} else {
					prop_val = gf_filter_pid_get_property_first(pid, prop_4cc);
					if (!prop_val && pck)
						prop_val = gf_filter_pck_get_property(pck, prop_4cc);
				}

				if (!prop_val && pck) {
					if (!strcmp(name, "cts")) {
						prop_val_patched.type = GF_PROP_LUINT;
						prop_val_patched.value.longuint = gf_filter_pck_get_cts(pck);
						prop_val = &prop_val_patched;
					} else if (!strcmp(name, "dts")) {
						prop_val_patched.type = GF_PROP_LUINT;
						prop_val_patched.value.longuint = gf_filter_pck_get_dts(pck);
						prop_val = &prop_val_patched;
					} else if (!strcmp(name, "dur")) {
						prop_val_patched.type = GF_PROP_UINT;
						prop_val_patched.value.uint = gf_filter_pck_get_duration(pck);
						prop_val = &prop_val_patched;
					} else if (!strcmp(name, "sap")) {
						prop_val_patched.type = GF_PROP_UINT;
						prop_val_patched.value.uint = gf_filter_pck_get_sap(pck);
						prop_val = &prop_val_patched;
					}
				}

				if (!prop_val) {
					if (!prop_4cc) {
						GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, ("[Filter] Unrecognized template %s\n", name));
					}
					is_ok = GF_FALSE;
				}
			} else {
				u32 i, len = (u32) (next_sep ? 1+(next_sep - name) : strlen(name) );
				szFinalName[k]='$';
				k++;
				for (i=0; i<len; i++) {
					szFinalName[k] = name[0];
					k++;
					name++;
				}
				szFinalName[k]='$';
				k++;
				sep[0] = '$';
				name = sep+1;
				continue;
			}
		}
		if (fsep) fsep[0] = '%';
		if (do_skip) {
			sep[0] = '$';
			szFinalName[k] = '$';
			k++;
			while (name[0] && (name[0] != '$')) {
				szFinalName[k] = name[0];
				k++;
				name++;
			}
			szFinalName[k] = '$';
			k++;
			name++;


			continue;

		}


		if (!is_ok && !prop_val && prop_4cc) {
			if (prop_4cc==GF_PROP_PID_CROP_POS) {
				prop_val_patched.type = GF_PROP_VEC2I;
				prop_val_patched.value.vec2i.x = 0;
				prop_val_patched.value.vec2i.y = 0;
				prop_val = &prop_val_patched;
				is_ok=GF_TRUE;
			}
			else if (prop_4cc==GF_PROP_PID_ORIG_SIZE) {
				prop_val_patched.type = GF_PROP_VEC2I;
				prop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_WIDTH);
				prop_val_patched.value.vec2i.x = prop_val ? prop_val->value.uint : 0;
				prop_val = gf_filter_pid_get_property_first(pid, GF_PROP_PID_HEIGHT);
				prop_val_patched.value.vec2i.y = prop_val ? prop_val->value.uint : 0;
				prop_val = &prop_val_patched;
				is_ok=GF_TRUE;
			} else {
				GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, ("[Filter] property %s not found for pid, cannot resolve template\n", name));
				return GF_BAD_PARAM;
			}
		}

		if (!is_ok) {
			if (sep) sep[0] = '$';
			return GF_BAD_PARAM;
		}
		if (prop_val) {
			if ((prop_val->type==GF_PROP_UINT) || (prop_val->type==GF_PROP_SINT)) {
				value = prop_val->value.uint;
				has_val = GF_TRUE;
			} else {
				str_val = gf_props_dump_val(prop_val, szPropVal, GF_PROP_DUMP_DATA_NONE, NULL);
			}
		} else if (is_file_str) {
			str_val = filename;
		}
		szTemplateVal[0]=0;
		if (has_val) {
			sprintf(szTemplateVal, szFormat, value);
		} else if (str_val) {
			if (is_file_str) {
				if (!strncmp(str_val, "gfio://", 7))
					str_val = gf_fileio_translate_url(str_val);

				if (filename) {
					strcpy(szTemplateVal, filename);
				} else {
					char *ext, *sname;
					ext = strstr(str_val, "://");
					sname = strrchr(ext ? ext+4 : str_val, '/');
					if (!sname) sname = strrchr(ext ? ext+4 : str_val, '\\');
					if (sname && ext)
						str_val = sname+1;

					if (!sname) sname = (char *) str_val;
					else sname++;

					ext = strrchr(str_val, '.');

					if (ext && (ext > sname) ) {
						u32 len = (u32) (ext - sname);
						strncpy(szTemplateVal, sname, ext - sname);
						szTemplateVal[len] = 0;
					} else {
						strcpy(szTemplateVal, sname);
					}
				}
			} else {
				strcpy(szTemplateVal, str_val);
			}
		} else {
			GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, ("[Filter] property %s not found for pid, cannot resolve template\n", name));
			return GF_BAD_PARAM;
		}
		if (k + strlen(szTemplateVal) > GF_MAX_PATH) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, ("[Filter] Not enough memory to solve file template %s\n", szTemplate));
			return GF_OUT_OF_MEM;
		}

		strcat(szFinalName, szTemplateVal);
		k = (u32) strlen(szFinalName);

		if (!sep) break;
		sep[0] = '$';
		name = sep+1;
	}
	szFinalName[k] = 0;
	return GF_OK;
}
