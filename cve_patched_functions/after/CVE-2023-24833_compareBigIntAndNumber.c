static CallResult<bool> compareBigIntAndNumber(
    Runtime &runtime,
    Handle<BigIntPrimitive> leftHandle,
    double right,
    bool (*comparator)(int)) {
  switch (std::fpclassify(right)) {
    case FP_NAN:
      // BigInt comparison to NaN is always false.
      return false;
    case FP_INFINITE:
      // If rhs is +infinite, it is greater than lhs; otherwise, it is less than
      // rhs.
      return comparator(right > 0 ? -1 : 1);
    default:
      break;
  }

  // Split the rhs into integral and fractional parts.
  double integralPart;
  const double fractionalPart = std::modf(right, &integralPart);

  // Now use the rhs' integral part to create a new BigInt, which is compared to
  // lhs.
  auto rightHandle = BigIntPrimitive::fromDouble(runtime, integralPart);
  if (LLVM_UNLIKELY(rightHandle == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }

  // If rhs' integral part is different than lhs, then use the integral parts'
  // comparison to decide the result.
  if (int comparisonResult = leftHandle->compare(rightHandle->getBigInt())) {
    return comparator(comparisonResult);
  }

  // Lhs' and rhs' integral parts are equal, thus resort the rhs' fractional
  // part.
  if (fractionalPart != 0) {
    //  If rhs is negative, then it is smaller than lhs; otherwise, it is
    //  greater.
    return comparator(right < 0 ? 1 : -1);
  }

  // Lhs' and rhs' integral parts are equal, and rhs does not have a fractional
  // part (it is zero), thus they are equal.
  return comparator(0);
}
