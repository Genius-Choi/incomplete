static int filter_channel(AVFilterContext *ctx, void *arg, int ch, int nb_jobs)
{
    AudioFWTDNContext *s = ctx->priv;
    ThreadData *td = arg;
    AVFrame *in = td->in;
    AVFrame *out = td->out;
    ChannelParams *cp = &s->cp[ch];
    const double *src = (const double *)(in->extended_data[ch]);
    double *dst = (double *)out->extended_data[ch];
    double *absmean = (double *)s->absmean->extended_data[ch];
    double *new_absmean = (double *)s->new_absmean->extended_data[ch];
    double *stddev = (double *)s->stddev->extended_data[ch];
    double *new_stddev = (double *)s->new_stddev->extended_data[ch];
    double *filter = (double *)s->filter->extended_data[ch];
    double is_noise = 0.0;
    int ret;

    ret = forward(s, src, in->nb_samples, cp->output_coefs, cp->output_length, ch, s->sn);
    if (ret < 0)
        return ret;

    if (!s->got_profile && s->need_profile) {
        for (int level = 0; level <= s->levels; level++) {
            const int length = cp->output_length[level];
            const double scale = sqrt(2.0 * log(length));

            stddev[level] = measure_stddev(cp->output_coefs[level], length,
                            measure_mean(cp->output_coefs[level], length)) * scale;
            absmean[level] = measure_absmean(cp->output_coefs[level], length) * scale;
        }
    } else if (!s->got_profile && !s->need_profile && !s->adaptive) {
        for (int level = 0; level <= s->levels; level++) {
            const int length = cp->output_length[level];
            const double scale = sqrt(2.0 * log(length));

            stddev[level] = 0.5 * s->sigma * scale;
            absmean[level] = 0.5 * s->sigma * scale;
        }
    }

    for (int level = 0; level <= s->levels; level++) {
        const int length = cp->output_length[level];
        double vad;

        new_stddev[level] = measure_stddev(cp->output_coefs[level], length,
                            measure_mean(cp->output_coefs[level], length));
        new_absmean[level] = measure_absmean(cp->output_coefs[level], length);
        if (new_absmean[level] <= FLT_EPSILON)
            vad = 1.0;
        else
            vad = new_stddev[level] / new_absmean[level];
        if (level < s->levels)
            is_noise += sqr(vad - 1.232);
    }

    is_noise *= in->sample_rate;
    is_noise /= s->nb_samples;
    for (int level = 0; level <= s->levels; level++) {
        const double percent = ctx->is_disabled ? 0. : s->percent;
        const int length = cp->output_length[level];
        const double scale = sqrt(2.0 * log(length));

        if (is_noise < 0.05 && s->adaptive) {
            stddev[level] = new_stddev[level] * scale;
            absmean[level] = new_absmean[level] * scale;
        }

        noise_filter(stddev[level], cp->output_coefs[level], filter, absmean[level],
                     s->softness, new_stddev[level], length);
        denoise_level(cp->filter_coefs[level], cp->output_coefs[level], filter, percent, length);
    }

    ret = inverse(s, cp->filter_coefs, cp->filter_length, dst, out->nb_samples, ch, s->sn);
    if (ret < 0)
        return ret;

    return 0;
}
