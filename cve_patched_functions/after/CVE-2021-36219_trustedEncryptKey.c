void trustedEncryptKey(int *errStatus, char *errString, char *key,
                 uint8_t *encryptedPrivateKey, uint32_t *enc_len) {

    LOG_DEBUG (__FUNCTION__);

    *errStatus = UNKNOWN_ERROR;

    memset(errString, 0, BUF_LEN);

    checkKey(errStatus, errString, key);

    if (*errStatus != 0) {
        snprintf(errString + strlen(errString), BUF_LEN, "check_key failed");
        return;
    }

    uint32_t sealedLen = sgx_calc_sealed_data_size(0, MAX_KEY_LENGTH);


    if (sealedLen > BUF_LEN) {
        *errStatus = ENCRYPTED_KEY_TOO_LONG;
        snprintf(errString, BUF_LEN, "sealedLen > MAX_ENCRYPTED_KEY_LENGTH");
        return;
    }


    memset(encryptedPrivateKey, 0, BUF_LEN);

    sgx_status_t status = sgx_seal_data(0, NULL, MAX_KEY_LENGTH, (uint8_t *) key, sealedLen,
                                        (sgx_sealed_data_t *) encryptedPrivateKey);
    if (status != SGX_SUCCESS) {
        *errStatus = SEAL_KEY_FAILED;
        snprintf(errString, BUF_LEN, "SGX seal data failed with status %d", status);
        return;
    }

    *enc_len = sealedLen;

    char decryptedKey[BUF_LEN];
    memset(decryptedKey, 0, BUF_LEN);

    trustedDecryptKey(errStatus, errString, encryptedPrivateKey, sealedLen, decryptedKey);

    if (*errStatus != 0) {
        snprintf(errString + strlen(errString), BUF_LEN, ":trustedDecryptKey failed");
        return;
    }

    uint64_t decryptedKeyLen = strnlen(decryptedKey, MAX_KEY_LENGTH);

    if (decryptedKeyLen == MAX_KEY_LENGTH) {
        snprintf(errString, BUF_LEN, "Decrypted key is not null terminated");
        return;
    }


    *errStatus = -8;

    if (strncmp(key, decryptedKey, MAX_KEY_LENGTH) != 0) {
        snprintf(errString, BUF_LEN, "Decrypted key does not match original key");
        return;
    }

    *errStatus = 0;
}
