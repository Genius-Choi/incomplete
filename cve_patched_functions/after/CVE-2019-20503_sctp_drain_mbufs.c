sctp_drain_mbufs(struct sctp_tcb *stcb)
{
	/*
	 * We must hunt this association for MBUF's past the cumack (i.e.
	 * out of order data that we can renege on).
	 */
	struct sctp_association *asoc;
	struct sctp_tmit_chunk *chk, *nchk;
	uint32_t cumulative_tsn_p1;
	struct sctp_queued_to_read *control, *ncontrol;
	int cnt, strmat;
	uint32_t gap, i;
	int fnd = 0;

	/* We look for anything larger than the cum-ack + 1 */

	asoc = &stcb->asoc;
	if (asoc->cumulative_tsn == asoc->highest_tsn_inside_map) {
		/* none we can reneg on. */
		return;
	}
	SCTP_STAT_INCR(sctps_protocol_drains_done);
	cumulative_tsn_p1 = asoc->cumulative_tsn + 1;
	cnt = 0;
	/* Ok that was fun, now we will drain all the inbound streams? */
	for (strmat = 0; strmat < asoc->streamincnt; strmat++) {
		TAILQ_FOREACH_SAFE(control, &asoc->strmin[strmat].inqueue, next_instrm, ncontrol) {
#ifdef INVARIANTS
			if (control->on_strm_q != SCTP_ON_ORDERED ) {
				panic("Huh control: %p on_q: %d -- not ordered?",
				      control, control->on_strm_q);
			}
#endif
			if (SCTP_TSN_GT(control->sinfo_tsn, cumulative_tsn_p1)) {
				/* Yep it is above cum-ack */
				cnt++;
				SCTP_CALC_TSN_TO_GAP(gap, control->sinfo_tsn, asoc->mapping_array_base_tsn);
				KASSERT(control->length > 0, ("control has zero length"));
				if (asoc->size_on_all_streams >= control->length) {
					asoc->size_on_all_streams -= control->length;
				} else {
#ifdef INVARIANTS
					panic("size_on_all_streams = %u smaller than control length %u", asoc->size_on_all_streams, control->length);
#else
					asoc->size_on_all_streams = 0;
#endif
				}
				sctp_ucount_decr(asoc->cnt_on_all_streams);
				SCTP_UNSET_TSN_PRESENT(asoc->mapping_array, gap);
				if (control->on_read_q) {
					TAILQ_REMOVE(&stcb->sctp_ep->read_queue, control, next);
					control->on_read_q = 0;
				}
				TAILQ_REMOVE(&asoc->strmin[strmat].inqueue, control, next_instrm);
				control->on_strm_q = 0;
				if (control->data) {
					sctp_m_freem(control->data);
					control->data = NULL;
				}
				sctp_free_remote_addr(control->whoFrom);
				/* Now its reasm? */
				TAILQ_FOREACH_SAFE(chk, &control->reasm, sctp_next, nchk) {
					cnt++;
					SCTP_CALC_TSN_TO_GAP(gap, chk->rec.data.tsn, asoc->mapping_array_base_tsn);
					KASSERT(chk->send_size > 0, ("chunk has zero length"));
					if (asoc->size_on_reasm_queue >= chk->send_size) {
						asoc->size_on_reasm_queue -= chk->send_size;
					} else {
#ifdef INVARIANTS
						panic("size_on_reasm_queue = %u smaller than chunk length %u", asoc->size_on_reasm_queue, chk->send_size);
#else
						asoc->size_on_reasm_queue = 0;
#endif
					}
					sctp_ucount_decr(asoc->cnt_on_reasm_queue);
					SCTP_UNSET_TSN_PRESENT(asoc->mapping_array, gap);
					TAILQ_REMOVE(&control->reasm, chk, sctp_next);
					if (chk->data) {
						sctp_m_freem(chk->data);
						chk->data = NULL;
					}
					sctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);
				}
				sctp_free_a_readq(stcb, control);
			}
		}
		TAILQ_FOREACH_SAFE(control, &asoc->strmin[strmat].uno_inqueue, next_instrm, ncontrol) {
#ifdef INVARIANTS
			if (control->on_strm_q != SCTP_ON_UNORDERED ) {
				panic("Huh control: %p on_q: %d -- not unordered?",
				      control, control->on_strm_q);
			}
#endif
			if (SCTP_TSN_GT(control->sinfo_tsn, cumulative_tsn_p1)) {
				/* Yep it is above cum-ack */
				cnt++;
				SCTP_CALC_TSN_TO_GAP(gap, control->sinfo_tsn, asoc->mapping_array_base_tsn);
				KASSERT(control->length > 0, ("control has zero length"));
				if (asoc->size_on_all_streams >= control->length) {
					asoc->size_on_all_streams -= control->length;
				} else {
#ifdef INVARIANTS
					panic("size_on_all_streams = %u smaller than control length %u", asoc->size_on_all_streams, control->length);
#else
					asoc->size_on_all_streams = 0;
#endif
				}
				sctp_ucount_decr(asoc->cnt_on_all_streams);
				SCTP_UNSET_TSN_PRESENT(asoc->mapping_array, gap);
				if (control->on_read_q) {
					TAILQ_REMOVE(&stcb->sctp_ep->read_queue, control, next);
					control->on_read_q = 0;
				}
				TAILQ_REMOVE(&asoc->strmin[strmat].uno_inqueue, control, next_instrm);
				control->on_strm_q = 0;
				if (control->data) {
					sctp_m_freem(control->data);
					control->data = NULL;
				}
				sctp_free_remote_addr(control->whoFrom);
				/* Now its reasm? */
				TAILQ_FOREACH_SAFE(chk, &control->reasm, sctp_next, nchk) {
					cnt++;
					SCTP_CALC_TSN_TO_GAP(gap, chk->rec.data.tsn, asoc->mapping_array_base_tsn);
					KASSERT(chk->send_size > 0, ("chunk has zero length"));
					if (asoc->size_on_reasm_queue >= chk->send_size) {
						asoc->size_on_reasm_queue -= chk->send_size;
					} else {
#ifdef INVARIANTS
						panic("size_on_reasm_queue = %u smaller than chunk length %u", asoc->size_on_reasm_queue, chk->send_size);
#else
						asoc->size_on_reasm_queue = 0;
#endif
					}
					sctp_ucount_decr(asoc->cnt_on_reasm_queue);
					SCTP_UNSET_TSN_PRESENT(asoc->mapping_array, gap);
					TAILQ_REMOVE(&control->reasm, chk, sctp_next);
					if (chk->data) {
						sctp_m_freem(chk->data);
						chk->data = NULL;
					}
					sctp_free_a_chunk(stcb, chk, SCTP_SO_NOT_LOCKED);
				}
				sctp_free_a_readq(stcb, control);
			}
		}
	}
	if (cnt) {
		/* We must back down to see what the new highest is */
		for (i = asoc->highest_tsn_inside_map; SCTP_TSN_GE(i, asoc->mapping_array_base_tsn); i--) {
			SCTP_CALC_TSN_TO_GAP(gap, i, asoc->mapping_array_base_tsn);
			if (SCTP_IS_TSN_PRESENT(asoc->mapping_array, gap)) {
				asoc->highest_tsn_inside_map = i;
				fnd = 1;
				break;
			}
		}
		if (!fnd) {
			asoc->highest_tsn_inside_map = asoc->mapping_array_base_tsn - 1;
		}

		/*
		 * Question, should we go through the delivery queue? The only
		 * reason things are on here is the app not reading OR a p-d-api up.
		 * An attacker COULD send enough in to initiate the PD-API and then
		 * send a bunch of stuff to other streams... these would wind up on
		 * the delivery queue.. and then we would not get to them. But in
		 * order to do this I then have to back-track and un-deliver
		 * sequence numbers in streams.. el-yucko. I think for now we will
		 * NOT look at the delivery queue and leave it to be something to
		 * consider later. An alternative would be to abort the P-D-API with
		 * a notification and then deliver the data.... Or another method
		 * might be to keep track of how many times the situation occurs and
		 * if we see a possible attack underway just abort the association.
		 */
#ifdef SCTP_DEBUG
		SCTPDBG(SCTP_DEBUG_PCB1, "Freed %d chunks from reneg harvest\n", cnt);
#endif
		/*
		 * Now do we need to find a new
		 * asoc->highest_tsn_inside_map?
		 */
		asoc->last_revoke_count = cnt;
		(void)SCTP_OS_TIMER_STOP(&stcb->asoc.dack_timer.timer);
		/*sa_ignore NO_NULL_CHK*/
		sctp_send_sack(stcb, SCTP_SO_NOT_LOCKED);
		sctp_chunk_output(stcb->sctp_ep, stcb, SCTP_OUTPUT_FROM_DRAIN, SCTP_SO_NOT_LOCKED);
	}
	/*
	 * Another issue, in un-setting the TSN's in the mapping array we
	 * DID NOT adjust the highest_tsn marker.  This will cause one of two
	 * things to occur. It may cause us to do extra work in checking for
	 * our mapping array movement. More importantly it may cause us to
	 * SACK every datagram. This may not be a bad thing though since we
	 * will recover once we get our cum-ack above and all this stuff we
	 * dumped recovered.
	 */
}
