int tport_bind_client(tport_master_t *mr,
                      tp_name_t const *tpn,
                      char const * const transports[],
		      enum tport_via public,
		      tagi_t *tags)
{
  int i;
  tport_primary_t *pri = NULL, **tbf;
  tp_name_t tpn0[1] = {{ "*", "*", "*", "*", NULL, NULL }};
  char const *why = "unknown";

  tport_vtable_t const *vtable;

  if (public == tport_type_local)
    public = tport_type_client;

  SU_DEBUG_5(("%s(%p) to " TPN_FORMAT "\n",
	      __func__, (void *)mr, TPN_ARGS(tpn)));

  memset(tpn0, 0, sizeof(tpn0));

  for (tbf = &mr->mr_primaries; *tbf; tbf = &(*tbf)->pri_next)
    ;

  for (i = 0; transports[i]; i++) {
    su_addrinfo_t hints[1];
    char const *proto = transports[i];

    if (strcmp(proto, tpn->tpn_proto) != 0 &&
        strcmp(tpn->tpn_proto, tpn_any) != 0)
      continue;

    vtable = tport_vtable_by_name(proto, public);
    if (!vtable)
      continue;

    /* Resolve protocol, skip unknown transport protocols */
    if (getprotohints(hints, proto, AI_PASSIVE) < 0)
      continue;

    tpn0->tpn_proto = proto;
    tpn0->tpn_comp = tpn->tpn_comp;
    tpn0->tpn_ident = tpn->tpn_ident;

    hints->ai_canonname = "*";

    if (!(pri = tport_alloc_primary(mr, vtable, tpn0, hints, tags, &why)))
      break;

    pri->pri_public = tport_type_client; /* XXX */
  }

  if (!pri) {
    SU_DEBUG_3(("tport_alloc_primary: %s failed\n", why));
    tport_zap_primary(*tbf);
  }

  return pri ? 0 : -1;
}
