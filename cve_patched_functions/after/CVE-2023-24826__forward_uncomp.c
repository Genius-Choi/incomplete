static void _forward_uncomp(gnrc_netif_hdr_t *netif_hdr, gnrc_pktsnip_t *pkt,
                            unsigned page, _generic_rb_entry_t *entry,
                            void *payload)
{
    sixlowpan_sfr_rfrag_t *hdr = pkt->data;
    gnrc_sixlowpan_frag_rb_base_t vrb_base = {
        .src_len = netif_hdr->src_l2addr_len,
        .tag = hdr->base.tag,
        .datagram_size = sixlowpan_sfr_rfrag_get_offset(hdr),
    };
    gnrc_pktsnip_t tmp = {
        .data = payload,
        .size = pkt->size - sizeof(sixlowpan_sfr_rfrag_t) - 1,
        .users = 1,
    };

    switch (page) {
#if defined(MODULE_GNRC_IPV6)
        case 0: {
            ipv6_hdr_t *ipv6_hdr = tmp.data;

            if (ipv6_hdr->hl <= 1) {
                DEBUG("6lo sfr: minimal hop-limit reached\n");
                /* try to reassemble to hand to IPv6 module for error
                 * handling */
                _try_reassembly(netif_hdr, pkt, 0, entry, page);
                return;
            }
            tmp.type = GNRC_NETTYPE_IPV6;
            break;
        }
#endif
        default:
            tmp.type = GNRC_NETTYPE_UNDEF;
            break;
    }
    vrb_base.arrival = xtimer_now_usec();
    memcpy(vrb_base.src, gnrc_netif_hdr_get_src_addr(netif_hdr),
           vrb_base.src_len);
    entry->entry.vrb = gnrc_sixlowpan_frag_vrb_from_route(&vrb_base,
                                                          NULL, &tmp);
    if (entry->entry.vrb == NULL) {
        DEBUG("6lo sfr: no route found or no VRB space left, "
              "trying reassembly\n");
        _try_reassembly(netif_hdr, pkt, 0, entry, page);
        return;
    }
    /* only decrement hop-limit after check in case we reassemble */
    switch (page) {
#if defined(MODULE_GNRC_IPV6)
        case 0: {
            ipv6_hdr_t *ipv6_hdr = tmp.data;

            ipv6_hdr->hl--;
            break;
        }
#endif
        default:
            break;
    }
    entry->type = _VRB;
    entry->entry.vrb->in_netif = gnrc_netif_hdr_get_netif(netif_hdr);
    entry->entry.vrb->offset_diff = 0; /* packet is uncompressed so offset
                                        * does not change */
    _forward_rfrag(pkt, entry, sixlowpan_sfr_rfrag_get_offset(hdr), page);
}
