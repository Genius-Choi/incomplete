char_entity(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t max_rewind, size_t max_lookbehind, size_t size)
{
	size_t end = 1;
	size_t content_start;
	size_t content_end;
	struct buf work = { 0, 0, 0, 0 };
	int numeric = 0;
	int hex = 0;
	int entity_base;
	uint32_t entity_val;

	if (end < size && data[end] == '#') {
		numeric = 1;
		end++;
	}

	if (end < size && numeric && tolower(data[end]) == 'x') {
		hex = 1;
		end++;
	}

	content_start = end;

	while (end < size) {
		const char c = data[end];
		if (hex) {
			if (!isxdigit(c)) break;
		} else if (numeric) {
			if (!isdigit(c)) break;
		} else if (!isalnum(c)) {
			break;
		}
		end++;
	}

	content_end = end;

	if (end > content_start && end < size && data[end] == ';')
		end++; /* well-formed entity */
	else
		return 0; /* not an entity */

	/* way too long to be a valid numeric entity */
	if (numeric && content_end - content_start > MAX_NUM_ENTITY_LEN)
		return 0;

	/* Validate the entity's contents */
	if (numeric) {
		if (hex)
			entity_base = 16;
		else
			entity_base = 10;

		// This is ok because  it'll stop once it hits the ';'
		entity_val = strtol((char*)data + content_start, NULL, entity_base);
		if (!is_valid_numeric_entity(entity_val))
			return 0;
	} else {
		if (!is_allowed_named_entity((const char *)data, end))
			return 0;
	}

	if (rndr->cb.entity) {
		work.data = data;
		work.size = end;
		rndr->cb.entity(ob, &work, rndr->opaque);
	} else {
		/* Necessary so we can normalize `&#X3E;` to `&#x3E;` */
		bufputc(ob, '&');
		if (numeric)
			bufputc(ob, '#');
		if (hex)
			bufputc(ob, 'x');
		bufput(ob, data + content_start, end - content_start);
	}

	return end;
}
