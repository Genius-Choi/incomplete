void CZNC::Loop() {
    while (true) {
        CString sError;

        ConfigState eState = GetConfigState();
        switch (eState) {
            case ECONFIG_NEED_REHASH:
                SetConfigState(ECONFIG_NOTHING);

                if (RehashConfig(sError)) {
                    Broadcast("Rehashing succeeded", true);
                } else {
                    Broadcast("Rehashing failed: " + sError, true);
                    Broadcast("ZNC is in some possibly inconsistent state!",
                              true);
                }
                break;
            case ECONFIG_DELAYED_WRITE:
                SetConfigState(ECONFIG_NOTHING);

                if (GetConfigWriteDelay() > 0) {
                    if (m_pConfigTimer == nullptr) {
                        m_pConfigTimer = new CConfigWriteTimer(GetConfigWriteDelay());
                        GetManager().AddCron(m_pConfigTimer);
                    }
                    break;
                }
                /* Fall through */
            case ECONFIG_NEED_WRITE:
            case ECONFIG_NEED_VERBOSE_WRITE:
                SetConfigState(ECONFIG_NOTHING);

                // stop pending configuration timer
                DisableConfigTimer();

                if (!WriteConfig()) {
                    Broadcast("Writing the config file failed", true);
                } else if (eState == ECONFIG_NEED_VERBOSE_WRITE) {
                    Broadcast("Writing the config succeeded", true);
                }
                break;
            case ECONFIG_NOTHING:
                break;
            case ECONFIG_NEED_QUIT:
                return;
        }

        // Check for users that need to be deleted
        if (HandleUserDeletion()) {
            // Also remove those user(s) from the config file
            WriteConfig();
        }

        // Csocket wants micro seconds
        // 100 msec to 5 min
        m_Manager.DynamicSelectLoop(100 * 1000, 5 * 60 * 1000 * 1000);
    }
}
