pf_state_key_attach(struct pf_state_key *sk, struct pf_state *st, int idx)
{
	struct pf_state_item	*si;
	struct pf_state_key     *cur;
	struct pf_state		*oldst = NULL;

	PF_ASSERT_LOCKED();

	KASSERT(st->key[idx] == NULL);
	sk->sk_removed = 0;
	cur = RBT_INSERT(pf_state_tree, &pf_statetbl, sk);
	if (cur != NULL) {
		sk->sk_removed = 1;
		/* key exists. check for same kif, if none, add to key */
		TAILQ_FOREACH(si, &cur->sk_states, si_entry) {
			struct pf_state *sist = si->si_st;
			if (sist->kif == st->kif &&
			    ((sist->key[PF_SK_WIRE]->af == sk->af &&
			     sist->direction == st->direction) ||
			    (sist->key[PF_SK_WIRE]->af !=
			     sist->key[PF_SK_STACK]->af &&
			     sk->af == sist->key[PF_SK_STACK]->af &&
			     sist->direction != st->direction))) {
				int reuse = 0;

				if (sk->proto == IPPROTO_TCP &&
				    sist->src.state >= TCPS_FIN_WAIT_2 &&
				    sist->dst.state >= TCPS_FIN_WAIT_2)
					reuse = 1;
				if (pf_status.debug >= LOG_NOTICE) {
					log(LOG_NOTICE,
					    "pf: %s key attach %s on %s: ",
					    (idx == PF_SK_WIRE) ?
					    "wire" : "stack",
					    reuse ? "reuse" : "failed",
					    st->kif->pfik_name);
					pf_print_state_parts(st,
					    (idx == PF_SK_WIRE) ?  sk : NULL,
					    (idx == PF_SK_STACK) ?  sk : NULL);
					addlog(", existing: ");
					pf_print_state_parts(sist,
					    (idx == PF_SK_WIRE) ?  sk : NULL,
					    (idx == PF_SK_STACK) ?  sk : NULL);
					addlog("\n");
				}
				if (reuse) {
					pf_set_protostate(sist, PF_PEER_BOTH,
					    TCPS_CLOSED);
					/* remove late or sks can go away */
					oldst = sist;
				} else {
					pf_state_key_unref(sk);
					return (NULL);	/* collision! */
				}
			}
		}

		/* reuse the existing state key */
		pf_state_key_unref(sk);
		sk = cur;
	}

	if ((si = pool_get(&pf_state_item_pl, PR_NOWAIT)) == NULL) {
		if (TAILQ_EMPTY(&sk->sk_states)) {
			KASSERT(cur == NULL);
			RBT_REMOVE(pf_state_tree, &pf_statetbl, sk);
			sk->sk_removed = 1;
			pf_state_key_unref(sk);
		}

		return (NULL);
	}

	st->key[idx] = pf_state_key_ref(sk); /* give a ref to state */
	si->si_st = pf_state_ref(st);

	/* list is sorted, if-bound states before floating */
	if (st->kif == pfi_all)
		TAILQ_INSERT_TAIL(&sk->sk_states, si, si_entry);
	else
		TAILQ_INSERT_HEAD(&sk->sk_states, si, si_entry);

	if (oldst)
		pf_remove_state(oldst);

	/* caller owns the pf_state ref, which owns a pf_state_key ref now */
	return (sk);
}
