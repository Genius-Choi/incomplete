bool Filter::maybeRetryReset(Http::StreamResetReason reset_reason,
                             UpstreamRequest& upstream_request) {
  // We don't retry if we already started the response, don't have a retry policy defined,
  // or if we've already retried this upstream request (currently only possible if a per
  // try timeout occurred and hedge_on_per_try_timeout is enabled).
  if (downstream_response_started_ || !retry_state_ || upstream_request.retried()) {
    return false;
  }
  RetryState::Http3Used was_using_http3 = RetryState::Http3Used::Unknown;
  if (conn_pool_new_stream_with_early_data_and_http3_ && upstream_request.hadUpstream()) {
    was_using_http3 = (upstream_request.streamInfo().protocol().has_value() &&
                       upstream_request.streamInfo().protocol().value() == Http::Protocol::Http3)
                          ? RetryState::Http3Used::Yes
                          : RetryState::Http3Used::No;
  }
  const RetryStatus retry_status = retry_state_->shouldRetryReset(
      reset_reason, was_using_http3,
      [this, can_send_early_data = upstream_request.upstreamStreamOptions().can_send_early_data_,
       can_use_http3 =
           upstream_request.upstreamStreamOptions().can_use_http3_](bool disable_http3) -> void {
        // This retry might be because of ConnectionFailure of 0-RTT handshake. In this case, though
        // the original request is retried with the same can_send_early_data setting, it will not be
        // sent as early data by the underlying connection pool grid.
        doRetry(can_send_early_data, disable_http3 ? false : can_use_http3);
      });
  if (retry_status == RetryStatus::Yes) {
    runRetryOptionsPredicates(upstream_request);
    pending_retries_++;

    if (upstream_request.upstreamHost()) {
      upstream_request.upstreamHost()->stats().rq_error_.inc();
    }

    auto request_ptr = upstream_request.removeFromList(upstream_requests_);
    if (Runtime::runtimeFeatureEnabled("envoy.reloadable_features.allow_upstream_inline_write")) {
      request_ptr->cleanUp();
      callbacks_->dispatcher().deferredDelete(std::move(request_ptr));
    }
    return true;
  } else if (retry_status == RetryStatus::NoOverflow) {
    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamOverflow);
  } else if (retry_status == RetryStatus::NoRetryLimitExceeded) {
    callbacks_->streamInfo().setResponseFlag(StreamInfo::ResponseFlag::UpstreamRetryLimitExceeded);
  }

  return false;
}
