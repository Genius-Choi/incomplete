typedArrayPrototypeCopyWithin(void *, Runtime &runtime, NativeArgs args) {
  if (JSTypedArrayBase::validateTypedArray(
          runtime, args.getThisHandle(), true) == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }

  GCScope gcScope{runtime};

  auto O = args.vmcastThis<JSTypedArrayBase>();

  // The this objectâ€™s [[ArrayLength]] internal slot is accessed in place of
  // performing a [[Get]] of "length".
  double len = O->getLength();

  // 5. Let relativeTarget be ToIntegerOrInfinity(target).
  // 6. ReturnIfAbrupt(relativeTarget).
  auto relativeTargetRes = toIntegerOrInfinity(runtime, args.getArgHandle(0));
  if (LLVM_UNLIKELY(relativeTargetRes == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  double relativeTarget = relativeTargetRes->getNumber();

  // 7. If relativeTarget < 0, let to be max((len + relativeTarget),0); else let
  // to be min(relativeTarget, len).
  double to = convertNegativeBoundsRelativeToLength(relativeTarget, len);

  // 8. Let relativeStart be ToIntegerOrInfinity(start).
  // 9. ReturnIfAbrupt(relativeStart).
  auto relativeStartRes = toIntegerOrInfinity(runtime, args.getArgHandle(1));
  if (LLVM_UNLIKELY(relativeStartRes == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  double relativeStart = relativeStartRes->getNumber();

  // 10. If relativeStart < 0, let from be max((len + relativeStart),0); else
  // let from be min(relativeStart, len).
  double from = convertNegativeBoundsRelativeToLength(relativeStart, len);

  // 11. If end is undefined, let relativeEnd be len; else let relativeEnd be
  // ToIntegerOrInfinity(end).
  // 12. ReturnIfAbrupt(relativeEnd).
  double relativeEnd;
  if (args.getArg(2).isUndefined()) {
    relativeEnd = len;
  } else {
    auto relativeEndRes = toIntegerOrInfinity(runtime, args.getArgHandle(2));
    if (LLVM_UNLIKELY(relativeEndRes == ExecutionStatus::EXCEPTION)) {
      return ExecutionStatus::EXCEPTION;
    }
    relativeEnd = relativeEndRes->getNumber();
  }

  // 13. If relativeEnd < 0, let final be max((len + relativeEnd),0); else let
  // final be min(relativeEnd, len).
  double fin = convertNegativeBoundsRelativeToLength(relativeEnd, len);

  // 14. Let count be min(final-from, len-to).
  double count = std::min(fin - from, len - to);

  int direction;
  if (from < to && to < from + count) {
    // 15. If from<to and to<from+count
    // a. Let direction be -1.
    direction = -1;
    // b. Let from be from + count -1.
    from = from + count - 1;
    // c. Let to be to + count -1.
    to = to + count - 1;
  } else {
    // 16. Else,
    // a. Let direction = 1.
    direction = 1;
  }

  // Need to case on the TypedArray type to avoid encoding using HermesValues.
  // We need to preserve the bit-level encoding of values, and HermesValues
  // destroy information, e.g. which NaN is being used.
#define TYPED_ARRAY(name, type)                                            \
  case CellKind::name##ArrayKind: {                                        \
    auto *arr = vmcast<JSTypedArray<type, CellKind::name##ArrayKind>>(*O); \
    if (!arr->attached(runtime)) {                                         \
      return runtime.raiseTypeError(                                       \
          "Underlying ArrayBuffer detached after calling copyWithin");     \
    }                                                                      \
    while (count > 0) {                                                    \
      arr->at(runtime, to) = arr->at(runtime, from);                       \
      from += direction;                                                   \
      to += direction;                                                     \
      --count;                                                             \
    }                                                                      \
    break;                                                                 \
  }

  switch (O->getKind()) {
#include "hermes/VM/TypedArrays.def"
    default:
      llvm_unreachable("Invalid TypedArray after ValidateTypedArray call");
  }

  return O.getHermesValue();
}
