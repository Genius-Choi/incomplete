static int get_input(struct mansession *s, char *output)
{
	int res, x;
	int maxlen = sizeof(s->session->inbuf) - 1;
	char *src = s->session->inbuf;
	int timeout = -1;
	time_t now;

	/*
	 * Look for \r\n within the buffer. If found, copy to the output
	 * buffer and return, trimming the \r\n (not used afterwards).
	 */
	for (x = 0; x < s->session->inlen; x++) {
		int cr;	/* set if we have \r */
		if (src[x] == '\r' && x+1 < s->session->inlen && src[x + 1] == '\n') {
			cr = 2;	/* Found. Update length to include \r\n */
		} else if (src[x] == '\n') {
			cr = 1;	/* also accept \n only */
		} else {
			continue;
		}
		memmove(output, src, x);	/*... but trim \r\n */
		output[x] = '\0';		/* terminate the string */
		x += cr;			/* number of bytes used */
		s->session->inlen -= x;			/* remaining size */
		memmove(src, src + x, s->session->inlen); /* remove used bytes */
		return 1;
	}
	if (s->session->inlen >= maxlen) {
		/* no crlf found, and buffer full - sorry, too long for us
		 * keep the last character in case we are in the middle of a CRLF. */
		ast_log(LOG_WARNING, "Discarding message from %s. Line too long: %.25s...\n", ast_sockaddr_stringify_addr(&s->session->addr), src);
		src[0] = src[s->session->inlen - 1];
		s->session->inlen = 1;
		s->parsing = MESSAGE_LINE_TOO_LONG;
	}
	res = 0;
	while (res == 0) {
		/* calculate a timeout if we are not authenticated */
		if (!s->session->authenticated) {
			if(time(&now) == -1) {
				ast_log(LOG_ERROR, "error executing time(): %s\n", strerror(errno));
				return -1;
			}

			timeout = (authtimeout - (now - s->session->authstart)) * 1000;
			if (timeout < 0) {
				/* we have timed out */
				return 0;
			}
		}

		ast_mutex_lock(&s->session->notify_lock);
		if (s->session->pending_event) {
			s->session->pending_event = 0;
			ast_mutex_unlock(&s->session->notify_lock);
			return 0;
		}
		s->session->waiting_thread = pthread_self();
		ast_mutex_unlock(&s->session->notify_lock);

		res = ast_wait_for_input(ast_iostream_get_fd(s->session->stream), timeout);

		ast_mutex_lock(&s->session->notify_lock);
		s->session->waiting_thread = AST_PTHREADT_NULL;
		ast_mutex_unlock(&s->session->notify_lock);
	}
	if (res < 0) {
		if (s->session->kicked) {
			ast_debug(1, "Manager session has been kicked\n");
			return -1;
		}
		/* If we get a signal from some other thread (typically because
		 * there are new events queued), return 0 to notify the caller.
		 */
		if (errno == EINTR || errno == EAGAIN) {
			return 0;
		}
		ast_log(LOG_WARNING, "poll() returned error: %s\n", strerror(errno));
		return -1;
	}

	ao2_lock(s->session);
	res = ast_iostream_read(s->session->stream, src + s->session->inlen, maxlen - s->session->inlen);
	if (res < 1) {
		res = -1;	/* error return */
	} else {
		s->session->inlen += res;
		src[s->session->inlen] = '\0';
		res = 0;
	}
	ao2_unlock(s->session);
	return res;
}
