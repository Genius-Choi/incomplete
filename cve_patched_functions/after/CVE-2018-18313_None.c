S_regclass(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth,
                 const bool stop_at_1,  /* Just parse the next thing, don't
                                           look for a full character class */
                 bool allow_multi_folds,
                 const bool silence_non_portable,   /* Don't output warnings
                                                       about too large
                                                       characters */
                 const bool strict,
                 bool optimizable,                  /* ? Allow a non-ANYOF return
                                                       node */
                 SV** ret_invlist, /* Return an inversion list, not a node */
                 AV** return_posix_warnings
          )
{
    /* parse a bracketed class specification.  Most of these will produce an
     * ANYOF node; but something like [a] will produce an EXACT node; [aA], an
     * EXACTFish node; [[:ascii:]], a POSIXA node; etc.  It is more complex
     * under /i with multi-character folds: it will be rewritten following the
     * paradigm of this example, where the <multi-fold>s are characters which
     * fold to multiple character sequences:
     *      /[abc\x{multi-fold1}def\x{multi-fold2}ghi]/i
     * gets effectively rewritten as:
     *      /(?:\x{multi-fold1}|\x{multi-fold2}|[abcdefghi]/i
     * reg() gets called (recursively) on the rewritten version, and this
     * function will return what it constructs.  (Actually the <multi-fold>s
     * aren't physically removed from the [abcdefghi], it's just that they are
     * ignored in the recursion by means of a flag:
     * <RExC_in_multi_char_class>.)
     *
     * ANYOF nodes contain a bit map for the first NUM_ANYOF_CODE_POINTS
     * characters, with the corresponding bit set if that character is in the
     * list.  For characters above this, a range list or swash is used.  There
     * are extra bits for \w, etc. in locale ANYOFs, as what these match is not
     * determinable at compile time
     *
     * Returns NULL, setting *flagp to RESTART_PASS1 if the sizing scan needs
     * to be restarted, or'd with NEED_UTF8 if the pattern needs to be upgraded
     * to UTF-8.  This can only happen if ret_invlist is non-NULL.
     */

    UV prevvalue = OOB_UNICODE, save_prevvalue = OOB_UNICODE;
    IV range = 0;
    UV value = OOB_UNICODE, save_value = OOB_UNICODE;
    regnode *ret;
    STRLEN numlen;
    int namedclass = OOB_NAMEDCLASS;
    char *rangebegin = NULL;
    bool need_class = 0;
    SV *listsv = NULL;
    STRLEN initial_listsv_len = 0; /* Kind of a kludge to see if it is more
				      than just initialized.  */
    SV* properties = NULL;    /* Code points that match \p{} \P{} */
    SV* posixes = NULL;     /* Code points that match classes like [:word:],
                               extended beyond the Latin1 range.  These have to
                               be kept separate from other code points for much
                               of this function because their handling  is
                               different under /i, and for most classes under
                               /d as well */
    SV* nposixes = NULL;    /* Similarly for [:^word:].  These are kept
                               separate for a while from the non-complemented
                               versions because of complications with /d
                               matching */
    SV* simple_posixes = NULL; /* But under some conditions, the classes can be
                                  treated more simply than the general case,
                                  leading to less compilation and execution
                                  work */
    UV element_count = 0;   /* Number of distinct elements in the class.
			       Optimizations may be possible if this is tiny */
    AV * multi_char_matches = NULL; /* Code points that fold to more than one
                                       character; used under /i */
    UV n;
    char * stop_ptr = RExC_end;    /* where to stop parsing */

    /* ignore unescaped whitespace? */
    const bool skip_white = cBOOL(   ret_invlist
                                  || (RExC_flags & RXf_PMf_EXTENDED_MORE));

    /* Unicode properties are stored in a swash; this holds the current one
     * being parsed.  If this swash is the only above-latin1 component of the
     * character class, an optimization is to pass it directly on to the
     * execution engine.  Otherwise, it is set to NULL to indicate that there
     * are other things in the class that have to be dealt with at execution
     * time */
    SV* swash = NULL;		/* Code points that match \p{} \P{} */

    /* Set if a component of this character class is user-defined; just passed
     * on to the engine */
    bool has_user_defined_property = FALSE;

    /* inversion list of code points this node matches only when the target
     * string is in UTF-8.  These are all non-ASCII, < 256.  (Because is under
     * /d) */
    SV* has_upper_latin1_only_utf8_matches = NULL;

    /* Inversion list of code points this node matches regardless of things
     * like locale, folding, utf8ness of the target string */
    SV* cp_list = NULL;

    /* Like cp_list, but code points on this list need to be checked for things
     * that fold to/from them under /i */
    SV* cp_foldable_list = NULL;

    /* Like cp_list, but code points on this list are valid only when the
     * runtime locale is UTF-8 */
    SV* only_utf8_locale_list = NULL;

    /* In a range, if one of the endpoints is non-character-set portable,
     * meaning that it hard-codes a code point that may mean a different
     * charactger in ASCII vs. EBCDIC, as opposed to, say, a literal 'A' or a
     * mnemonic '\t' which each mean the same character no matter which
     * character set the platform is on. */
    unsigned int non_portable_endpoint = 0;

    /* Is the range unicode? which means on a platform that isn't 1-1 native
     * to Unicode (i.e. non-ASCII), each code point in it should be considered
     * to be a Unicode value.  */
    bool unicode_range = FALSE;
    bool invert = FALSE;    /* Is this class to be complemented */

    bool warn_super = ALWAYS_WARN_SUPER;

    regnode * const orig_emit = RExC_emit; /* Save the original RExC_emit in
        case we need to change the emitted regop to an EXACT. */
    const char * orig_parse = RExC_parse;
    const SSize_t orig_size = RExC_size;
    bool posixl_matches_all = FALSE; /* Does /l class have both e.g. \W,\w ? */

    /* This variable is used to mark where the end in the input is of something
     * that looks like a POSIX construct but isn't.  During the parse, when
     * something looks like it could be such a construct is encountered, it is
     * checked for being one, but not if we've already checked this area of the
     * input.  Only after this position is reached do we check again */
    char *not_posix_region_end = RExC_parse - 1;

    AV* posix_warnings = NULL;
    const bool do_posix_warnings =     return_posix_warnings
                                   || (PASS2 && ckWARN(WARN_REGEXP));

    GET_RE_DEBUG_FLAGS_DECL;

    PERL_ARGS_ASSERT_REGCLASS;
#ifndef DEBUGGING
    PERL_UNUSED_ARG(depth);
#endif

    DEBUG_PARSE("clas");

#if UNICODE_MAJOR_VERSION < 3 /* no multifolds in early Unicode */      \
    || (UNICODE_MAJOR_VERSION == 3 && UNICODE_DOT_VERSION == 0          \
                                   && UNICODE_DOT_DOT_VERSION == 0)
    allow_multi_folds = FALSE;
#endif

    /* Assume we are going to generate an ANYOF node. */
    ret = reganode(pRExC_state,
                   (LOC)
                    ? ANYOFL
                    : ANYOF,
                   0);

    if (SIZE_ONLY) {
	RExC_size += ANYOF_SKIP;
	listsv = &PL_sv_undef; /* For code scanners: listsv always non-NULL. */
    }
    else {
        ANYOF_FLAGS(ret) = 0;

 	RExC_emit += ANYOF_SKIP;
	listsv = newSVpvs_flags("# comment\n", SVs_TEMP);
	initial_listsv_len = SvCUR(listsv);
        SvTEMP_off(listsv); /* Grr, TEMPs and mortals are conflated.  */
    }

    SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);

    assert(RExC_parse <= RExC_end);

    if (UCHARAT(RExC_parse) == '^') {	/* Complement the class */
	RExC_parse++;
        invert = TRUE;
        allow_multi_folds = FALSE;
        MARK_NAUGHTY(1);
        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);
    }

    /* Check that they didn't say [:posix:] instead of [[:posix:]] */
    if (! ret_invlist && MAYBE_POSIXCC(UCHARAT(RExC_parse))) {
        int maybe_class = handle_possible_posix(pRExC_state,
                                                RExC_parse,
                                                &not_posix_region_end,
                                                NULL,
                                                TRUE /* checking only */);
        if (PASS2 && maybe_class >= OOB_NAMEDCLASS && do_posix_warnings) {
            SAVEFREESV(RExC_rx_sv);
            ckWARN4reg(not_posix_region_end,
                    "POSIX syntax [%c %c] belongs inside character classes%s",
                    *RExC_parse, *RExC_parse,
                    (maybe_class == OOB_NAMEDCLASS)
                    ? ((POSIXCC_NOTYET(*RExC_parse))
                        ? " (but this one isn't implemented)"
                        : " (but this one isn't fully valid)")
                    : ""
                    );
            (void)ReREFCNT_inc(RExC_rx_sv);
        }
    }

    /* If the caller wants us to just parse a single element, accomplish this
     * by faking the loop ending condition */
    if (stop_at_1 && RExC_end > RExC_parse) {
        stop_ptr = RExC_parse + 1;
    }

    /* allow 1st char to be ']' (allowing it to be '-' is dealt with later) */
    if (UCHARAT(RExC_parse) == ']')
	goto charclassloop;

    while (1) {

        if (   posix_warnings
            && av_tindex_skip_len_mg(posix_warnings) >= 0
            && RExC_parse > not_posix_region_end)
        {
            /* Warnings about posix class issues are considered tentative until
             * we are far enough along in the parse that we can no longer
             * change our mind, at which point we either output them or add
             * them, if it has so specified, to what gets returned to the
             * caller.  This is done each time through the loop so that a later
             * class won't zap them before they have been dealt with. */
            output_or_return_posix_warnings(pRExC_state, posix_warnings,
                                            return_posix_warnings);
        }

        if  (RExC_parse >= stop_ptr) {
            break;
        }

        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);

        if  (UCHARAT(RExC_parse) == ']') {
            break;
        }

      charclassloop:

	namedclass = OOB_NAMEDCLASS; /* initialize as illegal */
        save_value = value;
        save_prevvalue = prevvalue;

	if (!range) {
	    rangebegin = RExC_parse;
	    element_count++;
            non_portable_endpoint = 0;
	}
	if (UTF && ! UTF8_IS_INVARIANT(* RExC_parse)) {
	    value = utf8n_to_uvchr((U8*)RExC_parse,
				   RExC_end - RExC_parse,
				   &numlen, UTF8_ALLOW_DEFAULT);
	    RExC_parse += numlen;
	}
	else
	    value = UCHARAT(RExC_parse++);

        if (value == '[') {
            char * posix_class_end;
            namedclass = handle_possible_posix(pRExC_state,
                                               RExC_parse,
                                               &posix_class_end,
                                               do_posix_warnings ? &posix_warnings : NULL,
                                               FALSE    /* die if error */);
            if (namedclass > OOB_NAMEDCLASS) {

                /* If there was an earlier attempt to parse this particular
                 * posix class, and it failed, it was a false alarm, as this
                 * successful one proves */
                if (   posix_warnings
                    && av_tindex_skip_len_mg(posix_warnings) >= 0
                    && not_posix_region_end >= RExC_parse
                    && not_posix_region_end <= posix_class_end)
                {
                    av_undef(posix_warnings);
                }

                RExC_parse = posix_class_end;
            }
            else if (namedclass == OOB_NAMEDCLASS) {
                not_posix_region_end = posix_class_end;
            }
            else {
                namedclass = OOB_NAMEDCLASS;
            }
        }
        else if (   RExC_parse - 1 > not_posix_region_end
                 && MAYBE_POSIXCC(value))
        {
            (void) handle_possible_posix(
                        pRExC_state,
                        RExC_parse - 1,  /* -1 because parse has already been
                                            advanced */
                        &not_posix_region_end,
                        do_posix_warnings ? &posix_warnings : NULL,
                        TRUE /* checking only */);
        }
        else if (value == '\\') {
            /* Is a backslash; get the code point of the char after it */

            if (RExC_parse >= RExC_end) {
                vFAIL("Unmatched [");
            }

	    if (UTF && ! UTF8_IS_INVARIANT(UCHARAT(RExC_parse))) {
		value = utf8n_to_uvchr((U8*)RExC_parse,
				   RExC_end - RExC_parse,
				   &numlen, UTF8_ALLOW_DEFAULT);
		RExC_parse += numlen;
	    }
	    else
		value = UCHARAT(RExC_parse++);

	    /* Some compilers cannot handle switching on 64-bit integer
	     * values, therefore value cannot be an UV.  Yes, this will
	     * be a problem later if we want switch on Unicode.
	     * A similar issue a little bit later when switching on
	     * namedclass. --jhi */

            /* If the \ is escaping white space when white space is being
             * skipped, it means that that white space is wanted literally, and
             * is already in 'value'.  Otherwise, need to translate the escape
             * into what it signifies. */
            if (! skip_white || ! isBLANK_A(value)) switch ((I32)value) {

	    case 'w':	namedclass = ANYOF_WORDCHAR;	break;
	    case 'W':	namedclass = ANYOF_NWORDCHAR;	break;
	    case 's':	namedclass = ANYOF_SPACE;	break;
	    case 'S':	namedclass = ANYOF_NSPACE;	break;
	    case 'd':	namedclass = ANYOF_DIGIT;	break;
	    case 'D':	namedclass = ANYOF_NDIGIT;	break;
	    case 'v':	namedclass = ANYOF_VERTWS;	break;
	    case 'V':	namedclass = ANYOF_NVERTWS;	break;
	    case 'h':	namedclass = ANYOF_HORIZWS;	break;
	    case 'H':	namedclass = ANYOF_NHORIZWS;	break;
            case 'N':  /* Handle \N{NAME} in class */
                {
                    const char * const backslash_N_beg = RExC_parse - 2;
                    int cp_count;

                    if (! grok_bslash_N(pRExC_state,
                                        NULL,      /* No regnode */
                                        &value,    /* Yes single value */
                                        &cp_count, /* Multiple code pt count */
                                        flagp,
                                        strict,
                                        depth)
                    ) {

                        if (*flagp & NEED_UTF8)
                            FAIL("panic: grok_bslash_N set NEED_UTF8");
                        if (*flagp & RESTART_PASS1)
                            return NULL;

                        if (cp_count < 0) {
                            vFAIL("\\N in a character class must be a named character: \\N{...}");
                        }
                        else if (cp_count == 0) {
                            if (PASS2) {
                                ckWARNreg(RExC_parse,
                                        "Ignoring zero length \\N{} in character class");
                            }
                        }
                        else { /* cp_count > 1 */
                            if (! RExC_in_multi_char_class) {
                                if (invert || range || *RExC_parse == '-') {
                                    if (strict) {
                                        RExC_parse--;
                                        vFAIL("\\N{} in inverted character class or as a range end-point is restricted to one character");
                                    }
                                    else if (PASS2) {
                                        ckWARNreg(RExC_parse, "Using just the first character returned by \\N{} in character class");
                                    }
                                    break; /* <value> contains the first code
                                              point. Drop out of the switch to
                                              process it */
                                }
                                else {
                                    SV * multi_char_N = newSVpvn(backslash_N_beg,
                                                 RExC_parse - backslash_N_beg);
                                    multi_char_matches
                                        = add_multi_match(multi_char_matches,
                                                          multi_char_N,
                                                          cp_count);
                                }
                            }
                        } /* End of cp_count != 1 */

                        /* This element should not be processed further in this
                         * class */
                        element_count--;
                        value = save_value;
                        prevvalue = save_prevvalue;
                        continue;   /* Back to top of loop to get next char */
                    }

                    /* Here, is a single code point, and <value> contains it */
                    unicode_range = TRUE;   /* \N{} are Unicode */
                }
                break;
	    case 'p':
	    case 'P':
		{
		char *e;

                /* We will handle any undefined properties ourselves */
                U8 swash_init_flags = _CORE_SWASH_INIT_RETURN_IF_UNDEF
                                       /* And we actually would prefer to get
                                        * the straight inversion list of the
                                        * swash, since we will be accessing it
                                        * anyway, to save a little time */
                                      |_CORE_SWASH_INIT_ACCEPT_INVLIST;

		if (RExC_parse >= RExC_end)
		    vFAIL2("Empty \\%c", (U8)value);
		if (*RExC_parse == '{') {
		    const U8 c = (U8)value;
		    e = (char *) memchr(RExC_parse, '}', RExC_end - RExC_parse);
                    if (!e) {
                        RExC_parse++;
                        vFAIL2("Missing right brace on \\%c{}", c);
                    }

                    RExC_parse++;
                    while (isSPACE(*RExC_parse)) {
                         RExC_parse++;
		    }

		    if (UCHARAT(RExC_parse) == '^') {

                        /* toggle.  (The rhs xor gets the single bit that
                         * differs between P and p; the other xor inverts just
                         * that bit) */
                        value ^= 'P' ^ 'p';

                        RExC_parse++;
                        while (isSPACE(*RExC_parse)) {
                            RExC_parse++;
                        }
                    }

                    if (e == RExC_parse)
                        vFAIL2("Empty \\%c{}", c);

		    n = e - RExC_parse;
		    while (isSPACE(*(RExC_parse + n - 1)))
		        n--;
		}   /* The \p isn't immediately followed by a '{' */
		else if (! isALPHA(*RExC_parse)) {
                    RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;
                    vFAIL2("Character following \\%c must be '{' or a "
                           "single-character Unicode property name",
                           (U8) value);
                }
                else {
		    e = RExC_parse;
		    n = 1;
		}
		if (!SIZE_ONLY) {
                    SV* invlist;
                    char* name;
                    char* base_name;    /* name after any packages are stripped */
                    char* lookup_name = NULL;
                    const char * const colon_colon = "::";

                    /* Try to get the definition of the property into
                     * <invlist>.  If /i is in effect, the effective property
                     * will have its name be <__NAME_i>.  The design is
                     * discussed in commit
                     * 2f833f5208e26b208886e51e09e2c072b5eabb46 */
                    name = savepv(Perl_form(aTHX_ "%.*s", (int)n, RExC_parse));
                    SAVEFREEPV(name);
                    if (FOLD) {
                        lookup_name = savepv(Perl_form(aTHX_ "__%s_i", name));

                        /* The function call just below that uses this can fail
                         * to return, leaking memory if we don't do this */
                        SAVEFREEPV(lookup_name);
                    }

                    /* Look up the property name, and get its swash and
                     * inversion list, if the property is found  */
                    SvREFCNT_dec(swash); /* Free any left-overs */
                    swash = _core_swash_init("utf8",
                                             (lookup_name)
                                              ? lookup_name
                                              : name,
                                             &PL_sv_undef,
                                             1, /* binary */
                                             0, /* not tr/// */
                                             NULL, /* No inversion list */
                                             &swash_init_flags
                                            );
                    if (! swash || ! (invlist = _get_swash_invlist(swash))) {
                        HV* curpkg = (IN_PERL_COMPILETIME)
                                      ? PL_curstash
                                      : CopSTASH(PL_curcop);
                        UV final_n = n;
                        bool has_pkg;

                        if (swash) {    /* Got a swash but no inversion list.
                                           Something is likely wrong that will
                                           be sorted-out later */
                            SvREFCNT_dec_NN(swash);
                            swash = NULL;
                        }

                        /* Here didn't find it.  It could be a an error (like a
                         * typo) in specifying a Unicode property, or it could
                         * be a user-defined property that will be available at
                         * run-time.  The names of these must begin with 'In'
                         * or 'Is' (after any packages are stripped off).  So
                         * if not one of those, or if we accept only
                         * compile-time properties, is an error; otherwise add
                         * it to the list for run-time look up. */
                        if ((base_name = rninstr(name, name + n,
                                                 colon_colon, colon_colon + 2)))
                        { /* Has ::.  We know this must be a user-defined
                             property */
                            base_name += 2;
                            final_n -= base_name - name;
                            has_pkg = TRUE;
                        }
                        else {
                            base_name = name;
                            has_pkg = FALSE;
                        }

                        if (   final_n < 3
                            || base_name[0] != 'I'
                            || (base_name[1] != 's' && base_name[1] != 'n')
                            || ret_invlist)
                        {
                            const char * const msg
                                = (has_pkg)
                                  ? "Illegal user-defined property name"
                                  : "Can't find Unicode property definition";
                            RExC_parse = e + 1;

                            /* diag_listed_as: Can't find Unicode property definition "%s" */
                            vFAIL3utf8f("%s \"%" UTF8f "\"",
                                msg, UTF8fARG(UTF, n, name));
                        }

                        /* If the property name doesn't already have a package
                         * name, add the current one to it so that it can be
                         * referred to outside it. [perl #121777] */
                        if (! has_pkg && curpkg) {
                            char* pkgname = HvNAME(curpkg);
                            if (memNEs(pkgname, HvNAMELEN(curpkg), "main")) {
                                char* full_name = Perl_form(aTHX_
                                                            "%s::%s",
                                                            pkgname,
                                                            name);
                                n = strlen(full_name);
                                name = savepvn(full_name, n);
                                SAVEFREEPV(name);
                            }
                        }
                        Perl_sv_catpvf(aTHX_ listsv, "%cutf8::%s%" UTF8f "%s\n",
                                        (value == 'p' ? '+' : '!'),
                                        (FOLD) ? "__" : "",
                                        UTF8fARG(UTF, n, name),
                                        (FOLD) ? "_i" : "");
                        has_user_defined_property = TRUE;
                        optimizable = FALSE;    /* Will have to leave this an
                                                   ANYOF node */

                        /* We don't know yet what this matches, so have to flag
                         * it */
                        ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;
                    }
                    else {

                        /* Here, did get the swash and its inversion list.  If
                         * the swash is from a user-defined property, then this
                         * whole character class should be regarded as such */
                        if (swash_init_flags
                            & _CORE_SWASH_INIT_USER_DEFINED_PROPERTY)
                        {
                            has_user_defined_property = TRUE;
                        }
                        else if
                            /* We warn on matching an above-Unicode code point
                             * if the match would return true, except don't
                             * warn for \p{All}, which has exactly one element
                             * = 0 */
                            (_invlist_contains_cp(invlist, 0x110000)
                                && (! (_invlist_len(invlist) == 1
                                       && *invlist_array(invlist) == 0)))
                        {
                            warn_super = TRUE;
                        }


                        /* Invert if asking for the complement */
                        if (value == 'P') {
			    _invlist_union_complement_2nd(properties,
                                                          invlist,
                                                          &properties);

                            /* The swash can't be used as-is, because we've
			     * inverted things; delay removing it to here after
			     * have copied its invlist above */
                            SvREFCNT_dec_NN(swash);
                            swash = NULL;
                        }
                        else {
                            _invlist_union(properties, invlist, &properties);
			}
		    }
		}
		RExC_parse = e + 1;
                namedclass = ANYOF_UNIPROP;  /* no official name, but it's
                                                named */

		/* \p means they want Unicode semantics */
		REQUIRE_UNI_RULES(flagp, NULL);
		}
		break;
	    case 'n':	value = '\n';			break;
	    case 'r':	value = '\r';			break;
	    case 't':	value = '\t';			break;
	    case 'f':	value = '\f';			break;
	    case 'b':	value = '\b';			break;
	    case 'e':	value = ESC_NATIVE;             break;
	    case 'a':	value = '\a';                   break;
	    case 'o':
		RExC_parse--;	/* function expects to be pointed at the 'o' */
		{
		    const char* error_msg;
		    bool valid = grok_bslash_o(&RExC_parse,
                                               RExC_end,
					       &value,
					       &error_msg,
                                               PASS2,   /* warnings only in
                                                           pass 2 */
                                               strict,
                                               silence_non_portable,
                                               UTF);
		    if (! valid) {
			vFAIL(error_msg);
		    }
		}
                non_portable_endpoint++;
		break;
	    case 'x':
		RExC_parse--;	/* function expects to be pointed at the 'x' */
		{
		    const char* error_msg;
		    bool valid = grok_bslash_x(&RExC_parse,
                                               RExC_end,
					       &value,
					       &error_msg,
					       PASS2, /* Output warnings */
                                               strict,
                                               silence_non_portable,
                                               UTF);
                    if (! valid) {
			vFAIL(error_msg);
		    }
		}
                non_portable_endpoint++;
		break;
	    case 'c':
		value = grok_bslash_c(*RExC_parse++, PASS2);
                non_portable_endpoint++;
		break;
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7':
		{
		    /* Take 1-3 octal digits */
		    I32 flags = PERL_SCAN_SILENT_ILLDIGIT;
                    numlen = (strict) ? 4 : 3;
                    value = grok_oct(--RExC_parse, &numlen, &flags, NULL);
		    RExC_parse += numlen;
                    if (numlen != 3) {
                        if (strict) {
                            RExC_parse += (UTF) ? UTF8SKIP(RExC_parse) : 1;
                            vFAIL("Need exactly 3 octal digits");
                        }
                        else if (! SIZE_ONLY /* like \08, \178 */
                                 && numlen < 3
                                 && RExC_parse < RExC_end
                                 && isDIGIT(*RExC_parse)
                                 && ckWARN(WARN_REGEXP))
                        {
                            SAVEFREESV(RExC_rx_sv);
                            reg_warn_non_literal_string(
                                 RExC_parse + 1,
                                 form_short_octal_warning(RExC_parse, numlen));
                            (void)ReREFCNT_inc(RExC_rx_sv);
                        }
                    }
                    non_portable_endpoint++;
		    break;
		}
	    default:
		/* Allow \_ to not give an error */
		if (!SIZE_ONLY && isWORDCHAR(value) && value != '_') {
                    if (strict) {
                        vFAIL2("Unrecognized escape \\%c in character class",
                               (int)value);
                    }
                    else {
                        SAVEFREESV(RExC_rx_sv);
                        ckWARN2reg(RExC_parse,
                            "Unrecognized escape \\%c in character class passed through",
                            (int)value);
                        (void)ReREFCNT_inc(RExC_rx_sv);
                    }
		}
		break;
	    }   /* End of switch on char following backslash */
	} /* end of handling backslash escape sequences */

        /* Here, we have the current token in 'value' */

	if (namedclass > OOB_NAMEDCLASS) { /* this is a named class \blah */
            U8 classnum;

	    /* a bad range like a-\d, a-[:digit:].  The '-' is taken as a
	     * literal, as is the character that began the false range, i.e.
	     * the 'a' in the examples */
	    if (range) {
		if (!SIZE_ONLY) {
		    const int w = (RExC_parse >= rangebegin)
                                  ? RExC_parse - rangebegin
                                  : 0;
                    if (strict) {
                        vFAIL2utf8f(
                            "False [] range \"%" UTF8f "\"",
                            UTF8fARG(UTF, w, rangebegin));
                    }
                    else {
                        SAVEFREESV(RExC_rx_sv); /* in case of fatal warnings */
                        ckWARN2reg(RExC_parse,
                            "False [] range \"%" UTF8f "\"",
                            UTF8fARG(UTF, w, rangebegin));
                        (void)ReREFCNT_inc(RExC_rx_sv);
                        cp_list = add_cp_to_invlist(cp_list, '-');
                        cp_foldable_list = add_cp_to_invlist(cp_foldable_list,
                                                             prevvalue);
                    }
		}

		range = 0; /* this was not a true range */
                element_count += 2; /* So counts for three values */
	    }

            classnum = namedclass_to_classnum(namedclass);

	    if (LOC && namedclass < ANYOF_POSIXL_MAX
#ifndef HAS_ISASCII
                && classnum != _CC_ASCII
#endif
            ) {
                /* What the Posix classes (like \w, [:space:]) match in locale
                 * isn't knowable under locale until actual match time.  Room
                 * must be reserved (one time per outer bracketed class) to
                 * store such classes.  The space will contain a bit for each
                 * named class that is to be matched against.  This isn't
                 * needed for \p{} and pseudo-classes, as they are not affected
                 * by locale, and hence are dealt with separately */
                if (! need_class) {
                    need_class = 1;
                    if (SIZE_ONLY) {
                        RExC_size += ANYOF_POSIXL_SKIP - ANYOF_SKIP;
                    }
                    else {
                        RExC_emit += ANYOF_POSIXL_SKIP - ANYOF_SKIP;
                    }
                    ANYOF_FLAGS(ret) |= ANYOF_MATCHES_POSIXL;
                    ANYOF_POSIXL_ZERO(ret);

                    /* We can't change this into some other type of node
                     * (unless this is the only element, in which case there
                     * are nodes that mean exactly this) as has runtime
                     * dependencies */
                    optimizable = FALSE;
                }

                /* Coverity thinks it is possible for this to be negative; both
                 * jhi and khw think it's not, but be safer */
                assert(! (ANYOF_FLAGS(ret) & ANYOF_MATCHES_POSIXL)
                       || (namedclass + ((namedclass % 2) ? -1 : 1)) >= 0);

                /* See if it already matches the complement of this POSIX
                 * class */
                if ((ANYOF_FLAGS(ret) & ANYOF_MATCHES_POSIXL)
                    && ANYOF_POSIXL_TEST(ret, namedclass + ((namedclass % 2)
                                                            ? -1
                                                            : 1)))
                {
                    posixl_matches_all = TRUE;
                    break;  /* No need to continue.  Since it matches both
                               e.g., \w and \W, it matches everything, and the
                               bracketed class can be optimized into qr/./s */
                }

                /* Add this class to those that should be checked at runtime */
                ANYOF_POSIXL_SET(ret, namedclass);

                /* The above-Latin1 characters are not subject to locale rules.
                 * Just add them, in the second pass, to the
                 * unconditionally-matched list */
                if (! SIZE_ONLY) {
                    SV* scratch_list = NULL;

                    /* Get the list of the above-Latin1 code points this
                     * matches */
                    _invlist_intersection_maybe_complement_2nd(PL_AboveLatin1,
                                          PL_XPosix_ptrs[classnum],

                                          /* Odd numbers are complements, like
                                           * NDIGIT, NASCII, ... */
                                          namedclass % 2 != 0,
                                          &scratch_list);
                    /* Checking if 'cp_list' is NULL first saves an extra
                     * clone.  Its reference count will be decremented at the
                     * next union, etc, or if this is the only instance, at the
                     * end of the routine */
                    if (! cp_list) {
                        cp_list = scratch_list;
                    }
                    else {
                        _invlist_union(cp_list, scratch_list, &cp_list);
                        SvREFCNT_dec_NN(scratch_list);
                    }
                    continue;   /* Go get next character */
                }
            }
            else if (! SIZE_ONLY) {

                /* Here, not in pass1 (in that pass we skip calculating the
                 * contents of this class), and is not /l, or is a POSIX class
                 * for which /l doesn't matter (or is a Unicode property, which
                 * is skipped here). */
                if (namedclass >= ANYOF_POSIXL_MAX) {  /* If a special class */
                    if (namedclass != ANYOF_UNIPROP) { /* UNIPROP = \p and \P */

                        /* Here, should be \h, \H, \v, or \V.  None of /d, /i
                         * nor /l make a difference in what these match,
                         * therefore we just add what they match to cp_list. */
                        if (classnum != _CC_VERTSPACE) {
                            assert(   namedclass == ANYOF_HORIZWS
                                   || namedclass == ANYOF_NHORIZWS);

                            /* It turns out that \h is just a synonym for
                             * XPosixBlank */
                            classnum = _CC_BLANK;
                        }

                        _invlist_union_maybe_complement_2nd(
                                cp_list,
                                PL_XPosix_ptrs[classnum],
                                namedclass % 2 != 0,    /* Complement if odd
                                                          (NHORIZWS, NVERTWS)
                                                        */
                                &cp_list);
                    }
                }
                else if (  UNI_SEMANTICS
                        || classnum == _CC_ASCII
                        || (DEPENDS_SEMANTICS && (   classnum == _CC_DIGIT
                                                  || classnum == _CC_XDIGIT)))
                {
                    /* We usually have to worry about /d and /a affecting what
                     * POSIX classes match, with special code needed for /d
                     * because we won't know until runtime what all matches.
                     * But there is no extra work needed under /u, and
                     * [:ascii:] is unaffected by /a and /d; and :digit: and
                     * :xdigit: don't have runtime differences under /d.  So we
                     * can special case these, and avoid some extra work below,
                     * and at runtime. */
                    _invlist_union_maybe_complement_2nd(
                                                     simple_posixes,
                                                     PL_XPosix_ptrs[classnum],
                                                     namedclass % 2 != 0,
                                                     &simple_posixes);
                }
                else {  /* Garden variety class.  If is NUPPER, NALPHA, ...
                           complement and use nposixes */
                    SV** posixes_ptr = namedclass % 2 == 0
                                       ? &posixes
                                       : &nposixes;
                    _invlist_union_maybe_complement_2nd(
                                                     *posixes_ptr,
                                                     PL_XPosix_ptrs[classnum],
                                                     namedclass % 2 != 0,
                                                     posixes_ptr);
                }
	    }
	} /* end of namedclass \blah */

        SKIP_BRACKETED_WHITE_SPACE(skip_white, RExC_parse);

        /* If 'range' is set, 'value' is the ending of a range--check its
         * validity.  (If value isn't a single code point in the case of a
         * range, we should have figured that out above in the code that
         * catches false ranges).  Later, we will handle each individual code
         * point in the range.  If 'range' isn't set, this could be the
         * beginning of a range, so check for that by looking ahead to see if
         * the next real character to be processed is the range indicator--the
         * minus sign */

	if (range) {
#ifdef EBCDIC
            /* For unicode ranges, we have to test that the Unicode as opposed
             * to the native values are not decreasing.  (Above 255, there is
             * no difference between native and Unicode) */
	    if (unicode_range && prevvalue < 255 && value < 255) {
                if (NATIVE_TO_LATIN1(prevvalue) > NATIVE_TO_LATIN1(value)) {
                    goto backwards_range;
                }
            }
            else
#endif
	    if (prevvalue > value) /* b-a */ {
		int w;
#ifdef EBCDIC
              backwards_range:
#endif
                w = RExC_parse - rangebegin;
                vFAIL2utf8f(
                    "Invalid [] range \"%" UTF8f "\"",
                    UTF8fARG(UTF, w, rangebegin));
                NOT_REACHED; /* NOTREACHED */
	    }
	}
	else {
            prevvalue = value; /* save the beginning of the potential range */
            if (! stop_at_1     /* Can't be a range if parsing just one thing */
                && *RExC_parse == '-')
            {
                char* next_char_ptr = RExC_parse + 1;

                /* Get the next real char after the '-' */
                SKIP_BRACKETED_WHITE_SPACE(skip_white, next_char_ptr);

                /* If the '-' is at the end of the class (just before the ']',
                 * it is a literal minus; otherwise it is a range */
                if (next_char_ptr < RExC_end && *next_char_ptr != ']') {
                    RExC_parse = next_char_ptr;

                    /* a bad range like \w-, [:word:]- ? */
                    if (namedclass > OOB_NAMEDCLASS) {
                        if (strict || (PASS2 && ckWARN(WARN_REGEXP))) {
                            const int w = RExC_parse >= rangebegin
                                          ?  RExC_parse - rangebegin
                                          : 0;
                            if (strict) {
                                vFAIL4("False [] range \"%*.*s\"",
                                    w, w, rangebegin);
                            }
                            else if (PASS2) {
                                vWARN4(RExC_parse,
                                    "False [] range \"%*.*s\"",
                                    w, w, rangebegin);
                            }
                        }
                        if (!SIZE_ONLY) {
                            cp_list = add_cp_to_invlist(cp_list, '-');
                        }
                        element_count++;
                    } else
                        range = 1;	/* yeah, it's a range! */
                    continue;	/* but do it the next time */
                }
	    }
	}

        if (namedclass > OOB_NAMEDCLASS) {
            continue;
        }

        /* Here, we have a single value this time through the loop, and
         * <prevvalue> is the beginning of the range, if any; or <value> if
         * not. */

	/* non-Latin1 code point implies unicode semantics.  Must be set in
	 * pass1 so is there for the whole of pass 2 */
	if (value > 255) {
            REQUIRE_UNI_RULES(flagp, NULL);
	}

        /* Ready to process either the single value, or the completed range.
         * For single-valued non-inverted ranges, we consider the possibility
         * of multi-char folds.  (We made a conscious decision to not do this
         * for the other cases because it can often lead to non-intuitive
         * results.  For example, you have the peculiar case that:
         *  "s s" =~ /^[^\xDF]+$/i => Y
         *  "ss"  =~ /^[^\xDF]+$/i => N
         *
         * See [perl #89750] */
        if (FOLD && allow_multi_folds && value == prevvalue) {
            if (value == LATIN_SMALL_LETTER_SHARP_S
                || (value > 255 && _invlist_contains_cp(PL_HasMultiCharFold,
                                                        value)))
            {
                /* Here <value> is indeed a multi-char fold.  Get what it is */

                U8 foldbuf[UTF8_MAXBYTES_CASE];
                STRLEN foldlen;

                UV folded = _to_uni_fold_flags(
                                value,
                                foldbuf,
                                &foldlen,
                                FOLD_FLAGS_FULL | (ASCII_FOLD_RESTRICTED
                                                   ? FOLD_FLAGS_NOMIX_ASCII
                                                   : 0)
                                );

                /* Here, <folded> should be the first character of the
                 * multi-char fold of <value>, with <foldbuf> containing the
                 * whole thing.  But, if this fold is not allowed (because of
                 * the flags), <fold> will be the same as <value>, and should
                 * be processed like any other character, so skip the special
                 * handling */
                if (folded != value) {

                    /* Skip if we are recursed, currently parsing the class
                     * again.  Otherwise add this character to the list of
                     * multi-char folds. */
                    if (! RExC_in_multi_char_class) {
                        STRLEN cp_count = utf8_length(foldbuf,
                                                      foldbuf + foldlen);
                        SV* multi_fold = sv_2mortal(newSVpvs(""));

                        Perl_sv_catpvf(aTHX_ multi_fold, "\\x{%" UVXf "}", value);

                        multi_char_matches
                                        = add_multi_match(multi_char_matches,
                                                          multi_fold,
                                                          cp_count);

                    }

                    /* This element should not be processed further in this
                     * class */
                    element_count--;
                    value = save_value;
                    prevvalue = save_prevvalue;
                    continue;
                }
            }
        }

        if (strict && PASS2 && ckWARN(WARN_REGEXP)) {
            if (range) {

                /* If the range starts above 255, everything is portable and
                 * likely to be so for any forseeable character set, so don't
                 * warn. */
                if (unicode_range && non_portable_endpoint && prevvalue < 256) {
                    vWARN(RExC_parse, "Both or neither range ends should be Unicode");
                }
                else if (prevvalue != value) {

                    /* Under strict, ranges that stop and/or end in an ASCII
                     * printable should have each end point be a portable value
                     * for it (preferably like 'A', but we don't warn if it is
                     * a (portable) Unicode name or code point), and the range
                     * must be be all digits or all letters of the same case.
                     * Otherwise, the range is non-portable and unclear as to
                     * what it contains */
                    if (             (isPRINT_A(prevvalue) || isPRINT_A(value))
                        && (          non_portable_endpoint
                            || ! (   (isDIGIT_A(prevvalue) && isDIGIT_A(value))
                                  || (isLOWER_A(prevvalue) && isLOWER_A(value))
                                  || (isUPPER_A(prevvalue) && isUPPER_A(value))
                    ))) {
                        vWARN(RExC_parse, "Ranges of ASCII printables should"
                                          " be some subset of \"0-9\","
                                          " \"A-Z\", or \"a-z\"");
                    }
                    else if (prevvalue >= 0x660) { /* ARABIC_INDIC_DIGIT_ZERO */
                        SSize_t index_start;
                        SSize_t index_final;

                        /* But the nature of Unicode and languages mean we
                         * can't do the same checks for above-ASCII ranges,
                         * except in the case of digit ones.  These should
                         * contain only digits from the same group of 10.  The
                         * ASCII case is handled just above.  0x660 is the
                         * first digit character beyond ASCII.  Hence here, the
                         * range could be a range of digits.  First some
                         * unlikely special cases.  Grandfather in that a range
                         * ending in 19DA (NEW TAI LUE THAM DIGIT ONE) is bad
                         * if its starting value is one of the 10 digits prior
                         * to it.  This is because it is an alternate way of
                         * writing 19D1, and some people may expect it to be in
                         * that group.  But it is bad, because it won't give
                         * the expected results.  In Unicode 5.2 it was
                         * considered to be in that group (of 11, hence), but
                         * this was fixed in the next version */

                        if (UNLIKELY(value == 0x19DA && prevvalue >= 0x19D0)) {
                            goto warn_bad_digit_range;
                        }
                        else if (UNLIKELY(   prevvalue >= 0x1D7CE
                                          &&     value <= 0x1D7FF))
                        {
                            /* This is the only other case currently in Unicode
                             * where the algorithm below fails.  The code
                             * points just above are the end points of a single
                             * range containing only decimal digits.  It is 5
                             * different series of 0-9.  All other ranges of
                             * digits currently in Unicode are just a single
                             * series.  (And mktables will notify us if a later
                             * Unicode version breaks this.)
                             *
                             * If the range being checked is at most 9 long,
                             * and the digit values represented are in
                             * numerical order, they are from the same series.
                             * */
                            if (         value - prevvalue > 9
                                ||    (((    value - 0x1D7CE) % 10)
                                     <= (prevvalue - 0x1D7CE) % 10))
                            {
                                goto warn_bad_digit_range;
                            }
                        }
                        else {

                            /* For all other ranges of digits in Unicode, the
                             * algorithm is just to check if both end points
                             * are in the same series, which is the same range.
                             * */
                            index_start = _invlist_search(
                                                    PL_XPosix_ptrs[_CC_DIGIT],
                                                    prevvalue);

                            /* Warn if the range starts and ends with a digit,
                             * and they are not in the same group of 10. */
                            if (   index_start >= 0
                                && ELEMENT_RANGE_MATCHES_INVLIST(index_start)
                                && (index_final =
                                    _invlist_search(PL_XPosix_ptrs[_CC_DIGIT],
                                                    value)) != index_start
                                && index_final >= 0
                                && ELEMENT_RANGE_MATCHES_INVLIST(index_final))
                            {
                              warn_bad_digit_range:
                                vWARN(RExC_parse, "Ranges of digits should be"
                                                  " from the same group of"
                                                  " 10");
                            }
                        }
                    }
                }
            }
            if ((! range || prevvalue == value) && non_portable_endpoint) {
                if (isPRINT_A(value)) {
                    char literal[3];
                    unsigned d = 0;
                    if (isBACKSLASHED_PUNCT(value)) {
                        literal[d++] = '\\';
                    }
                    literal[d++] = (char) value;
                    literal[d++] = '\0';

                    vWARN4(RExC_parse,
                           "\"%.*s\" is more clearly written simply as \"%s\"",
                           (int) (RExC_parse - rangebegin),
                           rangebegin,
                           literal
                        );
                }
                else if isMNEMONIC_CNTRL(value) {
                    vWARN4(RExC_parse,
                           "\"%.*s\" is more clearly written simply as \"%s\"",
                           (int) (RExC_parse - rangebegin),
                           rangebegin,
                           cntrl_to_mnemonic((U8) value)
                        );
                }
            }
        }

        /* Deal with this element of the class */
	if (! SIZE_ONLY) {

#ifndef EBCDIC
            cp_foldable_list = _add_range_to_invlist(cp_foldable_list,
                                                     prevvalue, value);
#else
            /* On non-ASCII platforms, for ranges that span all of 0..255, and
             * ones that don't require special handling, we can just add the
             * range like we do for ASCII platforms */
            if ((UNLIKELY(prevvalue == 0) && value >= 255)
                || ! (prevvalue < 256
                      && (unicode_range
                          || (! non_portable_endpoint
                              && ((isLOWER_A(prevvalue) && isLOWER_A(value))
                                  || (isUPPER_A(prevvalue)
                                      && isUPPER_A(value)))))))
            {
                cp_foldable_list = _add_range_to_invlist(cp_foldable_list,
                                                         prevvalue, value);
            }
            else {
                /* Here, requires special handling.  This can be because it is
                 * a range whose code points are considered to be Unicode, and
                 * so must be individually translated into native, or because
                 * its a subrange of 'A-Z' or 'a-z' which each aren't
                 * contiguous in EBCDIC, but we have defined them to include
                 * only the "expected" upper or lower case ASCII alphabetics.
                 * Subranges above 255 are the same in native and Unicode, so
                 * can be added as a range */
                U8 start = NATIVE_TO_LATIN1(prevvalue);
                unsigned j;
                U8 end = (value < 256) ? NATIVE_TO_LATIN1(value) : 255;
                for (j = start; j <= end; j++) {
                    cp_foldable_list = add_cp_to_invlist(cp_foldable_list, LATIN1_TO_NATIVE(j));
                }
                if (value > 255) {
                    cp_foldable_list = _add_range_to_invlist(cp_foldable_list,
                                                             256, value);
                }
            }
#endif
        }

	range = 0; /* this range (if it was one) is done now */
    } /* End of loop through all the text within the brackets */


    if (   posix_warnings && av_tindex_skip_len_mg(posix_warnings) >= 0) {
        output_or_return_posix_warnings(pRExC_state, posix_warnings,
                                        return_posix_warnings);
    }

    /* If anything in the class expands to more than one character, we have to
     * deal with them by building up a substitute parse string, and recursively
     * calling reg() on it, instead of proceeding */
    if (multi_char_matches) {
	SV * substitute_parse = newSVpvn_flags("?:", 2, SVs_TEMP);
        I32 cp_count;
	STRLEN len;
	char *save_end = RExC_end;
	char *save_parse = RExC_parse;
	char *save_start = RExC_start;
        STRLEN prefix_end = 0;      /* We copy the character class after a
                                       prefix supplied here.  This is the size
                                       + 1 of that prefix */
        bool first_time = TRUE;     /* First multi-char occurrence doesn't get
                                       a "|" */
        I32 reg_flags;

        assert(! invert);
        assert(RExC_precomp_adj == 0); /* Only one level of recursion allowed */

#if 0   /* Have decided not to deal with multi-char folds in inverted classes,
           because too confusing */
        if (invert) {
            sv_catpv(substitute_parse, "(?:");
        }
#endif

        /* Look at the longest folds first */
        for (cp_count = av_tindex_skip_len_mg(multi_char_matches);
                        cp_count > 0;
                        cp_count--)
        {

            if (av_exists(multi_char_matches, cp_count)) {
                AV** this_array_ptr;
                SV* this_sequence;

                this_array_ptr = (AV**) av_fetch(multi_char_matches,
                                                 cp_count, FALSE);
                while ((this_sequence = av_pop(*this_array_ptr)) !=
                                                                &PL_sv_undef)
                {
                    if (! first_time) {
                        sv_catpv(substitute_parse, "|");
                    }
                    first_time = FALSE;

                    sv_catpv(substitute_parse, SvPVX(this_sequence));
                }
            }
        }

        /* If the character class contains anything else besides these
         * multi-character folds, have to include it in recursive parsing */
        if (element_count) {
            sv_catpv(substitute_parse, "|[");
            prefix_end = SvCUR(substitute_parse);
            sv_catpvn(substitute_parse, orig_parse, RExC_parse - orig_parse);

            /* Put in a closing ']' only if not going off the end, as otherwise
             * we are adding something that really isn't there */
            if (RExC_parse < RExC_end) {
                sv_catpv(substitute_parse, "]");
            }
        }

        sv_catpv(substitute_parse, ")");
#if 0
        if (invert) {
            /* This is a way to get the parse to skip forward a whole named
             * sequence instead of matching the 2nd character when it fails the
             * first */
            sv_catpv(substitute_parse, "(*THEN)(*SKIP)(*FAIL)|.)");
        }
#endif

        /* Set up the data structure so that any errors will be properly
         * reported.  See the comments at the definition of
         * REPORT_LOCATION_ARGS for details */
        RExC_precomp_adj = orig_parse - RExC_precomp;
	RExC_start =  RExC_parse = SvPV(substitute_parse, len);
        RExC_adjusted_start = RExC_start + prefix_end;
	RExC_end = RExC_parse + len;
        RExC_in_multi_char_class = 1;
        RExC_emit = (regnode *)orig_emit;

	ret = reg(pRExC_state, 1, &reg_flags, depth+1);

	*flagp |= reg_flags&(HASWIDTH|SIMPLE|SPSTART|POSTPONED|RESTART_PASS1|NEED_UTF8);

        /* And restore so can parse the rest of the pattern */
        RExC_parse = save_parse;
	RExC_start = RExC_adjusted_start = save_start;
        RExC_precomp_adj = 0;
	RExC_end = save_end;
	RExC_in_multi_char_class = 0;
        SvREFCNT_dec_NN(multi_char_matches);
        return ret;
    }

    /* Here, we've gone through the entire class and dealt with multi-char
     * folds.  We are now in a position that we can do some checks to see if we
     * can optimize this ANYOF node into a simpler one, even in Pass 1.
     * Currently we only do two checks:
     * 1) is in the unlikely event that the user has specified both, eg. \w and
     *    \W under /l, then the class matches everything.  (This optimization
     *    is done only to make the optimizer code run later work.)
     * 2) if the character class contains only a single element (including a
     *    single range), we see if there is an equivalent node for it.
     * Other checks are possible */
    if (   optimizable
        && ! ret_invlist   /* Can't optimize if returning the constructed
                              inversion list */
        && (UNLIKELY(posixl_matches_all) || element_count == 1))
    {
        U8 op = END;
        U8 arg = 0;

        if (UNLIKELY(posixl_matches_all)) {
            op = SANY;
        }
        else if (namedclass > OOB_NAMEDCLASS) { /* this is a single named
                                                   class, like \w or [:digit:]
                                                   or \p{foo} */

            /* All named classes are mapped into POSIXish nodes, with its FLAG
             * argument giving which class it is */
            switch ((I32)namedclass) {
                case ANYOF_UNIPROP:
                    break;

                /* These don't depend on the charset modifiers.  They always
                 * match under /u rules */
                case ANYOF_NHORIZWS:
                case ANYOF_HORIZWS:
                    namedclass = ANYOF_BLANK + namedclass - ANYOF_HORIZWS;
                    /* FALLTHROUGH */

                case ANYOF_NVERTWS:
                case ANYOF_VERTWS:
                    op = POSIXU;
                    goto join_posix;

                /* The actual POSIXish node for all the rest depends on the
                 * charset modifier.  The ones in the first set depend only on
                 * ASCII or, if available on this platform, also locale */
                case ANYOF_ASCII:
                case ANYOF_NASCII:
#ifdef HAS_ISASCII
                    op = (LOC) ? POSIXL : POSIXA;
#else
                    op = POSIXA;
#endif
                    goto join_posix;

                /* The following don't have any matches in the upper Latin1
                 * range, hence /d is equivalent to /u for them.  Making it /u
                 * saves some branches at runtime */
                case ANYOF_DIGIT:
                case ANYOF_NDIGIT:
                case ANYOF_XDIGIT:
                case ANYOF_NXDIGIT:
                    if (! DEPENDS_SEMANTICS) {
                        goto treat_as_default;
                    }

                    op = POSIXU;
                    goto join_posix;

                /* The following change to CASED under /i */
                case ANYOF_LOWER:
                case ANYOF_NLOWER:
                case ANYOF_UPPER:
                case ANYOF_NUPPER:
                    if (FOLD) {
                        namedclass = ANYOF_CASED + (namedclass % 2);
                    }
                    /* FALLTHROUGH */

                /* The rest have more possibilities depending on the charset.
                 * We take advantage of the enum ordering of the charset
                 * modifiers to get the exact node type, */
                default:
                  treat_as_default:
                    op = POSIXD + get_regex_charset(RExC_flags);
                    if (op > POSIXA) { /* /aa is same as /a */
                        op = POSIXA;
                    }

                  join_posix:
                    /* The odd numbered ones are the complements of the
                     * next-lower even number one */
                    if (namedclass % 2 == 1) {
                        invert = ! invert;
                        namedclass--;
                    }
                    arg = namedclass_to_classnum(namedclass);
                    break;
            }
        }
        else if (value == prevvalue) {

            /* Here, the class consists of just a single code point */

            if (invert) {
                if (! LOC && value == '\n') {
                    op = REG_ANY; /* Optimize [^\n] */
                    *flagp |= HASWIDTH|SIMPLE;
                    MARK_NAUGHTY(1);
                }
            }
            else if (value < 256 || UTF) {

                /* Optimize a single value into an EXACTish node, but not if it
                 * would require converting the pattern to UTF-8. */
                op = compute_EXACTish(pRExC_state);
            }
        } /* Otherwise is a range */
        else if (! LOC) {   /* locale could vary these */
            if (prevvalue == '0') {
                if (value == '9') {
                    arg = _CC_DIGIT;
                    op = POSIXA;
                }
            }
            else if (! FOLD || ASCII_FOLD_RESTRICTED) {
                /* We can optimize A-Z or a-z, but not if they could match
                 * something like the KELVIN SIGN under /i. */
                if (prevvalue == 'A') {
                    if (value == 'Z'
#ifdef EBCDIC
                        && ! non_portable_endpoint
#endif
                    ) {
                        arg = (FOLD) ? _CC_ALPHA : _CC_UPPER;
                        op = POSIXA;
                    }
                }
                else if (prevvalue == 'a') {
                    if (value == 'z'
#ifdef EBCDIC
                        && ! non_portable_endpoint
#endif
                    ) {
                        arg = (FOLD) ? _CC_ALPHA : _CC_LOWER;
                        op = POSIXA;
                    }
                }
            }
        }

        /* Here, we have changed <op> away from its initial value iff we found
         * an optimization */
        if (op != END) {

            /* Throw away this ANYOF regnode, and emit the calculated one,
             * which should correspond to the beginning, not current, state of
             * the parse */
            const char * cur_parse = RExC_parse;
            RExC_parse = (char *)orig_parse;
            if ( SIZE_ONLY) {
                if (! LOC) {

                    /* To get locale nodes to not use the full ANYOF size would
                     * require moving the code above that writes the portions
                     * of it that aren't in other nodes to after this point.
                     * e.g.  ANYOF_POSIXL_SET */
                    RExC_size = orig_size;
                }
            }
            else {
                RExC_emit = (regnode *)orig_emit;
                if (PL_regkind[op] == POSIXD) {
                    if (op == POSIXL) {
                        RExC_contains_locale = 1;
                    }
                    if (invert) {
                        op += NPOSIXD - POSIXD;
                    }
                }
            }

            ret = reg_node(pRExC_state, op);

            if (PL_regkind[op] == POSIXD || PL_regkind[op] == NPOSIXD) {
                if (! SIZE_ONLY) {
                    FLAGS(ret) = arg;
                }
                *flagp |= HASWIDTH|SIMPLE;
            }
            else if (PL_regkind[op] == EXACT) {
                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, 0, value,
                                           TRUE /* downgradable to EXACT */
                                           );
            }

            RExC_parse = (char *) cur_parse;

            SvREFCNT_dec(posixes);
            SvREFCNT_dec(nposixes);
            SvREFCNT_dec(simple_posixes);
            SvREFCNT_dec(cp_list);
            SvREFCNT_dec(cp_foldable_list);
            return ret;
        }
    }

    if (SIZE_ONLY)
        return ret;
    /****** !SIZE_ONLY (Pass 2) AFTER HERE *********/

    /* If folding, we calculate all characters that could fold to or from the
     * ones already on the list */
    if (cp_foldable_list) {
        if (FOLD) {
            UV start, end;	/* End points of code point ranges */

            SV* fold_intersection = NULL;
            SV** use_list;

            /* Our calculated list will be for Unicode rules.  For locale
             * matching, we have to keep a separate list that is consulted at
             * runtime only when the locale indicates Unicode rules.  For
             * non-locale, we just use the general list */
            if (LOC) {
                use_list = &only_utf8_locale_list;
            }
            else {
                use_list = &cp_list;
            }

            /* Only the characters in this class that participate in folds need
             * be checked.  Get the intersection of this class and all the
             * possible characters that are foldable.  This can quickly narrow
             * down a large class */
            _invlist_intersection(PL_utf8_foldable, cp_foldable_list,
                                  &fold_intersection);

            /* The folds for all the Latin1 characters are hard-coded into this
             * program, but we have to go out to disk to get the others. */
            if (invlist_highest(cp_foldable_list) >= 256) {

                /* This is a hash that for a particular fold gives all
                 * characters that are involved in it */
                if (! PL_utf8_foldclosures) {
                    _load_PL_utf8_foldclosures();
                }
            }

            /* Now look at the foldable characters in this class individually */
            invlist_iterinit(fold_intersection);
            while (invlist_iternext(fold_intersection, &start, &end)) {
                UV j;

                /* Look at every character in the range */
                for (j = start; j <= end; j++) {
                    U8 foldbuf[UTF8_MAXBYTES_CASE+1];
                    STRLEN foldlen;
                    SV** listp;

                    if (j < 256) {

                        if (IS_IN_SOME_FOLD_L1(j)) {

                            /* ASCII is always matched; non-ASCII is matched
                             * only under Unicode rules (which could happen
                             * under /l if the locale is a UTF-8 one */
                            if (isASCII(j) || ! DEPENDS_SEMANTICS) {
                                *use_list = add_cp_to_invlist(*use_list,
                                                            PL_fold_latin1[j]);
                            }
                            else {
                                has_upper_latin1_only_utf8_matches
                                    = add_cp_to_invlist(
                                            has_upper_latin1_only_utf8_matches,
                                            PL_fold_latin1[j]);
                            }
                        }

                        if (HAS_NONLATIN1_SIMPLE_FOLD_CLOSURE(j)
                            && (! isASCII(j) || ! ASCII_FOLD_RESTRICTED))
                        {
                            add_above_Latin1_folds(pRExC_state,
                                                   (U8) j,
                                                   use_list);
                        }
                        continue;
                    }

                    /* Here is an above Latin1 character.  We don't have the
                     * rules hard-coded for it.  First, get its fold.  This is
                     * the simple fold, as the multi-character folds have been
                     * handled earlier and separated out */
                    _to_uni_fold_flags(j, foldbuf, &foldlen,
                                                        (ASCII_FOLD_RESTRICTED)
                                                        ? FOLD_FLAGS_NOMIX_ASCII
                                                        : 0);

                    /* Single character fold of above Latin1.  Add everything in
                    * its fold closure to the list that this node should match.
                    * The fold closures data structure is a hash with the keys
                    * being the UTF-8 of every character that is folded to, like
                    * 'k', and the values each an array of all code points that
                    * fold to its key.  e.g. [ 'k', 'K', KELVIN_SIGN ].
                    * Multi-character folds are not included */
                    if ((listp = hv_fetch(PL_utf8_foldclosures,
                                        (char *) foldbuf, foldlen, FALSE)))
                    {
                        AV* list = (AV*) *listp;
                        IV k;
                        for (k = 0; k <= av_tindex_skip_len_mg(list); k++) {
                            SV** c_p = av_fetch(list, k, FALSE);
                            UV c;
                            assert(c_p);

                            c = SvUV(*c_p);

                            /* /aa doesn't allow folds between ASCII and non- */
                            if ((ASCII_FOLD_RESTRICTED
                                && (isASCII(c) != isASCII(j))))
                            {
                                continue;
                            }

                            /* Folds under /l which cross the 255/256 boundary
                             * are added to a separate list.  (These are valid
                             * only when the locale is UTF-8.) */
                            if (c < 256 && LOC) {
                                *use_list = add_cp_to_invlist(*use_list, c);
                                continue;
                            }

                            if (isASCII(c) || c > 255 || AT_LEAST_UNI_SEMANTICS)
                            {
                                cp_list = add_cp_to_invlist(cp_list, c);
                            }
                            else {
                                /* Similarly folds involving non-ascii Latin1
                                * characters under /d are added to their list */
                                has_upper_latin1_only_utf8_matches
                                        = add_cp_to_invlist(
                                           has_upper_latin1_only_utf8_matches,
                                           c);
                            }
                        }
                    }
                }
            }
            SvREFCNT_dec_NN(fold_intersection);
        }

        /* Now that we have finished adding all the folds, there is no reason
         * to keep the foldable list separate */
        _invlist_union(cp_list, cp_foldable_list, &cp_list);
	SvREFCNT_dec_NN(cp_foldable_list);
    }

    /* And combine the result (if any) with any inversion lists from posix
     * classes.  The lists are kept separate up to now because we don't want to
     * fold the classes (folding of those is automatically handled by the swash
     * fetching code) */
    if (simple_posixes) {   /* These are the classes known to be unaffected by
                               /a, /aa, and /d */
        if (cp_list) {
            _invlist_union(cp_list, simple_posixes, &cp_list);
            SvREFCNT_dec_NN(simple_posixes);
        }
        else {
            cp_list = simple_posixes;
        }
    }
    if (posixes || nposixes) {

        /* We have to adjust /a and /aa */
        if (AT_LEAST_ASCII_RESTRICTED) {

            /* Under /a and /aa, nothing above ASCII matches these */
            if (posixes) {
                _invlist_intersection(posixes,
                                    PL_XPosix_ptrs[_CC_ASCII],
                                    &posixes);
            }

            /* Under /a and /aa, everything above ASCII matches these
             * complements */
            if (nposixes) {
                _invlist_union_complement_2nd(nposixes,
                                              PL_XPosix_ptrs[_CC_ASCII],
                                              &nposixes);
            }
        }

        if (! DEPENDS_SEMANTICS) {

            /* For everything but /d, we can just add the current 'posixes' and
             * 'nposixes' to the main list */
            if (posixes) {
                if (cp_list) {
                    _invlist_union(cp_list, posixes, &cp_list);
                    SvREFCNT_dec_NN(posixes);
                }
                else {
                    cp_list = posixes;
                }
            }
            if (nposixes) {
                if (cp_list) {
                    _invlist_union(cp_list, nposixes, &cp_list);
                    SvREFCNT_dec_NN(nposixes);
                }
                else {
                    cp_list = nposixes;
                }
            }
        }
        else {
            /* Under /d, things like \w match upper Latin1 characters only if
             * the target string is in UTF-8.  But things like \W match all the
             * upper Latin1 characters if the target string is not in UTF-8.
             *
             * Handle the case where there something like \W separately */
            if (nposixes) {
                SV* only_non_utf8_list = invlist_clone(PL_UpperLatin1);

                /* A complemented posix class matches all upper Latin1
                 * characters if not in UTF-8.  And it matches just certain
                 * ones when in UTF-8.  That means those certain ones are
                 * matched regardless, so can just be added to the
                 * unconditional list */
                if (cp_list) {
                    _invlist_union(cp_list, nposixes, &cp_list);
                    SvREFCNT_dec_NN(nposixes);
                    nposixes = NULL;
                }
                else {
                    cp_list = nposixes;
                }

                /* Likewise for 'posixes' */
                _invlist_union(posixes, cp_list, &cp_list);

                /* Likewise for anything else in the range that matched only
                 * under UTF-8 */
                if (has_upper_latin1_only_utf8_matches) {
                    _invlist_union(cp_list,
                                   has_upper_latin1_only_utf8_matches,
                                   &cp_list);
                    SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);
                    has_upper_latin1_only_utf8_matches = NULL;
                }

                /* If we don't match all the upper Latin1 characters regardless
                 * of UTF-8ness, we have to set a flag to match the rest when
                 * not in UTF-8 */
                _invlist_subtract(only_non_utf8_list, cp_list,
                                  &only_non_utf8_list);
                if (_invlist_len(only_non_utf8_list) != 0) {
                    ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;
                }
            }
            else {
                /* Here there were no complemented posix classes.  That means
                 * the upper Latin1 characters in 'posixes' match only when the
                 * target string is in UTF-8.  So we have to add them to the
                 * list of those types of code points, while adding the
                 * remainder to the unconditional list.
                 *
                 * First calculate what they are */
                SV* nonascii_but_latin1_properties = NULL;
                _invlist_intersection(posixes, PL_UpperLatin1,
                                      &nonascii_but_latin1_properties);

                /* And add them to the final list of such characters. */
                _invlist_union(has_upper_latin1_only_utf8_matches,
                               nonascii_but_latin1_properties,
                               &has_upper_latin1_only_utf8_matches);

                /* Remove them from what now becomes the unconditional list */
                _invlist_subtract(posixes, nonascii_but_latin1_properties,
                                  &posixes);

                /* And add those unconditional ones to the final list */
                if (cp_list) {
                    _invlist_union(cp_list, posixes, &cp_list);
                    SvREFCNT_dec_NN(posixes);
                    posixes = NULL;
                }
                else {
                    cp_list = posixes;
                }

                SvREFCNT_dec(nonascii_but_latin1_properties);

                /* Get rid of any characters that we now know are matched
                 * unconditionally from the conditional list, which may make
                 * that list empty */
                _invlist_subtract(has_upper_latin1_only_utf8_matches,
                                  cp_list,
                                  &has_upper_latin1_only_utf8_matches);
                if (_invlist_len(has_upper_latin1_only_utf8_matches) == 0) {
                    SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);
                    has_upper_latin1_only_utf8_matches = NULL;
                }
            }
        }
    }

    /* And combine the result (if any) with any inversion list from properties.
     * The lists are kept separate up to now so that we can distinguish the two
     * in regards to matching above-Unicode.  A run-time warning is generated
     * if a Unicode property is matched against a non-Unicode code point. But,
     * we allow user-defined properties to match anything, without any warning,
     * and we also suppress the warning if there is a portion of the character
     * class that isn't a Unicode property, and which matches above Unicode, \W
     * or [\x{110000}] for example.
     * (Note that in this case, unlike the Posix one above, there is no
     * <has_upper_latin1_only_utf8_matches>, because having a Unicode property
     * forces Unicode semantics */
    if (properties) {
        if (cp_list) {

            /* If it matters to the final outcome, see if a non-property
             * component of the class matches above Unicode.  If so, the
             * warning gets suppressed.  This is true even if just a single
             * such code point is specified, as, though not strictly correct if
             * another such code point is matched against, the fact that they
             * are using above-Unicode code points indicates they should know
             * the issues involved */
            if (warn_super) {
                warn_super = ! (invert
                               ^ (invlist_highest(cp_list) > PERL_UNICODE_MAX));
            }

            _invlist_union(properties, cp_list, &cp_list);
            SvREFCNT_dec_NN(properties);
        }
        else {
            cp_list = properties;
        }

        if (warn_super) {
            ANYOF_FLAGS(ret)
             |= ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER;

            /* Because an ANYOF node is the only one that warns, this node
             * can't be optimized into something else */
            optimizable = FALSE;
        }
    }

    /* Here, we have calculated what code points should be in the character
     * class.
     *
     * Now we can see about various optimizations.  Fold calculation (which we
     * did above) needs to take place before inversion.  Otherwise /[^k]/i
     * would invert to include K, which under /i would match k, which it
     * shouldn't.  Therefore we can't invert folded locale now, as it won't be
     * folded until runtime */

    /* If we didn't do folding, it's because some information isn't available
     * until runtime; set the run-time fold flag for these.  (We don't have to
     * worry about properties folding, as that is taken care of by the swash
     * fetching).  We know to set the flag if we have a non-NULL list for UTF-8
     * locales, or the class matches at least one 0-255 range code point */
    if (LOC && FOLD) {

        /* Some things on the list might be unconditionally included because of
         * other components.  Remove them, and clean up the list if it goes to
         * 0 elements */
        if (only_utf8_locale_list && cp_list) {
            _invlist_subtract(only_utf8_locale_list, cp_list,
                              &only_utf8_locale_list);

            if (_invlist_len(only_utf8_locale_list) == 0) {
                SvREFCNT_dec_NN(only_utf8_locale_list);
                only_utf8_locale_list = NULL;
            }
        }
        if (only_utf8_locale_list) {
            ANYOF_FLAGS(ret)
                 |=  ANYOFL_FOLD
                    |ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD;
        }
        else if (cp_list) { /* Look to see if a 0-255 code point is in list */
            UV start, end;
            invlist_iterinit(cp_list);
            if (invlist_iternext(cp_list, &start, &end) && start < 256) {
                ANYOF_FLAGS(ret) |= ANYOFL_FOLD;
            }
            invlist_iterfinish(cp_list);
        }
    }
    else if (   DEPENDS_SEMANTICS
             && (    has_upper_latin1_only_utf8_matches
                 || (ANYOF_FLAGS(ret) & ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER)))
    {
        OP(ret) = ANYOFD;
        optimizable = FALSE;
    }


    /* Optimize inverted simple patterns (e.g. [^a-z]) when everything is known
     * at compile time.  Besides not inverting folded locale now, we can't
     * invert if there are things such as \w, which aren't known until runtime
     * */
    if (cp_list
        && invert
        && OP(ret) != ANYOFD
        && ! (ANYOF_FLAGS(ret) & (ANYOF_LOCALE_FLAGS))
	&& ! HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)
    {
        _invlist_invert(cp_list);

        /* Any swash can't be used as-is, because we've inverted things */
        if (swash) {
            SvREFCNT_dec_NN(swash);
            swash = NULL;
        }

	/* Clear the invert flag since have just done it here */
	invert = FALSE;
    }

    if (ret_invlist) {
        assert(cp_list);

        *ret_invlist = cp_list;
        SvREFCNT_dec(swash);

        /* Discard the generated node */
        if (SIZE_ONLY) {
            RExC_size = orig_size;
        }
        else {
            RExC_emit = orig_emit;
        }
        return orig_emit;
    }

    /* Some character classes are equivalent to other nodes.  Such nodes take
     * up less room and generally fewer operations to execute than ANYOF nodes.
     * Above, we checked for and optimized into some such equivalents for
     * certain common classes that are easy to test.  Getting to this point in
     * the code means that the class didn't get optimized there.  Since this
     * code is only executed in Pass 2, it is too late to save space--it has
     * been allocated in Pass 1, and currently isn't given back.  But turning
     * things into an EXACTish node can allow the optimizer to join it to any
     * adjacent such nodes.  And if the class is equivalent to things like /./,
     * expensive run-time swashes can be avoided.  Now that we have more
     * complete information, we can find things necessarily missed by the
     * earlier code.  Another possible "optimization" that isn't done is that
     * something like [Ee] could be changed into an EXACTFU.  khw tried this
     * and found that the ANYOF is faster, including for code points not in the
     * bitmap.  This still might make sense to do, provided it got joined with
     * an adjacent node(s) to create a longer EXACTFU one.  This could be
     * accomplished by creating a pseudo ANYOF_EXACTFU node type that the join
     * routine would know is joinable.  If that didn't happen, the node type
     * could then be made a straight ANYOF */

    if (optimizable && cp_list && ! invert) {
        UV start, end;
        U8 op = END;  /* The optimzation node-type */
        int posix_class = -1;   /* Illegal value */
        const char * cur_parse= RExC_parse;

        invlist_iterinit(cp_list);
        if (! invlist_iternext(cp_list, &start, &end)) {

            /* Here, the list is empty.  This happens, for example, when a
             * Unicode property that doesn't match anything is the only element
             * in the character class (perluniprops.pod notes such properties).
             * */
            op = OPFAIL;
            *flagp |= HASWIDTH|SIMPLE;
        }
        else if (start == end) {    /* The range is a single code point */
            if (! invlist_iternext(cp_list, &start, &end)

                    /* Don't do this optimization if it would require changing
                     * the pattern to UTF-8 */
                && (start < 256 || UTF))
            {
                /* Here, the list contains a single code point.  Can optimize
                 * into an EXACTish node */

                value = start;

                if (! FOLD) {
                    op = (LOC)
                         ? EXACTL
                         : EXACT;
                }
                else if (LOC) {

                    /* A locale node under folding with one code point can be
                     * an EXACTFL, as its fold won't be calculated until
                     * runtime */
                    op = EXACTFL;
                }
                else {

                    /* Here, we are generally folding, but there is only one
                     * code point to match.  If we have to, we use an EXACT
                     * node, but it would be better for joining with adjacent
                     * nodes in the optimization pass if we used the same
                     * EXACTFish node that any such are likely to be.  We can
                     * do this iff the code point doesn't participate in any
                     * folds.  For example, an EXACTF of a colon is the same as
                     * an EXACT one, since nothing folds to or from a colon. */
                    if (value < 256) {
                        if (IS_IN_SOME_FOLD_L1(value)) {
                            op = EXACT;
                        }
                    }
                    else {
                        if (_invlist_contains_cp(PL_utf8_foldable, value)) {
                            op = EXACT;
                        }
                    }

                    /* If we haven't found the node type, above, it means we
                     * can use the prevailing one */
                    if (op == END) {
                        op = compute_EXACTish(pRExC_state);
                    }
                }
            }
        }   /* End of first range contains just a single code point */
        else if (start == 0) {
            if (end == UV_MAX) {
                op = SANY;
                *flagp |= HASWIDTH|SIMPLE;
                MARK_NAUGHTY(1);
            }
            else if (end == '\n' - 1
                    && invlist_iternext(cp_list, &start, &end)
                    && start == '\n' + 1 && end == UV_MAX)
            {
                op = REG_ANY;
                *flagp |= HASWIDTH|SIMPLE;
                MARK_NAUGHTY(1);
            }
        }
        invlist_iterfinish(cp_list);

        if (op == END) {
            const UV cp_list_len = _invlist_len(cp_list);
            const UV* cp_list_array = invlist_array(cp_list);

            /* Here, didn't find an optimization.  See if this matches any of
             * the POSIX classes.  These run slightly faster for above-Unicode
             * code points, so don't bother with POSIXA ones nor the 2 that
             * have no above-Unicode matches.  We can avoid these checks unless
             * the ANYOF matches at least as high as the lowest POSIX one
             * (which was manually found to be \v.  The actual code point may
             * increase in later Unicode releases, if a higher code point is
             * assigned to be \v, but this code will never break.  It would
             * just mean we could execute the checks for posix optimizations
             * unnecessarily) */

            if (cp_list_array[cp_list_len-1] > 0x2029) {
                for (posix_class = 0;
                     posix_class <= _HIGHEST_REGCOMP_DOT_H_SYNC;
                     posix_class++)
                {
                    int try_inverted;
                    if (posix_class == _CC_ASCII || posix_class == _CC_CNTRL) {
                        continue;
                    }
                    for (try_inverted = 0; try_inverted < 2; try_inverted++) {

                        /* Check if matches normal or inverted */
                        if (_invlistEQ(cp_list,
                                       PL_XPosix_ptrs[posix_class],
                                       try_inverted))
                        {
                            op = (try_inverted)
                                 ? NPOSIXU
                                 : POSIXU;
                            *flagp |= HASWIDTH|SIMPLE;
                            goto found_posix;
                        }
                    }
                }
              found_posix: ;
            }
        }

        if (op != END) {
            RExC_parse = (char *)orig_parse;
            RExC_emit = (regnode *)orig_emit;

            if (regarglen[op]) {
                ret = reganode(pRExC_state, op, 0);
            } else {
                ret = reg_node(pRExC_state, op);
            }

            RExC_parse = (char *)cur_parse;

            if (PL_regkind[op] == EXACT) {
                alloc_maybe_populate_EXACT(pRExC_state, ret, flagp, 0, value,
                                           TRUE /* downgradable to EXACT */
                                          );
            }
            else if (PL_regkind[op] == POSIXD || PL_regkind[op] == NPOSIXD) {
                FLAGS(ret) = posix_class;
            }

            SvREFCNT_dec_NN(cp_list);
            return ret;
        }
    }

    /* Here, <cp_list> contains all the code points we can determine at
     * compile time that match under all conditions.  Go through it, and
     * for things that belong in the bitmap, put them there, and delete from
     * <cp_list>.  While we are at it, see if everything above 255 is in the
     * list, and if so, set a flag to speed up execution */

    populate_ANYOF_from_invlist(ret, &cp_list);

    if (invert) {
        ANYOF_FLAGS(ret) |= ANYOF_INVERT;
    }

    /* Here, the bitmap has been populated with all the Latin1 code points that
     * always match.  Can now add to the overall list those that match only
     * when the target string is UTF-8 (<has_upper_latin1_only_utf8_matches>).
     * */
    if (has_upper_latin1_only_utf8_matches) {
	if (cp_list) {
	    _invlist_union(cp_list,
                           has_upper_latin1_only_utf8_matches,
                           &cp_list);
	    SvREFCNT_dec_NN(has_upper_latin1_only_utf8_matches);
	}
	else {
	    cp_list = has_upper_latin1_only_utf8_matches;
	}
        ANYOF_FLAGS(ret) |= ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP;
    }

    /* If there is a swash and more than one element, we can't use the swash in
     * the optimization below. */
    if (swash && element_count > 1) {
	SvREFCNT_dec_NN(swash);
	swash = NULL;
    }

    /* Note that the optimization of using 'swash' if it is the only thing in
     * the class doesn't have us change swash at all, so it can include things
     * that are also in the bitmap; otherwise we have purposely deleted that
     * duplicate information */
    set_ANYOF_arg(pRExC_state, ret, cp_list,
                  (HAS_NONLOCALE_RUNTIME_PROPERTY_DEFINITION)
                   ? listsv : NULL,
                  only_utf8_locale_list,
                  swash, has_user_defined_property);

    *flagp |= HASWIDTH|SIMPLE;

    if (ANYOF_FLAGS(ret) & ANYOF_LOCALE_FLAGS) {
        RExC_contains_locale = 1;
    }

    return ret;
}
