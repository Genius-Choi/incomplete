static void cmd_print_format(RCore *core, const char *_input, const ut8* block, int len) {
	char *input = NULL;
	int mode = R_PRINT_MUSTSEE;
	switch (_input[1]) {
	case '*': // "pf*"
		_input++;
		mode = R_PRINT_SEEFLAGS;
		break;
	case 'q': // "pfq"
		_input++;
		mode = R_PRINT_QUIET | R_PRINT_MUSTSEE;
		break;
	case 'd': // "pfd"
		_input++;
		mode = R_PRINT_DOT;
		break;
	case 'j': // "pfj"
		_input++;
		mode = R_PRINT_JSON;
		break;
	case 'v': // "pfv"
		_input++;
		mode = R_PRINT_VALUE | R_PRINT_MUSTSEE;
		break;
	case 'c': // "pfc"
		_input++;
		mode = R_PRINT_STRUCT;
		break;
	case 's': { // "pfs"
		const char *val = NULL;
		_input += 2;
		if (*_input == '.') {
			_input++;
			val = sdb_get (core->print->formats, _input, NULL);
			if (val) {
				r_cons_printf ("%d\n", r_print_format_struct_size (core->print, val, mode, 0));
			} else {
				R_LOG_WARN ("Struct %s not defined. Use pfs.struct_name | pfs format", _input);
			}
		} else if (*_input == ' ') {
			while (*_input == ' ' && *_input != '\0') {
				_input++;
			}
			if (*_input) {
				r_cons_printf ("%d\n", r_print_format_struct_size (core->print, _input, mode, 0));
			} else {
				R_LOG_WARN ("Struct %s not defined. Use pfs.struct_name | pfs format", _input);
			}
		} else {
			eprintf ("Usage: pfs.struct_name | pfs format\n");
		}
		return;
	}
	case '?': // "pf?"
		_input += 2;
		if (*_input) {
			if (*_input == '?') {
				_input++;
				if (_input && *_input == '?') {
					_input++;
					if (_input && *_input == '?') {
						print_format_help_help_help_help (core);
					} else {
						r_core_cmd_help (core, help_detail2_pf);
					}
				} else {
					r_core_cmd_help (core, help_detail_pf);
				}
			} else {
				const char *struct_name = r_str_trim_head_ro (_input);
				const char *val = sdb_const_get (core->print->formats, struct_name, NULL);
				if (val) {
					r_cons_printf ("%s\n", val);
				} else {
					R_LOG_ERROR ("Struct %s is not defined", _input);
				}
			}
		} else {
			r_core_cmd_help (core, help_msg_pf);
		}
		return;
	case 'b': // "pfb"
		if (_input[2] == ' ') {
			r_core_cmd_print_binformat (core, r_str_trim_head_ro (_input + 2), PFB_ART);
		} else {
			eprintf ("Usage: pfb [binfmt] [names...]\n");
		}
		return;
	case 'o': // "pfo"
		if (_input[2] == '?') {
			cmd_pfo_help (core);
		} else if (_input[2] == ' ') {
			const char *fname = r_str_trim_head_ro (_input + 3);
			char *tmp = r_str_newf (R_JOIN_2_PATHS (R2_SDB_FORMAT, "%s"), fname);
			char *path = r_str_r2_prefix (tmp);
			if (r_str_endswith (_input, ".h")) {
				char *error_msg = NULL;
				const char *dir = r_config_get (core->config, "dir.types");
				char *out = r_anal_cparse_file (core->anal, path, dir, &error_msg);
				if (out) {
					r_anal_save_parsed_type (core->anal, out);
					r_core_cmd0 (core, ".ts*");
					free (out);
				} else {
					R_LOG_ERROR ("Cannot parse: %s", error_msg);
				}
			} else {
				/// XXX not sure what this code is suposed to be used for
				char *home = r_xdg_datadir ("format");
				if (!r_core_cmd_file (core, home) && !r_core_cmd_file (core, path)) {
					if (!r_core_cmd_file (core, _input + 3)) {
						R_LOG_ERROR ("pfo: cannot open format file at '%s'", path);
					}
				}
				free (home);
			}
			free (path);
			free (tmp);
		} else {
			RList *files;
			RListIter *iter;
			const char *fn;
			char *home = r_xdg_datadir ("format");
			if (home) {
				files = r_sys_dir (home);
				r_list_foreach (files, iter, fn) {
					if (*fn && *fn != '.') {
						r_cons_println (fn);
					}
				}
				r_list_free (files);
				free (home);
			}
			char *path = r_str_r2_prefix (R2_SDB_FORMAT R_SYS_DIR);
			if (path) {
				files = r_sys_dir (path);
				r_list_foreach (files, iter, fn) {
					if (*fn && *fn != '.') {
						r_cons_println (fn);
					}
				}
				r_list_free (files);
				free (path);
			}
		}
		return;
	} // switch

	input = strdup (_input);
	/* syntax aliasing bridge for 'pf foo=xxd' -> 'pf.foo xxd' */
	if (input[1] == ' ') {
		char *eq = strchr (input + 2, '=');
		if (eq) {
			input[1] = '.';
			*eq = ' ';
		}
	}

	bool listFormats = false;
	if (input[1] == '.') {
		listFormats = true;
	} else if (!strcmp (input, "*") && mode == R_PRINT_SEEFLAGS) {
		listFormats = true;
	}

	core->print->reg = core->dbg->reg;
	core->print->get_register = r_reg_get;
	core->print->get_register_value = r_reg_get_value;

	int o_blocksize = core->blocksize;

	if (listFormats) {
		core->print->num = core->num;
		/* print all stored format */
		if (!input[1] || !input[2]) { // "pf."
			SdbListIter *iter;
			SdbKv *kv;
			SdbList *sdbls = sdb_foreach_list (core->print->formats, true);
			ls_foreach (sdbls, iter, kv) {
				r_cons_printf ("pf.%s %s\n", sdbkv_key (kv), sdbkv_value (kv));
			}
			/* delete a format */
		} else if (input[1] && input[2] == '-') { // "pf-"
			if (input[3] == '*') { // "pf-*"
				sdb_free (core->print->formats);
				core->print->formats = sdb_new0 ();
			} else { // "pf-xxx"
				sdb_unset (core->print->formats, input + 3, 0);
			}
		} else {
			char *name = strdup (input + (input[1] ? 2 : 1));
			char *space = strchr (name, ' ');
			char *eq = strchr (name, '=');
			char *dot = strchr (name, '.');
			if (dot) {
				*dot = 0;
			}
			if (!space && !sdb_const_get (core->print->formats, name, NULL)) {
				R_LOG_ERROR ("Unknown format name '%s'", name);
				goto err_name;
			}
			if (dot) {
				*dot = '.';
			}
			if (space) {
				const char *afterspace = r_str_trim_head_ro (space + 1);
				if (*afterspace == '=' && eq) {
					r_str_cpy (space, afterspace);
					space = NULL;
				}
			}

			if (eq && !dot) {
				*eq = ' ';
				space = eq;
				eq = NULL;
			}

			/* store a new format */
			if (space && (!eq || space < eq)) {
				*space++ = 0;
				if (strchr (name, '.')) {
					R_LOG_ERROR ("Struct or fields name can not contain a dot (%s)", name);
				} else {
					// pf.foo=xxx
					sdb_set (core->print->formats, name, space, 0);
				}
				goto err_name;
			}

			if (!strchr (name, '.') && !sdb_const_get (core->print->formats, name, NULL)) {
				R_LOG_ERROR ("Cannot find '%s' format", name);
				goto err_name;
			}

			char *delim = strchr (name, '.');
			if (delim) {
				int len = delim - name;
				if (len > 0) {
					name[len] = '\0';
				}
			}

			/* Load format from name into fmt to get the size */
			/* Make sure the structure will be printed entirely */
			char *fmt = sdb_get (core->print->formats, name, NULL);
			if (fmt) {
				// TODO: what is +10 magic number?
				// Backtracks to commit e5e23c237755cdeb13ba15938c93ada590e453db / issue #2808
				int size = r_print_format_struct_size (core->print, fmt, mode, 0) + 10;
				if (size > core->blocksize) {
					r_core_block_size (core, size);
				}
				free (fmt);
			}
			/* display a format */
			if (dot) {
				*dot++ = 0;
				eq = strchr (dot, '=');
				if (eq) { // Write mode (pf.field=value)
					*eq++ = 0;
					r_str_trim_tail (name);
					mode = R_PRINT_MUSTSET;
					r_print_format (core->print, core->offset,
						core->block, core->blocksize, name, mode, eq, dot);
				} else {
					r_print_format (core->print, core->offset,
						core->block, core->blocksize, name, mode, NULL, dot);
				}
			} else {
				r_print_format (core->print, core->offset,
					core->block, core->blocksize, name, mode, NULL, NULL);
			}
		err_name:
			free (name);
		}
	} else {
		/* Make sure the structure will be printed entirely */
		ut8 *buf = NULL;
		const char *fmt = r_str_trim_head_ro (input + 1);
		int struct_sz = r_print_format_struct_size (core->print, fmt, mode, 0);
		int size = R_MAX (core->blocksize, struct_sz);
		if (size < 1) {
			goto err_buf;
		}
		buf = calloc (1, size);
		if (!buf) {
			goto err_buf;
		}
		memcpy (buf, core->block, core->blocksize);

		char *args = strdup (fmt);
		if (!args) {
			goto err_args;
		}

		/* check if fmt is '\d+ \d+<...>', common mistake due to usage string*/
		const char *arg1 = strtok (args, " ");
		if (arg1 && r_str_isnumber (arg1)) {
			r_core_cmd_help (core, (const char *[]) {
				"Usage:", "pf [0|cnt][format-string]", "",
				NULL
			});
			goto err_arg1;
		}
		r_print_format (core->print, core->offset,
			buf, size, fmt, mode, NULL, NULL);
	err_arg1:
		free (args);
	err_args:
		free (buf);
	err_buf:
		;
	}
	free (input);
	r_core_block_size (core, o_blocksize);
}
