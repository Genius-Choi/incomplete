void Filter::maybeDoShadowing() {
  for (const auto& shadow_policy_wrapper : active_shadow_policies_) {
    const auto& shadow_policy = shadow_policy_wrapper.get();

    ASSERT(!shadow_policy.cluster().empty());
    Http::RequestMessagePtr request(new Http::RequestMessageImpl(
        Http::createHeaderMap<Http::RequestHeaderMapImpl>(*downstream_headers_)));
    if (callbacks_->decodingBuffer()) {
      request->body().add(*callbacks_->decodingBuffer());
    }
    if (downstream_trailers_) {
      request->trailers(Http::createHeaderMap<Http::RequestTrailerMapImpl>(*downstream_trailers_));
    }

    auto options = Http::AsyncClient::RequestOptions()
                       .setTimeout(timeout_.global_timeout_)
                       .setParentSpan(callbacks_->activeSpan())
                       .setChildSpanName("mirror")
                       .setSampled(shadow_policy.traceSampled());
    config_.shadowWriter().shadow(shadow_policy.cluster(), std::move(request), options);
  }
}
