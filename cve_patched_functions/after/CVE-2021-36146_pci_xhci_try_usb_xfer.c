pci_xhci_try_usb_xfer(struct pci_xhci_vdev *xdev,
		      struct pci_xhci_dev_emu *dev,
		      struct pci_xhci_dev_ep *devep,
		      struct xhci_endp_ctx *ep_ctx,
		      uint32_t slot,
		      uint32_t epid)
{
	struct usb_xfer *xfer;
	int		err;
	int		do_intr;

	ep_ctx->dwEpCtx0 =
		FIELD_REPLACE(ep_ctx->dwEpCtx0, XHCI_ST_EPCTX_RUNNING, 0x7, 0);

	err = 0;
	do_intr = 0;

	xfer = devep->ep_xfer;
	pthread_mutex_lock(&devep->mtx);

	/* outstanding requests queued up */
	if (dev->dev_ue->ue_data != NULL) {
		err = dev->dev_ue->ue_data(dev->dev_instance, xfer, epid & 0x1 ?
					   USB_XFER_IN : USB_XFER_OUT, epid/2);
		if (err == USB_ERR_CANCELLED) {
			if (USB_DATA_GET_ERRCODE(&xfer->data[xfer->head]) ==
			    USB_NAK)
				err = XHCI_TRB_ERROR_SUCCESS;
		}
		/*
		 * Only for usb_mouse.c, emulation with port mapping will do it
		 * by the libusb callback function.
		 */
		else if (dev->dev_ue->ue_devtype == USB_DEV_STATIC) {
			err = pci_xhci_xfer_complete(xdev, xfer, slot, epid,
						     &do_intr);
			if (err == XHCI_TRB_ERROR_SUCCESS && do_intr)
				pci_xhci_assert_interrupt(xdev);

			pci_xhci_free_usb_xfer(devep->ep_xfer);
			devep->ep_xfer = NULL;
		}
	}

	pthread_mutex_unlock(&devep->mtx);
	return err;
}
