static void http_response_xsendfile2(server *srv, connection *con, const buffer *value, const array *xdocroot) {
    const char *pos = value->ptr;
    buffer *b = srv->tmp_buf;
    const int status = con->http_status;

    /* reset Content-Length, if set by backend */
    if (con->parsed_response & HTTP_CONTENT_LENGTH) {
        data_string *ds = (data_string *)
          array_get_element(con->response.headers, "Content-Length");
        if (ds) buffer_reset(ds->value);
        con->parsed_response &= ~HTTP_CONTENT_LENGTH;
        con->response.content_length = -1;
    }

    while (*pos) {
        const char *filename, *range;
        stat_cache_entry *sce;
        off_t begin_range, end_range, range_len;

        while (' ' == *pos) pos++;
        if (!*pos) break;

        filename = pos;
        if (NULL == (range = strchr(pos, ' '))) {
            /* missing range */
            log_error_write(srv, __FILE__, __LINE__, "ss",
                            "Couldn't find range after filename:", filename);
            con->http_status = 502;
            break;
        }
        buffer_copy_string_len(b, filename, range - filename);

        /* find end of range */
        for (pos = ++range; *pos && *pos != ' ' && *pos != ','; pos++) ;

        buffer_urldecode_path(b);
        buffer_path_simplify(b, b);
        if (con->conf.force_lowercase_filenames) {
            buffer_to_lower(b);
        }
        if (xdocroot->used) {
            size_t i, xlen = buffer_string_length(b);
            for (i = 0; i < xdocroot->used; ++i) {
                data_string *ds = (data_string *)xdocroot->data[i];
                size_t dlen = buffer_string_length(ds->value);
                if (dlen <= xlen
                    && (!con->conf.force_lowercase_filenames
                    ? 0 == memcmp(b->ptr, ds->value->ptr, dlen)
                    : 0 == strncasecmp(b->ptr, ds->value->ptr, dlen))) {
                    break;
                }
            }
            if (i == xdocroot->used) {
                log_error_write(srv, __FILE__, __LINE__, "SBs",
                                "X-Sendfile2 (", b,
                                ") not under configured x-sendfile-docroot(s)");
                con->http_status = 403;
                break;
            }
        }

        if (HANDLER_ERROR == stat_cache_get_entry(srv, con, b, &sce)) {
            log_error_write(srv, __FILE__, __LINE__, "sb", "send-file error: "
                            "couldn't get stat_cache entry for X-Sendfile2:",
                            b);
            con->http_status = 404;
            break;
        } else if (!S_ISREG(sce->st.st_mode)) {
            log_error_write(srv, __FILE__, __LINE__, "sb",
                            "send-file error: wrong filetype for X-Sendfile2:",
                            b);
            con->http_status = 502;
            break;
        }
        /* found the file */

        /* parse range */
        end_range = sce->st.st_size - 1;
        {
            char *rpos = NULL;
            errno = 0;
            begin_range = strtoll(range, &rpos, 10);
            if (errno != 0 || begin_range < 0 || rpos == range)
                goto range_failed;
            if ('-' != *rpos++) goto range_failed;
            if (rpos != pos) {
                range = rpos;
                end_range = strtoll(range, &rpos, 10);
                if (errno != 0 || end_range < 0 || rpos == range)
                    goto range_failed;
            }
            if (rpos != pos) goto range_failed;

            goto range_success;

range_failed:
            log_error_write(srv, __FILE__, __LINE__, "ss",
                            "Couldn't decode range after filename:", filename);
            con->http_status = 502;
            break;

range_success: ;
        }

        /* no parameters accepted */

        while (*pos == ' ') pos++;
        if (*pos != '\0' && *pos != ',') {
            con->http_status = 502;
            break;
        }

        range_len = end_range - begin_range + 1;
        if (range_len < 0) {
            con->http_status = 502;
            break;
        }
        if (range_len != 0) {
            if (0 != http_chunk_append_file_range(srv, con, b,
                                                  begin_range, range_len)) {
                con->http_status = 502;
                break;
            }
        }

        if (*pos == ',') pos++;
    }

    if (con->http_status >= 400 && status < 300) {
        con->mode = DIRECT;
    } else if (0 != status && 200 != status) {
        con->http_status = status;
    }
}
