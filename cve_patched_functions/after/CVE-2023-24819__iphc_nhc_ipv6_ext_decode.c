static size_t _iphc_nhc_ipv6_ext_decode(gnrc_pktsnip_t *sixlo, size_t offset,
                                        size_t *prev_nh_offset,
                                        gnrc_pktsnip_t *ipv6,
                                        size_t *uncomp_hdr_len)
{
    uint8_t *payload = sixlo->data;
    ipv6_ext_t *ext_hdr;
    uint8_t ipv6_ext_nhc = payload[offset++];
    uint8_t protnum;
    uint8_t ext_len = (ipv6_ext_nhc & NHC_IPV6_EXT_NH)
                    ? payload[offset]
                    : payload[offset + 1];

    /* realloc size for uncompressed snip, if too small */
    if (ipv6->size < (*uncomp_hdr_len + sizeof(ipv6_ext_t) + ext_len)) {
        if (gnrc_pktbuf_realloc_data(ipv6,
                                     *uncomp_hdr_len + sizeof(ipv6_ext_t) +
                                     ext_len)) {
            DEBUG("6lo iphc: unable to decode IPv6 Extension header NHC "
                  "(not enough buffer space)\n");
            return 0;
        }
    }
    ext_hdr = (ipv6_ext_t *)((uint8_t *)ipv6->data + *uncomp_hdr_len);
    switch (ipv6_ext_nhc & NHC_IPV6_EXT_EID_MASK) {
        case NHC_IPV6_EXT_EID_HOPOPT:
            protnum = PROTNUM_IPV6_EXT_HOPOPT;
            break;
        case NHC_IPV6_EXT_EID_RH:
            protnum = PROTNUM_IPV6_EXT_RH;
            break;
        case NHC_IPV6_EXT_EID_FRAG:
            protnum = PROTNUM_IPV6_EXT_FRAG;
            break;
        case NHC_IPV6_EXT_EID_DST:
            protnum = PROTNUM_IPV6_EXT_DST;
            break;
        case NHC_IPV6_EXT_EID_MOB:
            protnum = PROTNUM_IPV6_EXT_MOB;
            break;
        default:
            DEBUG("6lo iphc: unexpected extension header EID %u\n",
                  (ipv6_ext_nhc & NHC_IPV6_EXT_EID_MASK) >> 1U);
            return 0;
    }
    ((uint8_t *)ipv6->data)[*prev_nh_offset] = protnum;
    if (!(ipv6_ext_nhc & NHC_IPV6_EXT_NH)) {
        ext_hdr->nh = payload[offset++];
        /* signal end of next header compression to caller */
        *prev_nh_offset = 0;
    }
    else {
        *prev_nh_offset = (&ext_hdr->nh) - ((uint8_t *)ipv6->data);
    }
    /* skip already fetched length field */
    offset++;
    ext_hdr->len = ((sizeof(ipv6_ext_t) + ext_len) - IPV6_EXT_LEN_UNIT) /
                   IPV6_EXT_LEN_UNIT;
    memcpy(ext_hdr + 1, &payload[offset], ext_len);
    offset += ext_len;
    *uncomp_hdr_len += sizeof(ipv6_ext_t) + ext_len;
    return offset;
}
