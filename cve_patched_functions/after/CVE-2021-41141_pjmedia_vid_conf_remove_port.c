PJ_DEF(pj_status_t) pjmedia_vid_conf_remove_port( pjmedia_vid_conf *vid_conf,
						  unsigned slot)
{
    vconf_port *cport;

    PJ_ASSERT_RETURN(vid_conf && slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);

    pj_mutex_lock(vid_conf->mutex);

    /* Port must be valid. */
    cport = vid_conf->ports[slot];
    if (cport == NULL) {
	pj_mutex_unlock(vid_conf->mutex);
	return PJ_EINVAL;
    }

    /* Disconnect slot -> listeners */
    while (cport->listener_cnt) {
	pjmedia_vid_conf_disconnect_port(vid_conf, slot,
					 cport->listener_slots[0]);
    }

    /* Disconnect transmitters -> slot */
    while (cport->transmitter_cnt) {
	pjmedia_vid_conf_disconnect_port(vid_conf,
					 cport->transmitter_slots[0], slot);
    }

    /* Remove the port. */
    vid_conf->ports[slot] = NULL;
    --vid_conf->port_cnt;

    PJ_LOG(4,(THIS_FILE,"Removed port %d (%.*s)",
	      slot, (int)cport->name.slen, cport->name.ptr));

    /* Release pool */
    pj_pool_safe_release(&cport->pool);

    if (AUTO_STOP_CLOCK && vid_conf->connect_cnt == 0) {
	pj_status_t status;

	/* Warning: will stuck if this is called from the clock thread */
	status = pjmedia_clock_stop(vid_conf->clock);
	if (status != PJ_SUCCESS) {
	    PJ_PERROR(4, (THIS_FILE, status, "Failed to stop clock"));
	    pj_mutex_unlock(vid_conf->mutex);
	    return status;
	}
    }

    pj_mutex_unlock(vid_conf->mutex);

    return PJ_SUCCESS;
}
