type_str(const NetplanNetDefinition* def)
{
    const NetplanDefType type = def->type;
    switch (type) {
        case NETPLAN_DEF_TYPE_ETHERNET:
            /* 20-byte IPoIB MAC + colons */
            if (def->ib_mode || (def->match.mac && strlen(def->match.mac) == 59))
                return "infiniband";
            else
                return "ethernet";
        case NETPLAN_DEF_TYPE_MODEM:
            if (modem_is_gsm(def))
                return "gsm";
            else
                return "cdma";
        case NETPLAN_DEF_TYPE_WIFI:
            return "wifi";
        case NETPLAN_DEF_TYPE_BRIDGE:
            return "bridge";
        case NETPLAN_DEF_TYPE_BOND:
            return "bond";
        case NETPLAN_DEF_TYPE_VLAN:
            return "vlan";
        case NETPLAN_DEF_TYPE_VRF:
            return "vrf";
        case NETPLAN_DEF_TYPE_DUMMY:    /* wokeignore:rule=dummy */
            return "dummy";             /* wokeignore:rule=dummy */
        case NETPLAN_DEF_TYPE_VETH:
            return "veth";
        case NETPLAN_DEF_TYPE_TUNNEL:
            if (def->tunnel.mode == NETPLAN_TUNNEL_MODE_WIREGUARD)
                return "wireguard";
            else if (def->tunnel.mode == NETPLAN_TUNNEL_MODE_VXLAN)
                return "vxlan";
            return "ip-tunnel";
        case NETPLAN_DEF_TYPE_NM:
            /* needs to be overriden by passthrough "connection.type" setting */
            g_assert(def->backend_settings.passthrough);
            GData *passthrough = def->backend_settings.passthrough;
            return g_datalist_get_data(&passthrough, "connection.type");
        // LCOV_EXCL_START
        default:
            g_assert_not_reached();
        // LCOV_EXCL_STOP
    }
}
