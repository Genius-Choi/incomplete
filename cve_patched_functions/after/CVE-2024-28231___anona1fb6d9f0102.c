            {
                if (!was_decoded && reader->getAttributes().security_attributes().is_submessage_protected)
                {
                    return;
                }

                if (!reader->getAttributes().security_attributes().is_payload_protected)
                {
                    reader->processDataMsg(&change);
                    return;
                }

                if (!reader->matched_writer_is_matched(change.writerGUID))
                {
                    return;
                }

                if (!participant_->security_manager().decode_serialized_payload(change.serializedPayload,
                        crypto_payload_, reader->getGuid(), change.writerGUID))
                {
                    return;
                }

                std::swap(change.serializedPayload.data, crypto_payload_.data);
                std::swap(change.serializedPayload.length, crypto_payload_.length);

                SerializedPayload_t original_payload = change.serializedPayload;
                reader->processDataMsg(&change);
                IPayloadPool* payload_pool = change.payload_owner();
                if (payload_pool)
                {
                    payload_pool->release_payload(change);
                    change.serializedPayload = original_payload;
                }
                original_payload.data = nullptr;
                std::swap(change.serializedPayload.data, crypto_payload_.data);
                std::swap(change.serializedPayload.length, crypto_payload_.length);
            };
