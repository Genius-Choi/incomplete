    OFCondition readSpecific(IODImagePixelModule<T>& p, const Uint32 numFrames, const size_t numBytesFrame)
    {
        // Avoid compiler warning about unused parameter
        (void)p;
        unsigned long numTotalWords = 0;
        const Uint16* pixData       = NULL;
        if (m_Item.findAndGetUint16Array(DCM_PixelData, pixData, &numTotalWords).good())
        {
            if (numTotalWords == numBytesFrame * numFrames / 2 /* we compare to num words not num bytes */)
            {
                for (Uint32 n = 0; n < numFrames; n++)
                {
                    DcmIODTypes::Frame* f = new DcmIODTypes::Frame;
                    if (f)
                    {
                        f->length  = numBytesFrame;
                        f->pixData = new Uint8[f->length];
                        memcpy(f->pixData, pixData + n * numBytesFrame / 2, numBytesFrame);
                        m_CT.m_Frames.push_back(f);
                    }
                    else
                    {
                        return EC_MemoryExhausted;
                    }
                }
            }
            else
            {
                DCMECT_ERROR("Invalid number of pixels: Expected " << numBytesFrame * numFrames / 2
                                                                   << " pixels but Pixel Data has " << numTotalWords
                                                                   << " pixels");
                return ECT_InvalidPixelInfo;
            }
        }
        else
        {
            DCMECT_ERROR("No Pixel Data element found");
            return ECT_NoPixelData;
        }
        return EC_Normal;
    }
