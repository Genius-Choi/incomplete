handle_ccp(cp, dp, len)
    struct pkt *cp;
    u_char *dp;
    int len;
{
    int clen;
    struct compressor **comp;

    if (len < CCP_HDRLEN)
	return;
    clen = CCP_LENGTH(dp);
    if (clen > len)
	return;

    switch (CCP_CODE(dp)) {
    case CCP_CONFACK:
	cp->flags &= ~(CCP_DECOMP_RUN | CCP_ISUP);
	if (clen < CCP_HDRLEN + CCP_OPT_MINLEN
	    || clen < CCP_HDRLEN + CCP_OPT_LENGTH(dp + CCP_HDRLEN))
	    break;
	dp += CCP_HDRLEN;
	clen -= CCP_HDRLEN;
	for (comp = compressors; *comp != NULL; ++comp) {
	    if ((*comp)->compress_proto == dp[0]) {
		if (cp->state != NULL) {
		    (*cp->comp->decomp_free)(cp->state);
		    cp->state = NULL;
		}
		cp->comp = *comp;
		cp->state = (*comp)->decomp_alloc(dp, CCP_OPT_LENGTH(dp));
		cp->flags |= CCP_ISUP;
		if (cp->state != NULL
		    && (*cp->comp->decomp_init)
		        (cp->state, dp, clen, 0, 0, 8192, 1))
		    cp->flags = (cp->flags & ~CCP_ERR) | CCP_DECOMP_RUN;
		break;
	    }
	}
	break;

    case CCP_CONFNAK:
    case CCP_CONFREJ:
	cp->flags &= ~(CCP_DECOMP_RUN | CCP_ISUP);
	break;

    case CCP_RESETACK:
	if (cp->flags & CCP_ISUP) {
	    if (cp->state && (cp->flags & CCP_DECOMP_RUN)) {
		(*cp->comp->decomp_reset)(cp->state);
		cp->flags &= ~CCP_ERROR;
	    }
	}
	break;
    }
}
