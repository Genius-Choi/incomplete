x509_verify(struct x509_verify_ctx *ctx, X509 *leaf, char *name)
{
	struct x509_verify_chain *current_chain;
	int retry_chain_build, full_chain = 0;

	if (ctx->roots == NULL || ctx->max_depth == 0) {
		ctx->error = X509_V_ERR_INVALID_CALL;
		goto err;
	}

	if (ctx->xsc != NULL) {
		if (leaf != NULL || name != NULL) {
			ctx->error = X509_V_ERR_INVALID_CALL;
			goto err;
		}
		leaf = ctx->xsc->cert;

		/* XXX */
		full_chain = 1;
		if (ctx->xsc->param->flags & X509_V_FLAG_PARTIAL_CHAIN)
			full_chain = 0;
		/*
		 * XXX
		 * The legacy code expects the top level cert to be
		 * there, even if we didn't find a chain. So put it
		 * there, we will clobber it later if we find a valid
		 * chain.
		 */
		if ((ctx->xsc->chain = sk_X509_new_null()) == NULL) {
			ctx->error = X509_V_ERR_OUT_OF_MEM;
			goto err;
		}
		if (!X509_up_ref(leaf)) {
			ctx->error = X509_V_ERR_OUT_OF_MEM;
			goto err;
		}
		if (!sk_X509_push(ctx->xsc->chain, leaf)) {
			X509_free(leaf);
			ctx->error = X509_V_ERR_OUT_OF_MEM;
			goto err;
		}
		ctx->xsc->error_depth = 0;
		ctx->xsc->current_cert = leaf;
	}

	if (!x509_verify_cert_valid(ctx, leaf, NULL))
		goto err;

	if (!x509_verify_cert_hostname(ctx, leaf, name))
		goto err;

	if ((current_chain = x509_verify_chain_new()) == NULL) {
		ctx->error = X509_V_ERR_OUT_OF_MEM;
		goto err;
	}
	if (!x509_verify_chain_append(current_chain, leaf, &ctx->error)) {
		x509_verify_chain_free(current_chain);
		goto err;
	}
	do {
		retry_chain_build = 0;
		if (x509_verify_ctx_cert_is_root(ctx, leaf, full_chain)) {
			if (!x509_verify_ctx_add_chain(ctx, current_chain)) {
				x509_verify_chain_free(current_chain);
				goto err;
			}
		} else {
			x509_verify_build_chains(ctx, leaf, current_chain,
			    full_chain);
			if (full_chain && ctx->chains_count == 0) {
				/*
				 * Save the error state from the xsc
				 * at this point to put back on the
				 * xsc in case we do not find a chain
				 * that is trusted but not a full
				 * chain to a self signed root. This
				 * is because the unvalidated chain is
				 * used by the autochain batshittery
				 * on failure and will be needed for
				 * that.
				 */
				if (!x509_verify_ctx_save_xsc_error(ctx)) {
					x509_verify_chain_free(current_chain);
					goto err;
				}
				full_chain = 0;
				retry_chain_build = 1;
			}
		}
	} while (retry_chain_build);

	x509_verify_chain_free(current_chain);

	/*
	 * Do the new verifier style return, where we don't have an xsc
	 * that allows a crazy callback to turn invalid things into valid.
	 */
	if (ctx->xsc == NULL) {
		/*
		 * Safety net:
		 * We could not find a validated chain, and for some reason do not
		 * have an error set.
		 */
		if (ctx->chains_count == 0 && ctx->error == X509_V_OK)
			ctx->error = X509_V_ERR_UNSPECIFIED;

		/*
		 * If we are not using an xsc, and have no possibility for the
		 * crazy OpenSSL callback API changing the results of
		 * validation steps (because the callback can make validation
		 * proceed in the presence of invalid certs), any chains we
		 * have here are correctly built and verified.
		 */
		if (ctx->chains_count > 0)
			ctx->error = X509_V_OK;

		return ctx->chains_count;
	}

	/*
	 * Otherwise we are doing compatibility with an xsc, which means that we
	 * will have one chain, which might actually be a bogus chain because
	 * the callback told us to ignore errors and proceed to build an invalid
	 * chain. Possible return values from this include returning 1 with an
	 * invalid chain and a value of xsc->error != X509_V_OK (It's tradition
	 * that makes it ok).
	 */

	if (ctx->chains_count > 0) {
		/*
		 * The chain we have using an xsc might not be a verified chain
		 * if the callback perverted things while we built it to ignore
		 * failures and proceed with chain building. We put this chain
		 * and the error associated with it on the xsc.
		 */
		if (!x509_verify_ctx_set_xsc_chain(ctx, ctx->chains[0], 1, 1))
			goto err;

		/*
		 * Call the callback for completion up our built
		 * chain. The callback could still tell us to
		 * fail. Since this chain might exist as the result of
		 * callback doing perversions, we could still return
		 * "success" with something other than X509_V_OK set
		 * as the error.
		 */
		if (!x509_vfy_callback_indicate_completion(ctx->xsc))
			goto err;
	} else {
		/*
		 * We did not find a chain. Bring back the failure
		 * case we wanted to the xsc if we saved one. If we
		 * did not we should have just the leaf on the xsc.
		 */
		if (!x509_verify_ctx_restore_xsc_error(ctx))
			goto err;

		/*
		 * Safety net, ensure we have an error set in the
		 * failing case.
		 */
		if (ctx->xsc->error == X509_V_OK) {
			if (ctx->error == X509_V_OK)
				ctx->error = X509_V_ERR_UNSPECIFIED;
			ctx->xsc->error = ctx->error;
		}

		/*
		 * Let the callback override the return value
		 * at depth 0 if it chooses to
		 */
		return ctx->xsc->verify_cb(0, ctx->xsc);
	}

	/* We only ever find one chain in compat mode with an xsc. */
	return 1;

 err:
	if (ctx->error == X509_V_OK)
		ctx->error = X509_V_ERR_UNSPECIFIED;

	if (ctx->xsc != NULL) {
		if (ctx->xsc->error == X509_V_OK)
			ctx->xsc->error = X509_V_ERR_UNSPECIFIED;
		ctx->error = ctx->xsc->error;
	}

	return 0;
}
