void parse_flags(int argc, char* argv[])
{
    string *arg = new string[argc];

    for(int i = 0; i < argc; i++)
        arg[i] = argv[i];

    if(argc > 1 && arg[1].substr(0, 1) == "-")
    {
        size_t o = 0;

        flags_exist = true;
        size_t e = arg[1].find_first_not_of("-iodrvcmRfKCBPLT0123456789");
        if(e != string::npos)
            abort("Unknown flag -%s", arg[1].substr(e, 1).c_str());

        // abort if argument matches [^LPTK][1-9] (but for source/compilation simplicity we don't include a regex lib)
        do
        {
            string c = "-";
            o = arg[1].find_first_of("0123456789", o + 1);
            if(o != string::npos)
                c = arg[1].substr(o - 1, 1);
            if(c != "-" && c != "L" && c != "P" && c != "T" && c != "K" && (c < "0" || c > "9"))
                abort("Numeric values must be preceded by L, P, T or K");
        } while (o != string::npos);

        decompress_flag = arg[1].find_first_of("d") != string::npos ? true : false;
        recursive_flag = arg[1].find_first_of("r") != string::npos ? true : false;
        verbose_flag = arg[1].find_first_of("v") != string::npos ? true : false;
        output_pipe = arg[1].find_first_of("o") != string::npos ? true : false;
        benchmark_flag = arg[1].find_first_of("m") != string::npos ? true : false;
        recover_flag = arg[1].find_first_of("R") != string::npos ? true : false;
        force_flag = arg[1].find_first_of("f") != string::npos ? true : false;
        continue_flag = arg[1].find_first_of("C") != string::npos ? true : false;
        cache_flag = arg[1].find_first_of("B") != string::npos ? false : true;
        input_pipe = arg[1].find_first_of("i") != string::npos ? true : false;
        output_pipe = arg[1].find_first_of("o") != string::npos ? true : false;

#ifdef WINDOWS
        if(int_flag(arg[1], "P") != -1)
        {
            switch(int_flag(arg[1], "P"))
            {
                case 1:
					if (!SetPriorityClass(GetCurrentProcess(), PROCESS_MODE_BACKGROUND_BEGIN))
					{
						PRINT(WARNING, "%s%s: -P1 not supported by this OS - using -P2 instead\n", BLANK_LINE, "qpress");
						SetPriorityClass(GetCurrentProcess(), IDLE_PRIORITY_CLASS);
					}
					break;
                case 2: SetPriorityClass(GetCurrentProcess(), IDLE_PRIORITY_CLASS); break;
                case 3: SetPriorityClass(GetCurrentProcess(), NORMAL_PRIORITY_CLASS); break;
                case 4: SetPriorityClass(GetCurrentProcess(), ABOVE_NORMAL_PRIORITY_CLASS); break;
                default: abort("Invalid -P flag value");
            }
        }

#endif
        if(int_flag(arg[1], "L") != -1)
        {
            if (int_flag(arg[1], "L") > 0 && int_flag(arg[1], "L") < 4)
                if(decompress_flag || recover_flag)
                    abort("-d or -R flag cannot be used with -L flag");
                else
                    compression_level = int_flag(arg[1], "L");
            else
                abort("Invalid -L flag value");
        }

        if(int_flag(arg[1], "T") != -1)
        {
            if (int_flag(arg[1], "T") >= 1 && int_flag(arg[1], "T") <= MAX_THREAD_COUNT)
                    threads = int_flag(arg[1], "T");
            else
                abort("Invalid -T flag value");
        }

        if(int_flag(arg[1], "K") != -1)
        {
            if (1024*int_flag(arg[1], "K") >= AIO_MAX_SECTOR_SIZE && 1024*int_flag(arg[1], "K") <= MAX_COMPRESS_CHUNK_SIZE)
                if(decompress_flag || benchmark_flag || recover_flag )
                    abort("-d, -m or -R flag cannot be used with -K flag");
                else
                    compress_chunk_size = (1024*int_flag(arg[1], "K"));
            else
                abort("Invalid -K flag value");
        }
    }

    if((decompress_flag && (recursive_flag || benchmark_flag || recover_flag || continue_flag)) ||
       (benchmark_flag && (recursive_flag || verbose_flag || output_pipe || recover_flag || continue_flag)) ||
       (recover_flag && (recursive_flag || continue_flag)))
            abort("Flag combination does not make sense");
}
