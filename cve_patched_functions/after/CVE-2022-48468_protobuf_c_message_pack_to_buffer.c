protobuf_c_message_pack_to_buffer(const ProtobufCMessage *message,
				  ProtobufCBuffer *buffer)
{
	unsigned i;
	size_t rv = 0;

	ASSERT_IS_MESSAGE(message);
	for (i = 0; i < message->descriptor->n_fields; i++) {
		const ProtobufCFieldDescriptor *field =
			message->descriptor->fields + i;
		const void *member =
			((const char *) message) + field->offset;
		const void *qmember =
			((const char *) message) + field->quantifier_offset;

		if (field->label == PROTOBUF_C_LABEL_REQUIRED) {
			rv += required_field_pack_to_buffer(field, member, buffer);
		} else if ((field->label == PROTOBUF_C_LABEL_OPTIONAL ||
			    field->label == PROTOBUF_C_LABEL_NONE) &&
			   (0 != (field->flags & PROTOBUF_C_FIELD_FLAG_ONEOF))) {
			rv += oneof_field_pack_to_buffer(
				field,
				*(const uint32_t *) qmember,
				member,
				buffer
			);
		} else if (field->label == PROTOBUF_C_LABEL_OPTIONAL) {
			rv += optional_field_pack_to_buffer(
				field,
				*(const protobuf_c_boolean *) qmember,
				member,
				buffer
			);
		} else if (field->label == PROTOBUF_C_LABEL_NONE) {
			rv += unlabeled_field_pack_to_buffer(
				field,
				member,
				buffer
			);
		} else {
			rv += repeated_field_pack_to_buffer(
				field,
				*(const size_t *) qmember,
				member,
				buffer
			);
		}
	}
	for (i = 0; i < message->n_unknown_fields; i++)
		rv += unknown_field_pack_to_buffer(&message->unknown_fields[i], buffer);

	return rv;
}
