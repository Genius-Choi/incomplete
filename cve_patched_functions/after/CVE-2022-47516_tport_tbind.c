int tport_tbind(tport_t *self,
		tp_name_t const *tpn,
		char const * const transports[],
		tag_type_t tag, tag_value_t value, ...)
{
  ta_list ta;
  int server = 1, retval, public = 0;
  tp_name_t mytpn[1];
  tport_master_t *mr;
  char const *http_connect = NULL;

  if (self == NULL || tport_is_secondary(self) ||
      tpn == NULL || transports == NULL) {
    su_seterrno(EINVAL);
    return -1;
  }

  *mytpn = *tpn;

  if (mytpn->tpn_ident == NULL)
    mytpn->tpn_ident = self->tp_ident;

  ta_start(ta, tag, value);

  tl_gets(ta_args(ta),
	  TPTAG_SERVER_REF(server),
	  TPTAG_PUBLIC_REF(public),
	  TPTAG_IDENT_REF(mytpn->tpn_ident),
	  TPTAG_HTTP_CONNECT_REF(http_connect),
	  TAG_END());

  mr = self->tp_master; assert(mr);

  if (http_connect && public == 0)
    public = tport_type_connect;

  if (public && public != tport_type_stun)
    server = 0;

  if (server)
    retval = tport_bind_server(mr, mytpn, transports, (enum tport_via)public, ta_args(ta));
  else
    retval = tport_bind_client(mr, mytpn, transports, (enum tport_via)public, ta_args(ta));

  ta_end(ta);

  return retval;
}
