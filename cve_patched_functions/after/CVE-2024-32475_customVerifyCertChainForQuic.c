ValidationResults ContextImpl::customVerifyCertChainForQuic(
    STACK_OF(X509)& cert_chain, Ssl::ValidateResultCallbackPtr callback, bool is_server,
    const Network::TransportSocketOptionsConstSharedPtr& transport_socket_options,
    const CertValidator::ExtraValidationContext& validation_context, const std::string& host_name) {
  ASSERT(!tls_contexts_.empty());
  // It doesn't matter which SSL context is used, because they share the same cert validation
  // config.
  SSL_CTX* ssl_ctx = tls_contexts_[0].ssl_ctx_.get();
  if (SSL_CTX_get_verify_mode(ssl_ctx) == SSL_VERIFY_NONE) {
    // Skip validation if the TLS is configured SSL_VERIFY_NONE.
    return {ValidationResults::ValidationStatus::Successful,
            Envoy::Ssl::ClientValidationStatus::NotValidated, absl::nullopt, absl::nullopt};
  }
  ValidationResults result =
      cert_validator_->doVerifyCertChain(cert_chain, std::move(callback), transport_socket_options,
                                         *ssl_ctx, validation_context, is_server, host_name);
  return result;
}
