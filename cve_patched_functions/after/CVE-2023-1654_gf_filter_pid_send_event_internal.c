void gf_filter_pid_send_event_internal(GF_FilterPid *pid, GF_FilterEvent *evt, Bool force_downstream)
{
	GF_FilterEvent *an_evt;
	GF_FilterPid *target_pid=NULL;
	Bool upstream=GF_FALSE;
	if (!pid) {
		pid = evt->base.on_pid;
		if (!pid) return;
	}
	//filter is being shut down, prevent any event posting
	if (pid->filter->finalized) return;

	if ((evt->base.type==GF_FEVT_FILE_DELETE) && !evt->file_del.url) return;

	if (!force_downstream && PID_IS_OUTPUT(pid)) {
		upstream = GF_TRUE;
	}

	GF_LOG(GF_LOG_INFO, GF_LOG_FILTER, ("Filter %s PID %s queuing %s event %s\n", pid->pid->filter->name, pid->pid->name, upstream ? "upstream" : "downstream", gf_filter_event_name(evt->base.type) ));

	if (upstream) {
		u32 i, j;

		an_evt = init_evt(evt);

		for (i=0; i<pid->filter->num_output_pids; i++) {
			GF_FilterPid *apid = gf_list_get(pid->filter->output_pids, i);
			if (evt->base.on_pid && (apid != evt->base.on_pid)) continue;
			for (j=0; j<apid->num_destinations; j++) {
				GF_FilterEvent *up_evt;
				GF_FilterPidInst *pidi = gf_list_get(apid->destinations, j);

				up_evt = dup_evt(an_evt);
				up_evt->base.on_pid = (GF_FilterPid *)pidi;
				gf_fs_post_task_class(pidi->filter->session, gf_filter_pid_send_event_upstream, pidi->filter, NULL, "upstream_event", up_evt, TASK_TYPE_EVENT);
			}
		}
		free_evt(an_evt);
		return;
	}


	if ((evt->base.type == GF_FEVT_STOP)
		|| (evt->base.type == GF_FEVT_PLAY)
		|| (evt->base.type==GF_FEVT_SOURCE_SEEK)
	) {
		u32 i, nb_playing=0;
		Bool do_reset = GF_TRUE;
		gf_mx_p(pid->pid->filter->tasks_mx);

		for (i=0; i<pid->pid->num_destinations; i++) {
			GF_FilterPidInst *pidi = gf_list_get(pid->pid->destinations, i);
			if (pidi->is_playing || pidi->play_queued) nb_playing++;
			if (pidi->stop_queued) nb_playing--;

			//pre-check pid instance play state
			if (pidi == (GF_FilterPidInst *)evt->base.on_pid) {
				//if STOP and pid instance already stop, silently discard
				if ((evt->base.type == GF_FEVT_STOP) && !pidi->is_playing && !pidi->play_queued) {
					gf_mx_v(pid->pid->filter->tasks_mx);
					return;
				}
				//if PLAY and pid instance already playing, silently discard
				else if ((evt->base.type == GF_FEVT_PLAY) && pidi->is_playing && !pidi->stop_queued) {
					gf_mx_v(pid->pid->filter->tasks_mx);
					return;
				}
			}
		}
		//do not set discard_packets flag on pid instance when:
		//- pid has at least one active output and we play one
		//- pid has more than one active output and we stop one
		if (evt->base.type == GF_FEVT_STOP) {
			if (nb_playing>1)
				do_reset = GF_FALSE;

			if (PID_IS_INPUT(pid)) {
				((GF_FilterPidInst*)evt->base.on_pid)->stop_queued = 1;
			}
		} else {
			if (nb_playing)
				do_reset = GF_FALSE;
			if (PID_IS_INPUT(pid)) {
				((GF_FilterPidInst*)evt->base.on_pid)->play_queued = 1;
			}
		}

		for (i=0; i<pid->pid->num_destinations; i++) {
			GF_FilterPidInst *pidi = gf_list_get(pid->pid->destinations, i);

			if (!do_reset && (pidi != (GF_FilterPidInst*)evt->base.on_pid))
				continue;

			if (evt->base.type == GF_FEVT_PLAY) {
				pidi->is_end_of_stream = GF_FALSE;
			} else {
				//flag pid instance to discard all packets (cf above note)
				safe_int_inc(&pidi->discard_packets);
			}
		}

		gf_mx_v(pid->pid->filter->tasks_mx);
	}

	an_evt = init_evt(evt);
	if (evt->base.on_pid) {
		target_pid = evt->base.on_pid;
		an_evt->base.on_pid = evt->base.on_pid->pid;
		safe_int_inc(&target_pid->pid->filter->num_events_queued);
	}
	gf_fs_post_task_class(pid->pid->filter->session, gf_filter_pid_send_event_downstream, pid->pid->filter, target_pid, "downstream_event", an_evt, TASK_TYPE_EVENT);
}
