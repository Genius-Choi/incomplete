int pfe_firmware_init(void)
{
#define PFE_KEY_HASH	NULL
	char *pfe_firmware_name;
	const void *raw_image_addr;
	size_t raw_image_size = 0;
	u8 *pfe_firmware;
#ifdef CONFIG_CHAIN_OF_TRUST
	uintptr_t pfe_esbc_hdr = 0;
	uintptr_t pfe_img_addr = 0;
#endif
	int ret = 0;
	int fw_count;

	ret = pfe_spi_flash_init();
	if (ret)
		goto err;

	ret = pfe_fit_check();
	if (ret)
		goto err;

#ifdef CONFIG_CHAIN_OF_TRUST
	pfe_esbc_hdr = (uintptr_t)pfe_esbc_hdr_addr;
	pfe_img_addr = (uintptr_t)pfe_fit_addr;
	if (fsl_check_boot_mode_secure() != 0) {
		/*
		 * In case of failure in validation, fsl_secboot_validate
		 * would not return back in case of Production environment
		 * with ITS=1. In Development environment (ITS=0 and
		 * SB_EN=1), the function may return back in case of
		 * non-fatal failures.
		 */
		ret = fsl_secboot_validate(pfe_esbc_hdr,
					   PFE_KEY_HASH,
					   &pfe_img_addr);
		if (ret != 0)
			printf("PFE firmware(s) validation failed\n");
		else
			printf("PFE firmware(s) validation Successful\n");
	}
#endif

	for (fw_count = 0; fw_count < 2; fw_count++) {
		if (fw_count == 0)
			pfe_firmware_name = "class";
		else if (fw_count == 1)
			pfe_firmware_name = "tmu";

		pfe_get_fw(&raw_image_addr, &raw_image_size, pfe_firmware_name);
		pfe_firmware = malloc(raw_image_size);
		if (!pfe_firmware)
			return -ENOMEM;
		memcpy((void *)pfe_firmware, (void *)raw_image_addr,
		       raw_image_size);

		if (fw_count == 0)
			ret = pfe_load_elf(CLASS_MASK, pfe_firmware);
		else if (fw_count == 1)
			ret = pfe_load_elf(TMU_MASK, pfe_firmware);

		if (ret < 0) {
			printf("%s: %s firmware load failed\n", __func__,
			       pfe_firmware_name);
			goto err;
		}
		debug("%s: %s firmware loaded\n", __func__, pfe_firmware_name);
		free(pfe_firmware);
	}

	tmu_enable(0xb);
	class_enable();
	gpi_enable(HGPI_BASE_ADDR);

err:
	return ret;
}
