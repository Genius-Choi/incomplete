static GF_Err txtin_process_webvtt(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck)
{
	GF_Err e;

	if (ctx->playstate==2)
		return GF_EOS;
	if (!ctx->is_setup) {
		ctx->is_setup = GF_TRUE;
		e = txtin_webvtt_setup(filter, ctx);
		if (e || !ctx->pid_framed) return e;
	}
	if (!ctx->vttparser) return (ctx->playstate==2) ? GF_EOS : GF_NOT_SUPPORTED;

	if (ctx->seek_state==1) {
		ctx->seek_state = 2;
		gf_webvtt_parser_restart(ctx->vttparser);
	}
	if (ctx->pid_framed) {
		const GF_PropertyValue *p;
		const char *vtt_pre=NULL, *vtt_cueid=NULL, *vtt_settings=NULL;
		p = gf_filter_pck_get_property_str(ipck, "vtt_pre");
		if (p) vtt_pre = p->value.string;
		p = gf_filter_pck_get_property_str(ipck, "vtt_cueid");
		if (p) vtt_cueid = p->value.string;
		p = gf_filter_pck_get_property_str(ipck, "vtt_settings");
		if (p) vtt_settings = p->value.string;

		e = gf_webvtt_parser_parse_payload(ctx->vttparser,
			gf_timestamp_rescale(ctx->start, ctx->timescale, 1000),
			gf_timestamp_rescale(ctx->end, ctx->timescale, 1000),
			vtt_pre, vtt_cueid, vtt_settings);
	} else {
		if (!ctx->file_name)
			gf_webvtt_parser_not_done(ctx->vttparser);

		e = gf_webvtt_parser_parse_ext(ctx->vttparser, ctx->src, ctx->in_over);
	}

	if (e < GF_OK) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, ("[TXTIn] WebVTT process error %s\n", gf_error_to_string(e) ));
	}
	return e;
}
