int r_jws_advanced_compact_parsen(jws_t * jws, const char * jws_str, size_t jws_str_len, uint32_t parse_flags, int x5u_flags) {
  int ret;
  char ** str_array = NULL;
  char * token = NULL;
  size_t split_size = 0, unzip_len = 0;
  json_t * j_header = NULL;
  struct _o_datum dat_header = {0, NULL}, dat_payload = {0, NULL};
  unsigned char * unzip = NULL;

  if (jws != NULL && jws_str != NULL && jws_str_len) {
    token = o_strndup(jws_str, jws_str_len);
    if ((split_size = split_string(token, ".", &str_array)) == 2 || split_size == 3) {
      // Check if all first 2 elements are base64url
      if (o_base64url_decode_alloc((unsigned char *)str_array[0], o_strlen(str_array[0]), &dat_header) &&
          o_base64url_decode_alloc((unsigned char *)str_array[1], o_strlen(str_array[1]), &dat_payload)) {
        ret = RHN_OK;
        do {
          // Decode header
          j_header = json_loadb((const char*)dat_header.data, dat_header.size, JSON_DECODE_ANY, NULL);
          if (r_jws_extract_header(jws, j_header, parse_flags, x5u_flags) != RHN_OK) {
            y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_advanced_compact_parsen - error extracting header params");
            ret = RHN_ERROR_PARAM;
            break;
          }
          json_decref(jws->j_header);

          jws->j_header = json_incref(j_header);

          if (!(parse_flags&R_PARSE_UNSIGNED)) {
            if (r_jws_get_alg(jws) == R_JWA_ALG_NONE) {
              y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_advanced_compact_parsen - error unsigned jws");
              ret = RHN_ERROR_INVALID;
              break;
            }
          }

          // Decode payload
          if (0 == o_strcmp("DEF", r_jws_get_header_str_value(jws, "zip"))) {
            if (_r_inflate_payload(dat_payload.data, dat_payload.size, &unzip, &unzip_len) != RHN_OK) {
              y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_advanced_compact_parsen - error _r_inflate_payload");
              ret = RHN_ERROR_PARAM;
              break;
            }
            if (r_jws_set_payload(jws, unzip, unzip_len) != RHN_OK) {
              y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_advanced_compact_parsen - error r_jws_set_payload");
              ret = RHN_ERROR_PARAM;
              break;
            }
          } else {
            if (r_jws_set_payload(jws, dat_payload.data, dat_payload.size) != RHN_OK) {
              y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_advanced_compact_parsen - Error r_jws_set_payload");
              ret = RHN_ERROR;
              break;
            }
          }

          o_free(jws->header_b64url);
          jws->header_b64url = (unsigned char *)o_strdup(str_array[0]);

          o_free(jws->signature_b64url);
          jws->signature_b64url = NULL;
          if (str_array[2] != NULL) {
            jws->signature_b64url = (unsigned char *)o_strdup(str_array[2]);
          }
          if (r_jws_get_alg(jws) != R_JWA_ALG_NONE && o_strnullempty(str_array[2])) {
            y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_advanced_compact_parsen - error invalid signature length");
            ret = RHN_ERROR_PARAM;
            break;
          } else if (r_jws_get_alg(jws) == R_JWA_ALG_NONE && !o_strnullempty(str_array[2])) {
            y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_advanced_compact_parsen - error signature must be empty");
            ret = RHN_ERROR_PARAM;
            break;
          }
        } while (0);
        json_decref(j_header);
        o_free(unzip);
      } else {
        y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_advanced_compact_parsen - error decoding jws from base64url format");
        ret = RHN_ERROR_PARAM;
      }
      o_free(dat_header.data);
      o_free(dat_payload.data);
    } else {
      y_log_message(Y_LOG_LEVEL_ERROR, "r_jws_advanced_compact_parsen - jws_str invalid format");
      ret = RHN_ERROR_PARAM;
    }
    free_string_array(str_array);
    o_free(token);
  } else {
    ret = RHN_ERROR_PARAM;
  }
  return ret;
}
