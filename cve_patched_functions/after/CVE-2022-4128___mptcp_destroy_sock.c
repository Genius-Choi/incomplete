static void __mptcp_destroy_sock(struct sock *sk)
{
	struct mptcp_subflow_context *subflow, *tmp;
	struct mptcp_sock *msk = mptcp_sk(sk);
	LIST_HEAD(conn_list);

	pr_debug("msk=%p", msk);

	might_sleep();

	/* join list will be eventually flushed (with rst) at sock lock release time*/
	list_splice_init(&msk->conn_list, &conn_list);

	mptcp_stop_timer(sk);
	sk_stop_timer(sk, &sk->sk_timer);
	msk->pm.status = 0;

	/* clears msk->subflow, allowing the following loop to close
	 * even the initial subflow
	 */
	mptcp_dispose_initial_subflow(msk);
	list_for_each_entry_safe(subflow, tmp, &conn_list, node) {
		struct sock *ssk = mptcp_subflow_tcp_sock(subflow);
		__mptcp_close_ssk(sk, ssk, subflow, 0);
	}

	sk->sk_prot->destroy(sk);

	WARN_ON_ONCE(msk->rmem_fwd_alloc);
	WARN_ON_ONCE(msk->rmem_released);
	sk_stream_kill_queues(sk);
	xfrm_sk_free_policy(sk);

	sk_refcnt_debug_release(sk);
	sock_put(sk);
}
