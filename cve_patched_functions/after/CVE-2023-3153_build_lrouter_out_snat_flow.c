build_lrouter_out_snat_flow(struct hmap *lflows, struct ovn_datapath *od,
                            const struct nbrec_nat *nat, struct ds *match,
                            struct ds *actions, bool distributed,
                            struct eth_addr mac, int cidr_bits, bool is_v6,
                            struct ovn_port *l3dgw_port)
{
    /* Egress SNAT table: Packets enter the egress pipeline with
    * source ip address that needs to be SNATted to a external ip
    * address. */
    if (strcmp(nat->type, "snat") && strcmp(nat->type, "dnat_and_snat")) {
        return;
    }

    bool stateless = lrouter_dnat_and_snat_is_stateless(nat);
    if (od->is_gw_router) {
        ds_clear(match);
        ds_put_format(match, "ip && ip%s.src == %s",
                      is_v6 ? "6" : "4", nat->logical_ip);
        ds_clear(actions);

        if (nat->allowed_ext_ips || nat->exempted_ext_ips) {
            lrouter_nat_add_ext_ip_match(od, lflows, match, nat,
                                         is_v6, false, cidr_bits);
        }

        if (!strcmp(nat->type, "dnat_and_snat") && stateless) {
            ds_put_format(actions, "ip%s.src=%s; next;",
                          is_v6 ? "6" : "4", nat->external_ip);
        } else {
            ds_put_format(match, " && (!ct.trk || !ct.rpl)");
            ds_put_format(actions, "ct_snat(%s", nat->external_ip);

            if (nat->external_port_range[0]) {
                ds_put_format(actions, ",%s",
                              nat->external_port_range);
            }
            ds_put_format(actions, ");");
        }

        /* The priority here is calculated such that the
        * nat->logical_ip with the longest mask gets a higher
        * priority. */
        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_SNAT,
                                cidr_bits + 1, ds_cstr(match),
                                ds_cstr(actions), &nat->header_);
    } else {
        uint16_t priority = cidr_bits + 1;

        /* Distributed router. */
        ds_clear(match);
        ds_put_format(match, "ip && ip%s.src == %s && outport == %s",
                      is_v6 ? "6" : "4", nat->logical_ip,
                      l3dgw_port->json_key);
        if (od->n_l3dgw_ports) {
            if (distributed) {
                ovs_assert(nat->logical_port);
                priority += 128;
                ds_put_format(match, " && is_chassis_resident(\"%s\")",
                              nat->logical_port);
            } else {
                /* Flows for NAT rules that are centralized are only
                * programmed on the gateway chassis. */
                priority += 128;
                ds_put_format(match, " && is_chassis_resident(%s)",
                              l3dgw_port->cr_port->json_key);
            }
        }
        ds_clear(actions);

        if (nat->allowed_ext_ips || nat->exempted_ext_ips) {
            lrouter_nat_add_ext_ip_match(od, lflows, match, nat,
                                         is_v6, false, cidr_bits);
        }

        if (distributed) {
            ds_put_format(actions, "eth.src = "ETH_ADDR_FMT"; ",
                          ETH_ADDR_ARGS(mac));
        }

        if (stateless) {
            ds_put_format(actions, "ip%s.src=%s; next;",
                          is_v6 ? "6" : "4", nat->external_ip);
        } else {
            ds_put_format(actions, "ct_snat_in_czone(%s",
                        nat->external_ip);
            if (nat->external_port_range[0]) {
                ds_put_format(actions, ",%s", nat->external_port_range);
            }
            ds_put_format(actions, ");");
        }

        /* The priority here is calculated such that the
        * nat->logical_ip with the longest mask gets a higher
        * priority. */
        ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_SNAT,
                                priority, ds_cstr(match),
                                ds_cstr(actions), &nat->header_);

        if (!stateless) {
            ds_put_cstr(match, " && "REGBIT_DST_NAT_IP_LOCAL" == 1");
            ds_clear(actions);
            if (distributed) {
                ds_put_format(actions, "eth.src = "ETH_ADDR_FMT"; ",
                              ETH_ADDR_ARGS(mac));
            }
            ds_put_format(actions,  REGBIT_DST_NAT_IP_LOCAL" = 0; ct_snat(%s",
                          nat->external_ip);
            if (nat->external_port_range[0]) {
                ds_put_format(actions, ",%s", nat->external_port_range);
            }
            ds_put_format(actions, ");");
            ovn_lflow_add_with_hint(lflows, od, S_ROUTER_OUT_SNAT,
                                    priority + 1, ds_cstr(match),
                                    ds_cstr(actions), &nat->header_);
        }
    }
}
