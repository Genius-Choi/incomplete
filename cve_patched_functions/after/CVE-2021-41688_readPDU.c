readPDU(PRIVATE_ASSOCIATIONKEY ** association, DUL_BLOCKOPTIONS block,
        int timeout, unsigned char **buffer,
        unsigned char *pduType, unsigned char *pduReserved,
        unsigned long *pduLength)
{
    OFCondition cond = EC_Normal;
    unsigned long maxLength;

    *buffer = NULL;
    if ((*association)->inputPDU == NO_PDU) {
        cond = readPDUHead(association, (*association)->pduHead,
                           sizeof((*association)->pduHead),
                           block, timeout, &(*association)->nextPDUType,
                           &(*association)->nextPDUReserved,
                           &(*association)->nextPDULength);
        if (cond.bad())
            return cond;
        (*association)->inputPDU = PDU_HEAD;
    }

    size_t limit = dcmAssociatePDUSizeLimit.get();
    if ((limit > 0) && ((*association)->nextPDULength > limit))
    {
      DCMNET_ERROR("A-ASSOCIATE PDU too large: " << (*association)->nextPDULength << " bytes, refusing." );
      return NET_EC_AssociatePDUTooLarge;
    }

    maxLength = ((*association)->nextPDULength)+100;
    *buffer = (unsigned char *)malloc(size_t(maxLength));
    if (*buffer)
    {
      (void) memcpy(*buffer, (*association)->pduHead, sizeof((*association)->pduHead));
      cond = readPDUBody(association, block, timeout,
        (*buffer) + sizeof((*association)->pduHead),
        maxLength - sizeof((*association)->pduHead),
        pduType, pduReserved, pduLength);
    } else cond = EC_MemoryExhausted;
    return cond;
}
