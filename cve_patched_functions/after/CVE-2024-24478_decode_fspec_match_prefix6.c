decode_fspec_match_prefix6(proto_tree *tree, proto_item *parent_item, int hf_addr,
                           tvbuff_t *tvb, gint offset, guint16 tlen, packet_info *pinfo)
{
    proto_tree        *prefix_tree;
    ws_in6_addr addr;     /* IPv6 address                       */
    address           addr_str;
    int               plen;     /* prefix length                      */
    int               length;   /* number of octets needed for prefix */
    int               poffset_place = 1;
    int               plength_place = 0;

    /* snarf length and prefix */
    plen = tvb_get_guint8(tvb, offset);
    if (plen == 0) /* I should be facing a draft 04 version where the prefix offset is switched with length */
    {
      plen =  tvb_get_guint8(tvb, offset+1);
      poffset_place = 0;
      plength_place = 1;
    }
    length = tvb_get_ipv6_addr_with_prefix_len(tvb, offset + 2, &addr, plen);
    if (length < 0) {
        expert_add_info_format(pinfo, parent_item, &ei_bgp_prefix_length_err, "Length is invalid %u", plen);
        return -1;
    }

    /* put prefix into protocol tree */
    set_address(&addr_str, AT_IPv6, 16, addr.bytes);
    prefix_tree = proto_tree_add_subtree_format(tree, tvb, offset,
            tlen != 0 ? tlen : 1 + length, ett_bgp_prefix, NULL, "%s/%u",
            address_to_str(pinfo->pool, &addr_str), plen);
    proto_tree_add_item(prefix_tree, hf_bgp_flowspec_nlri_ipv6_pref_len, tvb, offset + plength_place, 1, ENC_BIG_ENDIAN);
    proto_tree_add_item(prefix_tree, hf_bgp_flowspec_nlri_ipv6_pref_offset, tvb, offset + poffset_place, 1, ENC_BIG_ENDIAN);
    proto_tree_add_ipv6(prefix_tree, hf_addr, tvb, offset + 2, length, &addr);
    if (parent_item != NULL)
      proto_item_append_text(parent_item, " (%s/%u)",
                             address_to_str(pinfo->pool, &addr_str), plen);
    return(2 + length);
}
