memcached_return_t memcached_response(memcached_instance_st *instance, char *buffer,
                                      size_t buffer_length, memcached_result_st *result) {
  if (memcached_is_udp(instance->root)) {
    return memcached_set_error(*instance, MEMCACHED_NOT_SUPPORTED, MEMCACHED_AT);
  }

  /* We may have old commands in the buffer not sent, first purge */
  if ((instance->root->flags.no_block) and (memcached_is_processing_input(instance->root) == false))
  {
    (void) memcached_io_write(instance);
  }

  /*  Before going into loop wait to see if we have any IO waiting for us */
  if (0) {
    memcached_return_t read_rc = memcached_io_wait_for_read(instance);
    fprintf(stderr, "%s:%d: %s\n", __FILE__, __LINE__, memcached_strerror(NULL, read_rc));
  }

  /*
   * The previous implementation purged all pending requests and just
   * returned the last one. Purge all pending messages to ensure backwards
   * compatibility.
   */
  if (memcached_is_binary(instance->root) == false
      and memcached_server_response_count(instance) > 1) {
    memcached_result_st junked_result;
    memcached_result_st *junked_result_ptr =
        memcached_result_create(instance->root, &junked_result);

    assert(junked_result_ptr);

    while (memcached_server_response_count(instance) > 1) {
      memcached_return_t rc =
          _read_one_response(instance, buffer, buffer_length, junked_result_ptr);

      // @TODO should we return an error on another but a bad read case?
      if (memcached_fatal(rc)) {
        memcached_result_free(junked_result_ptr);
        return rc;
      }
    }
    memcached_result_free(junked_result_ptr);
  }

  return _read_one_response(instance, buffer, buffer_length, result);
}
