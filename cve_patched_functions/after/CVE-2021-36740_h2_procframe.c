h2_procframe(struct worker *wrk, struct h2_sess *h2, h2_frame h2f)
{
	struct h2_req *r2;
	h2_error h2e;

	ASSERT_RXTHR(h2);
	if (h2->rxf_stream == 0 && h2f->act_szero != 0)
		return (h2f->act_szero);

	if (h2->rxf_stream != 0 && h2f->act_snonzero != 0)
		return (h2f->act_snonzero);

	if (h2->rxf_stream > h2->highest_stream && h2f->act_sidle != 0)
		return (h2f->act_sidle);

	if (h2->rxf_stream != 0 && !(h2->rxf_stream & 1)) {
		// rfc7540,l,1140,1145
		// rfc7540,l,1153,1158
		/* No even streams, we don't do PUSH_PROMISE */
		Lck_Lock(&h2->sess->mtx);
		VSLb(h2->vsl, SLT_Debug, "H2: illegal stream (=%u)",
		    h2->rxf_stream);
		Lck_Unlock(&h2->sess->mtx);
		return (H2CE_PROTOCOL_ERROR);
	}

	VTAILQ_FOREACH(r2, &h2->streams, list)
		if (r2->stream == h2->rxf_stream)
			break;

	if (h2->new_req != NULL &&
	    !(r2 && h2->new_req == r2->req && h2f == H2_F_CONTINUATION))
		return (H2CE_PROTOCOL_ERROR);	// rfc7540,l,1859,1863

	h2e = h2f->rxfunc(wrk, h2, r2);
	if (h2e == 0)
		return (0);
	if (h2->rxf_stream == 0 || h2e->connection)
		return (h2e);	// Connection errors one level up

	H2_Send_Get(wrk, h2, h2->req0);
	H2_Send_RST(wrk, h2, h2->req0, h2->rxf_stream, h2e);
	H2_Send_Rel(h2, h2->req0);
	return (0);
}
