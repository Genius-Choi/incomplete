static status_t process_certreq(private_tls_peer_t *this, bio_reader_t *reader)
{
	chunk_t types, hashsig, context, ext;
	bio_reader_t *extensions, *extension;

	if (!this->peer)
	{
		DBG1(DBG_TLS, "server requested a certificate, but client "
			 "authentication disabled");
	}
	this->crypto->append_handshake(this->crypto,
								TLS_CERTIFICATE_REQUEST, reader->peek(reader));

	if (this->tls->get_version_max(this->tls) < TLS_1_3)
	{
		if (!reader->read_data8(reader, &types))
		{
			DBG1(DBG_TLS, "certreq message header invalid");
			this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
			return NEED_MORE;
		}
		this->cert_types = chunk_clone(types);
		if (this->tls->get_version_max(this->tls) >= TLS_1_2)
		{
			if (!reader->read_data16(reader, &hashsig))
			{
				DBG1(DBG_TLS, "certreq message invalid");
				this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
				return NEED_MORE;
			}
			this->hashsig = chunk_clone(hashsig);
		}

		if (!read_certificate_authorities(this, reader))
		{
			DBG1(DBG_TLS, "certreq message invalid");
			this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
			return NEED_MORE;
		}
	}
	else
	{
		/* certificate request context as described in RFC 8446, section 4.3.2 */
		reader->read_data8(reader, &context);

		reader->read_data16(reader, &ext);
		extensions = bio_reader_create(ext);
		while (extensions->remaining(extensions))
		{
			uint16_t extension_type;
			chunk_t extension_data;

			if (!extensions->read_uint16(extensions, &extension_type) ||
				!extensions->read_data16(extensions, &extension_data))
			{
				DBG1(DBG_TLS, "invalid extension in CertificateRequest");
				this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
				extensions->destroy(extensions);
				return NEED_MORE;
			}
			extension = bio_reader_create(extension_data);
			switch (extension_type)
			{
				case TLS_EXT_SIGNATURE_ALGORITHMS:
					if (!extension->read_data16(extension, &extension_data))
					{
						DBG1(DBG_TLS, "invalid %N extension",
							 tls_extension_names, extension_type);
						this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
						extension->destroy(extension);
						extensions->destroy(extensions);
						return NEED_MORE;
					}
					chunk_free(&this->hashsig);
					this->hashsig = chunk_clone(extension_data);
					break;
				case TLS_EXT_CERTIFICATE_AUTHORITIES:
					if (!read_certificate_authorities(this, extension))
					{
						DBG1(DBG_TLS, "certificate request message invalid");
						this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
						extension->destroy(extension);
						extensions->destroy(extensions);
						return NEED_MORE;
					}
					break;
				default:
					break;
			}
			extension->destroy(extension);
		}
	extensions->destroy(extensions);
	}
	this->state = STATE_CERTREQ_RECEIVED;
	return NEED_MORE;
}
