static status_t process_client_hello(private_tls_server_t *this,
									 bio_reader_t *reader)
{
	uint16_t legacy_version = 0, version = 0, extension_type = 0;
	chunk_t random, session, ciphers, versions = chunk_empty, compression;
	chunk_t ext = chunk_empty, key_shares = chunk_empty;
	key_share_t peer = {0};
	chunk_t extension_data = chunk_empty;
	bio_reader_t *extensions, *extension;
	tls_cipher_suite_t *suites;
	tls_version_t original_version_max;
	int count, i;
	rng_t *rng;

	this->crypto->append_handshake(this->crypto,
								   TLS_CLIENT_HELLO, reader->peek(reader));

	if (!reader->read_uint16(reader, &legacy_version) ||
		!reader->read_data(reader, sizeof(this->client_random), &random) ||
		!reader->read_data8(reader, &session) ||
		!reader->read_data16(reader, &ciphers) ||
		!reader->read_data8(reader, &compression) ||
		(reader->remaining(reader) && !reader->read_data16(reader, &ext)))
	{
		DBG1(DBG_TLS, "received invalid ClientHello");
		this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
		return NEED_MORE;
	}

	/* before we do anything version-related, determine our supported suites
	 * as that might change the min./max. versions */
	this->crypto->get_cipher_suites(this->crypto, NULL);

	extensions = bio_reader_create(ext);
	while (extensions->remaining(extensions))
	{
		if (!extensions->read_uint16(extensions, &extension_type) ||
			!extensions->read_data16(extensions, &extension_data))
		{
			DBG1(DBG_TLS, "received invalid ClientHello Extensions");
			this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
			extensions->destroy(extensions);
			return NEED_MORE;
		}
		extension = bio_reader_create(extension_data);
		DBG2(DBG_TLS, "received TLS '%N' extension",
			 tls_extension_names, extension_type);
		DBG3(DBG_TLS, "%B", &extension_data);
		switch (extension_type)
		{
			case TLS_EXT_SIGNATURE_ALGORITHMS:
				if (!extension->read_data16(extension, &extension_data))
				{
					DBG1(DBG_TLS, "invalid %N extension",
						 tls_extension_names, extension_type);
					this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
					extensions->destroy(extensions);
					extension->destroy(extension);
					return NEED_MORE;
				}
				chunk_free(&this->hashsig);
				this->hashsig = chunk_clone(extension_data);
				break;
			case TLS_EXT_SUPPORTED_GROUPS:
				if (!extension->read_data16(extension, &extension_data))
				{
					DBG1(DBG_TLS, "invalid %N extension",
						 tls_extension_names, extension_type);
					this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
					extensions->destroy(extensions);
					extension->destroy(extension);
					return NEED_MORE;
				}
				chunk_free(&this->curves);
				this->curves_received = TRUE;
				this->curves = chunk_clone(extension_data);
				break;
			case TLS_EXT_SUPPORTED_VERSIONS:
				if (!extension->read_data8(extension, &versions))
				{
					DBG1(DBG_TLS, "invalid %N extension",
						 tls_extension_names, extension_type);
					this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
					extensions->destroy(extensions);
					extension->destroy(extension);
					return NEED_MORE;
				}
				break;
			case TLS_EXT_KEY_SHARE:
				if (!extension->read_data16(extension, &key_shares))
				{
					DBG1(DBG_TLS, "invalid %N extension",
						 tls_extension_names, extension_type);
					this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
					extensions->destroy(extensions);
					extension->destroy(extension);
					return NEED_MORE;
				}
				break;
			default:
				break;
		}
		extension->destroy(extension);
	}
	extensions->destroy(extensions);

	if (this->tls->get_version_max(this->tls) >= TLS_1_3 && !this->hashsig.len)
	{
		DBG1(DBG_TLS, "no %N extension received", tls_extension_names,
			 TLS_MISSING_EXTENSION);
		this->alert->add(this->alert, TLS_FATAL, TLS_MISSING_EXTENSION);
		return NEED_MORE;
	}

	memcpy(this->client_random, random.ptr, sizeof(this->client_random));

	htoun32(&this->server_random, time(NULL));
	rng = lib->crypto->create_rng(lib->crypto, RNG_WEAK);
	if (!rng ||
		!rng->get_bytes(rng, sizeof(this->server_random) - 4,
						this->server_random + 4))
	{
		DBG1(DBG_TLS, "failed to generate server random");
		this->alert->add(this->alert, TLS_FATAL, TLS_INTERNAL_ERROR);
		DESTROY_IF(rng);
		return NEED_MORE;
	}
	rng->destroy(rng);

	original_version_max = this->tls->get_version_max(this->tls);

	if (versions.len)
	{
		bio_reader_t *client_versions;

		client_versions = bio_reader_create(versions);
		while (client_versions->remaining(client_versions))
		{
			if (client_versions->read_uint16(client_versions, &version))
			{
				if (this->tls->set_version(this->tls, version, version))
				{
					this->client_version = version;
					break;
				}
			}
		}
		client_versions->destroy(client_versions);
	}
	else
	{
		version = legacy_version;
		if (this->tls->set_version(this->tls, version, version))
		{
			this->client_version = version;
		}
	}

	/* downgrade protection (see RFC 8446, section 4.1.3) */
	if ((original_version_max == TLS_1_3 && version < TLS_1_3) ||
		(original_version_max == TLS_1_2 && version < TLS_1_2))
	{
		chunk_t downgrade_protection = tls_downgrade_protection_tls11;

		if (version == TLS_1_2)
		{
			downgrade_protection = tls_downgrade_protection_tls12;
		}
		memcpy(&this->server_random[24], downgrade_protection.ptr,
			   downgrade_protection.len);
	}

	if (!this->client_version)
	{
		DBG1(DBG_TLS, "proposed version %N not supported", tls_version_names,
	   		 version);
		this->alert->add(this->alert, TLS_FATAL, TLS_PROTOCOL_VERSION);
		return NEED_MORE;
	}

	if (this->tls->get_version_max(this->tls) < TLS_1_3)
	{
		this->suite = this->crypto->resume_session(this->crypto, session,
										 this->peer,
										 chunk_from_thing(this->client_random),
										 chunk_from_thing(this->server_random));
	}

	if (this->suite && !retrying(this))
	{
		this->session = chunk_clone(session);
		this->resume = TRUE;
		DBG1(DBG_TLS, "resumed %N using suite %N",
			 tls_version_names, this->tls->get_version_max(this->tls),
			 tls_cipher_suite_names, this->suite);
	}
	else
	{
		tls_cipher_suite_t original_suite = this->suite;

		count = ciphers.len / sizeof(uint16_t);
		suites = alloca(count * sizeof(tls_cipher_suite_t));
		DBG2(DBG_TLS, "received %d TLS cipher suites:", count);
		for (i = 0; i < count; i++)
		{
			suites[i] = untoh16(&ciphers.ptr[i * sizeof(uint16_t)]);
			DBG2(DBG_TLS, "  %N", tls_cipher_suite_names, suites[i]);
		}
		if (!select_suite_and_key(this, suites, count))
		{
			this->alert->add(this->alert, TLS_FATAL, TLS_HANDSHAKE_FAILURE);
			return NEED_MORE;
		}
		if (retrying(this) && original_suite != this->suite)
		{
			DBG1(DBG_TLS, "selected %N instead of %N during retry",
				 tls_cipher_suite_names, this->suite, tls_cipher_suite_names,
				 original_suite);
			this->alert->add(this->alert, TLS_FATAL, TLS_ILLEGAL_PARAMETER);
			return NEED_MORE;
		}
		if (this->tls->get_version_max(this->tls) < TLS_1_3)
		{
			rng = lib->crypto->create_rng(lib->crypto, RNG_STRONG);
			if (!rng ||
				!rng->allocate_bytes(rng, SESSION_ID_SIZE, &this->session))
			{
				DBG1(DBG_TLS, "generating TLS session identifier failed, skipped");
			}
			DESTROY_IF(rng);
		}
		else
		{
			chunk_free(&this->session);
			this->session = chunk_clone(session);
		}
		DBG1(DBG_TLS, "negotiated %N using suite %N",
			 tls_version_names, this->tls->get_version_max(this->tls),
			 tls_cipher_suite_names, this->suite);
	}

	if (this->tls->get_version_max(this->tls) >= TLS_1_3)
	{
		diffie_hellman_group_t group;
		tls_named_group_t curve, requesting_curve = 0;
		enumerator_t *enumerator;
		array_t *peer_key_shares;

		peer_key_shares = array_create(sizeof(key_share_t), 1);
		extension = bio_reader_create(key_shares);
		while (extension->remaining(extension))
		{
			if (!extension->read_uint16(extension, &peer.curve) ||
				!extension->read_data16(extension, &peer.key_share) ||
				!peer.key_share.len)
			{
				DBG1(DBG_TLS, "invalid %N extension",
					 tls_extension_names, extension_type);
				this->alert->add(this->alert, TLS_FATAL, TLS_DECODE_ERROR);
				extension->destroy(extension);
				array_destroy(peer_key_shares);
				return NEED_MORE;
			}
			array_insert(peer_key_shares, ARRAY_TAIL, &peer);
		}
		extension->destroy(extension);

		enumerator = this->crypto->create_ec_enumerator(this->crypto);
		while (enumerator->enumerate(enumerator, &group, &curve))
		{
			if (!requesting_curve &&
				peer_supports_curve(this, curve) &&
				!peer_offered_curve(peer_key_shares, curve, NULL))
			{
				requesting_curve = curve;
			}
			if (peer_supports_curve(this, curve) &&
				peer_offered_curve(peer_key_shares, curve, &peer))
			{
				DBG1(DBG_TLS, "using key exchange %N",
					 tls_named_group_names, curve);
				this->dh = lib->crypto->create_dh(lib->crypto, group);
				break;
			}
		}
		enumerator->destroy(enumerator);
		array_destroy(peer_key_shares);

		if (!this->dh)
		{
			if (retrying(this))
			{
				DBG1(DBG_TLS, "already replied with a hello retry request");
				this->alert->add(this->alert, TLS_FATAL, TLS_UNEXPECTED_MESSAGE);
				return NEED_MORE;
			}

			if (!requesting_curve)
			{
				DBG1(DBG_TLS, "no mutual supported group in client hello");
				this->alert->add(this->alert, TLS_FATAL, TLS_ILLEGAL_PARAMETER);
				return NEED_MORE;
			}
			this->requested_curve = requesting_curve;

			if (!this->crypto->hash_handshake(this->crypto, NULL))
			{
				DBG1(DBG_TLS, "failed to hash handshake messages");
				this->alert->add(this->alert, TLS_FATAL, TLS_INTERNAL_ERROR);
				return NEED_MORE;
			}
		}
		else
		{
			if (peer.key_share.len &&
				peer.curve != TLS_CURVE25519 &&
				peer.curve != TLS_CURVE448)
			{	/* classic format (see RFC 8446, section 4.2.8.2) */
				if (peer.key_share.ptr[0] != TLS_ANSI_UNCOMPRESSED)
				{
					DBG1(DBG_TLS, "DH point format '%N' not supported",
						 tls_ansi_point_format_names, peer.key_share.ptr[0]);
					this->alert->add(this->alert, TLS_FATAL, TLS_INTERNAL_ERROR);
					return NEED_MORE;
				}
				peer.key_share = chunk_skip(peer.key_share, 1);
			}
			if (!peer.key_share.len ||
				!this->dh->set_other_public_value(this->dh, peer.key_share))
			{
				DBG1(DBG_TLS, "DH key derivation failed");
				this->alert->add(this->alert, TLS_FATAL, TLS_HANDSHAKE_FAILURE);
				return NEED_MORE;
			}
			this->requested_curve = 0;
		}
	}

	this->state = STATE_HELLO_RECEIVED;
	return NEED_MORE;
}
