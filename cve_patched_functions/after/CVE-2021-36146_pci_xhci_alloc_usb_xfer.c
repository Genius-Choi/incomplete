pci_xhci_alloc_usb_xfer(struct pci_xhci_dev_emu *dev, int epid)
{
	struct usb_xfer *xfer;
	struct xhci_dev_ctx *dev_ctx;
	struct xhci_endp_ctx *ep_ctx;
	int max_blk_cnt, i = 0;
	uint8_t type;

	if (!dev)
		return NULL;

	dev_ctx = dev->dev_ctx;
	ep_ctx = &dev_ctx->ctx_ep[epid];
	type = XHCI_EPCTX_1_EPTYPE_GET(ep_ctx->dwEpCtx1);

	/* TODO:
	 * The following code is still not perfect, due to fixed values are
	 * not flexible and the overflow risk is still existed. Will try to
	 * find a dynamic way could work both for Linux and Windows.
	 */
	switch (type) {
	case XHCI_EPTYPE_CTRL:
	case XHCI_EPTYPE_INT_IN:
	case XHCI_EPTYPE_INT_OUT:
		max_blk_cnt = 128;
		break;
	case XHCI_EPTYPE_BULK_IN:
	case XHCI_EPTYPE_BULK_OUT:
		max_blk_cnt = 1024;
		break;
	case XHCI_EPTYPE_ISOC_IN:
	case XHCI_EPTYPE_ISOC_OUT:
		max_blk_cnt = 2048;
		break;
	default:
		UPRINTF(LFTL, "err: unexpected epid %d type %d\r\n",
				epid, type);
		return NULL;
	}

	xfer = calloc(1, sizeof(struct usb_xfer));
	if (!xfer)
		return NULL;

	xfer->reqs = calloc(max_blk_cnt, sizeof(struct usb_dev_req *));
	if (!xfer->reqs)
		goto fail;

	xfer->data = calloc(max_blk_cnt, sizeof(struct usb_block));
	if (!xfer->data)
		goto fail;

	for (i = 0; i < max_blk_cnt; ++i) {
		xfer->data[i].hcb = calloc(1, sizeof(struct xhci_block));
		if (!xfer->data[i].hcb)
			goto fail;
	}

	UPRINTF(LINF, "allocate %d blocks for epid %d type %d\r\n",
			max_blk_cnt, epid, type);

	xfer->max_blk_cnt = max_blk_cnt;
	xfer->dev = (void *)dev;
	xfer->epid = epid;
	return xfer;

fail:
	if (xfer->data) {
		for (; i >= 0; i--)
			if (xfer->data[i].hcb)
				free(xfer->data[i].hcb);
		free(xfer->data);
	}
	if (xfer->reqs)
		free(xfer->reqs);
	free(xfer);
	return NULL;
}
