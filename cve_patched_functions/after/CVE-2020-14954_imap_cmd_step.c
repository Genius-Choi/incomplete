int imap_cmd_step(struct ImapAccountData *adata)
{
  if (!adata)
    return -1;

  size_t len = 0;
  int c;
  int rc;
  int stillrunning = 0;
  struct ImapCommand *cmd = NULL;

  if (adata->status == IMAP_FATAL)
  {
    cmd_handle_fatal(adata);
    return IMAP_RES_BAD;
  }

  /* read into buffer, expanding buffer as necessary until we have a full
   * line */
  do
  {
    if (len == adata->blen)
    {
      mutt_mem_realloc(&adata->buf, adata->blen + IMAP_CMD_BUFSIZE);
      adata->blen = adata->blen + IMAP_CMD_BUFSIZE;
      mutt_debug(LL_DEBUG3, "grew buffer to %lu bytes\n", adata->blen);
    }

    /* back up over '\0' */
    if (len)
      len--;
    c = mutt_socket_readln_d(adata->buf + len, adata->blen - len, adata->conn, MUTT_SOCK_LOG_FULL);
    if (c <= 0)
    {
      mutt_debug(LL_DEBUG1, "Error reading server response\n");
      cmd_handle_fatal(adata);
      return IMAP_RES_BAD;
    }

    len += c;
  }
  /* if we've read all the way to the end of the buffer, we haven't read a
   * full line (mutt_socket_readln strips the \r, so we always have at least
   * one character free when we've read a full line) */
  while (len == adata->blen);

  /* don't let one large string make cmd->buf hog memory forever */
  if ((adata->blen > IMAP_CMD_BUFSIZE) && (len <= IMAP_CMD_BUFSIZE))
  {
    mutt_mem_realloc(&adata->buf, IMAP_CMD_BUFSIZE);
    adata->blen = IMAP_CMD_BUFSIZE;
    mutt_debug(LL_DEBUG3, "shrank buffer to %lu bytes\n", adata->blen);
  }

  adata->lastread = mutt_date_epoch();

  /* handle untagged messages. The caller still gets its shot afterwards. */
  if ((mutt_str_startswith(adata->buf, "* ", CASE_MATCH) ||
       mutt_str_startswith(imap_next_word(adata->buf), "OK [", CASE_MATCH)) &&
      cmd_handle_untagged(adata))
  {
    return IMAP_RES_BAD;
  }

  /* server demands a continuation response from us */
  if (adata->buf[0] == '+')
    return IMAP_RES_RESPOND;

  /* Look for tagged command completions.
   *
   * Some response handlers can end up recursively calling
   * imap_cmd_step() and end up handling all tagged command
   * completions.
   * (e.g. FETCH->set_flag->set_header_color->~h pattern match.)
   *
   * Other callers don't even create an adata->cmds entry.
   *
   * For both these cases, we default to returning OK */
  rc = IMAP_RES_OK;
  c = adata->lastcmd;
  do
  {
    cmd = &adata->cmds[c];
    if (cmd->state == IMAP_RES_NEW)
    {
      if (mutt_str_startswith(adata->buf, cmd->seq, CASE_MATCH))
      {
        if (!stillrunning)
        {
          /* first command in queue has finished - move queue pointer up */
          adata->lastcmd = (adata->lastcmd + 1) % adata->cmdslots;
        }
        cmd->state = cmd_status(adata->buf);
        rc = cmd->state;
        if (cmd->state == IMAP_RES_NO || cmd->state == IMAP_RES_BAD)
        {
          mutt_message(_("IMAP command failed: %s"), adata->buf);
        }
      }
      else
        stillrunning++;
    }

    c = (c + 1) % adata->cmdslots;
  } while (c != adata->nextcmd);

  if (stillrunning)
    rc = IMAP_RES_CONTINUE;
  else
  {
    mutt_debug(LL_DEBUG3, "IMAP queue drained\n");
    imap_cmd_finish(adata);
  }

  return rc;
}
