static int lhs(void) {
	int code = RLC_ERR;
	uint8_t k[S][K];
	bn_t m, n, msg[S][L], sk[S], d[S], x[S][L];
	g1_t _r, h, as[S], cs[S], sig[S];
	g1_t a[S][L], c[S][L], r[S][L];
	g2_t _s, s[S][L], pk[S], y[S], z[S];
	gt_t *hs[S], vk;
	const char *data = "database-identifier";
	const char *id[S] = { "Alice", "Bob" };
	dig_t ft[S], *f[S] = { NULL };
	size_t flen[S];
	char *ls[L] = { NULL };

	bn_null(m);
	bn_null(n);
	g1_null(h);
	g1_null(_r);
	g2_null(_s);
	gt_null(vk);

	RLC_TRY {
		bn_new(m);
		bn_new(n);
		g1_new(h);
		g1_new(_r);
		g2_new(_s);
		gt_new(vk);

		for (int i = 0; i < S; i++) {
			hs[i] = RLC_ALLOCA(gt_t, RLC_TERMS);
			for (int j = 0; j < RLC_TERMS; j++) {
				gt_null(hs[i][j]);
				gt_new(hs[i][j]);
			}
			for (int j = 0; j < L; j++) {
				bn_null(x[i][j]);
				bn_null(msg[i][j]);
				g1_null(a[i][j]);
				g1_null(c[i][j]);
				g1_null(r[i][j]);
				g2_null(s[i][j]);
				bn_new(x[i][j]);
				bn_new(msg[i][j]);
				g1_new(a[i][j]);
				g1_new(c[i][j]);
				g1_new(r[i][j]);
				g2_new(s[i][j]);
			}
			bn_null(sk[i]);
			bn_null(d[i]);
			g1_null(sig[i]);
			g1_null(as[i]);
			g1_null(cs[i]);
			g2_null(y[i]);
			g2_null(z[i]);
			g2_null(pk[i]);

			bn_new(sk[i]);
			bn_new(d[i]);
			g1_new(sig[i]);
			g1_new(as[i]);
			g1_new(cs[i]);
			g2_new(y[i]);
			g2_new(z[i]);
			g2_new(pk[i]);
		}

		/* Define linear function. */
		for (int i = 0; i < S; i++) {
			f[i] = RLC_ALLOCA(dig_t, RLC_TERMS);
			for (int j = 0; j < RLC_TERMS; j++) {
				dig_t t;
				rand_bytes((uint8_t *)&t, sizeof(dig_t));
				f[i][j] = t & RLC_MASK(RLC_DIG / 2);
			}
			flen[i] = L;
		}

		/* Initialize scheme for messages of single components. */
		g1_get_ord(n);
		cp_cmlhs_init(h);

		TEST_CASE("context-hiding linear homomorphic signature is correct") {
			int label[L], b = i % 2;

			for (int j = 0; j < S; j++) {
				cp_cmlhs_gen(x[j], hs[j], L, k[j], K, sk[j], pk[j], d[j], y[j], b);
			}
			/* Compute all signatures (ECDSA if b = 0; BLS if b = 1). */
			for (int j = 0; j < S; j++) {
				for (int l = 0; l < L; l++) {
					label[l] = l;
					bn_rand_mod(msg[j][l], n);
					cp_cmlhs_sig(sig[j], z[j], a[j][l], c[j][l], r[j][l],
						s[j][l], msg[j][l], data, label[l], x[j][l], h, k[j], K,
						d[j], sk[j], b);
				}
			}
			/* Apply linear function over signatures. */
			for (int j = 0; j < S; j++) {
				cp_cmlhs_fun(as[j], cs[j], a[j], c[j], f[j], flen[j]);
			}

			cp_cmlhs_evl(_r, _s, r[0], s[0], f[0], flen[0]);
			for (int j = 1; j < S; j++) {
				cp_cmlhs_evl(r[0][0], s[0][0], r[j], s[j], f[j], flen[j]);
				g1_add(_r, _r, r[0][0]);
				g2_add(_s, _s, s[0][0]);
			}
			g1_norm(_r, _r);
			g2_norm(_s, _s);
			/* We share messages between users to simplify tests. */
			bn_zero(m);
			for (int j = 0; j < S; j++) {
				for (int l = 0; l < L; l++) {
					bn_mul_dig(msg[j][l], msg[j][l], f[j][l]);
					bn_add(m, m, msg[j][l]);
					bn_mod(m, m, n);
				}
			}

			TEST_ASSERT(cp_cmlhs_ver(_r, _s, sig, z, as, cs, m, data, h, label,
				(const gt_t **)hs, (const dig_t **)f, flen, y, pk, S, b), end);

			cp_cmlhs_off(vk, h, label, (const gt_t **)hs, (const dig_t **)f,
				flen, S);
			TEST_ASSERT(cp_cmlhs_onv(_r, _s, sig, z, as, cs, m, data, h, vk,
				y, pk, S, b) == 1, end);
		}
		TEST_END;

		TEST_CASE("simple linear multi-key homomorphic signature is correct") {
			for (int j = 0; j < S; j++) {
				cp_mklhs_gen(sk[j], pk[j]);
				for (int l = 0; l < L; l++) {
					ls[l] = "l";
					bn_rand_mod(msg[j][l], n);
					cp_mklhs_sig(a[j][l], msg[j][l], data, id[j], ls[l], sk[j]);
				}
			}

			for (int j = 0; j < S; j++) {
				cp_mklhs_fun(d[j], msg[j], f[j], L);
			}

			g1_set_infty(_r);
			for (int j = 0; j < S; j++) {
				cp_mklhs_evl(r[0][j], a[j], f[j], L);
				g1_add(_r, _r, r[0][j]);
			}
			g1_norm(_r, _r);

			bn_zero(m);
			for (int j = 0; j < S; j++) {
				for (int l = 0; l < L; l++) {
					bn_mul_dig(msg[j][l], msg[j][l], f[j][l]);
					bn_add(m, m, msg[j][l]);
					bn_mod(m, m, n);
				}
			}

			TEST_ASSERT(cp_mklhs_ver(_r, m, d, data, id, (const char **)ls,
					(const dig_t **)f, flen, pk, S), end);

			cp_mklhs_off(as, ft, id, (const char **)ls, (const dig_t **)f,
					flen, S);
			TEST_ASSERT(cp_mklhs_onv(_r, m, d, data, id, as, ft, pk, S), end);
		}
		TEST_END;
	}
	RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;

  end:
	bn_free(n);
	bn_free(m);
	g1_free(h);
	g1_free(_r);
	g2_free(_s);
	gt_free(vk);

	for (int i = 0; i < S; i++) {
		RLC_FREE(f[i]);
		for (int j = 0; j < RLC_TERMS; j++) {
			  gt_free(hs[i][j]);
		}
		RLC_FREE(hs[i]);
		for (int j = 0; j < L; j++) {
			bn_free(x[i][j]);
			bn_free(msg[i][j]);
			g1_free(a[i][j]);
			g1_free(c[i][j]);
			g1_free(r[i][j]);
			g2_free(s[i][j]);
		}
		bn_free(sk[i]);
		bn_free(d[i]);
		g1_free(sig[i]);
		g1_free(as[i]);
		g1_free(cs[i]);
		g2_free(y[i]);
		g2_free(z[i]);
		g2_free(pk[i]);
	}
	return code;
}
