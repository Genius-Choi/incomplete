R_API void r_meta_print(RAnal *a, RAnalMetaItem *d, ut64 start, ut64 size, int rad, PJ *pj, bool show_full) {
	r_return_if_fail (!(rad == 'j' && !pj)); // rad == 'j' => pj
	char *pstr, *base64_str;
	RCore *core = a->coreb.core;
	bool esc_bslash = core ? core->print->esc_bslash : false;
	if (r_spaces_current (&a->meta_spaces) &&
	    r_spaces_current (&a->meta_spaces) != d->space) {
		return;
	}
	char *str = NULL;
	if (d->str) {
		if (d->type == R_META_TYPE_STRING) {
			if (d->subtype == R_STRING_ENC_UTF8) {
				str = r_str_escape_utf8 (d->str, false, esc_bslash);
			} else {
				if (!d->subtype) {  /* temporary legacy workaround */
					esc_bslash = false;
				}
				str = r_str_escape_latin1 (d->str, false, esc_bslash, false);
			}
		} else {
			str = r_str_escape (d->str);
		}
	}
	if (str || d->type == R_META_TYPE_DATA) {
		if (d->type == R_META_TYPE_STRING && !*str) {
			free (str);
			return;
		}
		if (!str) {
			pstr = "";
		} else if (d->type == 'f') {
			pstr = str;
		} else if (d->type == 's') {
			pstr = str;
		} else if (d->type == 't') {
			// Sanitize (don't escape) Ct comments so we can see "char *", etc.
			free (str);
			str = strdup (d->str);
			r_str_sanitize (str);
			pstr = str;
		} else if (d->type != 'C') {
			r_name_filter (str, 0);
			pstr = str;
		} else {
			pstr = d->str;
		}
//		r_str_sanitize (str);
		switch (rad) {
		case 'j':
			pj_o (pj);
			pj_kn (pj, "offset", start);
			pj_ks (pj, "type", r_meta_type_tostring (d->type));

			if (d->type == 'H') {
				pj_k (pj, "color");
				ut8 r = 0, g = 0, b = 0, A = 0;
				const char *esc = strchr (d->str, '\x1b');
				if (esc) {
					r_cons_rgb_parse (esc, &r, &g, &b, &A);
					char *rgb_str = r_cons_rgb_tostring (r, g, b);
					base64_str = r_base64_encode_dyn (rgb_str, -1);
					if (d->type == 's' && base64_str) {
						pj_s (pj, base64_str);
						free (base64_str);
					} else {
						pj_s (pj, rgb_str);
					}
					free (rgb_str);
				} else {
					pj_s (pj, str);
				}
			} else {
				pj_k (pj, "name");
				if (d->type == 's' && (base64_str = r_base64_encode_dyn (d->str, -1))) {
					pj_s (pj, base64_str);
				} else {
					pj_s (pj, str);
				}
			}
			if (d->type == 'd') {
				pj_kn (pj, "size", size);
			} else if (d->type == 's') {
				const char *enc;
				switch (d->subtype) {
				case R_STRING_ENC_UTF8:
					enc = "utf8";
					break;
				case 0:  /* temporary legacy encoding */
					enc = "iz";
					break;
				default:
					enc = "latin1";
				}
				pj_ks (pj, "enc", enc);
				pj_kb (pj, "ascii", r_str_is_ascii (d->str));
			}

			pj_end (pj);
			break;
		case 0:
		case 1:
		case '*':
		default:
			switch (d->type) {
			case R_META_TYPE_COMMENT:
				{
				const char *type = r_meta_type_tostring (d->type);
				char *s = sdb_encode ((const ut8*)pstr, -1);
				if (!s) {
					s = strdup (pstr);
				}
				if (rad) {
					if (!strcmp (type, "CCu")) {
						a->cb_printf ("%s base64:%s @ 0x%08" PFMT64x "\n",
								type, s, start);
					} else {
						a->cb_printf ("%s %s @ 0x%08" PFMT64x "\n",
								type, pstr, start);
					}
				} else {
					if (!strcmp (type, "CCu")) {
						char *mys = r_str_escape (pstr);
						a->cb_printf ("0x%08" PFMT64x " %s \"%s\"\n",
								start, type, mys);
						free (mys);
					} else {
						a->cb_printf ("0x%08"PFMT64x" %s \"%s\"\n",
								start, type, pstr);
					}
				}
				free (s);
				}
				break;
			case R_META_TYPE_STRING:
				if (rad) {
					char cmd[] = "Cs#";
					switch (d->subtype) {
					case 'a':
					case '8':
						cmd[2] = d->subtype;
						break;
					default:
						cmd[2] = 0;
					}
					a->cb_printf ("%s %" PFMT64u " @ 0x%08" PFMT64x " # %s\n",
							cmd, size, start, pstr);
				} else {
					const char *enc;
					switch (d->subtype) {
					case '8':
						enc = "utf8";
						break;
					default:
						enc = r_str_is_ascii (d->str)? "ascii": "latin1";
					}
					if (show_full) {
						a->cb_printf ("0x%08" PFMT64x " %s[%" PFMT64u "] \"%s\"\n",
								start, enc, size, pstr);
					} else {
						a->cb_printf ("%s[%" PFMT64u "] \"%s\"\n",
								enc, size, pstr);
					}
				}
				break;
			case R_META_TYPE_HIDE:
			case R_META_TYPE_DATA:
				if (rad) {
					a->cb_printf ("%s %" PFMT64u " @ 0x%08" PFMT64x "\n",
							r_meta_type_tostring (d->type),
							size, start);
				} else {
					if (show_full) {
						const char *dtype = d->type == 'h'? "hidden": "data";
						a->cb_printf ("0x%08" PFMT64x " %s %s %"PFMT64u"\n",
								start, dtype,
								r_meta_type_tostring (d->type),
								size);
					} else {
						a->cb_printf ("%" PFMT64u "\n", size);
					}
				}
				break;
			case R_META_TYPE_MAGIC:
			case R_META_TYPE_FORMAT:
				if (rad) {
					a->cb_printf ("%s %" PFMT64u " %s @ 0x%08" PFMT64x "\n",
							r_meta_type_tostring (d->type),
							size, pstr, start);
				} else {
					if (show_full) {
						const char *dtype = d->type == 'm'? "magic": "format";
						a->cb_printf ("0x%08" PFMT64x " %s %" PFMT64u " %s\n",
								start, dtype, size, pstr);
					} else {
						a->cb_printf ("%" PFMT64u " %s\n", size, pstr);
					}
				}
				break;
			case R_META_TYPE_VARTYPE:
				if (rad) {
					a->cb_printf ("%s %s @ 0x%08" PFMT64x "\n",
							r_meta_type_tostring (d->type), pstr, start);
				} else {
					a->cb_printf ("0x%08" PFMT64x " %s\n", start, pstr);
				}
				break;
			case R_META_TYPE_HIGHLIGHT:
				{
					ut8 r = 0, g = 0, b = 0, A = 0;
					const char *esc = strchr (d->str, '\x1b');
					r_cons_rgb_parse (esc, &r, &g, &b, &A);
					a->cb_printf ("%s rgb:%02x%02x%02x @ 0x%08" PFMT64x "\n",
						r_meta_type_tostring (d->type), r, g, b, start);
					// TODO: d->size
				}
				break;
			default:
				if (rad) {
					a->cb_printf ("%s %" PFMT64u " 0x%08" PFMT64x " # %s\n",
						r_meta_type_tostring (d->type),
						size, start, pstr);
				} else {
					// TODO: use b64 here
					a->cb_printf ("0x%08" PFMT64x " array[%" PFMT64u "] %s %s\n",
						start, size,
						r_meta_type_tostring (d->type), pstr);
				}
				break;
			}
			break;
		}
		if (str) {
			free (str);
		}
	}
}
