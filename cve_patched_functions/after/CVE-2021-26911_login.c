void IMAPSession::login(ErrorCode * pError)
{
    int r;
    
    MCLog("login");
    
    MCAssert(mState == STATE_CONNECTED);

    MC_SAFE_RELEASE(mLoginResponse);
    MC_SAFE_RELEASE(mUnparsedResponseData);
    
    const char * utf8username;
    const char * utf8password;
    utf8username = MCUTF8(mUsername);
    utf8password = MCUTF8(mPassword);
    if (utf8username == NULL) {
        utf8username = "";
    }
    if (utf8password == NULL) {
        utf8password = "";
    }
    
    switch (mAuthType) {
        case 0:
        default:
            r = mailimap_login(mImap, utf8username, utf8password);
            break;
            
        case AuthTypeSASLCRAMMD5:
            r = mailimap_authenticate(mImap, "CRAM-MD5",
                                      MCUTF8(mHostname),
                                      NULL,
                                      NULL,
                                      utf8username, utf8username,
                                      utf8password, NULL);
            break;
            
        case AuthTypeSASLPlain:
            r = mailimap_authenticate(mImap, "PLAIN",
                                      MCUTF8(mHostname),
                                      NULL,
                                      NULL,
                                      utf8username, utf8username,
                                      utf8password, NULL);
            break;
            
        case AuthTypeSASLGSSAPI:
            // needs to be tested
            r = mailimap_authenticate(mImap, "GSSAPI",
                                      MCUTF8(mHostname),
                                      NULL,
                                      NULL,
                                      utf8username, utf8username,
                                      utf8password, NULL /* realm */);
            break;
            
        case AuthTypeSASLDIGESTMD5:
            r = mailimap_authenticate(mImap, "DIGEST-MD5",
                                      MCUTF8(mHostname),
                                      NULL,
                                      NULL,
                                      utf8username, utf8username,
                                      utf8password, NULL);
            break;
            
        case AuthTypeSASLLogin:
            r = mailimap_authenticate(mImap, "LOGIN",
                                      MCUTF8(mHostname),
                                      NULL,
                                      NULL,
                                      utf8username, utf8username,
                                      utf8password, NULL);
            break;
            
        case AuthTypeSASLSRP:
            r = mailimap_authenticate(mImap, "SRP",
                                      MCUTF8(mHostname),
                                      NULL,
                                      NULL,
                                      utf8username, utf8username,
                                      utf8password, NULL);
            break;
            
        case AuthTypeSASLNTLM:
            r = mailimap_authenticate(mImap, "NTLM",
                                      MCUTF8(mHostname),
                                      NULL,
                                      NULL,
                                      utf8username, utf8username,
                                      utf8password, NULL/* realm */);
            break;
            
        case AuthTypeSASLKerberosV4:
            r = mailimap_authenticate(mImap, "KERBEROS_V4",
                                      MCUTF8(mHostname),
                                      NULL,
                                      NULL,
                                      utf8username, utf8username,
                                      utf8password, NULL/* realm */);
            break;
            
        case AuthTypeXOAuth2:
        case AuthTypeXOAuth2Outlook:
            if (mOAuth2Token == NULL) {
                r = MAILIMAP_ERROR_STREAM;
            }
            else {
                r = mailimap_oauth2_authenticate(mImap, utf8username, MCUTF8(mOAuth2Token));
            }
            break;
    }
    if (r == MAILIMAP_ERROR_STREAM) {
        mShouldDisconnect = true;
        * pError = ErrorConnection;
        return;
    }
    else if (r == MAILIMAP_ERROR_PARSE) {
        mShouldDisconnect = true;
        * pError = ErrorParse;

        Data * unparsed_response = Data::data();
        if (mImap->imap_stream_buffer != NULL) {
            unparsed_response = Data::dataWithBytes(mImap->imap_stream_buffer->str, (unsigned int) mImap->imap_stream_buffer->len);
        }
        MC_SAFE_REPLACE_RETAIN(Data, mUnparsedResponseData, unparsed_response);

        return;
    }
    else if (hasError(r)) {
        String * response;
        
        response = MCSTR("");
        if (mImap->imap_response != NULL) {
            response = String::stringWithUTF8Characters(mImap->imap_response);
        }
        MC_SAFE_REPLACE_COPY(String, mLoginResponse, response);
        if (response->locationOfString(MCSTR("not enabled for IMAP use")) != -1) {
            * pError = ErrorGmailIMAPNotEnabled;
        }
        else if (response->locationOfString(MCSTR("IMAP access is disabled")) != -1) {
            * pError = ErrorGmailIMAPNotEnabled;
        }
        else if (response->locationOfString(MCSTR("bandwidth limits")) != -1) {
            * pError = ErrorGmailExceededBandwidthLimit;
        }
        else if (response->locationOfString(MCSTR("Too many simultaneous connections")) != -1) {
            * pError = ErrorGmailTooManySimultaneousConnections;
        }
        else if (response->locationOfString(MCSTR("Maximum number of connections")) != -1) {
            * pError = ErrorGmailTooManySimultaneousConnections;
        }
        else if (response->locationOfString(MCSTR("Application-specific password required")) != -1) {
            * pError = ErrorGmailApplicationSpecificPasswordRequired;
        }
        else if (response->locationOfString(MCSTR("http://me.com/move")) != -1) {
            * pError = ErrorMobileMeMoved;
        }
        else if (response->locationOfString(MCSTR("OCF12")) != -1) {
            * pError = ErrorYahooUnavailable;
        }
        else if (response->locationOfString(MCSTR("Login to your account via a web browser")) != -1) {
            * pError = ErrorOutlookLoginViaWebBrowser;
        }
        else if (response->locationOfString(MCSTR("Service temporarily unavailable")) != -1) {
            mShouldDisconnect = true;
            * pError = ErrorConnection;
        }
        else {
            * pError = ErrorAuthentication;
        }
        return;
    }
    
    String * loginResponse = MCSTR("");
    if (mIsGmail) {
        if (mImap->imap_response != NULL) {
            loginResponse = String::stringWithUTF8Characters(mImap->imap_response);
            
            int location = loginResponse->locationOfString(MCSTR(" authenticated (Success)"));
            if (location != -1) {
                String * emailAndName = loginResponse->substringToIndex(location);
                location = emailAndName->locationOfString(MCSTR(" "));
                MC_SAFE_RELEASE(mGmailUserDisplayName);
                mGmailUserDisplayName = emailAndName->substringFromIndex(location + 1);
                mGmailUserDisplayName->retain();
            }
        }
    }
    MC_SAFE_REPLACE_COPY(String, mLoginResponse, loginResponse);
    
    mState = STATE_LOGGEDIN;
    
    if (isAutomaticConfigurationEnabled()) {
        if (mCurrentCapabilities != NULL) {
            applyCapabilities(mCurrentCapabilities);
        } else {
            IndexSet *capabilities = capability(pError);
            if (* pError != ErrorNone) {
                MCLog("capabilities failed");
                return;
            } else {
                MC_SAFE_REPLACE_RETAIN(IndexSet, mCurrentCapabilities, capabilities);
                applyCapabilities(mCurrentCapabilities);
            }
        }
    }
    else {
        // TODO: capabilities should be shared with other sessions for non automatic capabilities sessions.
    }
    enableFeatures();

    if (isAutomaticConfigurationEnabled()) {
        bool hasDefaultNamespace = false;
        if (isNamespaceEnabled()) {
            IMAPNamespace * personalNamespace = NULL;
            
            if (mFetchedNamespace != NULL) {
                personalNamespace = mFetchedNamespace;
            } else {
                HashMap * result = fetchNamespace(pError);
                if (* pError != ErrorNone) {
                    MCLog("fetch namespace failed");
                    return;
                }
                personalNamespace = (IMAPNamespace *) result->objectForKey(IMAPNamespacePersonal);
            }
            
            if (personalNamespace != NULL) {
                setDefaultNamespace(personalNamespace);
                mDelimiter = defaultNamespace()->mainDelimiter();
                if (mFetchedNamespace != personalNamespace) {
                    MC_SAFE_REPLACE_RETAIN(IMAPNamespace, mFetchedNamespace, personalNamespace);
                }
                hasDefaultNamespace = true;
            }
        }
        
        if (!hasDefaultNamespace) {
            clist * imap_folders;
            IMAPFolder * folder;
            Array * folders;
            
            r = mailimap_list(mImap, "", "", &imap_folders);
            folders = resultsWithError(r, imap_folders, pError);
            if (* pError != ErrorNone)
                return;
            
            if (folders->count() > 0) {
                folder = (IMAPFolder *) folders->objectAtIndex(0);
            }
            else {
                folder = NULL;
            }
            if (folder == NULL) {
                * pError = ErrorNonExistantFolder;
                return;
            }
            
            mDelimiter = folder->delimiter();
            IMAPNamespace * defaultNamespace = IMAPNamespace::namespaceWithPrefix(MCSTR(""), folder->delimiter());
            setDefaultNamespace(defaultNamespace);
        }
        
        if (isIdentityEnabled()) {
//            IMAPIdentity * serverIdentity = NULL;
//            if (mFetchedIdentity) {
//                serverIdentity = mFetchedIdentity;
//            } else {
//                serverIdentity = identity(clientIdentity(), pError);
//            }
//            if (* pError != ErrorNone) {
//                // Ignore identity errors
//                MCLog("fetch identity failed");
//            }
//            else {
//                if (mFetchedIdentity != serverIdentity) {
//                    MC_SAFE_REPLACE_RETAIN(IMAPIdentity, mFetchedIdentity, serverIdentity);
//                }
//                MC_SAFE_REPLACE_RETAIN(IMAPIdentity, mServerIdentity, serverIdentity);
//            }
        }
    }
    else {
        // TODO: namespace should be shared with other sessions for non automatic namespace.
    }
    
    mAutomaticConfigurationDone = true;
    
    * pError = ErrorNone;
    MCLog("login ok");
}
