void VariableUnserializer::unserializeProp(ObjectData* obj,
                                           const String& key,
                                           Class* ctx,
                                           const String& realKey,
                                           int nProp) {

  auto const cls = obj->getVMClass();
  auto const lookup = cls->getDeclPropSlot(ctx, key.get());
  auto const slot = lookup.slot;
  tv_lval t;

  if (slot == kInvalidSlot || !lookup.accessible) {
    // Unserialize as a dynamic property. If this is the first, we need to
    // pre-allocate space in the array to ensure the elements don't move during
    // unserialization.
    obj->reserveDynProps(nProp);
    t = obj->makeDynProp(realKey.get());
  } else {
    // We'll check if this doesn't violate the type-hint once we're done
    // unserializing all the props.
    t = obj->getPropLval(ctx, key.get());
  }

  unserializePropertyValue(t, nProp);
  if (!RuntimeOption::RepoAuthoritative) return;
  if (!Repo::get().global().HardPrivatePropInference) return;

  /*
   * We assume for performance reasons in repo authoriative mode that
   * we can see all the sets to private properties in a class.
   *
   * It's a hole in this if we don't check unserialization doesn't
   * violate what we've seen, which we handle by throwing if the repo
   * was built with this option.
   */
  if (UNLIKELY(slot == kInvalidSlot)) return;
  auto const repoTy = cls->declPropRepoAuthType(slot);
  if (LIKELY(tvMatchesRepoAuthType(*t, repoTy))) return;
  if (t.type() == KindOfUninit &&
      (cls->declProperties()[slot].attrs & AttrLateInit)) {
    return;
  }
  throwUnexpectedType(key, obj, *t);
}
