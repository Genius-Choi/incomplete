static TEE_Result get_hkdf_params(uint32_t algo, const TEE_Attribute *params,
				  uint32_t param_count,
				  void **salt, size_t *salt_len, void **info,
				  size_t *info_len, size_t *okm_len,
				  uint32_t *hash_id)
{
	size_t n;
	enum { SALT = 0x1, LENGTH = 0x2, INFO = 0x4, HASH = 0x8 };
	uint8_t found = 0;

	*salt = *info = NULL;
	*salt_len = *info_len = *okm_len = 0;

	if (algo == TEE_ALG_HKDF) {
		*hash_id = TEE_ALG_SHA256;
	} else {
		*hash_id = TEE_ALG_GET_DIGEST_HASH(algo);
		found |= HASH;
	}

	for (n = 0; n < param_count; n++) {
		switch (params[n].attributeID) {
		case __OPTEE_TEE_ATTR_HKDF_SALT:
		case TEE_ATTR_HKDF_SALT:
			if (!(found & SALT)) {
				*salt = params[n].content.ref.buffer;
				*salt_len = params[n].content.ref.length;
				found |= SALT;
			}
			break;
		case TEE_ATTR_KDF_KEY_SIZE:
		case TEE_ATTR_HKDF_OKM_LENGTH:
			if (!(found & LENGTH)) {
				*okm_len = params[n].content.value.a;
				found |= LENGTH;
			}
			break;
		case __OPTEE_ATTR_HKDF_INFO:
		case TEE_ATTR_HKDF_INFO:
			if (!(found & INFO)) {
				*info = params[n].content.ref.buffer;
				*info_len = params[n].content.ref.length;
				found |= INFO;
			}
			break;
		case TEE_ATTR_HKDF_HASH_ALGORITHM:
			if (!(found & HASH)) {
				*hash_id = params[n].content.value.a;
				found |= HASH;
			}
			break;
		default:
			/* Unexpected attribute */
			return TEE_ERROR_BAD_PARAMETERS;
		}

	}

	if (!(found & LENGTH))
		return TEE_ERROR_BAD_PARAMETERS;

	return TEE_SUCCESS;
}
