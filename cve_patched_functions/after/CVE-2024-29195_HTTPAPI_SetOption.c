HTTPAPI_RESULT HTTPAPI_SetOption(HTTP_HANDLE handle, const char* optionName, const void* value)
{
    HTTPAPI_RESULT result;
    if (
        (handle == NULL) ||
        (optionName == NULL) ||
        (value == NULL)
        )
    {
        result = HTTPAPI_INVALID_ARG;
        LogError("invalid parameter (NULL) passed to HTTPAPI_SetOption");
    }
    else
    {
        HTTP_HANDLE_DATA* httpHandleData = (HTTP_HANDLE_DATA*)handle;
        if (strcmp(OPTION_HTTP_TIMEOUT, optionName) == 0)
        {
            long timeout = (long)(*(unsigned int*)value);
            httpHandleData->timeout = timeout;
            result = HTTPAPI_OK;
        }
        else if (strcmp(SU_OPTION_X509_CERT, optionName) == 0 || strcmp(OPTION_X509_ECC_CERT, optionName) == 0)
        {
            httpHandleData->x509certificate = (const char*)value;
            if (httpHandleData->x509privatekey != NULL)
            {
                httpHandleData->x509SchannelHandle = x509_schannel_create(httpHandleData->x509certificate, httpHandleData->x509privatekey);
                if (httpHandleData->x509SchannelHandle == NULL)
                {
                    LogError("unable to x509_schannel_create");
                    result = HTTPAPI_ERROR;
                }
                else
                {
                    result = HTTPAPI_OK;
                }
            }
            else
            {
                /*if certificate comes 1st and private key is not set yet, then return OK and wait for the private key to be set*/
                result = HTTPAPI_OK;
            }
        }
        else if (strcmp(SU_OPTION_X509_PRIVATE_KEY, optionName) == 0 || strcmp(OPTION_X509_ECC_KEY, optionName) == 0)
        {
            httpHandleData->x509privatekey = (const char*)value;
            if (httpHandleData->x509certificate != NULL)
            {
                httpHandleData->x509SchannelHandle = x509_schannel_create(httpHandleData->x509certificate, httpHandleData->x509privatekey);
                if (httpHandleData->x509SchannelHandle == NULL)
                {
                    LogError("unable to x509_schannel_create");
                    result = HTTPAPI_ERROR;
                }
                else
                {
                    result = HTTPAPI_OK;
                }
            }
            else
            {
                /*if privatekey comes 1st and certificate is not set yet, then return OK and wait for the certificate to be set*/
                result = HTTPAPI_OK;
            }
        }
        else if (strcmp(OPTION_TRUSTED_CERT, optionName) == 0)
        {
            if (value == NULL)
            {
                LogError("Invalid paramater: OPTION_TRUSTED_CERT value=NULL"); 
                result = MU_FAILURE;
            }
            else
            {
                if (httpHandleData->trustedCertificate != NULL)
                {   
                    free(httpHandleData->trustedCertificate);
                    httpHandleData->trustedCertificate = NULL;
                }

                if (mallocAndStrcpy_s((char**)&httpHandleData->trustedCertificate, (const char*)value) != 0)
                {
                    LogError("unable to mallocAndStrcpy_s option trusted certificate");
                    result = MU_FAILURE;
                }
                else
                {
                    result = HTTPAPI_OK;
                }
            }
        }
        else if (strcmp(OPTION_HTTP_PROXY, optionName) == 0)
        {
            char proxyAddressAndPort[MAX_HOSTNAME_LEN];
            HTTP_PROXY_OPTIONS* proxy_data = (HTTP_PROXY_OPTIONS*)value;
            if (proxy_data->host_address == NULL || proxy_data->port <= 0)
            {
                LogError("invalid proxy_data values ( host_address = %p, port = %d)", proxy_data->host_address, proxy_data->port);
                result = HTTPAPI_ERROR;
            }
            else
            {
                if (sprintf_s(proxyAddressAndPort, MAX_HOSTNAME_LEN, "%s:%d", proxy_data->host_address, proxy_data->port) <= 0)
                {
                    LogError("failure constructing proxy address");
                    result = HTTPAPI_ERROR;
                }
                else
                {
                    if(httpHandleData->proxy_host != NULL)
                    {
                        free((void*)httpHandleData->proxy_host);
                        httpHandleData->proxy_host = NULL;
                    }
                    if(mallocAndStrcpy_s((char**)&(httpHandleData->proxy_host), (const char*)proxyAddressAndPort) != 0)
                    {
                        LogError("failure allocate proxy host");
                        result = HTTPAPI_ERROR;
                    }
                    else
                    {
                        if (proxy_data->username != NULL && proxy_data->password != NULL)
                        {
                            if(httpHandleData->proxy_username != NULL)
                            {
                                free((void*)httpHandleData->proxy_username);
                                httpHandleData->proxy_username = NULL;
                            }
                            if(mallocAndStrcpy_s((char**)&(httpHandleData->proxy_username), (const char*)proxy_data->username) != 0)
                            {
                                LogError("failure allocate proxy username");
                                free((void*)httpHandleData->proxy_host);
                                httpHandleData->proxy_host = NULL;
                                result = HTTPAPI_ERROR;
                            }
                            else
                            {
                                if(httpHandleData->proxy_password != NULL)
                                {
                                  free((void*)httpHandleData->proxy_password);
                                  httpHandleData->proxy_password = NULL;
                                }
                                if(mallocAndStrcpy_s((char**)&(httpHandleData->proxy_password), (const char*)proxy_data->password) != 0)
                                {
                                    LogError("failure allocate proxy password");
                                    free((void*)httpHandleData->proxy_host);
                                    httpHandleData->proxy_host = NULL;
                                    free((void*)httpHandleData->proxy_username);
                                    httpHandleData->proxy_username = NULL;
                                    result = HTTPAPI_ERROR;
                                }
                                else
                                {
                                  result = HTTPAPI_OK;
                                }
                            }
                        }
                        else
                        {
                            result = HTTPAPI_OK;
                        }
                    }
                }
            }
        }
        else
        {
            result = HTTPAPI_INVALID_ARG;
            LogError("unknown option %s", optionName);
        }
    }
    return result;
}
