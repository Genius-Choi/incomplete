static int handle_turn_refresh(turn_turnserver *server,
			       ts_ur_super_session *ss, stun_tid *tid, int *resp_constructed,
			       int *err_code, 	const uint8_t **reason, uint16_t *unknown_attrs, uint16_t *ua_num,
			       ioa_net_data *in_buffer, ioa_network_buffer_handle nbh,
			       int message_integrity, int *no_response, int can_resume) {

	allocation* a = get_allocation_ss(ss);
	int af4c = 0;
	int af6c = 0;
	int af4 = 0;
	int af6 = 0;
	{
		int i;
		for(i = 0;i<ALLOC_PROTOCOLS_NUMBER; ++i) {
			if(a->relay_sessions[i].s && !ioa_socket_tobeclosed(a->relay_sessions[i].s)) {
				int family = get_ioa_socket_address_family(a->relay_sessions[i].s);
				if(AF_INET == family) {
					af4c = 1;
				} else if(AF_INET6 == family) {
					af6c = 1;
				}
			}
		}
	}

	if (!is_allocation_valid(a) && !(*(server->mobility))) {

		*err_code = 437;
		*reason = (const uint8_t *)"Invalid allocation";

	} else {

		turn_time_t lifetime = 0;
		int to_delete = 0;
		mobile_id_t mid = 0;
		char smid[sizeof(ss->s_mobile_id)] = "\0";

		stun_attr_ref sar = stun_attr_get_first_str(ioa_network_buffer_data(in_buffer->nbh), 
							    ioa_network_buffer_get_size(in_buffer->nbh));
		while (sar && (!(*err_code)) && (*ua_num < MAX_NUMBER_OF_UNKNOWN_ATTRS)) {
			int attr_type = stun_attr_get_type(sar);
			switch (attr_type) {
			SKIP_ATTRIBUTES;
			case STUN_ATTRIBUTE_MOBILITY_TICKET: {
				if(!(*(server->mobility))) {
					*err_code = 405;
					*reason = (const uint8_t *)"Mobility forbidden";
				} else {
					int smid_len = stun_attr_get_len(sar);
					if(smid_len>0 && (((size_t)smid_len)<sizeof(smid))) {
						const uint8_t* smid_val = stun_attr_get_value(sar);
						if(smid_val) {
							bcopy(smid_val, smid, (size_t)smid_len);
							mid = string_to_mobile_id(smid);
							if(is_allocation_valid(a) && (mid != ss->old_mobile_id)) {
								*err_code = 400;
								*reason = (const uint8_t *)"Mobility ticket cannot be used for a stable, already established allocation";
							}
						}
					} else {
						*err_code = 400;
						*reason = (const uint8_t *)"Mobility ticket has wrong length";
					}
				}
			}
				break;
			case STUN_ATTRIBUTE_LIFETIME: {
				if (stun_attr_get_len(sar) != 4) {
					*err_code = 400;
					*reason = (const uint8_t *)"Wrong Lifetime field format";
				} else {
					const uint8_t* value = stun_attr_get_value(sar);
					if (!value) {
						*err_code = 400;
						*reason = (const uint8_t *)"Wrong lifetime field data";
					} else {
						lifetime = nswap32(*((const uint32_t*)value));
						if (!lifetime)
							to_delete = 1;
					}
				}
			}
				break;
			case STUN_ATTRIBUTE_ADDITIONAL_ADDRESS_FAMILY: /* deprecated, for backward compatibility with older versions of TURN-bis */
			case STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY: {
				int af_req = stun_get_requested_address_family(sar);
				{
					int is_err = 0;
					switch (af_req) {
					case STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV4:
						if(!af4c) {
							is_err = 1;
						} else {
							af4 = 1;
						}
						break;
					case STUN_ATTRIBUTE_REQUESTED_ADDRESS_FAMILY_VALUE_IPV6:
						if(!af6c) {
							is_err = 1;
						} else {
							af6 = 1;
						}
						break;
					default:
						is_err = 1;
					}

					if(is_err) {
						*err_code = 443;
						*reason = (const uint8_t *)"Peer Address Family Mismatch (1)";
					}
				}
			}
				break;
			default:
				if(attr_type>=0x0000 && attr_type<=0x7FFF)
					unknown_attrs[(*ua_num)++] = nswap16(attr_type);
			};
			sar = stun_attr_get_next_str(ioa_network_buffer_data(in_buffer->nbh), 
						     ioa_network_buffer_get_size(in_buffer->nbh), sar);
		}

		if (*ua_num > 0) {

			*err_code = 420;

		} else if (*err_code) {

			;

		} else if(!is_allocation_valid(a)) {

			if(mid && smid[0]) {

				turnserver_id tsid = ((0xFF00000000000000LL) & mid)>>56;

				if(tsid != server->id) {

					if(server->send_socket_to_relay) {
						ioa_socket_handle new_s = detach_ioa_socket(ss->client_socket);
						if(new_s) {
						  if(server->send_socket_to_relay(tsid, mid, tid, new_s, message_integrity, 
										  RMT_MOBILE_SOCKET, in_buffer, can_resume)<0) {
						    *err_code = 400;
						    *reason = (const uint8_t *)"Wrong mobile ticket";
						  } else {
						    *no_response = 1;
						  }
						} else {
							*err_code = 500;
							*reason = (const uint8_t *)"Cannot create new socket";
							return -1;
						}
					} else {
						*err_code = 500;
						*reason = (const uint8_t *)"Server send socket procedure is not set";
					}

					ss->to_be_closed = 1;

				} else {

					ts_ur_super_session *orig_ss = get_session_from_mobile_map(server, mid);
					if(!orig_ss || orig_ss->to_be_closed || ioa_socket_tobeclosed(orig_ss->client_socket)) {
						*err_code = 404;
						*reason = (const uint8_t *)"Allocation not found";
					} else if(orig_ss == ss) {
						*err_code = 437;
						*reason = (const uint8_t *)"Invalid allocation";
					} else if(!(orig_ss->is_mobile)) {
						*err_code = 500;
						*reason = (const uint8_t *)"Software error: invalid mobile allocation";
					} else if(orig_ss->client_socket == ss->client_socket) {
						*err_code = 500;
						*reason = (const uint8_t *)"Software error: invalid mobile client socket (orig)";
					} else if(!(ss->client_socket)) {
						*err_code = 500;
						*reason = (const uint8_t *)"Software error: invalid mobile client socket (new)";
					} else {

						get_realm_options_by_name(orig_ss->realm_options.name, &(ss->realm_options));

						//Check security:
						int postpone_reply = 0;

						if(!(ss->hmackey_set)) {
							copy_auth_parameters(orig_ss,ss);
						}

						if(check_stun_auth(server, ss, tid, resp_constructed, err_code, reason, in_buffer, nbh,
								STUN_METHOD_REFRESH, &message_integrity, &postpone_reply, can_resume)<0) {
							if(!(*err_code)) {
								*err_code = 401;
							}
						}

						if(postpone_reply) {

							*no_response = 1;

						} else if(!(*err_code)) {

							//Session transfer:

							if (to_delete)
								lifetime = 0;
							else {
								lifetime = stun_adjust_allocate_lifetime(lifetime, *(server->max_allocate_lifetime), ss->max_session_time_auth);
							}

							if (af4c && refresh_relay_connection(server, orig_ss, lifetime, 0, 0, 0,
										err_code, AF_INET) < 0) {

								if (!(*err_code)) {
									*err_code = 437;
									*reason = (const uint8_t *)"Cannot refresh relay connection (internal error)";
								}

							} else if (af6c && refresh_relay_connection(server, orig_ss, lifetime, 0, 0, 0,
										err_code, AF_INET6) < 0) {

								if (!(*err_code)) {
									*err_code = 437;
									*reason = (const uint8_t *)"Cannot refresh relay connection (internal error)";
								}

							} else {

								//Transfer socket:

								ioa_socket_handle s = detach_ioa_socket(ss->client_socket);

								ss->to_be_closed = 1;

								if(!s) {
									*err_code = 500;
								} else {

									if(attach_socket_to_session(server, s, orig_ss) < 0) {
										if(orig_ss->client_socket != s) {
											IOA_CLOSE_SOCKET(s);
										}
										*err_code = 500;
									} else {

										if(ss->hmackey_set) {
											copy_auth_parameters(ss,orig_ss);
										}

										delete_session_from_mobile_map(ss);
										delete_session_from_mobile_map(orig_ss);
										put_session_into_mobile_map(orig_ss);

										//Use new buffer and redefine ss:
										nbh = ioa_network_buffer_allocate(server->e);

										dec_quota(ss);
										ss = orig_ss;
										inc_quota(ss,ss->username);

										ss->old_mobile_id = mid;
										size_t len = ioa_network_buffer_get_size(nbh);

										turn_report_allocation_set(&(ss->alloc), lifetime, 1);

										stun_init_success_response_str(STUN_METHOD_REFRESH, ioa_network_buffer_data(nbh), &len, tid);
										uint32_t lt = nswap32(lifetime);

										stun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_LIFETIME,
												(const uint8_t*) &lt, 4);
										ioa_network_buffer_set_size(nbh,len);

										stun_attr_add_str(ioa_network_buffer_data(nbh), &len,
											STUN_ATTRIBUTE_MOBILITY_TICKET,
											(uint8_t*)ss->s_mobile_id,strlen(ss->s_mobile_id));
										ioa_network_buffer_set_size(nbh,len);

										{
											const uint8_t *field = (const uint8_t *) get_version(server);
											size_t fsz = strlen(get_version(server));
											size_t len = ioa_network_buffer_get_size(nbh);
											stun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_SOFTWARE, field, fsz);
											ioa_network_buffer_set_size(nbh, len);
										}

										if(message_integrity) {
											stun_attr_add_integrity_str(server->ct,ioa_network_buffer_data(nbh),&len,ss->hmackey,ss->pwd,SHATYPE_DEFAULT);
											ioa_network_buffer_set_size(nbh,len);
										}

										if ((server->fingerprint) || ss->enforce_fingerprints) {
											if (stun_attr_add_fingerprint_str(ioa_network_buffer_data(nbh), &len) < 0) {
												*err_code = 500;
												ioa_network_buffer_delete(server->e, nbh);
												return -1;
											}
											ioa_network_buffer_set_size(nbh, len);
										}

										*no_response = 1;

										return write_client_connection(server, ss, nbh, TTL_IGNORE, TOS_IGNORE);
									}
								}
							}
						}

						report_turn_session_info(server,orig_ss,0);
					}
				}
			} else {
				*err_code = 437;
				*reason = (const uint8_t *)"Invalid allocation";
			}

		} else {

			if (to_delete)
				lifetime = 0;
			else {
				lifetime = stun_adjust_allocate_lifetime(lifetime, *(server->max_allocate_lifetime), ss->max_session_time_auth);
			}

			if(!af4 && !af6) {
				af4 = af4c;
				af6 = af6c;
			}

			if (af4 && refresh_relay_connection(server, ss, lifetime, 0, 0, 0,
					err_code, AF_INET) < 0) {

				if (!(*err_code)) {
					*err_code = 437;
					*reason = (const uint8_t *)"Cannot refresh relay connection (internal error)";
				}

			} else if (af6 && refresh_relay_connection(server, ss, lifetime, 0, 0, 0,
					err_code, AF_INET6) < 0) {

				if (!(*err_code)) {
					*err_code = 437;
					*reason = (const uint8_t *)"Cannot refresh relay connection (internal error)";
				}

			} else {

				turn_report_allocation_set(&(ss->alloc), lifetime, 1);

				size_t len = ioa_network_buffer_get_size(nbh);
				stun_init_success_response_str(STUN_METHOD_REFRESH, ioa_network_buffer_data(nbh), &len, tid);

				if(ss->s_mobile_id[0]) {
					stun_attr_add_str(ioa_network_buffer_data(nbh), &len,
									STUN_ATTRIBUTE_MOBILITY_TICKET,
									(uint8_t*)ss->s_mobile_id,strlen(ss->s_mobile_id));
					ioa_network_buffer_set_size(nbh,len);
				}

				uint32_t lt = nswap32(lifetime);
				stun_attr_add_str(ioa_network_buffer_data(nbh), &len, STUN_ATTRIBUTE_LIFETIME,
						(const uint8_t*) &lt, 4);

				ioa_network_buffer_set_size(nbh,len);

				*resp_constructed = 1;
			}
		}
	}

	if(!no_response) {
		if (!(*resp_constructed)) {

			if (!(*err_code)) {
				*err_code = 437;
			}

			size_t len = ioa_network_buffer_get_size(nbh);
			stun_init_error_response_str(STUN_METHOD_REFRESH, ioa_network_buffer_data(nbh), &len, *err_code, *reason, tid);
			ioa_network_buffer_set_size(nbh,len);

			*resp_constructed = 1;
		}
	}

	return 0;
}
