sendPDataTCP(PRIVATE_ASSOCIATIONKEY ** association,
             DUL_PDVLIST * pdvList)
{
    DUL_PDV *pdv;
    unsigned long
        count,
        length,
        pdvLength,
        maxLength;

    OFBool localLast;
    unsigned char *p;
    DUL_DATAPDU dataPDU;
    OFBool firstTrip;

    /* assign the amount of PDVs in the array and the PDV array itself to local variables */
    count = pdvList->count;
    pdv = pdvList->pdv;

    /* determine the maximum size (length) of a PDU which can be sent over the network. */
    /* Note that the name "maxPDV" here is misleading. This field contains the maxPDU */
    /* size which is max PDV size +6 or max PDV data field + 12. */
    maxLength = (*association)->maxPDV;

    /* send the error indicator variable to ok */
    OFCondition cond = EC_Normal;

    /* adjust maxLength (maximum length of a PDU) */
    if (maxLength == 0) maxLength = ASC_MAXIMUMPDUSIZE - 12;
    else if (maxLength < 14)
    {
       char buf[256];
       sprintf(buf, "DUL Cannot send P-DATA PDU because receiver's max PDU size of %lu is illegal (must be > 12)", maxLength);
       cond = makeDcmnetCondition(DULC_ILLEGALPDULENGTH, OF_error, buf);
    }
    else maxLength -= 12;

    /* start a loop iterate over all PDVs in the given */
    /* list and send every PDVs data over the network */
    while (cond.good() && count > 0)
    {
        --count;
        /* determine length of PDV */
        length = pdv->fragmentLength;
        /* determine data to be set */
        p = (unsigned char *) pdv->data;
        /* because the current PDV's length can be greater than maxLength, we need */
        /* to start another loop so that we are able to send data gradually. So, */
        /* as long as this is the first iteration or length is greater than 0 and */
        /* at the same time no error occurred, do the following */
        firstTrip = OFTrue;
        while ((firstTrip || (length > 0)) && (cond.good())) {
            /* indicate that the first iteration has been executed */
            firstTrip = OFFalse;
            /* determine the length of the data fragment that will be sent */
            pdvLength = (length <= maxLength) ? length : maxLength;
            /* determine if the following fragment will be the last fragment to send */
            localLast = ((pdvLength == length) && pdv->lastPDV);
            /* construct a data PDU */
            cond = constructDataPDU(p, pdvLength, pdv->pdvType,
                           pdv->presentationContextID, localLast, &dataPDU);
            /* send the constructed PDU over the network */
            cond = writeDataPDU(association, &dataPDU);

            /* adjust the pointer to the data, so that he points to data which still has to be sent */
            p += pdvLength;
            /* adjust the length of the fragment which still has to be sent */
            length -= pdvLength;
        }
        /* advance to the next PDV */
        pdv++;

    }
    /* return corresponding result value */
    return cond;
}
