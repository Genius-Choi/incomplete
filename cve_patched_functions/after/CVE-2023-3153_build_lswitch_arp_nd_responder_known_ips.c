build_lswitch_arp_nd_responder_known_ips(struct ovn_port *op,
                                         struct hmap *lflows,
                                         const struct hmap *ports,
                                         const struct shash *meter_groups,
                                         struct ds *actions,
                                         struct ds *match)
{
    if (op->nbsp) {
        if (!strcmp(op->nbsp->type, "virtual")) {
            /* Handle
             *  - GARPs for virtual ip which belongs to a logical port
             *    of type 'virtual' and bind that port.
             *
             *  - ARP reply from the virtual ip which belongs to a logical
             *    port of type 'virtual' and bind that port.
             *
             *  - IPv6 Neighbor Solicitations requests that targets virtual
             *    ip which belongs to a logical port of type 'virtual' and
             *    bind that port.
             *
             *  - IPv6 unsolicited Neighbor Advertisements that targets
             *    ip which belongs to a logical port of type 'virtual'
             *    and bind that port.
             * */
            struct in6_addr ip;

            const char *virtual_ip = smap_get(&op->nbsp->options,
                                              "virtual-ip");
            const char *virtual_parents = smap_get(&op->nbsp->options,
                                                   "virtual-parents");
            if (!virtual_ip || !virtual_parents) {
                return;
            }

            bool is_ipv4 = strchr(virtual_ip, '.') ? true : false;
            if (is_ipv4) {
                ovs_be32 ipv4;
                if (!ip_parse(virtual_ip, &ipv4)) {
                     return;
                }
            } else {
                if (!ipv6_parse(virtual_ip, &ip)) {
                     return;
                }
            }

            char *tokstr = xstrdup(virtual_parents);
            char *save_ptr = NULL;
            char *vparent;
            for (vparent = strtok_r(tokstr, ",", &save_ptr); vparent != NULL;
                 vparent = strtok_r(NULL, ",", &save_ptr)) {
                struct ovn_port *vp = ovn_port_find(ports, vparent);
                if (!vp || vp->od != op->od) {
                    /* vparent name should be valid and it should belong
                     * to the same logical switch. */
                    continue;
                }

                if (is_ipv4) {
                    ds_clear(match);
                    ds_put_format(match, "inport == \"%s\" && "
                            "((arp.op == 1 && arp.spa == %s && "
                            "arp.tpa == %s) || (arp.op == 2 && "
                            "arp.spa == %s))",
                            vparent, virtual_ip, virtual_ip,
                            virtual_ip);
                } else {
                    struct ipv6_netaddr na;
                    /* Find VIP multicast group */
                    in6_addr_solicited_node(&na.sn_addr, &ip);
                    inet_ntop(AF_INET6, &na.sn_addr, na.sn_addr_s,
                              sizeof na.sn_addr_s);

                    ds_clear(match);
                    ds_put_format(match, "inport == \"%s\" && "
                            "((nd_ns && ip6.dst == {%s, %s} && "
                            "nd.target == %s) ||"
                            "(nd_na && nd.target == %s))",
                            vparent,
                            virtual_ip,
                            na.sn_addr_s,
                            virtual_ip,
                            virtual_ip);
                }

                ds_clear(actions);
                ds_put_format(actions,
                    "bind_vport(%s, inport); "
                    "next;",
                    op->json_key);
                ovn_lflow_add_with_lport_and_hint(lflows, op->od,
                                                  S_SWITCH_IN_ARP_ND_RSP, 100,
                                                  ds_cstr(match),
                                                  ds_cstr(actions), vparent,
                                                  &vp->nbsp->header_);
            }

            free(tokstr);
        } else {
            /*
             * Add ARP/ND reply flows if either the
             *  - port is up and it doesn't have 'unknown' address defined or
             *  - port type is router or
             *  - port type is localport
             */
            if (check_lsp_is_up &&
                !lsp_is_up(op->nbsp) && !lsp_is_router(op->nbsp) &&
                strcmp(op->nbsp->type, "localport")) {
                return;
            }

            if (lsp_is_external(op->nbsp) || op->has_unknown) {
                return;
            }

            if (is_vlan_transparent(op->od)) {
                return;
            }

            for (size_t i = 0; i < op->n_lsp_addrs; i++) {
                for (size_t j = 0; j < op->lsp_addrs[i].n_ipv4_addrs; j++) {
                    ds_clear(match);
                    ds_put_format(match, "arp.tpa == %s && arp.op == 1",
                                op->lsp_addrs[i].ipv4_addrs[j].addr_s);
                    ds_clear(actions);
                    ds_put_format(actions,
                        "eth.dst = eth.src; "
                        "eth.src = %s; "
                        "arp.op = 2; /* ARP reply */ "
                        "arp.tha = arp.sha; "
                        "arp.sha = %s; "
                        "arp.tpa = arp.spa; "
                        "arp.spa = %s; "
                        "outport = inport; "
                        "flags.loopback = 1; "
                        "output;",
                        op->lsp_addrs[i].ea_s, op->lsp_addrs[i].ea_s,
                        op->lsp_addrs[i].ipv4_addrs[j].addr_s);
                    ovn_lflow_add_with_hint(lflows, op->od,
                                            S_SWITCH_IN_ARP_ND_RSP, 50,
                                            ds_cstr(match),
                                            ds_cstr(actions),
                                            &op->nbsp->header_);

                    /* Do not reply to an ARP request from the port that owns
                     * the address (otherwise a DHCP client that ARPs to check
                     * for a duplicate address will fail).  Instead, forward
                     * it the usual way.
                     *
                     * (Another alternative would be to simply drop the packet.
                     * If everything is working as it is configured, then this
                     * would produce equivalent results, since no one should
                     * reply to the request.  But ARPing for one's own IP
                     * address is intended to detect situations where the
                     * network is not working as configured, so dropping the
                     * request would frustrate that intent.) */
                    ds_put_format(match, " && inport == %s", op->json_key);
                    ovn_lflow_add_with_lport_and_hint(lflows, op->od,
                                                      S_SWITCH_IN_ARP_ND_RSP,
                                                      100, ds_cstr(match),
                                                      "next;", op->key,
                                                      &op->nbsp->header_);
                }

                /* For ND solicitations, we need to listen for both the
                 * unicast IPv6 address and its all-nodes multicast address,
                 * but always respond with the unicast IPv6 address. */
                for (size_t j = 0; j < op->lsp_addrs[i].n_ipv6_addrs; j++) {
                    ds_clear(match);
                    ds_put_format(match,
                            "nd_ns && ip6.dst == {%s, %s} && nd.target == %s",
                            op->lsp_addrs[i].ipv6_addrs[j].addr_s,
                            op->lsp_addrs[i].ipv6_addrs[j].sn_addr_s,
                            op->lsp_addrs[i].ipv6_addrs[j].addr_s);

                    ds_clear(actions);
                    ds_put_format(actions,
                            "%s { "
                            "eth.src = %s; "
                            "ip6.src = %s; "
                            "nd.target = %s; "
                            "nd.tll = %s; "
                            "outport = inport; "
                            "flags.loopback = 1; "
                            "output; "
                            "};",
                            lsp_is_router(op->nbsp) ? "nd_na_router" : "nd_na",
                            op->lsp_addrs[i].ea_s,
                            op->lsp_addrs[i].ipv6_addrs[j].addr_s,
                            op->lsp_addrs[i].ipv6_addrs[j].addr_s,
                            op->lsp_addrs[i].ea_s);
                    ovn_lflow_add_with_hint__(lflows, op->od,
                                              S_SWITCH_IN_ARP_ND_RSP, 50,
                                              ds_cstr(match),
                                              ds_cstr(actions),
                                              NULL,
                                              copp_meter_get(COPP_ND_NA,
                                                  op->od->nbs->copp,
                                                  meter_groups),
                                              &op->nbsp->header_);

                    /* Do not reply to a solicitation from the port that owns
                     * the address (otherwise DAD detection will fail). */
                    ds_put_format(match, " && inport == %s", op->json_key);
                    ovn_lflow_add_with_lport_and_hint(lflows, op->od,
                                                      S_SWITCH_IN_ARP_ND_RSP,
                                                      100, ds_cstr(match),
                                                      "next;", op->key,
                                                      &op->nbsp->header_);
                }
            }
        }

        if (op->peer) {
            const char *arp_proxy = smap_get(&op->nbsp->options,"arp_proxy");

            struct lport_addresses proxy_arp_addrs;
            int i = 0;

            /* Add responses for ARP proxies. */
            if (arp_proxy && extract_ip_addresses(arp_proxy,
                                                  &proxy_arp_addrs) &&
                proxy_arp_addrs.n_ipv4_addrs) {
                /* Match rule on all proxy ARP IPs. */
                ds_clear(match);
                ds_put_cstr(match, "arp.op == 1 && arp.tpa == {");

                for (i = 0; i < proxy_arp_addrs.n_ipv4_addrs; i++) {
                    ds_put_format(match, "%s,",
                                  proxy_arp_addrs.ipv4_addrs[i].addr_s);
                }

                ds_chomp(match, ',');
                ds_put_cstr(match, "}");
                destroy_lport_addresses(&proxy_arp_addrs);

                ds_clear(actions);
                ds_put_format(actions,
                    "eth.dst = eth.src; "
                    "eth.src = %s; "
                    "arp.op = 2; /* ARP reply */ "
                    "arp.tha = arp.sha; "
                    "arp.sha = %s; "
                    "arp.tpa <-> arp.spa; "
                    "outport = inport; "
                    "flags.loopback = 1; "
                    "output;",
                    op->peer->lrp_networks.ea_s,
                    op->peer->lrp_networks.ea_s);

                ovn_lflow_add_with_hint(lflows, op->od, S_SWITCH_IN_ARP_ND_RSP,
                    50, ds_cstr(match), ds_cstr(actions), &op->nbsp->header_);
            }
        }
    }
}
