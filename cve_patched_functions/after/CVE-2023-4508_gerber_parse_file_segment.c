gerber_parse_file_segment (gint levelOfRecursion, gerbv_image_t *image, 
			   gerb_state_t *state,	gerbv_net_t *curr_net, 
			   gerbv_stats_t *stats, gerb_file_t *fd, 
			   gchar *directoryPath)
{
    int read, coord, len, polygonPoints=0;
    double x_scale = 0.0, y_scale = 0.0;
    double delta_cp_x = 0.0, delta_cp_y = 0.0;
    double aperture_sizeX, aperture_sizeY;
    double scale;
    gboolean foundEOF = FALSE;
    gerbv_render_size_t boundingBoxNew = {HUGE_VAL,-HUGE_VAL,HUGE_VAL,-HUGE_VAL},
			boundingBox = boundingBoxNew;
    gerbv_error_list_t *error_list = stats->error_list;
    long int line_num = 1;

    while ((read = gerb_fgetc(fd)) != EOF) {
        /* figure out the scale, since we need to normalize 
	   all dimensions to inches */
        if (state->state->unit == GERBV_UNIT_MM)
            scale = 25.4;
        else
            scale = 1.0;
	switch ((char)(read & 0xff)) {
	case 'G':
	    dprintf("... Found G code at line %ld\n", line_num);
	    parse_G_code(fd, state, image, &line_num);
	    break;
	case 'D':
	    dprintf("... Found D code at line %ld\n", line_num);
	    parse_D_code(fd, state, image, &line_num);
	    break;
	case 'M':
	    dprintf("... Found M code at line %ld\n", line_num);

	    switch(parse_M_code(fd, image, &line_num)) {
	    case 1 :
	    case 2 :
	    case 3 :
		foundEOF = TRUE;
		break;
	    default:
		gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			_("Unknown M code found at line %ld in file \"%s\""),
			line_num, fd->filename);
	    } /* switch(parse_M_code) */
	    break;
	case 'X':
	    stats->X++;
	    coord = gerb_fgetint(fd, &len);
	    if (image->format)
		    add_trailing_zeros_if_omitted(&coord,
			    image->format->x_int + image->format->x_dec - len,
			    image->format);
	    dprintf("... Found X code %d at line %ld\n", coord, line_num);
	    if (image->format
	    &&  image->format->coordinate==GERBV_COORDINATE_INCREMENTAL)
	        state->curr_x += coord;
	    else
	        state->curr_x = coord;

	    state->changed = 1;
	    break;

	case 'Y':
	    stats->Y++;
	    coord = gerb_fgetint(fd, &len);
	    if (image->format)
		    add_trailing_zeros_if_omitted(&coord,
			    image->format->y_int + image->format->y_dec - len,
			    image->format);
	    dprintf("... Found Y code %d at line %ld\n", coord, line_num);
	    if (image->format
	    &&  image->format->coordinate==GERBV_COORDINATE_INCREMENTAL)
	        state->curr_y += coord;
	    else
	        state->curr_y = coord;

	    state->changed = 1;
	    break;

	case 'I':
	    stats->I++;
	    coord = gerb_fgetint(fd, &len);
	    if (image->format)
		    add_trailing_zeros_if_omitted(&coord,
			    image->format->x_int + image->format->x_dec - len,
			    image->format);
	    dprintf("... Found I code %d at line %ld\n", coord, line_num);
	    state->delta_cp_x = coord;
	    state->changed = 1;
	    break;

	case 'J':
	    stats->J++;
	    coord = gerb_fgetint(fd, &len);
	    if (image->format)
		    add_trailing_zeros_if_omitted(&coord,
			    image->format->y_int + image->format->y_dec - len,
			    image->format);
	    dprintf("... Found J code %d at line %ld\n", coord, line_num);
	    state->delta_cp_y = coord;
	    state->changed = 1;
	    break;

	case '%':
	    dprintf("... Found %% code at line %ld\n", line_num);
	    while (1) {
	    	parse_rs274x(levelOfRecursion, fd, image, state, curr_net,
				stats, directoryPath, &line_num);

	    	/* advance past any whitespace here */
		int c;
		while (1) {
		    c = gerb_fgetc(fd);

		    switch (c) {
		    case '\0': case '\t': case ' ':

			continue;

		    case '\n':
			line_num++;

			/* Get <CR> char, if any, from <LF><CR> pair */
			read = gerb_fgetc(fd);
			if (read != '\r' && read != EOF)
			    gerb_ungetc(fd);

			continue;

		    case '\r':
			line_num++;

			/* Get <LF> char, if any, from <CR><LF> pair */
			read = gerb_fgetc(fd);
			if (read != '\n' && read != EOF)
			    gerb_ungetc(fd);

			continue;
		    }

		    break; /* break while(1) */
		};

		if(c == EOF || c == '%')
		    break;

		/* Loop again to catch multiple blocks on the same line
		 * (separated by * char) */
		gerb_ungetc(fd);
	    }
	    break;
	case '*':  
	    dprintf("... Found * code at line %ld\n", line_num);
	    stats->star++;
	    if (state->changed == 0) break;
	    state->changed = 0;
	    
	    /* don't even bother saving the net if the aperture state is GERBV_APERTURE_STATE_OFF and we
	       aren't starting a polygon fill (where we need it to get to the start point) */
	    if ((state->aperture_state == GERBV_APERTURE_STATE_OFF)&&(!state->in_parea_fill)&&
	    		(state->interpolation != GERBV_INTERPOLATION_PAREA_START)) {
		/* save the coordinate so the next net can use it for a start point */
		state->prev_x = state->curr_x;
		state->prev_y = state->curr_y;
		break;
	    }
	    curr_net = gerber_create_new_net (curr_net, state->layer, state->state);
	    /*
	     * Scale to given coordinate format
	     * XXX only "omit leading zeros".
	     */
	    if (image && image->format ){
		x_scale = pow(10.0, (double)image->format->x_dec);
		y_scale = pow(10.0, (double)image->format->y_dec);
	    }
	    x_scale *= scale;
	    y_scale *= scale;
	    curr_net->start_x = (double)state->prev_x / x_scale;
	    curr_net->start_y = (double)state->prev_y / y_scale;
	    curr_net->stop_x = (double)state->curr_x / x_scale;
	    curr_net->stop_y = (double)state->curr_y / y_scale;
	    delta_cp_x = (double)state->delta_cp_x / x_scale;
	    delta_cp_y = (double)state->delta_cp_y / y_scale;

	    switch (state->interpolation) {
	    case GERBV_INTERPOLATION_CW_CIRCULAR :
	    case GERBV_INTERPOLATION_CCW_CIRCULAR : {
		int cw = (state->interpolation == GERBV_INTERPOLATION_CW_CIRCULAR);

		curr_net->cirseg = g_new0 (gerbv_cirseg_t, 1);
		if (state->mq_on) {
		    calc_cirseg_mq(curr_net, cw, delta_cp_x, delta_cp_y);
		} else {
		    calc_cirseg_sq(curr_net, cw, delta_cp_x, delta_cp_y);

		    /*
		     * In single quadrant circular interpolation Ix and Jy
		     * incremental distance must be unsigned.
		     */
		    if (delta_cp_x < 0 || delta_cp_y < 0) {
			gerbv_stats_printf(error_list,
				GERBV_MESSAGE_ERROR, -1, 
				_("Signed incremental distance IxJy "
				    "in single quadrant %s circular "
				    "interpolation %s at line %ld "
				    "in file \"%s\""),
				cw? _("CW"): _("CCW"), cw? "G02": "G03",
				line_num, fd->filename);
		    }

		}
		break;
	    }
	    case GERBV_INTERPOLATION_PAREA_START :
		/* 
		 * To be able to get back and fill in number of polygon corners
		 */
		state->parea_start_node = curr_net;
		state->in_parea_fill = 1;
		polygonPoints = 0;
		boundingBox = boundingBoxNew;
		break;
	    case GERBV_INTERPOLATION_PAREA_END :
		/* save the calculated bounding box to the master node */
		if (state->parea_start_node != NULL) {
		    state->parea_start_node->boundingBox = boundingBox;
		} else {
		    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
			    _("End of polygon without start "
				"at line %ld in file \"%s\""),
			    line_num, fd->filename);
		}

		/* close out the polygon */
		state->parea_start_node = NULL;
		state->in_parea_fill = 0;
		polygonPoints = 0;
		break;
	    default :
		break;
	    }  /* switch(state->interpolation) */

	    /* 
	     * Count number of points in Polygon Area 
	     */
	    if (state->in_parea_fill && state->parea_start_node) {
		/* 
		 * "...all lines drawn with D01 are considered edges of the
		 * polygon. D02 closes and fills the polygon."
		 * p.49 rs274xrevd_e.pdf
		 * D02 -> state->aperture_state == GERBV_APERTURE_STATE_OFF
		 */
		 
		 /* UPDATE: only end the polygon during a D02 call if we've already
		    drawn a polygon edge (with D01) */
		   
		if (state->aperture_state == GERBV_APERTURE_STATE_OFF
		&&  state->interpolation  != GERBV_INTERPOLATION_PAREA_START
		&&  polygonPoints > 0) {
		    curr_net->interpolation = GERBV_INTERPOLATION_PAREA_END;
		    curr_net = gerber_create_new_net (curr_net, state->layer, state->state);
		    curr_net->interpolation = GERBV_INTERPOLATION_PAREA_START;
		    state->parea_start_node->boundingBox = boundingBox;
		    state->parea_start_node = curr_net;
		    polygonPoints = 0;
		    curr_net = gerber_create_new_net (curr_net, state->layer, state->state);		    
		    curr_net->start_x = (double)state->prev_x / x_scale;
		    curr_net->start_y = (double)state->prev_y / y_scale;
		    curr_net->stop_x = (double)state->curr_x / x_scale;
		    curr_net->stop_y = (double)state->curr_y / y_scale;
		    boundingBox = boundingBoxNew;
		}
		else if (state->interpolation != GERBV_INTERPOLATION_PAREA_START)
		    polygonPoints++;
		
	    }  /* if (state->in_parea_fill && state->parea_start_node) */
	    
	    curr_net->interpolation = state->interpolation;

	    /* 
	     * Override circular interpolation if no center was given.
	     * This should be a safe hack, since a good file should always 
	     * include I or J.  And even if the radius is zero, the endpoint 
	     * should be the same as the start point, creating no line 
	     */
	    if (((state->interpolation == GERBV_INTERPOLATION_CW_CIRCULAR) || 
		 (state->interpolation == GERBV_INTERPOLATION_CCW_CIRCULAR)) && 
		((state->delta_cp_x == 0.0) && (state->delta_cp_y == 0.0)))
		curr_net->interpolation = GERBV_INTERPOLATION_LINEARx1;
	    
	    /*
	     * If we detected the end of Polygon Area Fill we go back to
	     * the interpolation we had before that.
	     * Also if we detected any of the quadrant flags, since some
	     * gerbers don't reset the interpolation (EagleCad again).
	     */
	    if ((state->interpolation == GERBV_INTERPOLATION_PAREA_START
	    ||   state->interpolation == GERBV_INTERPOLATION_PAREA_END)
	    && state->prev_interpolation != GERBV_INTERPOLATION_PAREA_END) {
		state->interpolation = state->prev_interpolation;
	    }

	    /*
	     * Save layer polarity and unit
	     */
	    curr_net->layer = state->layer;  
	    
	    state->delta_cp_x = 0.0;
	    state->delta_cp_y = 0.0;
	    curr_net->aperture = state->curr_aperture;
	    curr_net->aperture_state = state->aperture_state;

	    /*
	     * For next round we save the current position as
	     * the previous position
	     */
	    state->prev_x = state->curr_x;
	    state->prev_y = state->curr_y;

	    /*
	     * If we have an aperture defined at the moment we find 
	     * min and max of image with compensation for mm.
	     */
	    if ((curr_net->aperture == 0) && !state->in_parea_fill) 
		break;
	    
	    /* only update the min/max values and aperture stats if we are drawing */
	    if ((curr_net->aperture_state != GERBV_APERTURE_STATE_OFF)&&
	    		(curr_net->interpolation != GERBV_INTERPOLATION_PAREA_START)){
		double repeat_off_X = 0.0, repeat_off_Y = 0.0;

		/* Update stats with current aperture number if not in polygon */
		if (!state->in_parea_fill) {
			dprintf("     In %s(), adding 1 to D_list ...\n",
					__func__);
			int retcode = gerbv_stats_increment_D_list_count(
				stats->D_code_list, curr_net->aperture,
				1, error_list);
			if (retcode == -1) {
			    gerbv_stats_printf(error_list,
				    GERBV_MESSAGE_ERROR, -1,
				    _("Found undefined D code D%02d "
					"at line %ld in file \"%s\""),
				    curr_net->aperture, line_num, fd->filename);
			    stats->D_unknown++;
			}
		}

		/*
		 * If step_and_repeat (%SR%) is used, check min_x,max_y etc for
		 * the ends of the step_and_repeat lattice. This goes wrong in 
		 * the case of negative dist_X or dist_Y, in which case we 
		 * should compare against the startpoints of the lines, not 
		 * the stoppoints, but that seems an uncommon case (and the 
		 * error isn't very big any way).
		 */
		repeat_off_X = (state->layer->stepAndRepeat.X - 1) *
		    state->layer->stepAndRepeat.dist_X;
		repeat_off_Y = (state->layer->stepAndRepeat.Y - 1) *
		    state->layer->stepAndRepeat.dist_Y;
		
		cairo_matrix_init (&currentMatrix, 1, 0, 0, 1, 0, 0);
		/* offset image */
		cairo_matrix_translate (&currentMatrix, image->info->offsetA, 
					image->info->offsetB);
		/* do image rotation */
		cairo_matrix_rotate (&currentMatrix, image->info->imageRotation);
		/* it's a new layer, so recalculate the new transformation 
		 * matrix for it */
		/* do any rotations */
		cairo_matrix_rotate (&currentMatrix, state->layer->rotation);
			
		/* calculate current layer and state transformation matrices */
		/* apply scale factor */
		cairo_matrix_scale (&currentMatrix, state->state->scaleA, 
				    state->state->scaleB);
		/* apply offset */
		cairo_matrix_translate (&currentMatrix, state->state->offsetA,
					state->state->offsetB);
		/* apply mirror */
		switch (state->state->mirrorState) {
		case GERBV_MIRROR_STATE_FLIPA:
		    cairo_matrix_scale (&currentMatrix, -1, 1);
		    break;
		case GERBV_MIRROR_STATE_FLIPB:
		    cairo_matrix_scale (&currentMatrix, 1, -1);
		    break;
		case GERBV_MIRROR_STATE_FLIPAB:
		    cairo_matrix_scale (&currentMatrix, -1, -1);
		    break;
		default:
		    break;
		}
		/* finally, apply axis select */
		if (state->state->axisSelect == GERBV_AXIS_SELECT_SWAPAB) {
		    /* we do this by rotating 270 (counterclockwise, then 
		     *  mirroring the Y axis 
		     */
		    cairo_matrix_rotate (&currentMatrix, M_PI + M_PI_2);
		    cairo_matrix_scale (&currentMatrix, 1, -1);
		}
		/* if it's a macro, step through all the primitive components
		   and calculate the true bounding box */
		if ((image->aperture[curr_net->aperture] != NULL) &&
		    (image->aperture[curr_net->aperture]->type == GERBV_APTYPE_MACRO)) {
		    gerbv_simplified_amacro_t *ls = image->aperture[curr_net->aperture]->simplified;
	      
		    while (ls != NULL) {
			gdouble offsetx = 0, offsety = 0, widthx = 0, widthy = 0;
			gboolean calculatedAlready = FALSE;
			
			if (ls->type == GERBV_APTYPE_MACRO_CIRCLE) {
			    offsetx=ls->parameter[CIRCLE_CENTER_X];
			    offsety=ls->parameter[CIRCLE_CENTER_Y];
			    widthx=widthy=ls->parameter[CIRCLE_DIAMETER];
			} else if (ls->type == GERBV_APTYPE_MACRO_OUTLINE) {
			    int pointCounter,numberOfPoints;
			    numberOfPoints = ls->parameter[OUTLINE_NUMBER_OF_POINTS] + 1;
		
			    for (pointCounter = 0; pointCounter < numberOfPoints; pointCounter++) {
				gerber_update_min_and_max (&boundingBox,
							   curr_net->stop_x +
							   ls->parameter[OUTLINE_X_IDX_OF_POINT(pointCounter)],
							   curr_net->stop_y +
							   ls->parameter[OUTLINE_Y_IDX_OF_POINT(pointCounter)], 
							   0,0,0,0);
			    }
			    calculatedAlready = TRUE;
			} else if (ls->type == GERBV_APTYPE_MACRO_POLYGON) {
			    offsetx = ls->parameter[POLYGON_CENTER_X];
			    offsety = ls->parameter[POLYGON_CENTER_Y];
			    widthx = widthy = ls->parameter[POLYGON_DIAMETER];
			} else if (ls->type == GERBV_APTYPE_MACRO_MOIRE) {
			    offsetx = ls->parameter[MOIRE_CENTER_X];
			    offsety = ls->parameter[MOIRE_CENTER_Y];
			    widthx = widthy = ls->parameter[MOIRE_OUTSIDE_DIAMETER];
			} else if (ls->type == GERBV_APTYPE_MACRO_THERMAL) {
			    offsetx = ls->parameter[THERMAL_CENTER_X];
			    offsety = ls->parameter[THERMAL_CENTER_Y];
			    widthx = widthy = ls->parameter[THERMAL_OUTSIDE_DIAMETER];
			} else if (ls->type == GERBV_APTYPE_MACRO_LINE20) {
			    widthx = widthy = ls->parameter[LINE20_LINE_WIDTH];
			    gerber_update_min_and_max (&boundingBox,
						       curr_net->stop_x +
						       ls->parameter[LINE20_START_X],
						       curr_net->stop_y +
						       ls->parameter[LINE20_START_Y], 
						       widthx/2,widthx/2,widthy/2,widthy/2);
			    gerber_update_min_and_max (&boundingBox,
						       curr_net->stop_x +
						       ls->parameter[LINE20_END_X],
						       curr_net->stop_y +
						       ls->parameter[LINE20_END_Y], 
						       widthx/2,widthx/2,widthy/2,widthy/2);
			    calculatedAlready = TRUE;
			} else if (ls->type == GERBV_APTYPE_MACRO_LINE21) {
			    gdouble largestDimension = hypot(ls->parameter[LINE21_WIDTH],
							     ls->parameter[LINE21_HEIGHT]);
			    offsetx = ls->parameter[LINE21_CENTER_X];
			    offsety = ls->parameter[LINE21_CENTER_Y];
			    widthx = widthy = largestDimension;
			} else if (ls->type == GERBV_APTYPE_MACRO_LINE22) {
			    gdouble largestDimension = hypot(ls->parameter[LINE22_WIDTH],
							     ls->parameter[LINE22_HEIGHT]);

			    offsetx = ls->parameter[LINE22_LOWER_LEFT_X] +
	      			ls->parameter[LINE22_WIDTH]/2;
			    offsety = ls->parameter[LINE22_LOWER_LEFT_Y] +
	      			ls->parameter[LINE22_HEIGHT]/2;
			    widthx = widthy=largestDimension;
			}
	      	
			if (!calculatedAlready) {
			    gerber_update_min_and_max (&boundingBox,
						       curr_net->stop_x + offsetx,
						       curr_net->stop_y + offsety, 
						       widthx/2,widthx/2,widthy/2,widthy/2);
			}
	    		ls = ls->next;
		    }
		} else {
		    if (image->aperture[curr_net->aperture] != NULL) {
			aperture_sizeX = image->aperture[curr_net->aperture]->parameter[0];
			if ((image->aperture[curr_net->aperture]->type == GERBV_APTYPE_RECTANGLE) || (image->aperture[curr_net->aperture]->type == GERBV_APTYPE_OVAL)) {
				aperture_sizeY = image->aperture[curr_net->aperture]->parameter[1];
			}
			else
				aperture_sizeY = aperture_sizeX;
		    } else {
			/* this is usually for polygon fills, where the aperture width
			   is "zero" */
			aperture_sizeX = aperture_sizeY = 0;
		    }

		    /* if it's an arc path, use a special calc */

		    if ((curr_net->interpolation ==
					GERBV_INTERPOLATION_CW_CIRCULAR) ||
			(curr_net->interpolation ==
					GERBV_INTERPOLATION_CCW_CIRCULAR)) {
				calc_cirseg_bbox(curr_net->cirseg,
						aperture_sizeX, aperture_sizeY,
						&boundingBox);
		    } else {
			    /* check both the start and stop of the aperture points against
			       a running min/max counter */
			    /* Note: only check start coordinate if this isn't a flash, 
			       since the start point may be bogus if it is a flash */
			    if (curr_net->aperture_state != GERBV_APERTURE_STATE_FLASH) {
				gerber_update_min_and_max (&boundingBox,
							   curr_net->start_x, curr_net->start_y, 
							   aperture_sizeX/2,aperture_sizeX/2,
							   aperture_sizeY/2,aperture_sizeY/2);
			    }
			    gerber_update_min_and_max (&boundingBox,
						       curr_net->stop_x, curr_net->stop_y, 
						       aperture_sizeX/2,aperture_sizeX/2,
						       aperture_sizeY/2,aperture_sizeY/2);
		    }
					     
		}
		/* update the info bounding box with this latest bounding box */
		/* don't change the bounding box if the polarity is clear */
		if (state->layer->polarity != GERBV_POLARITY_CLEAR){
			gerber_update_image_min_max(&boundingBox, repeat_off_X, repeat_off_Y, image);
		}
		/* optionally update the knockout measurement box */
		if (knockoutMeasure) {
			if (boundingBox.left < knockoutLimitXmin)
				knockoutLimitXmin = boundingBox.left;
			if (boundingBox.right+repeat_off_X > knockoutLimitXmax)
				knockoutLimitXmax = boundingBox.right+repeat_off_X;
			if (boundingBox.bottom < knockoutLimitYmin)
				knockoutLimitYmin = boundingBox.bottom;
			if (boundingBox.top+repeat_off_Y > knockoutLimitYmax)
				knockoutLimitYmax = boundingBox.top+repeat_off_Y;
		}
		/* if we're not in a polygon fill, then update the object bounding box */
		if (!state->in_parea_fill) {
			curr_net->boundingBox = boundingBox;
			boundingBox = boundingBoxNew;
		}
	    }
	    break;

	case '\0': case '\t': case ' ':
	    break;

	case '\n':
	    line_num++;

	    /* Get <CR> char, if any, from <LF><CR> pair */
	    read = gerb_fgetc(fd);
	    if (read != '\r' && read != EOF)
		    gerb_ungetc(fd);
	    break;

	case '\r':
	    line_num++;

	    /* Get <LF> char, if any, from <CR><LF> pair */
	    read = gerb_fgetc(fd);
	    if (read != '\n' && read != EOF)
		    gerb_ungetc(fd);
	    break;

	default:
	    stats->unknown++;
	    gerbv_stats_printf(error_list, GERBV_MESSAGE_ERROR, -1,
		    _("Found unknown character '%s' (0x%x) "
			"at line %ld in file \"%s\""),
		    gerbv_escape_char(read), read,
		    line_num, fd->filename);
	}  /* switch((char) (read & 0xff)) */
    }
    return foundEOF;
}
