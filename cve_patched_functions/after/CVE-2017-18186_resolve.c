QPDF::resolve(int objid, int generation)
{
    // Check object cache before checking xref table.  This allows us
    // to insert things into the object cache that don't actually
    // exist in the file.
    QPDFObjGen og(objid, generation);
    if (this->m->resolving.count(og))
    {
        // This can happen if an object references itself directly or
        // indirectly in some key that has to be resolved during
        // object parsing, such as stream length.
	QTC::TC("qpdf", "QPDF recursion loop in resolve");
	warn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(),
		     "", this->m->file->getLastOffset(),
		     "loop detected resolving object " +
		     QUtil::int_to_string(objid) + " " +
		     QUtil::int_to_string(generation)));
        return new QPDF_Null;
    }
    ResolveRecorder rr(this, og);

    if (! this->m->obj_cache.count(og))
    {
	if (! this->m->xref_table.count(og))
	{
	    // PDF spec says unknown objects resolve to the null object.
	    return new QPDF_Null;
	}

	QPDFXRefEntry const& entry = this->m->xref_table[og];
        bool success = false;
        try
        {
            switch (entry.getType())
            {
              case 1:
                {
                    qpdf_offset_t offset = entry.getOffset();
                    // Object stored in cache by readObjectAtOffset
                    int aobjid;
                    int ageneration;
                    QPDFObjectHandle oh =
                        readObjectAtOffset(true, offset, "", objid, generation,
                                           aobjid, ageneration);
                }
                break;

              case 2:
                resolveObjectsInStream(entry.getObjStreamNumber());
                break;

              default:
                throw QPDFExc(qpdf_e_damaged_pdf,
                              this->m->file->getName(), "", 0,
                              "object " +
                              QUtil::int_to_string(objid) + "/" +
                              QUtil::int_to_string(generation) +
                              " has unexpected xref entry type");
            }
            success = true;
        }
        catch (QPDFExc& e)
        {
            warn(e);
        }
        catch (std::exception& e)
        {
            warn(QPDFExc(qpdf_e_damaged_pdf, this->m->file->getName(), "", 0,
                         "object " +
                         QUtil::int_to_string(objid) + "/" +
                         QUtil::int_to_string(generation) +
                         ": error reading object: " + e.what()));
        }
        if (! success)
        {
            QTC::TC("qpdf", "QPDF resolve failure to null");
            QPDFObjectHandle oh = QPDFObjectHandle::newNull();
            this->m->obj_cache[og] =
                ObjCache(QPDFObjectHandle::ObjAccessor::getObject(oh), -1, -1);
        }
    }

    return this->m->obj_cache[og].object;
}
