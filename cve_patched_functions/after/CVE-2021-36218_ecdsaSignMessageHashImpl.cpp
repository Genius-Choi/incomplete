Json::Value SGXWalletServer::ecdsaSignMessageHashImpl(int _base, const string &_keyName, const string &_messageHash) {
    spdlog::trace("Entering {}", __FUNCTION__);
    INIT_RESULT(result)

    result["signature_v"] = "";
    result["signature_r"] = "";
    result["signature_s"] = "";

    vector <string> signatureVector(3);

    try {
        string hashTmp = _messageHash;
        if (hashTmp[0] == '0' && (hashTmp[1] == 'x' || hashTmp[1] == 'X')) {
            hashTmp.erase(hashTmp.begin(), hashTmp.begin() + 2);
        }
        while (hashTmp[0] == '0') {
            hashTmp.erase(hashTmp.begin(), hashTmp.begin() + 1);
        }

        if (!checkECDSAKeyName(_keyName)) {
            throw SGXException(INVALID_ECDSA_KEY_NAME, "Invalid ECDSA key name");
        }
        if (!checkHex(hashTmp)) {
            throw SGXException(INVALID_HEX, "Invalid hash");
        }
        if (_base <= 0 || _base > 32) {
            throw SGXException(-22, "Invalid base");
        }

        shared_ptr <string> encryptedKey = readFromDb(_keyName, "");

        signatureVector = ecdsaSignHash(encryptedKey->c_str(), hashTmp.c_str(), _base);
        if (signatureVector.size() != 3) {
            throw SGXException(INVALID_ECSDA_SIGNATURE, "Invalid ecdsa signature");
        }

        result["signature_v"] = signatureVector.at(0);
        result["signature_r"] = signatureVector.at(1);
        result["signature_s"] = signatureVector.at(2);
    } HANDLE_SGX_EXCEPTION(result)

    RETURN_SUCCESS(result)
}
