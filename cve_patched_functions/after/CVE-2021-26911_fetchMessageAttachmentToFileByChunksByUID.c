void IMAPSession::fetchMessageAttachmentToFileByChunksByUID(String * folder, uint32_t uid, String * partID,
                                                    uint32_t estimatedSize, Encoding encoding,
                                                    String * outputFile, uint32_t chunkSize,
                                                    IMAPProgressCallback * progressCallback, ErrorCode * pError)
{
    DataStreamDecoder * decoder = new DataStreamDecoder();
    decoder->setEncoding(encoding);
    decoder->setFilename(outputFile);

    int nRetries = 0;
    int const maxRetries = 3;
    ErrorCode error = ErrorNone;
    uint32_t offset = 0;
    while (1) {
        AutoreleasePool * pool = new AutoreleasePool();

        LoadByChunkProgress * chunkProgressCallback = new LoadByChunkProgress();
        chunkProgressCallback->setOffset(offset);
        chunkProgressCallback->setEstimatedSize(estimatedSize);
        chunkProgressCallback->setProgressCallback(progressCallback);

        Data * data = fetchNonDecodedMessageAttachment(folder, true, uid, partID, false, offset, chunkSize, encoding, chunkProgressCallback, &error);

        MC_SAFE_RELEASE(chunkProgressCallback);

        if (error != ErrorNone) {
            pool->release();
            if ((error == ErrorConnection || error == ErrorParse) && nRetries < maxRetries) {
                error = ErrorNone;
                nRetries++;
                continue;
            }
            break;
        } else {
            nRetries = 0;
        }

        if (data == NULL) {
            break;
        }

        uint32_t encodedSize = data->length();
        if (encodedSize == 0) {
            pool->release();
            break;
        }

        error = decoder->appendData(data);

        pool->release();

        if (error != ErrorNone) {
            break;
        }

        offset += encodedSize;

        // Try detect is this chunk last.
        // Estimated size (extracted from BODYSTRUCTURE info) may be incorrect.
        // Also, server may return chunk with size less than requested.
        // So this detection is some tricky.
        bool endOfPart = ((encodedSize == 0) ||
                          (estimatedSize > 0 && (estimatedSize <= offset) && (encodedSize != chunkSize)) ||
                          (estimatedSize == 0 && encodedSize < chunkSize));
        if (endOfPart) {
            break;
        }
    }

    if (error == ErrorNone) {
        decoder->flushData();
    }

    MC_SAFE_RELEASE(decoder);

    * pError = error;
}
