int turn_session_info_copy_from(struct turn_session_info* tsi, ts_ur_super_session *ss)
{
	int ret = -1;

	if(tsi && ss) {
		tsi->id = ss->id;
		tsi->bps = ss->bps;
		tsi->start_time = ss->start_time;
		tsi->valid = is_allocation_valid(&(ss->alloc)) && !(ss->to_be_closed) && (ss->quota_used);
		if(tsi->valid) {
			if(ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].s) {
				tsi->expiration_time = ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].expiration_time;
				if(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s) {
					if(turn_time_before(tsi->expiration_time,ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].expiration_time)) {
						tsi->expiration_time = ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].expiration_time;
					}
				}
			} else if(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s) {
				tsi->expiration_time = ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].expiration_time;
			}
			if(ss->client_socket) {
				tsi->client_protocol = get_ioa_socket_type(ss->client_socket);
				addr_cpy(&(tsi->local_addr_data.addr),get_local_addr_from_ioa_socket(ss->client_socket));
				addr_to_string(&(tsi->local_addr_data.addr),(uint8_t*)tsi->local_addr_data.saddr);
				addr_cpy(&(tsi->remote_addr_data.addr),get_remote_addr_from_ioa_socket(ss->client_socket));
				addr_to_string(&(tsi->remote_addr_data.addr),(uint8_t*)tsi->remote_addr_data.saddr);
			}
			{
				if(ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].s) {
					tsi->peer_protocol = get_ioa_socket_type(ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].s);
					if(ss->alloc.is_valid) {
						addr_cpy(&(tsi->relay_addr_data_ipv4.addr),get_local_addr_from_ioa_socket(ss->alloc.relay_sessions[ALLOC_IPV4_INDEX].s));
						addr_to_string(&(tsi->relay_addr_data_ipv4.addr),(uint8_t*)tsi->relay_addr_data_ipv4.saddr);
					}
				}
				if(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s) {
					tsi->peer_protocol = get_ioa_socket_type(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s);
					if(ss->alloc.is_valid) {
						addr_cpy(&(tsi->relay_addr_data_ipv6.addr),get_local_addr_from_ioa_socket(ss->alloc.relay_sessions[ALLOC_IPV6_INDEX].s));
						addr_to_string(&(tsi->relay_addr_data_ipv6.addr),(uint8_t*)tsi->relay_addr_data_ipv6.saddr);
					}
				}
			}
			STRCPY(tsi->username,ss->username);
			tsi->enforce_fingerprints = ss->enforce_fingerprints;
			STRCPY(tsi->tls_method, get_ioa_socket_tls_method(ss->client_socket));
			STRCPY(tsi->tls_cipher, get_ioa_socket_tls_cipher(ss->client_socket));
			STRCPY(tsi->realm, ss->realm_options.name);
			STRCPY(tsi->origin, ss->origin);

			if(ss->t_received_packets > ss->received_packets)
				tsi->received_packets = ss->t_received_packets;
			else
				tsi->received_packets = ss->received_packets;

			if(ss->t_sent_packets > ss->sent_packets)
				tsi->sent_packets = ss->t_sent_packets;
			else
				tsi->sent_packets = ss->sent_packets;

			if(ss->t_received_bytes > ss->received_bytes)
				tsi->received_bytes = ss->t_received_bytes;
			else
				tsi->received_bytes = ss->received_bytes;

			if(ss->t_sent_bytes > ss->sent_bytes)
				tsi->sent_bytes = ss->t_sent_bytes;
			else
				tsi->sent_bytes = ss->sent_bytes;

			if (ss->t_peer_received_packets > ss->peer_received_packets)
				tsi->peer_received_packets = ss->t_peer_received_packets;
			else
				tsi->peer_received_packets = ss->peer_received_packets;

			if (ss->t_peer_sent_packets > ss->peer_sent_packets)
				tsi->peer_sent_packets = ss->t_peer_sent_packets;
			else
				tsi->peer_sent_packets = ss->peer_sent_packets;

			if (ss->t_peer_received_bytes > ss->peer_received_bytes)
				tsi->peer_received_bytes = ss->t_peer_received_bytes;
			else
				tsi->peer_received_bytes = ss->peer_received_bytes;

			if (ss->t_peer_sent_bytes > ss->peer_sent_bytes)
				tsi->peer_sent_bytes = ss->t_peer_sent_bytes;
			else
				tsi->peer_sent_bytes = ss->peer_sent_bytes;

			{
				tsi->received_rate = ss->received_rate;
				tsi->sent_rate = ss->sent_rate;
				tsi->total_rate = tsi->received_rate + tsi->sent_rate;
				tsi->peer_received_rate = ss->peer_received_rate;
				tsi->peer_sent_rate = ss->peer_sent_rate;
				tsi->peer_total_rate = tsi->peer_received_rate + tsi->peer_sent_rate;
			}

			tsi->is_mobile = ss->is_mobile;

			{
				size_t i;
				for(i=0;i<TURN_PERMISSION_HASHTABLE_SIZE;++i) {

					turn_permission_array *parray = &(ss->alloc.addr_to_perm.table[i]);

					{
						size_t j;
						for(j=0;j<TURN_PERMISSION_ARRAY_SIZE;++j) {
							turn_permission_slot* slot = &(parray->main_slots[j]);
							if(slot->info.allocated) {
								turn_session_info_add_peer(tsi,&(slot->info.addr));
								struct tsi_arg arg = {
									tsi,
									&(slot->info.addr)
								};
								lm_map_foreach_arg(&(slot->info.chns), turn_session_info_foreachcb, &arg);
							}
						}
					}

					{
						turn_permission_slot **slots = parray->extra_slots;
						if(slots) {
							size_t sz = parray->extra_sz;
							size_t j;
							for(j=0;j<sz;++j) {
								turn_permission_slot* slot = slots[j];
								if(slot && slot->info.allocated) {
									turn_session_info_add_peer(tsi,&(slot->info.addr));
									struct tsi_arg arg = {
										tsi,
										&(slot->info.addr)
									};
									lm_map_foreach_arg(&(slot->info.chns), turn_session_info_foreachcb, &arg);
								}
							}
						}
					}
				}
			}

			{
				tcp_connection_list *tcl = &(ss->alloc.tcs);
				if(tcl->elems) {
					size_t i;
					size_t sz = tcl->sz;
					for(i=0;i<sz;++i) {
						if(tcl->elems[i]) {
							tcp_connection *tc = tcl->elems[i];
							if(tc) {
								turn_session_info_add_peer(tsi,&(tc->peer_addr));
							}
						}
					}
				}
			}
		}

		ret = 0;
	}

	return ret;
}
