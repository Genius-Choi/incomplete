void ByteCodeGenerator::EnsureSpecialScopeSlots(FuncInfo* funcInfo, Scope* scope)
{
    if (scope->GetIsObject())
    {
        if (funcInfo->isThisLexicallyCaptured)
        {
            funcInfo->EnsureThisScopeSlot();
        }

        if (((!funcInfo->IsLambda() && funcInfo->GetCallsEval())
            || funcInfo->isSuperLexicallyCaptured))
        {
            if (funcInfo->superRegister != Js::Constants::NoRegister)
            {
                funcInfo->EnsureSuperScopeSlot();
            }

            if (funcInfo->superCtorRegister != Js::Constants::NoRegister)
            {
                funcInfo->EnsureSuperCtorScopeSlot();
            }
        }

        if (funcInfo->isNewTargetLexicallyCaptured)
        {
            funcInfo->EnsureNewTargetScopeSlot();
        }
    }
    else
    {
        // Don't rely on the Emit() pass to assign scope slots where needed, because peeps/shortcuts
        // may cause some expressions not to be emitted. Assign the slots we need before we start
        // emitting the prolog.
        // TODO: Investigate moving detection of non-local references to Emit() so we don't assign
        // slots to symbols that are never referenced in emitted code.

        if (funcInfo->isThisLexicallyCaptured)
        {
            funcInfo->EnsureThisScopeSlot();
        }

        if (funcInfo->isSuperLexicallyCaptured)
        {
            funcInfo->EnsureSuperScopeSlot();
        }

        if (funcInfo->isSuperCtorLexicallyCaptured)
        {
            funcInfo->EnsureSuperCtorScopeSlot();
        }

        if (funcInfo->isNewTargetLexicallyCaptured)
        {
            funcInfo->EnsureNewTargetScopeSlot();
        }
    }
}
