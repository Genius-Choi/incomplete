debugcore(filename, wildcards)
const char *filename;
boolean wildcards;
{
    const char *debugfiles, *p;

    if (!filename || !*filename)
        return FALSE; /* sanity precaution */

    if (sysopt.env_dbgfl == 0) {
        /* check once for DEBUGFILES in the environment;
           if found, it supersedes the sysconf value
           [note: getenv() rather than nh_getenv() since a long value
           is valid and doesn't pose any sort of overflow risk here] */
        if ((p = getenv("DEBUGFILES")) != 0) {
            if (sysopt.debugfiles)
                free((genericptr_t) sysopt.debugfiles);
            sysopt.debugfiles = dupstr(p);
            sysopt.env_dbgfl = 1;
        } else
            sysopt.env_dbgfl = -1;
    }

    debugfiles = sysopt.debugfiles;
    /* usual case: sysopt.debugfiles will be empty */
    if (!debugfiles || !*debugfiles)
        return FALSE;

/* strip filename's path if present */
#ifdef UNIX
    if ((p = rindex(filename, '/')) != 0)
        filename = p + 1;
#endif
#ifdef VMS
    filename = vms_basename(filename);
    /* vms_basename strips off 'type' suffix as well as path and version;
       we want to put suffix back (".c" assumed); since it always returns
       a pointer to a static buffer, we can safely modify its result */
    Strcat((char *) filename, ".c");
#endif

    /*
     * Wildcard match will only work if there's a single pattern (which
     * might be a single file name without any wildcarding) rather than
     * a space-separated list.
     * [to NOT do: We could step through the space-separated list and
     * attempt a wildcard match against each element, but that would be
     * overkill for the intended usage.]
     */
    if (wildcards && pmatch(debugfiles, filename))
        return TRUE;

    /* check whether filename is an element of the list */
    if ((p = strstr(debugfiles, filename)) != 0) {
        int l = (int) strlen(filename);

        if ((p == debugfiles || p[-1] == ' ' || p[-1] == '/')
            && (p[l] == ' ' || p[l] == '\0'))
            return TRUE;
    }
    return FALSE;
}
