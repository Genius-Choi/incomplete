tdirdelete(
	struct tmpnode *dir,
	struct tmpnode *tp,
	char *nm,
	enum dr_op op,
	struct cred *cred)
{
	struct tdirent *tpdp;
	int error;
	size_t namelen;
	struct tmpnode *tnp;
	timestruc_t now;

	ASSERT(RW_WRITE_HELD(&dir->tn_rwlock));
	ASSERT(RW_WRITE_HELD(&tp->tn_rwlock));
	ASSERT(dir->tn_type == VDIR);

	if (nm[0] == '\0')
		panic("tdirdelete: NULL name for %p", (void *)tp);

	/*
	 * return error when removing . and ..
	 */
	if (nm[0] == '.') {
		if (nm[1] == '\0')
			return (EINVAL);
		if (nm[1] == '.' && nm[2] == '\0')
			return (EEXIST); /* thus in ufs */
	}

	if (error = tmp_taccess(dir, VEXEC|VWRITE, cred))
		return (error);

	/*
	 * If the parent directory is "sticky", then the user must
	 * own the parent directory or the file in it, or else must
	 * have permission to write the file.  Otherwise it may not
	 * be deleted (except by privileged users).
	 * Same as ufs_dirremove.
	 */
	if ((error = tmp_sticky_remove_access(dir, tp, cred)) != 0)
		return (error);

	if (dir->tn_dir == NULL)
		return (ENOENT);

	tpdp = tmpfs_hash_lookup(nm, dir, 0, &tnp);
	if (tpdp == NULL) {
		/*
		 * If it is gone, some other thread got here first!
		 * Return error ENOENT.
		 */
		return (ENOENT);
	}

	/*
	 * If the tmpnode in the tdirent changed, we were probably
	 * the victim of a concurrent rename operation.  The original
	 * is gone, so return that status (same as UFS).
	 */
	if (tp != tnp)
		return (ENOENT);

	tmpfs_hash_out(tpdp);

	/*
	 * Take tpdp out of the directory list.
	 */
	ASSERT(tpdp->td_next != tpdp);
	ASSERT(tpdp->td_prev != tpdp);
	if (tpdp->td_prev) {
		tpdp->td_prev->td_next = tpdp->td_next;
	}
	if (tpdp->td_next) {
		tpdp->td_next->td_prev = tpdp->td_prev;
	}

	/*
	 * If the roving slot pointer happens to match tpdp,
	 * point it at the previous dirent.
	 */
	if (dir->tn_dir->td_prev == tpdp) {
		dir->tn_dir->td_prev = tpdp->td_prev;
	}
	ASSERT(tpdp->td_next != tpdp);
	ASSERT(tpdp->td_prev != tpdp);

	/*
	 * tpdp points to the correct directory entry
	 */
	namelen = strlen(tpdp->td_name) + 1;

	tmp_memfree(tpdp, sizeof (struct tdirent) + namelen);
	dir->tn_size -= (sizeof (struct tdirent) + namelen);
	dir->tn_dirents--;

	gethrestime(&now);
	dir->tn_mtime = now;
	dir->tn_ctime = now;
	tp->tn_ctime = now;

	ASSERT(tp->tn_nlink > 0);
	DECR_COUNT(&tp->tn_nlink, &tp->tn_tlock);
	if (op == DR_RMDIR && tp->tn_type == VDIR) {
		tdirtrunc(tp);
		ASSERT(tp->tn_nlink == 0);
	}
	return (0);
}
