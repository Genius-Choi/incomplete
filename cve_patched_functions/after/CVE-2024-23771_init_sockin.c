static void init_sockin(void) {
    struct sockaddr_in addrin;
#ifdef HAVE_INET6
    struct sockaddr_in6 addrin6;
#endif
    socklen_t addrin_len;
    int sockopt;

#ifdef HAVE_INET6
    if (inet6) {
        memset(&addrin6, 0, sizeof(addrin6));
        if (inet_pton(AF_INET6, bindaddr ? bindaddr : "::",
                      &addrin6.sin6_addr) == -1) {
            errx(1, "malformed --addr argument");
        }
        sockin = socket(PF_INET6, SOCK_STREAM, 0);
    } else
#endif
    {
        memset(&addrin, 0, sizeof(addrin));
        addrin.sin_addr.s_addr = bindaddr ? inet_addr(bindaddr) : INADDR_ANY;
        if (addrin.sin_addr.s_addr == (in_addr_t)INADDR_NONE)
            errx(1, "malformed --addr argument");
        sockin = socket(PF_INET, SOCK_STREAM, 0);
    }

    if (sockin == -1)
        err(1, "socket()");

    /* reuse address */
    sockopt = 1;
    if (setsockopt(sockin, SOL_SOCKET, SO_REUSEADDR,
                   &sockopt, sizeof(sockopt)) == -1)
        err(1, "setsockopt(SO_REUSEADDR)");

    /* disable Nagle since we buffer everything ourselves */
    sockopt = 1;
    if (setsockopt(sockin, IPPROTO_TCP, TCP_NODELAY,
            &sockopt, sizeof(sockopt)) == -1)
        err(1, "setsockopt(TCP_NODELAY)");

#ifdef TORTURE
    /* torture: cripple the kernel-side send buffer so we can only squeeze out
     * one byte at a time (this is for debugging)
     */
    sockopt = 1;
    if (setsockopt(sockin, SOL_SOCKET, SO_SNDBUF,
            &sockopt, sizeof(sockopt)) == -1)
        err(1, "setsockopt(SO_SNDBUF)");
#endif

    /* bind socket */
#ifdef HAVE_INET6
    if (inet6) {
        addrin6.sin6_family = AF_INET6;
        addrin6.sin6_port = htons(bindport);
        if (bind(sockin, (struct sockaddr *)&addrin6,
                 sizeof(struct sockaddr_in6)) == -1)
            err(1, "bind(port %u)", bindport);

        addrin_len = sizeof(addrin6);
        if (getsockname(sockin, (struct sockaddr *)&addrin6, &addrin_len) == -1)
            err(1, "getsockname()");
        printf("listening on: http://[%s]:%u/\n",
            get_address_text(&addrin6.sin6_addr), bindport);
    } else
#endif
    {
        addrin.sin_family = (u_char)PF_INET;
        addrin.sin_port = htons(bindport);
        if (bind(sockin, (struct sockaddr *)&addrin,
                 sizeof(struct sockaddr_in)) == -1)
            err(1, "bind(port %u)", bindport);
        addrin_len = sizeof(addrin);
        if (getsockname(sockin, (struct sockaddr *)&addrin, &addrin_len) == -1)
            err(1, "getsockname()");
        printf("listening on: http://%s:%u/\n",
            get_address_text(&addrin.sin_addr), bindport);
    }

    /* listen on socket */
    if (listen(sockin, max_connections) == -1)
        err(1, "listen()");

    /* enable acceptfilter (this is only available on FreeBSD) */
    if (want_accf) {
#if defined(__FreeBSD__)
        struct accept_filter_arg filt = {"httpready", ""};
        if (setsockopt(sockin, SOL_SOCKET, SO_ACCEPTFILTER,
                       &filt, sizeof(filt)) == -1)
            fprintf(stderr, "cannot enable acceptfilter: %s\n",
                strerror(errno));
        else
            printf("enabled acceptfilter\n");
#else
        printf("this platform doesn't support acceptfilter\n");
#endif
    }
}
