win_fix_scroll(int resize)
{
    win_T    *wp;
    linenr_T lnum;

    skip_update_topline = TRUE;  // avoid scrolling in curs_columns()
    FOR_ALL_WINDOWS(wp)
    {
	// Skip when window height has not changed.
	if (wp->w_height != wp->w_prev_height)
	{
	    // Determine botline needed to avoid scrolling and set cursor.
	    if (wp->w_winrow != wp->w_prev_winrow)
	    {
		lnum = wp->w_cursor.lnum;
		wp->w_cursor.lnum = MIN(wp->w_buffer->b_ml.ml_line_count,
			wp->w_botline - 1 + (wp->w_winrow - wp->w_prev_winrow)
					  + (wp->w_height - wp->w_prev_height));
		// Bring the new cursor position to the bottom of the screen.
		wp->w_fraction = FRACTION_MULT;
		scroll_to_fraction(wp, wp->w_prev_height);
		wp->w_cursor.lnum = lnum;
	    }
	    else if (wp == curwin)
		wp->w_valid &= ~VALID_CROW;
	    invalidate_botline_win(wp);
	    validate_botline_win(wp);
	}
	win_comp_scroll(wp);
	wp->w_prev_height = wp->w_height;
	wp->w_prev_winrow = wp->w_winrow;
    }
    skip_update_topline = FALSE;
    // Ensure cursor is valid when not in normal mode or when resized.
    if (!(get_real_state() & (MODE_NORMAL|MODE_CMDLINE|MODE_TERMINAL)))
	win_fix_cursor(FALSE);
    else if (resize)
	win_fix_cursor(TRUE);
}
