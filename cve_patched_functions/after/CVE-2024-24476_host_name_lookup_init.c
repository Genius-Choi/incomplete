host_name_lookup_init(void)
{
    char *hostspath;
    guint i;

    ws_assert(ipxnet_hash_table == NULL);
    ipxnet_hash_table = wmem_map_new(addr_resolv_scope, g_direct_hash, g_direct_equal);

    ws_assert(ipv4_hash_table == NULL);
    ipv4_hash_table = wmem_map_new(addr_resolv_scope, g_direct_hash, g_direct_equal);

    ws_assert(ipv6_hash_table == NULL);
    ipv6_hash_table = wmem_map_new(addr_resolv_scope, ipv6_oat_hash, ipv6_equal);

    ws_assert(async_dns_queue_head == NULL);
    async_dns_queue_head = wmem_list_new(addr_resolv_scope);

    /*
     * The manually resolved lists are the only address resolution maps
     * that are not reset by addr_resolv_cleanup(), because they are
     * the only ones that do not have entries from personal configuration
     * files that can change when changing configurations. All their
     * entries must also be in epan scope.
     */
    if (manually_resolved_ipv4_list == NULL)
        manually_resolved_ipv4_list = wmem_map_new(wmem_epan_scope(), g_direct_hash, g_direct_equal);

    if (manually_resolved_ipv6_list == NULL)
        manually_resolved_ipv6_list = wmem_map_new(wmem_epan_scope(), ipv6_oat_hash, ipv6_equal);

    /*
     * Load the global hosts file, if we have one.
     */
    if (!gbl_resolv_flags.load_hosts_file_from_profile_only) {
        hostspath = get_datafile_path(ENAME_HOSTS);
        if (!read_hosts_file(hostspath, TRUE) && errno != ENOENT) {
            report_open_failure(hostspath, errno, FALSE);
        }
        g_free(hostspath);
    }
    /*
     * Load the user's hosts file no matter what, if they have one.
     */
    hostspath = get_persconffile_path(ENAME_HOSTS, TRUE);
    if (!read_hosts_file(hostspath, TRUE) && errno != ENOENT) {
        report_open_failure(hostspath, errno, FALSE);
    }
    g_free(hostspath);
#ifdef CARES_HAVE_ARES_LIBRARY_INIT
    if (ares_library_init(ARES_LIB_INIT_ALL) == ARES_SUCCESS) {
#endif
        if (ares_init(&ghba_chan) == ARES_SUCCESS && ares_init(&ghbn_chan) == ARES_SUCCESS) {
            async_dns_initialized = TRUE;
            c_ares_set_dns_servers();
        }
#ifdef CARES_HAVE_ARES_LIBRARY_INIT
    }
#endif

    if (extra_hosts_files && !gbl_resolv_flags.load_hosts_file_from_profile_only) {
        for (i = 0; i < extra_hosts_files->len; i++) {
            read_hosts_file((const char *) g_ptr_array_index(extra_hosts_files, i), TRUE);
        }
    }

    subnet_name_lookup_init();

    add_manually_resolved();

    ss7pc_name_lookup_init();
}
