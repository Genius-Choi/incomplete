void ByteCodeGenerator::LoadNewTargetObject(FuncInfo *funcInfo)
{
    if (funcInfo->IsClassConstructor())
    {
        Assert(!funcInfo->IsLambda());

        m_writer.ArgIn0(funcInfo->newTargetRegister);
    }
    else if (funcInfo->IsLambda() && !(this->flags & fscrEval))
    {
        Scope *scope;
        Js::PropertyId envIndex = -1;
        GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);

        if (scope->GetFunc()->IsGlobalFunction())
        {
            m_writer.Reg1(Js::OpCode::LdUndef, funcInfo->newTargetRegister);
        }
        else
        {
            Js::PropertyId slot = scope->GetFunc()->newTargetScopeSlot;
            EmitInternalScopedSlotLoad(funcInfo, scope, envIndex, slot, funcInfo->newTargetRegister);
        }
    }
    else if ((funcInfo->IsGlobalFunction() || funcInfo->IsLambda()) && (this->flags & fscrEval))
    {
        Js::RegSlot scopeLocation;

        if (funcInfo->byteCodeFunction->GetIsStrictMode() && funcInfo->IsGlobalFunction())
        {
            scopeLocation = funcInfo->frameDisplayRegister;
        }
        else if (funcInfo->NeedEnvRegister())
        {
            scopeLocation = funcInfo->GetEnvRegister();
        }
        else
        {
            // If this eval doesn't have environment register or frame display register, we didn't capture anything from a class constructor.
            m_writer.Reg1(Js::OpCode::LdNewTarget, funcInfo->newTargetRegister);
            return;
        }

        uint cacheId = funcInfo->FindOrAddInlineCacheId(scopeLocation, Js::PropertyIds::_lexicalNewTargetSymbol, false, false);
        this->m_writer.ElementP(Js::OpCode::ScopedLdFld, funcInfo->newTargetRegister, cacheId);
    }
    else if (funcInfo->IsGlobalFunction())
    {
        m_writer.Reg1(Js::OpCode::LdUndef, funcInfo->newTargetRegister);
    }
    else
    {
        m_writer.Reg1(Js::OpCode::LdNewTarget, funcInfo->newTargetRegister);
    }
}
