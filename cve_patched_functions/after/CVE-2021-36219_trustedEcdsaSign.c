void trustedEcdsaSign(int *errStatus, char *errString, uint8_t *encryptedPrivateKey, uint32_t dec_len,
                 unsigned char *hash, char *sigR, char *sigS, uint8_t *sig_v, int base) {

    LOG_DEBUG (__FUNCTION__);

    char* arrM = NULL;
    char* arrR = NULL;
    char* arrS = NULL;

    char* privateKey = calloc(ECDSA_SKEY_LEN,1);

    mpz_t privateKeyMpz;
    mpz_init(privateKeyMpz);
    mpz_t msgMpz;
    mpz_init(msgMpz);

    signature sign = signature_init();

    domain_parameters curve = domain_parameters_init();
    domain_parameters_load_curve(curve, secp256k1);

    point publicKey = point_init();


    if (!hash) {
        *errStatus = -1;
        LOG_WARN("NULL message hash");
        snprintf(errString, BUF_LEN, "NULL message hash");
        goto clean;
    }

    if (!hash) {
        *errStatus = -1;
        char* msg = "NULL message hash";
        LOG_ERROR(msg);
        snprintf(errString, BUF_LEN, msg);
        goto clean;
    }

    if (!encryptedPrivateKey) {
        *errStatus = -1;
        snprintf(errString, BUF_LEN, "NULL encrypted ECDSA private key");
        LOG_ERROR(errString);
        goto clean;
    }
    
    

    sgx_status_t status = sgx_unseal_data(
            (const sgx_sealed_data_t *) encryptedPrivateKey, NULL, 0, privateKey, &dec_len);

    if (status != SGX_SUCCESS) {
        *errStatus = status;
        snprintf(errString, BUF_LEN, 
                "sgx_unseal_data failed for encryptedPrivateKey:status %d", status);
        LOG_ERROR(errString);
        goto clean;
    }
    

    if (mpz_set_str(privateKeyMpz, privateKey, ECDSA_SKEY_BASE) == -1) {
        *errStatus = -1;
        snprintf(errString, BUF_LEN, "mpz_set_str(privateKeyMpz ...) failed");
        LOG_ERROR(errString);
        goto clean;
    }


    if (mpz_set_str(msgMpz, hash, 16) == -1) {
        *errStatus = -1;
        snprintf(errString, BUF_LEN, "invalid message hash %s", hash);
        LOG_WARN(errString);
        goto clean;
    }

    signature_sign(sign, msgMpz, privateKeyMpz, curve);

    signature_extract_public_key(publicKey, privateKeyMpz, curve);



    if (!signature_verify(msgMpz, sign, publicKey, curve)) {
        *errStatus = -2;
        snprintf(errString, BUF_LEN, "ECDSA sig not verified");
        LOG_WARN(errString);
        goto clean;
    }

    arrR = calloc(mpz_sizeinbase(sign->r, base) + 2,1);
    mpz_get_str(arrR, base, sign->r);
    strncpy(sigR, arrR, 1024);
    arrS = calloc(mpz_sizeinbase(sign->s, base) + 2, 1);
    mpz_get_str(arrS, base, sign->s);
    strncpy(sigS, arrS, 1024);
    *sig_v = sign->v;

    clean:

    mpz_clear(privateKeyMpz);
    mpz_clear(msgMpz);
    domain_parameters_clear(curve);
    point_clear(publicKey);
    
    signature_free(sign);

    if (privateKey)
        free(privateKey);


    if (arrR) {
        free(arrR);
    }

    if (arrS) {
        free(arrS);
    }

    return;

}
