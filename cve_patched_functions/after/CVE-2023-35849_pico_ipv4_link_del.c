int pico_ipv4_link_del(struct pico_stack *S, struct pico_device *dev, struct pico_ip4 address)
{
    struct pico_ipv4_link test, *found;

    if (!dev || !dev->stack) {
        pico_err = PICO_ERR_EINVAL;
        return -1;
    }


    test.address.addr = address.addr;
    test.dev = dev;
    found = pico_tree_findKey(&S->Tree_dev_link, &test);
    if (!found) {
        pico_err = PICO_ERR_ENXIO;
        return -1;
    }

#ifdef PICO_SUPPORT_MCAST
    do {
        struct pico_ip4 mcast_all_hosts, mcast_addr, mcast_nm;
        struct pico_mcast_group *g = NULL;
        struct pico_tree_node *index, *_tmp;
        if (found == S->ipv4_mcast_default_link) {
            mcast_addr.addr = long_be(0xE0000000); /* 224.0.0.0 */
            mcast_nm.addr = long_be(0xF0000000); /* 15.0.0.0 */
            S->ipv4_mcast_default_link = NULL;
            pico_ipv4_route_del(S, mcast_addr, mcast_nm, 1);
        }

        mcast_all_hosts.addr = PICO_MCAST_ALL_HOSTS;
        pico_ipv4_mcast_leave(S, &address, &mcast_all_hosts, 1, PICO_IP_MULTICAST_EXCLUDE, NULL);
        pico_tree_foreach_safe(index, found->MCASTGroups, _tmp) {
            g = index->keyValue;
            pico_tree_delete(found->MCASTGroups, g);
            PICO_FREE(g);
        }
    } while(0);
    PICO_FREE(found->MCASTGroups);
#endif

    pico_ipv4_cleanup_routes(S, found);
    pico_tree_delete(&S->Tree_dev_link, found);
    if (S->default_bcast_route->link == found)
        S->default_bcast_route->link = NULL;

    PICO_FREE(found);

    return 0;
}
