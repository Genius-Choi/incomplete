int BUFFER_build(BUFFER_HANDLE handle, const unsigned char* source, size_t size)
{
    int result;
    if (handle == NULL)
    {
        /* Codes_SRS_BUFFER_07_009: [BUFFER_build shall return nonzero if handle is NULL ] */
        result = MU_FAILURE;
    }
    /* Codes_SRS_BUFFER_01_002: [The size argument can be zero, in which case the underlying buffer held by the buffer instance shall be freed.] */
    else if (size == 0)
    {
        /* Codes_SRS_BUFFER_01_003: [If size is zero, source can be NULL.] */
        BUFFER* b = (BUFFER*)handle;
        free(b->buffer);
        b->buffer = NULL;
        b->size = 0;

        result = 0;
    }
    else
    {
        if (source == NULL)
        {
            /* Codes_SRS_BUFFER_01_001: [If size is positive and source is NULL, BUFFER_build shall return nonzero] */
            result = MU_FAILURE;
        }
        else
        {
            BUFFER* b = (BUFFER*)handle;
            /* Codes_SRS_BUFFER_07_011: [BUFFER_build shall overwrite previous contents if the buffer has been previously allocated.] */
            unsigned char* newBuffer = (unsigned char*)realloc(b->buffer, size);
            if (newBuffer == NULL)
            {
                /* Codes_SRS_BUFFER_07_010: [BUFFER_build shall return nonzero if any error is encountered.] */
                LogError("Failure reallocating buffer");
                result = MU_FAILURE;
            }
            else
            {
                b->buffer = newBuffer;
                b->size = size;
                /* Codes_SRS_BUFFER_01_002: [The size argument can be zero, in which case nothing shall be copied from source.] */
                (void)memcpy(b->buffer, source, size);

                result = 0;
            }
        }
    }

    return result;
}
