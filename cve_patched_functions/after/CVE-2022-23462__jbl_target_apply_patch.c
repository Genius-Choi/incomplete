static iwrc _jbl_target_apply_patch(JBL_NODE target, const JBL_PATCHEXT *ex, IWPOOL *pool) {
  struct _JBL_NODE *ntmp;
  jbp_patch_t op = ex->p->op;
  JBL_PTR path = ex->path;
  JBL_NODE value = ex->p->vnode;
  bool oproot = ex->path->cnt == 1 && *ex->path->n[0] == '\0';

  if (op == JBP_TEST) {
    iwrc rc = 0;
    if (!value) {
      return JBL_ERROR_PATCH_NOVALUE;
    }
    if (_jbl_compare_nodes(oproot ? target : _jbl_node_find(target, path, 0, path->cnt), value, &rc)) {
      RCRET(rc);
      return JBL_ERROR_PATCH_TEST_FAILED;
    } else {
      return rc;
    }
  }
  if (oproot) { // Root operation
    if (op == JBP_REMOVE) {
      memset(target, 0, sizeof(*target));
    } else if ((op == JBP_REPLACE) || (op == JBP_ADD) || (op == JBP_ADD_CREATE)) {
      if (!value) {
        return JBL_ERROR_PATCH_NOVALUE;
      }
      memmove(target, value, sizeof(*value));
    }
  } else { // Not a root
    if ((op == JBP_REMOVE) || (op == JBP_REPLACE)) {
      _jbl_node_detach(target, ex->path);
    }
    if (op == JBP_REMOVE) {
      return 0;
    } else if ((op == JBP_MOVE) || (op == JBP_COPY) || (op == JBP_SWAP)) {
      if (op == JBP_MOVE) {
        value = _jbl_node_detach(target, ex->from);
      } else {
        value = _jbl_node_find(target, ex->from, 0, ex->from->cnt);
      }
      if (!value) {
        return JBL_ERROR_PATH_NOTFOUND;
      }
      if (op == JBP_SWAP) {
        ntmp = iwpool_calloc(sizeof(*ntmp), pool);
        if (!ntmp) {
          return iwrc_set_errno(IW_ERROR_ALLOC, errno);
        }
      }
    } else { // ADD/REPLACE/INCREMENT
      if (!value) {
        return JBL_ERROR_PATCH_NOVALUE;
      }
    }
    int lastidx = path->cnt - 1;
    JBL_NODE parent = (path->cnt > 1) ? _jbl_node_find(target, path, 0, lastidx) : target;
    if (!parent) {
      if (op == JBP_ADD_CREATE) {
        parent = target;
        for (int i = 0; i < lastidx; ++i) {
          JBL_NODE pn = _jbl_node_find(parent, path, i, i + 1);
          if (!pn) {
            pn = iwpool_calloc(sizeof(*pn), pool);
            if (!pn) {
              return iwrc_set_errno(IW_ERROR_ALLOC, errno);
            }
            pn->type = JBV_OBJECT;
            pn->key = path->n[i];
            pn->klidx = (int) strlen(pn->key);
            _jbn_add_item(parent, pn);
          } else if (pn->type != JBV_OBJECT) {
            return JBL_ERROR_PATCH_TARGET_INVALID;
          }
          parent = pn;
        }
      } else {
        return JBL_ERROR_PATCH_TARGET_INVALID;
      }
    }
    if (parent->type == JBV_ARRAY) {
      if ((path->n[lastidx][0] == '-') && (path->n[lastidx][1] == '\0')) {
        if (op == JBP_SWAP) {
          value = _jbl_node_detach(target, ex->from);
        }
        _jbn_add_item(parent, value); // Add to end of array
      } else {                        // Insert into the specified index
        int idx = iwatoi(path->n[lastidx]);
        int cnt = idx;
        JBL_NODE child = parent->child;
        while (child && cnt > 0) {
          cnt--;
          child = child->next;
        }
        if (cnt > 0) {
          return JBL_ERROR_PATCH_INVALID_ARRAY_INDEX;
        }
        value->klidx = idx;
        if (child) {
          if (op == JBP_SWAP) {
            _jbl_copy_node_data(ntmp, value);
            _jbl_copy_node_data(value, child);
            _jbl_copy_node_data(child, ntmp);
          } else {
            value->parent = parent;
            value->next = child;
            value->prev = child->prev;
            child->prev = value;
            if (child == parent->child) {
              parent->child = value;
            } else {
              value->prev->next = value;
            }
            while (child) {
              child->klidx++;
              child = child->next;
            }
          }
        } else {
          if (op == JBP_SWAP) {
            value = _jbl_node_detach(target, ex->from);
          }
          _jbn_add_item(parent, value);
        }
      }
    } else if (parent->type == JBV_OBJECT) {
      JBL_NODE child = _jbl_node_find(parent, path, path->cnt - 1, path->cnt);
      if (child) {
        if (op == JBP_INCREMENT) {
          return _jbl_increment_node_data(child, value);
        } else {
          if (op == JBP_SWAP) {
            _jbl_copy_node_data(ntmp, value);
            _jbl_copy_node_data(value, child);
            _jbl_copy_node_data(child, ntmp);
          } else {
            _jbl_copy_node_data(child, value);
          }
        }
      } else if (op != JBP_INCREMENT) {
        if (op == JBP_SWAP) {
          value = _jbl_node_detach(target, ex->from);
        }
        value->key = path->n[path->cnt - 1];
        value->klidx = (int) strlen(value->key);
        _jbn_add_item(parent, value);
      } else {
        return JBL_ERROR_PATCH_TARGET_INVALID;
      }
    } else {
      return JBL_ERROR_PATCH_TARGET_INVALID;
    }
  }
  return 0;
}
