static int rtcp_stats(switch_rtp_t *rtp_session)
{
	switch_core_session_t *session = switch_core_memory_pool_get_data(rtp_session->pool, "__session");
	srtp_hdr_t * hdr = &rtp_session->last_rtp_hdr;
	switch_rtcp_numbers_t * stats = &rtp_session->stats.rtcp;
	uint32_t packet_spacing_diff = 0, pkt_tsdiff, pkt_extended_seq;
	uint16_t pkt_seq, seq_diff, max_seq;
	const int MAX_DROPOUT = 3000;
	const int MAX_MISORDER = 100;
	const int RTP_SEQ_MOD = (1<<16);

	if(!rtp_session->rtcp_sock_output || !rtp_session->flags[SWITCH_RTP_FLAG_ENABLE_RTCP] || rtp_session->flags[SWITCH_RTP_FLAG_RTCP_PASSTHRU] || !rtp_session->rtcp_interval)
		return 0; /* do not process RTCP in current state */

	pkt_seq = (uint16_t) ntohs((uint16_t) rtp_session->last_rtp_hdr.seq);

	/* Detect sequence number cycle change */
	max_seq = stats->high_ext_seq_recv&0x0000ffff;
	seq_diff = pkt_seq - max_seq;

	if (seq_diff < MAX_DROPOUT) {  /* in order, with permissible gap */
		if (pkt_seq < max_seq) {
			stats->cycle++;
			switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG, "rtcp_stats:[cycle change] pkt_seq[%d] cycle[%d] max_seq[%d] stats_ssrc[%u] local_ts[%u]\n",
					pkt_seq, stats->cycle, max_seq, stats->ssrc, rtp_session->timer.samplecount);
		}
		pkt_extended_seq = stats->cycle << 16 | pkt_seq; /* getting the extended packet extended sequence ID */
		if (pkt_extended_seq > stats->high_ext_seq_recv) {
			stats->high_ext_seq_recv = pkt_extended_seq;
		}
	}
	else if (seq_diff <= (RTP_SEQ_MOD - MAX_MISORDER)) {   /* the sequence number made a very large jump */
		if (pkt_seq == stats->bad_seq) {
			rtcp_stats_init(rtp_session);
		} else {
			stats->bad_seq = (pkt_seq + 1) & (RTP_SEQ_MOD-1);
		}
		return 0; /* no stats, packet is out of sync and will be accounted as lost */
	} else {
		/* duplicate or reordered packet */
	}

	/* Verify that we are on the same stream source (we do not support multiple sources) */
	if (ntohl(hdr->ssrc) != stats->ssrc || !stats->init) {
		rtcp_stats_init(rtp_session);
	}

	stats->period_pkt_count++;
	stats->pkt_count++;
#ifdef DEBUG_RTCP
	switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG10, "rtcp_stats: period_pkt_count[%d]last_seq[%d]cycle[%d]stats_ssrc[%u]local_ts[%u]\n",
			stats->period_pkt_count, pkt_seq, stats->cycle, stats->ssrc, rtp_session->write_timer.samplecount);
#endif
	/* Interarrival jitter calculation */
	pkt_tsdiff = abs((int32_t)(rtp_session->timer.samplecount - ntohl(hdr->ts)));  /* relative transit times for this packet */
	if (stats->pkt_count < 2) { /* Can not compute Jitter with only one packet */
		stats->last_pkt_tsdiff = pkt_tsdiff;
	} else {
		/* Jitter : difference of relative transit times for the two packets */
		packet_spacing_diff = abs((int32_t)(pkt_tsdiff - stats->last_pkt_tsdiff));
		stats->last_pkt_tsdiff = pkt_tsdiff;
		/* Interarrival jitter estimation, "J(i) = J(i-1) + ( |D(i-1,i)| - J(i-1) )/16" */
		stats->inter_jitter = (stats->inter_jitter + (((double)packet_spacing_diff - stats->inter_jitter) /16.));
	}

#ifdef DEBUG_RTCP
	switch_log_printf(SWITCH_CHANNEL_SESSION_LOG(session), SWITCH_LOG_DEBUG10, "rtcp_stats: pkt_ts[%d]local_ts[%d]diff[%d]pkt_spacing[%d]inter_jitter[%f]seq[%d]stats_ssrc[%d]",
			ntohl(hdr->ts), rtp_session->timer.samplecount, pkt_tsdiff, packet_spacing_diff, stats->inter_jitter, ntohs(hdr->seq), stats->ssrc);
#endif
	return 1;
}
