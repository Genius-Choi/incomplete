  void testcompressDecompressWithUncommonParams(
      const uint32_t quality, const uint32_t window_bits, const uint32_t input_block_bits,
      const bool disable_literal_context_modeling,
      const Compression::Brotli::Compressor::BrotliCompressorImpl::EncoderMode encoder_mode,
      const bool disable_ring_buffer_reallocation) {
    Buffer::OwnedImpl buffer;
    Buffer::OwnedImpl accumulation_buffer;

    Compression::Brotli::Compressor::BrotliCompressorImpl compressor{
        quality,      window_bits, input_block_bits, disable_literal_context_modeling,
        encoder_mode, 4096};

    std::string original_text{};
    for (uint64_t i = 0; i < 30; ++i) {
      TestUtility::feedBufferWithRandomCharacters(buffer, default_input_size * i, i);
      original_text.append(buffer.toString());
      compressor.compress(buffer, Envoy::Compression::Compressor::State::Flush);
      accumulation_buffer.add(buffer);
      drainBuffer(buffer);
    }
    ASSERT_EQ(0, buffer.length());

    compressor.compress(buffer, Envoy::Compression::Compressor::State::Finish);
    accumulation_buffer.add(buffer);

    drainBuffer(buffer);
    ASSERT_EQ(0, buffer.length());

    Stats::IsolatedStoreImpl stats_store{};
    BrotliDecompressorImpl decompressor{stats_store, "test.", 4096,
                                        disable_ring_buffer_reallocation};

    decompressor.decompress(accumulation_buffer, buffer);
    std::string decompressed_text{buffer.toString()};

    ASSERT_EQ(original_text.length(), decompressed_text.length());
    EXPECT_EQ(original_text, decompressed_text);
    EXPECT_EQ(0, stats_store.counterFromString("test.brotli_error").value());
  }
