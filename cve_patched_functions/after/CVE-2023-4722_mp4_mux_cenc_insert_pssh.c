static void mp4_mux_cenc_insert_pssh(GF_MP4MuxCtx *ctx, TrackWriter *tkw, const GF_PropertyValue *pssh, u32 dyn_pssh_mode)
{
	bin128 *keyIDs=NULL;
	u32 max_keys = 0;
	u32 i, nb_pssh;
	GF_PropertyValue _the_prop;

	//set pssh
	const GF_PropertyValue *p=NULL;

	//only inject if pssh in packet
	if (dyn_pssh_mode==2) {
		GF_FilterPacket *pck;
		//nothing to inject
		if (!tkw->dyn_pssh) return;
		pck = gf_filter_pid_get_packet(tkw->ipid);
		if (pck) {
			pssh = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);
			//change of dynamic pssh is pending, don't inject the old one
			if (pssh) return;
		}
		_the_prop.type = GF_PROP_DATA;
		_the_prop.value.data.ptr = tkw->dyn_pssh;
		_the_prop.value.data.size = tkw->dyn_pssh_len;
		p = &_the_prop;
	} else {
		if (pssh) {
			p = pssh;
		} else {
			//inject pssh from packet if any, or from PID (used for keyroll of master+leaf schemes)
			if (dyn_pssh_mode) {
				GF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);
				if (pck) {
					p = gf_filter_pck_get_property(pck, GF_PROP_PID_CENC_PSSH);
				}
			}
			if (!p)
				p = gf_filter_pid_get_property(tkw->ipid, GF_PROP_PID_CENC_PSSH);
		}
		if (!p) return;
	}

	if (!ctx->bs_r) ctx->bs_r = gf_bs_new(p->value.data.ptr, p->value.data.size, GF_BITSTREAM_READ);
	else gf_bs_reassign_buffer(ctx->bs_r, p->value.data.ptr, p->value.data.size);

	nb_pssh = gf_bs_read_u32(ctx->bs_r);
	for (i = 0; i < nb_pssh; i++) {
		u32 mode;
		bin128 sysID;
		u32 j, kid_count, version=0;
		char *data;
		u32 len;

		gf_bs_read_data(ctx->bs_r, sysID, 16);
		version = gf_bs_read_u32(ctx->bs_r);
		kid_count = version ? gf_bs_read_u32(ctx->bs_r) : 0;

		if (kid_count>=max_keys) {
			max_keys = kid_count;
			keyIDs = gf_realloc(keyIDs, sizeof(bin128)*max_keys);
		}
		for (j=0; j<kid_count; j++) {
			gf_bs_read_data(ctx->bs_r, keyIDs[j], 16);
		}
		len = gf_bs_read_u32(ctx->bs_r);
		data = p->value.data.ptr + gf_bs_get_position(ctx->bs_r);

		if (tkw->is_item) mode = 2;
		else if (tkw->scheme_type==GF_ISOM_PIFF_SCHEME) mode = 1;
		else mode = 0;

		gf_cenc_set_pssh(ctx->file, sysID, version, kid_count, keyIDs, data, len, mode);
		gf_bs_skip_bytes(ctx->bs_r, len);
		if (gf_bs_is_overflow(ctx->bs_r))
			break;
	}
	if (keyIDs) gf_free(keyIDs);


	if (pssh) {
		if (tkw->dyn_pssh) gf_free(tkw->dyn_pssh);
		tkw->dyn_pssh = gf_malloc(sizeof(u8) * pssh->value.data.size);
		if (!tkw->dyn_pssh) return;
		memcpy(tkw->dyn_pssh, pssh->value.data.ptr, sizeof(u8) * pssh->value.data.size);
		tkw->dyn_pssh_len = pssh->value.data.size;
	}

}
