required_field_pack_to_buffer(const ProtobufCFieldDescriptor *field,
			      const void *member, ProtobufCBuffer *buffer)
{
	size_t rv;
	uint8_t scratch[MAX_UINT64_ENCODED_SIZE * 2];

	rv = tag_pack(field->id, scratch);
	switch (field->type) {
	case PROTOBUF_C_TYPE_SINT32:
		scratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
		rv += sint32_pack(*(const int32_t *) member, scratch + rv);
		buffer->append(buffer, rv, scratch);
		break;
	case PROTOBUF_C_TYPE_ENUM:
	case PROTOBUF_C_TYPE_INT32:
		scratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
		rv += int32_pack(*(const int32_t *) member, scratch + rv);
		buffer->append(buffer, rv, scratch);
		break;
	case PROTOBUF_C_TYPE_UINT32:
		scratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
		rv += uint32_pack(*(const uint32_t *) member, scratch + rv);
		buffer->append(buffer, rv, scratch);
		break;
	case PROTOBUF_C_TYPE_SINT64:
		scratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
		rv += sint64_pack(*(const int64_t *) member, scratch + rv);
		buffer->append(buffer, rv, scratch);
		break;
	case PROTOBUF_C_TYPE_INT64:
	case PROTOBUF_C_TYPE_UINT64:
		scratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
		rv += uint64_pack(*(const uint64_t *) member, scratch + rv);
		buffer->append(buffer, rv, scratch);
		break;
	case PROTOBUF_C_TYPE_SFIXED32:
	case PROTOBUF_C_TYPE_FIXED32:
	case PROTOBUF_C_TYPE_FLOAT:
		scratch[0] |= PROTOBUF_C_WIRE_TYPE_32BIT;
		rv += fixed32_pack(*(const uint32_t *) member, scratch + rv);
		buffer->append(buffer, rv, scratch);
		break;
	case PROTOBUF_C_TYPE_SFIXED64:
	case PROTOBUF_C_TYPE_FIXED64:
	case PROTOBUF_C_TYPE_DOUBLE:
		scratch[0] |= PROTOBUF_C_WIRE_TYPE_64BIT;
		rv += fixed64_pack(*(const uint64_t *) member, scratch + rv);
		buffer->append(buffer, rv, scratch);
		break;
	case PROTOBUF_C_TYPE_BOOL:
		scratch[0] |= PROTOBUF_C_WIRE_TYPE_VARINT;
		rv += boolean_pack(*(const protobuf_c_boolean *) member, scratch + rv);
		buffer->append(buffer, rv, scratch);
		break;
	case PROTOBUF_C_TYPE_STRING: {
		const char *str = *(char *const *) member;
		size_t sublen = str ? strlen(str) : 0;

		scratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
		rv += uint32_pack(sublen, scratch + rv);
		buffer->append(buffer, rv, scratch);
		buffer->append(buffer, sublen, (const uint8_t *) str);
		rv += sublen;
		break;
	}
	case PROTOBUF_C_TYPE_BYTES: {
		const ProtobufCBinaryData *bd = ((const ProtobufCBinaryData *) member);
		size_t sublen = bd->len;

		scratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
		rv += uint32_pack(sublen, scratch + rv);
		buffer->append(buffer, rv, scratch);
		buffer->append(buffer, sublen, bd->data);
		rv += sublen;
		break;
	}
	case PROTOBUF_C_TYPE_MESSAGE: {
		const ProtobufCMessage *msg = *(ProtobufCMessage * const *) member;
		
		scratch[0] |= PROTOBUF_C_WIRE_TYPE_LENGTH_PREFIXED;
		if (msg == NULL) {
			rv += uint32_pack(0, scratch + rv);
			buffer->append(buffer, rv, scratch);
		} else {
			size_t sublen = protobuf_c_message_get_packed_size(msg);
			rv += uint32_pack(sublen, scratch + rv);
			buffer->append(buffer, rv, scratch);
			protobuf_c_message_pack_to_buffer(msg, buffer);
			rv += sublen;
		}
		break;
	}
	default:
		PROTOBUF_C__ASSERT_NOT_REACHED();
	}
	return rv;
}
