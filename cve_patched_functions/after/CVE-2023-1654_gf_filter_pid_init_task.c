static void gf_filter_pid_init_task(GF_FSTask *task)
{
	u32 f_idx, count;
	Bool found_dest=GF_FALSE;
	Bool found_matching_sourceid;
	Bool can_reassign_filter = GF_FALSE;
	Bool can_try_link_resolution=GF_FALSE;
	Bool link_sinks_only = GF_FALSE;
	Bool implicit_link_found = GF_FALSE;
	u32 num_pass=0;
	GF_List *loaded_filters = NULL;
	GF_List *linked_dest_filters = NULL;
    GF_List *force_link_resolutions = NULL;
    GF_List *possible_linked_resolutions = NULL;
	GF_Filter *filter = task->filter;
	GF_FilterPid *pid = task->pid;
	GF_Filter *dynamic_filter_clone = NULL;
	Bool filter_found_but_pid_excluded = GF_FALSE;
	Bool possible_link_found_implicit_mode = GF_FALSE;
	u32 pid_is_file = 0;
	const char *filter_id;

	if (pid->destroyed || pid->removed) {
		assert(pid->init_task_pending);
		safe_int_dec(&pid->init_task_pending);
		return;
	}
	pid->props_changed_since_connect = GF_FALSE;

	//swap pid is pending on the possible destination filter
	if (filter->swap_pidinst_src || filter->swap_pidinst_dst) {
		task->requeue_request = GF_TRUE;
		task->can_swap = 1;
		return;
	}
	if (filter->caps_negociate) {
		if (! gf_filter_reconf_output(filter, pid))
			return;
	}

	gf_fs_check_graph_load(filter->session, GF_TRUE);

	if (filter->user_pid_props)
		gf_filter_pid_set_args(filter, pid);

	//explicit source, check if demux is forcd
	if (!pid->filter->dynamic_filter
		&& !pid->filter->num_input_pids
		&& (pid->filter->freg->flags & GF_FS_REG_FORCE_REMUX)
	) {
		const GF_PropertyValue *st = gf_filter_pid_get_property(pid, GF_PROP_PID_STREAM_TYPE);
		if (st && (st->value.uint==GF_STREAM_FILE))
			pid_is_file = 1;
	}

	//get filter ID:
	//this is a source - since we may have inserted filters in the middle (demuxers typically), get the last explicitly loaded ID in the chain
	if (filter->subsource_id) {
		filter_id = gf_filter_last_id_in_chain(filter, GF_FALSE);
		if (!filter_id && filter->cloned_from)
			filter_id = gf_filter_last_id_in_chain(filter->cloned_from, GF_FALSE);
	}
	//this is a sink or a mux - only use ID if defined on filter whether explicitly loaded or not ( some filters e.g. dasher,flist will self-assign an ID)
	else {
		//if clone use ID from clone otherwise linking will likely fail
		filter_id = filter->cloned_from ? filter->cloned_from->id : filter->id;
	}

	//we lock the instantiated filter list for the entire resolution process
	//we must unlock this mutex before calling lock on a filter mutex (->tasks_mx)
	//either directly or in functions calling it (e.g. gf_filter_in_parent_chain)
	//in case another thread is reconfiguring a filter fA:
	//- fA would have tasks_mx locked, and could be waiting for session->filters_mx to insert a new filter (inserting a filter chain)
	//- trying to lock fA->tasks_mx would then deadlock
	//cf issue 1799
	gf_mx_p(filter->session->filters_mx);

	linked_dest_filters = gf_list_new();
	force_link_resolutions = gf_list_new();
    possible_linked_resolutions = gf_list_new();

	GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s:%s init\n", pid->filter->name, pid->name));

	//we use at max 3 passes:
	//pass 1: try direct connections without loading intermediate filter chains. If PID gets connected, skip other passes
	//pass 2: try loading intermediate filter chains, but disable filter register swapping. If PID gets connected, skip last
	//pass 3: try loading intermediate filter chains, potentially swapping the source register
restart:

	if (num_pass) {

		//we're about to load filters to solve the link, use the already linked destination filters as list of loaded filters.
		//Not doing so may lead to loading several instances of the same filter for cases like:
		//-i encrypted aout vout
		//the first pid init (src->aout/vout) will load a demux, registering aout and vout as destination of demux
		//the second pid init (demux.Audio -> aout) will load cdcrypt, remove aout from demux destinations
		//the third pid init (demux.video) will
		//- match cdcrypt and link to it, but will not remove vout from demux destinations, resulting in further linking (this pass)
		//- create a new cdcrypt to solve demux.video -> vout
		
//		loaded_filters = gf_list_new();
		loaded_filters = gf_list_clone(linked_dest_filters);
	}

	found_matching_sourceid = GF_FALSE;

	//relock the filter list.
	//If the filter_dst we were checking is no longer present, rewind and go on
	//otherwise update its index (might be less if some filters were removed)
#define RELOCK_FILTER_LIST\
		gf_mx_p(filter->session->filters_mx); \
		count = gf_list_count(filter->session->filters); \
		f_dst_idx = gf_list_find(filter->session->filters, filter_dst); \
		if (f_dst_idx < 0) {\
			f_idx--;\
		} else {\
			f_idx = f_dst_idx;\
		}


	//try to connect pid to all running filters
	count = gf_list_count(filter->session->filters);
	for (f_idx=0; f_idx<count; f_idx++) {
		s32 f_dst_idx;
		Bool needs_clone;
		Bool cap_matched, in_parent_chain, is_sink;
		Bool ignore_source_ids;
		Bool use_explicit_link;
		GF_Filter *filter_dst;

single_retry:

		ignore_source_ids = GF_FALSE;
		use_explicit_link = GF_FALSE;
		filter_dst = gf_list_get(filter->session->filters, f_idx);
		//this can happen in multithreaded cases with filters being removed while we check for links
		if (!filter_dst)
			break;
		//source filter
		if (!filter_dst->freg->configure_pid) continue;
		if (filter_dst->finalized || filter_dst->removed || filter_dst->disabled || filter_dst->marked_for_removal || filter_dst->no_inputs) continue;
		if (filter_dst->target_filter == pid->filter) continue;

		//handle re-entrant filter registries (eg filter foo of type A output usually cannot connect to filter bar of type A)
		if (pid->pid->filter->freg == filter_dst->freg) {
			//only allowed for:
			if (
				// explicitly loaded filters
				filter->dynamic_filter
				//if cyclic explictly allowed by filter registry or if script or custom filter
				|| !(filter_dst->freg->flags & (GF_FS_REG_ALLOW_CYCLIC|GF_FS_REG_SCRIPT|GF_FS_REG_CUSTOM))
			) {
				continue;
			}
		}

		is_sink = GF_FALSE;
		if (filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE) {
			if (filter_dst->dynamic_filter) {
				if (!filter_dst->subsource_id) {
					is_sink = GF_TRUE;
				}
			} else if (filter_dst->forced_caps) {
				is_sink = !gf_filter_has_out_caps(filter_dst->forced_caps, filter_dst->nb_forced_caps);
			} else {
				is_sink = !gf_filter_has_out_caps(filter_dst->freg->caps, filter_dst->freg->nb_caps);
			}
		}

		//we linked to a sink in implicit mode and new filter is not a sink, continue
		if (link_sinks_only && !is_sink) continue;
		//we linked to a non-sink filter in implicit mode and the destination has no sourceID, continue
		if (implicit_link_found && !filter_dst->source_ids) {
			//destination not a sink, do not connect
			if (!is_sink) continue;
			//destination is a sink, do not connect if destination is not already registered as target for our filter
			//we need to check this for case such as
			//rtpin(avc) -> avc
			//           -> ts
			//which will invoke the AVC unframer/rewriter (ufnalu) only once and then try to link it to both TS mux and fout
			if ((gf_list_find(filter->destination_filters, filter_dst)<0)
				&& (gf_list_find(filter->destination_links, filter_dst)<0)
			) {
				continue;
			}
		}

		//check we are not already connected to this filter - we need this in case destination links/filters lists are reset
		if (pid->num_destinations) {
			u32 j;
			Bool already_linked = GF_FALSE;
			for (j=0; j<pid->num_destinations; j++) {
				GF_FilterPidInst *pidi = gf_list_get(pid->destinations, j);
				if (pidi->filter == filter_dst) {
					already_linked=GF_TRUE;
					break;
				}
			}
			if (already_linked) continue;
		}

		//we already linked to this one
		if (gf_list_find(linked_dest_filters, filter_dst)>=0) {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s already linked to filter %s\n", pid->name, filter_dst->name));
			continue;
		}
		if (gf_list_count(pid->filter->destination_filters)) {
			s32 ours = gf_list_find(pid->filter->destination_filters, filter_dst);
			if (ours<0) {
				ours = num_pass ? gf_list_del_item(pid->filter->destination_links, filter_dst) : -1;
				if (!filter_dst->source_ids && (ours<0)) {
					GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s has destination filters, filter %s not one of them\n", pid->name, filter_dst->name));
					continue;
				}

				pid->filter->dst_filter = NULL;
			} else {
				filter_dst->in_link_resolution = 0;
				pid->filter->dst_filter = filter_dst;
				//for mux->output case, the filter ID may be NULL but we still want to link
				if (!num_pass && !filter->subsource_id)
					ignore_source_ids = GF_TRUE;
			}
		}

		if (num_pass && gf_list_count(filter->destination_links)) {
			s32 ours = gf_list_find(pid->filter->destination_links, filter_dst);
			if (ours<0) {
				ours = gf_list_find(possible_linked_resolutions, filter_dst);
				if (ours<0) {
					ours = gf_list_find(force_link_resolutions, filter_dst);
				}
				if (ours<0) {
					GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s has destination links, filter %s not one of them\n", pid->name, filter_dst->name));
					continue;
				}
			}
			pid->filter->dst_filter = NULL;
		}
		//we must unlock the filters list at this point, otherwise we may end up in deadlock when checking gf_filter_in_parent_chain
		gf_mx_v(filter->session->filters_mx);
		gf_mx_p(filter_dst->tasks_mx);
		if (gf_list_count(filter_dst->source_filters)) {
			u32 j, count2 = gf_list_count(filter_dst->source_filters);
			for (j=0; j<count2; j++) {
				Bool in_par;
				GF_Filter *srcf = gf_list_get(filter_dst->source_filters, j);
				gf_mx_v(filter_dst->tasks_mx);
				in_par = gf_filter_in_parent_chain(pid->filter, srcf);
				gf_mx_p(filter_dst->tasks_mx);
				if (in_par) {
					ignore_source_ids = GF_TRUE;
					break;
				}
			}
		}
		gf_mx_v(filter_dst->tasks_mx);
		RELOCK_FILTER_LIST

		//if destination accepts only one input and connected or connection pending
		//note that if destination uses dynamic clone through source ids, we need to check this filter
		if (!filter_dst->max_extra_pids
		 	&& !filter_dst->dynamic_source_ids
			&& (filter_dst->num_input_pids || filter_dst->in_pid_connection_pending || filter_dst->in_link_resolution)
		 	&& (!filter->swap_pidinst_dst || (filter->swap_pidinst_dst->filter != filter_dst))
		) {
			if ((filter_dst->clonable==GF_FILTER_CLONE_PROBE)
				&& !(filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE)
				&& !filter->source_ids
			)
				filter_dst->clonable = GF_FILTER_NO_CLONE;

			//not explicitly clonable, don't connect to it
			if (filter_dst->clonable==GF_FILTER_NO_CLONE) {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Filter %s not clonable\n", filter_dst->name));
				continue;
			}

			//explicitly clonable but caps don't match, don't connect to it
			if (!gf_filter_pid_caps_match(pid, filter_dst->freg, filter_dst, NULL, NULL, pid->filter->dst_filter, -1)) {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s caps does not match clonable filter %s\n", pid->name, filter_dst->name));
				continue;
			}
		}

		if (gf_list_find(pid->filter->blacklisted, (void *) filter_dst->freg)>=0) continue;

		//we try to load a filter chain, so don't test against filters loaded for another chain
		if (filter_dst->dynamic_filter && (filter_dst != pid->filter->dst_filter)) {
			//dst was explicitly set and does not match
			if (pid->filter->dst_filter) {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s has explicit dest %s not %s\n", pid->name, pid->filter->dst_filter->name, filter_dst->name));
				continue;
			}
			//dst was not set, we may try to connect to this filter if it allows several input
			//this is typically the case for muxers instantiated dynamically
			if (!filter_dst->max_extra_pids) {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s has explicit dest %s (%p) matching but no extra pid possible\n", pid->name, filter_dst->name, filter_dst));
				continue;
			}
		}
		//pid->filter->dst_filter NULL and pid->filter->target_filter is not: we had a wrong resolved chain to target
		//so only attempt to relink the chain if dst_filter is the expected target
		if (!pid->filter->dst_filter && pid->filter->target_filter && (filter_dst != pid->filter->target_filter)) {
			if (filter_dst->target_filter != pid->filter->target_filter) {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s has target filter %s not matching %s->%s\n", pid->name, pid->filter->target_filter->name, filter_dst->name, filter_dst->target_filter ? filter_dst->target_filter->name : "null"));
				continue;
			}
			//if the target filter of this filter is the same as ours, try to connect - typically scalable streams decoding
		}

		//dynamic filters only connect to their destination, unless explicit connections through sources
		//we could remove this but this highly complicates PID resolution
		if (!filter_dst->source_ids && pid->filter->dynamic_filter && pid->filter->dst_filter && (filter_dst!=pid->filter->dst_filter)) {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s has dest filter %s not matching %s\n", pid->name, pid->filter->dst_filter->name, filter_dst->name));
			continue;
		}
		//walk up through the parent graph and check if this filter is already in. If so don't connect
		//since we don't allow re-entrant PIDs
		//we must unlock the filters list at this point, otherwise we may end up in deadlock when checking gf_filter_in_parent_chain
		gf_mx_v(filter->session->filters_mx);
		in_parent_chain = gf_filter_in_parent_chain(filter, filter_dst);

		RELOCK_FILTER_LIST

		if (in_parent_chain) {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s has filter %s in its parent chain\n", pid->name, filter_dst->name));
			continue;
		}

		//do not create cyclic graphs due to link resolution (dynamic filters)
		//look in all registered input PIDs of filter_dst and check if the current PID being linked has one of these pid in its source chain.
		//If so, do not link. this solves:
		//      fin:ID1 [-> dmx] (PID1) -> dynf1 (PID2) -> dst1:SID=1
		//                              -> dynf2 (PID3) -> dst2:SID=1
		//In this case, PID2 will inherit ID1 and could be accepted a source of dynf2 which already has PID1 registered
		//by walking up PID2 parent chain we check that PID1 will not be linked twice to the same filter
		//
		//We stop inspecting at the first filter with ID in the source
		if (filter->dynamic_filter)  {
			Bool cyclic_detected = GF_FALSE;
			u32 k;
			gf_mx_p(filter_dst->tasks_mx);
			//check filters pending a configure on filter_dst
			for (k=0; k<gf_list_count(filter_dst->temp_input_pids); k++) {
				GF_FilterPid *a_src_pid = gf_list_get(filter_dst->temp_input_pids, k);
				if (a_src_pid == pid) continue;
				if (gf_pid_in_parent_chain(pid, a_src_pid))
					cyclic_detected = GF_TRUE;
			}
			gf_mx_v(filter_dst->tasks_mx);

			//we must unlock the filters list at this point, otherwise we may end up in deadlock when checking gf_filter_in_parent_chain
			gf_mx_v(filter->session->filters_mx);
			gf_mx_p(filter_dst->tasks_mx);
			//check filters already connected on filter_dst
			for (k=0; k<filter_dst->num_input_pids && !cyclic_detected; k++) {
				GF_FilterPidInst *pidi = gf_list_get(filter_dst->input_pids, k);
				if (pidi->pid == pid) continue;
				if (gf_pid_in_parent_chain(pid, pidi->pid))
					cyclic_detected = GF_TRUE;
			}
			gf_mx_v(filter_dst->tasks_mx);

			RELOCK_FILTER_LIST

			if (cyclic_detected) {
				GF_LOG(GF_LOG_INFO, GF_LOG_FILTER, ("PID %s:%s has one or more PID in input chain already connected to filter %s, breaking cycle\n", pid->name, pid->filter->name, filter_dst->name));
				gf_list_del_item(force_link_resolutions, filter_dst);
				for (k=0; k<gf_list_count(filter_dst->destination_links); k++) {
					GF_Filter *a_dst = gf_list_get(filter_dst->destination_links, k);
                   gf_list_del_item(force_link_resolutions, a_dst);
				}
				for (k=0; k<gf_list_count(filter_dst->destination_filters); k++) {
					GF_Filter *a_dst = gf_list_get(filter_dst->destination_filters, k);
                    gf_list_del_item(force_link_resolutions, a_dst);
				}
				continue;
			}
		}

		//if the original filter is in the parent chain of this PID's filter, don't connect (equivalent to re-entrant)
		if (filter_dst->cloned_from) {
			if (gf_filter_in_parent_chain(filter, filter_dst->cloned_from) ) {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s has the original of cloned filter %s in its parent chain\n", pid->name, filter_dst->name));
				continue;
			}
			if (gf_filter_in_parent_chain(filter_dst->cloned_from, filter) ) {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s has the original of cloned filter %s in its output filter chain\n", pid->name, filter_dst->name));
				continue;
			}
		}

		//if the filter is in the parent chain of this PID's original filter, don't connect (equivalent to re-entrant)
		if (filter->cloned_from) {
			if (gf_filter_in_parent_chain(filter->cloned_from, filter_dst) ) {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s filter is cloned and has filter %s in its clone parent chain\n", pid->name, filter_dst->name));
				continue;
			}
		}

		//if we have sourceID info on the destination, check them
		needs_clone=GF_FALSE;
		if (filter_id) {
			if (filter_dst->source_ids) {
				Bool pid_excluded=GF_FALSE;
				if (!filter_source_id_match(pid, filter_id, filter_dst, &pid_excluded, &needs_clone)) {
					Bool not_ours=GF_TRUE;
					//if filter is a dynamic one with an ID set, fetch ID from previous filter in chain
					//this is need for cases such as "-i source filterFoo @ -o live.mpd":
					//the dasher filter will be dynamically loaded AND will also assign itself a filter ID
					//due to internal filter (dasher) logic
					//that dasher filter ID will be different from the ID assigned by '@' on dst file's sourceID,
					//which is the filter ID of filterFoo
					if (filter->dynamic_filter && filter->id) {
						const char *src_filter_id = gf_filter_last_id_in_chain(filter, GF_TRUE);
						if (filter_source_id_match(pid, src_filter_id, filter_dst, &pid_excluded, &needs_clone)) {
							not_ours = GF_FALSE;
						}
					}
					if (not_ours) {
						if (pid_excluded && !num_pass) filter_found_but_pid_excluded = GF_TRUE;

						GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s does not match source ID for filter %s\n", pid->name, filter_dst->name));
						continue;
					}
				}
				//if we are a dynamic filter linking to a destination filter without ID (no link directive) and
				//implicit mode is used, use implicit linking
				//otherwise force explicit linking
				//this avoids that dyn filters loaded for a link targeting an implicitly link filter link to a later filter:
				//avsource enc_v @ FX output
				//if enc_v loads a filter FA to connect to FX, we don't want FA->output
				if (!filter->dynamic_filter || filter_dst->id || !(filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE))
					use_explicit_link = GF_TRUE;
			}
			//if no source ID on the dst filter, this means the dst filter accepts any possible connections from out filter
			//unless prevented for this pid
			else if (pid->require_source_id) {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s requires source ID, not set for filter %s\n", pid->name, filter_dst->name));
				continue;
			}
		}
		//no filterID and dst expects only specific filters, continue
		else if (filter_dst->source_ids && !ignore_source_ids) {
			Bool pid_excluded=GF_FALSE;
			if ( (filter_dst->source_ids[0]!='*')
				&& (filter_dst->source_ids[0]!=filter->session->sep_frag)
				&& (filter_dst->source_ids[0]!=filter->session->sep_neg)
				) {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s does not match filter %s source ID\n", pid->name, filter_dst->name));
				continue;
			}
			if (!filter_source_id_match(pid, "*", filter_dst, &pid_excluded, &needs_clone)) {
				if (pid_excluded && !num_pass) filter_found_but_pid_excluded = GF_TRUE;
				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s is excluded by filter %s source ID\n", pid->name, filter_dst->name));
				continue;
			}
			use_explicit_link = GF_TRUE;
		}
		else if (filter->subsession_id != filter_dst->subsession_id) {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s and filter %s not in same subsession and no links directive\n", pid->name, filter_dst->name));
			continue;
		}
		//filters are in the same subsession and have a subsource_id (not part of chain-to-sink)
		//only link if same subsource_id
		else if (filter->subsource_id && filter_dst->subsource_id && (filter->subsource_id != filter_dst->subsource_id)) {
			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s and filter %s do not have same source and no links directive\n", pid->name, filter_dst->name));
			continue;
		}
		if (needs_clone) {
			//remember this filter as clonable (dynamic source id scheme) if none yet found.
			//If we had a matching sourceID, clone is not needed
			if (!num_pass && !dynamic_filter_clone && !found_matching_sourceid) {
				dynamic_filter_clone = filter_dst;
			}
			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s needs cloning of filter %s\n", pid->name, filter_dst->name));
			continue;
		} else if (dynamic_filter_clone && dynamic_filter_clone->freg==filter_dst->freg) {
			dynamic_filter_clone = NULL;
		}
		//remember we had a sourceid match
		found_matching_sourceid = GF_TRUE;

		//we have a match, check if caps are OK
		cap_matched = gf_filter_pid_caps_match(pid, filter_dst->freg, filter_dst, NULL, NULL, pid->filter->dst_filter, -1);

		//dst filter forces demuxing, pid is file and caps matched, do not test and do not activate link resolution
		//if can_try_link_resolution is still false at end of pass one, we will insert a reframer
		if (cap_matched && filter_dst->force_demux && pid_is_file) {
			if (pid_is_file==1)
				pid_is_file = 2;
			continue;
		}

		can_try_link_resolution = GF_TRUE;

		//this is the right destination filter. We however need to check if we don't have a possible destination link
		//whose destination is this destination (typically mux > fout/pipe/sock case). If that's the case, swap the destination
		//filter with the intermediate node before matching caps and resolving link
		if (num_pass) {
			u32 k, alt_count = gf_list_count(possible_linked_resolutions);
			for (k=0; k<alt_count; k++) {
				GF_Filter *adest = gf_list_get(possible_linked_resolutions, k);
				//we only apply this if the destination filter has the GF_FS_REG_DYNAMIC_REDIRECT flag set.
				//Not doing so could results in broken link resolution:
				//PID1(AVC) -> decoder1 -> compositor
				//PID2(PNG) -> decoder2 -> compositor
				//However this algo would force a connection of PID2 to decoder1 if decoder1 accepts multiple inputs, regardless of PID2 caps
				if (! (adest->freg->flags & GF_FS_REG_DYNAMIC_REDIRECT))
					continue;
				if ((gf_list_find(adest->destination_filters, filter_dst)>=0) || (gf_list_find(adest->destination_links, filter_dst)>=0) ) {
					filter_dst = adest;
					gf_list_rem(possible_linked_resolutions, k);
					break;
				}
			}
		}

		//if clonable filter and no match, check if we would match the caps without caps override of dest
		//note we don't do this on sources for the time being, since this might trigger undesired resolution of file->file
		if (!cap_matched && (filter_dst->clonable==GF_FILTER_CLONE) && pid->filter->num_input_pids) {
			cap_matched = gf_filter_pid_caps_match(pid, filter_dst->freg, NULL, NULL, NULL, pid->filter->dst_filter, -1);
		}

		if (!cap_matched) {
			Bool skipped = GF_FALSE;
			Bool reassigned=GF_FALSE;
			GF_Filter *new_f;

			//we don't load filter chains if we have a change of media type from anything except file to anything except file
			//i.e. transmodality (eg video->audio) can only be done through explicit filters
			if (gf_filter_pid_needs_explicit_resolution(pid, filter_dst)) {
				GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s needs explicit resolution for linking to filter %s\n", pid->name, filter_dst->name));
				continue;
			}

			//we had a destination set during link resolve, and we don't match that filter, consider the link resolution wrong
			if (pid->filter->dst_filter && (filter_dst == pid->filter->dst_filter)) {
				GF_Filter *old_dst = pid->filter->dst_filter;
				pid->filter->dst_filter = NULL;
				gf_list_del_item(pid->filter->destination_links, filter_dst);
				gf_list_del_item(pid->filter->destination_filters, filter_dst);
				//nobody using this filter, destroy
				if (old_dst->dynamic_filter
					&& !old_dst->has_pending_pids
					&& !old_dst->num_input_pids
					&& !old_dst->num_output_pids
					&& !old_dst->out_pid_connection_pending
				) {
					Bool skip = ((old_dst==filter_dst) && (filter_dst->dynamic_filter!=2)) ? GF_TRUE : GF_FALSE;
					gf_filter_post_remove(old_dst);
					if (skip)
						continue;
				}
			}
			if (!num_pass) {
                //we have an explicit link instruction so we must try dynamic link even if we connect to another filter
                //is_sink set, same thing (implicit mode only, force link to sink)
				if (filter_dst->source_ids || (is_sink && !implicit_link_found)) {
                    gf_list_add(force_link_resolutions, filter_dst);
                    //! filter is an alias, prevent linking to the filter being aliased
                    if (filter_dst->multi_sink_target) {
						gf_list_del_item(force_link_resolutions, filter_dst->multi_sink_target);
						gf_list_add(linked_dest_filters, filter_dst->multi_sink_target);
					}
				} else {
					//register as possible destination link. If a filter already registered is a destination of this possible link
					//only the possible link will be kept
					if (!possible_link_found_implicit_mode)
						add_possible_link_destination(possible_linked_resolutions, filter_dst);

					//implicit link mode: if possible destination is not a sink, stop checking for possible links
					//continue however first pass in case we have a direct match with a dynamic filter, eg:
					//tiled_input.mpd -> compositor -> ...
					//the first pid will resolve to dashin + tileagg
					//the second pid from dashin must link to tileagg, but if we stop the pass 0 loop
					//it would link to compositor with a new tileagg filter
					if (!use_explicit_link && (filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE) && !is_sink) {
						possible_link_found_implicit_mode = GF_TRUE;
					}
				}
				continue;
			}
			filter_found_but_pid_excluded = GF_FALSE;

			GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("Attempting to solve link between PID %s:%s and filter %s\n", pid->filter->freg->name, pid->name, filter_dst->name));

			if (num_pass==1) reassigned = GF_TRUE;
			else reassigned = GF_FALSE;

			//we pass the list of loaded filters for this pid, so that we don't instanciate twice the same chain start
			new_f = gf_filter_pid_resolve_link_check_loaded(pid, filter_dst, &reassigned, loaded_filters, &skipped);

			//try to load filters
			if (! new_f) {
				if (skipped) {
					continue;
				}
				if (pid->filter->session->run_status!=GF_OK) {
					GF_LOG(GF_LOG_DEBUG, GF_LOG_FILTER, ("PID %s:%s init canceled (session abort)\n", pid->filter->name, pid->name));
					gf_mx_v(filter->session->filters_mx);
					assert(pid->init_task_pending);
					safe_int_dec(&pid->init_task_pending);
					if (loaded_filters) gf_list_del(loaded_filters);
					gf_list_del(linked_dest_filters);
                    gf_list_del(force_link_resolutions);
                    gf_list_del(possible_linked_resolutions);
					return;
				}

				//filter was reassigned (pid is destroyed), return
				if (reassigned) {
					if (num_pass==1) {
						can_reassign_filter = GF_TRUE;
						continue;
					}
					gf_mx_v(filter->session->filters_mx);
					assert(pid->init_task_pending);
					safe_int_dec(&pid->init_task_pending);
					if (loaded_filters) gf_list_del(loaded_filters);
					gf_list_del(linked_dest_filters);
                    gf_list_del(force_link_resolutions);
                    gf_list_del(possible_linked_resolutions);
					return;
				}
				//we might had it wrong solving the chain initially, break the chain
				if (filter_dst->dynamic_filter && filter_dst->dst_filter) {
					GF_Filter *new_dst = filter_dst;
					while (new_dst->dst_filter && new_dst->dynamic_filter) {
						GF_Filter *f = new_dst;
						new_dst = new_dst->dst_filter;
						if (!f->num_input_pids && !f->num_output_pids && !f->in_pid_connection_pending) {
							gf_filter_post_remove(f);
						}
					}
					
					pid->filter->dst_filter = NULL;
					new_f = gf_filter_pid_resolve_link(pid, new_dst, &reassigned);
					if (!new_f) {
						if (reassigned) {
							gf_mx_v(filter->session->filters_mx);
							assert(pid->init_task_pending);
							safe_int_dec(&pid->init_task_pending);
							if (loaded_filters) gf_list_del(loaded_filters);
							gf_list_del(linked_dest_filters);
                            gf_list_del(force_link_resolutions);
                            gf_list_del(possible_linked_resolutions);
							return;
						} else {
							continue;
						}
					}
					//good to go !
				} else {
					continue;
				}
			}

			//in implicit link, if target is not here push it (we have no SID/FID to solve that later)
			if ((filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE)
				&& !gf_list_count(new_f->destination_filters)
				&& !gf_list_count(new_f->destination_links)
				&& !filter_dst->source_ids
			) {
				gf_list_add(new_f->destination_links, filter_dst);
			}

			//target was in clone probe but we have loaded a mux, disable clone
			if ((filter_dst->clonable==GF_FILTER_CLONE_PROBE) && new_f->max_extra_pids)
				filter_dst->clonable = GF_FILTER_NO_CLONE;

			gf_list_del_item(filter->destination_filters, filter_dst);
			if (gf_list_find(new_f->destination_filters, filter_dst)>=0) {
				if (filter_dst->clonable==GF_FILTER_NO_CLONE)
					filter_dst->in_link_resolution = GF_TRUE;
			}

			filter_dst = new_f;
			gf_list_add(loaded_filters, new_f);
		}

		if (!(filter_dst->freg->flags & (GF_FS_REG_ALLOW_CYCLIC|GF_FS_REG_SCRIPT|GF_FS_REG_CUSTOM))) {
			assert(pid->pid->filter->freg != filter_dst->freg);
		}

		safe_int_inc(&pid->filter->out_pid_connection_pending);
		gf_mx_p(filter_dst->tasks_mx);
		gf_list_add(filter_dst->temp_input_pids, pid);
		if (pid->filter != filter_dst->single_source)
			filter_dst->single_source = NULL;
		gf_mx_v(filter_dst->tasks_mx);
		gf_filter_pid_post_connect_task(filter_dst, pid);

		found_dest = GF_TRUE;
		gf_list_add(linked_dest_filters, filter_dst);

		gf_list_del_item(filter->destination_links, filter_dst);
		/*we are linking to a mux, check all destination filters registered with the muxer and remove them from our possible destination links*/
		if (filter_dst->max_extra_pids) {
			u32 k=0;
			for (k=0; k<gf_list_count(filter_dst->destination_filters); k++) {
				GF_Filter *dst_f = gf_list_get(filter_dst->destination_filters, k);
				gf_list_del_item(filter->destination_links, dst_f);
			}
		}

		//implicit link mode: if target was a sink, allow further sink connections, otherwise stop linking
		if (!use_explicit_link && (filter->session->flags & GF_FS_FLAG_IMPLICIT_MODE)) {
			if (is_sink)
				link_sinks_only = GF_TRUE;
			else if (!implicit_link_found) {
				u32 k=0;
				for (k=0; k<gf_list_count(force_link_resolutions); k++) {
					GF_Filter *dst_f = gf_list_get(force_link_resolutions, k);
					if (!dst_f->source_ids) {
						gf_list_rem(force_link_resolutions, k);
						k--;
					}
				}
				implicit_link_found = GF_TRUE;
			}
		}
    }

	if (!num_pass) {
		u32 i, k;
		gf_mx_v(filter->session->filters_mx);
		//cleanup forced filter list:
		//remove any forced filter which is a destination of a filter we already linked to
		for (i=0; i< gf_list_count(linked_dest_filters); i++) {
			GF_Filter *filter_dst = gf_list_get(linked_dest_filters, i);
			for (k=0; k<gf_list_count(force_link_resolutions); k++) {
				GF_Filter *dst_link = gf_list_get(force_link_resolutions, k);
				if (//if forced filter is in parent chain (already connected filters), don't force a link
					gf_filter_in_parent_chain(filter_dst, dst_link)
					|| gf_filter_in_parent_chain(dst_link, filter_dst)
					//if forced filter is in destination of filter (connection pending), don't force a link
					//we need to walk up the destination chain, not just check the first level since the filter_dst might be connected
					//and no longer have dst_link in its destination filter list
					//typical case is multithreaded mode with mux or tileagg filter
					|| filter_match_target_dst(filter_dst->destination_filters, dst_link)
					|| filter_match_target_dst(filter_dst->destination_links, dst_link)
					//if forced filter's target is the same as what we connected to, don't force a link
					|| (dst_link->target_filter == filter_dst)
				) {
					gf_list_rem(force_link_resolutions, k);
					k--;
				}
			}
		}

		//cleanup forced link resolution list: remove any forced filter which is a destination of another forced filter
		//this is needed when multiple pids link to a single dynamically loaded mux, where we could end up
		//with both the  destination link and the mux (in this order) in this list, creating a new mux if the destination has a pending link
		for (i=0; i<gf_list_count(force_link_resolutions); i++) {
			GF_Filter *forced_dst = gf_list_get(force_link_resolutions, i);
			for (k=i+1; k<gf_list_count(force_link_resolutions); k++) {
				GF_Filter *forced_inserted = gf_list_get(force_link_resolutions, k);

				if (gf_filter_in_parent_chain(forced_inserted, forced_dst)
					|| filter_match_target_dst(forced_inserted->destination_filters, forced_dst)
					|| filter_match_target_dst(forced_inserted->destination_links, forced_dst)
				) {
					gf_list_rem(force_link_resolutions, i);
					//prevent linking to this filter
					gf_list_add(linked_dest_filters, forced_dst);
					i--;
					break;
				}
			}
		}
		gf_mx_p(filter->session->filters_mx);
	}

	if (loaded_filters) {
		gf_list_del(loaded_filters);
		loaded_filters = NULL;
	}

	//we still have possible destination links and we can try link resolution, do it
	if (!num_pass && gf_list_count(filter->destination_links) && can_try_link_resolution && filter->session->max_resolve_chain_len) {
		num_pass = 1;
		goto restart;
	}
    //we must do the second pass if a filter has an explicit link set through source ID
	if (!num_pass && gf_list_count(force_link_resolutions)) {
		num_pass = 1;
		goto restart;
	}

    //connection task posted, nothing left to do
	if (found_dest) {
		assert(pid->init_task_pending);
		safe_int_dec(&pid->init_task_pending);
		gf_mx_v(filter->session->filters_mx);
		pid->filter->disabled = GF_FILTER_ENABLED;
		gf_list_del(linked_dest_filters);
        gf_list_del(force_link_resolutions);
        gf_list_del(possible_linked_resolutions);
		gf_fs_check_graph_load(filter->session, GF_FALSE);
		if (pid->not_connected) {
			pid->not_connected = 0;
			assert(pid->filter->num_out_pids_not_connected);
			pid->filter->num_out_pids_not_connected--;
		}
		return;
	}

	//on first pass, if we found a clone (eg a filter using freg:#PropName=*), instantiate this clone and redo the pid linking to this clone (last entry in the filter list)
	if (dynamic_filter_clone && !num_pass) {
		GF_Filter *clone = gf_filter_clone(dynamic_filter_clone, NULL);
		if (clone) {
			assert(dynamic_filter_clone->dynamic_source_ids);
			gf_free(clone->source_ids);
			clone->source_ids = gf_strdup(dynamic_filter_clone->dynamic_source_ids);
			clone->cloned_from = NULL;
			count = gf_list_count(filter->session->filters);
			gf_list_add(pid->filter->destination_links, clone);
			f_idx = count-1;
			num_pass = 1;
			goto single_retry;
		}
	}

	//nothing found at first pass and demuxed forced, inject a reframer filter
	if (!num_pass && !can_try_link_resolution && (pid_is_file==2)) {
		GF_Err e;
		GF_Filter *f = gf_fs_load_filter(filter->session, "reframer", &e);
		if (!e) {
			GF_LOG(GF_LOG_INFO, GF_LOG_FILTER, ("Local file PID %s to local file detected, forcing remux\n", pid->name));
			f->dynamic_filter = 2;
			f->subsession_id = pid->filter->subsession_id;
			f->subsource_id = pid->filter->subsource_id;
			//force pid's filter destination to the reframer - this will in pass #2:
			//- force solving file->reframer, loading the demuxer
			//- since caps between pid and reframer don't match and reframer is not used by anyone, the reframer will be removed
			//We end up with a demuxed source with no intermediate reframer filter :)
			pid->filter->dst_filter = f;
			num_pass = 1;
			goto restart;
		}
	}

	//nothing found, redo a pass, this time allowing for link resolve
	if (!num_pass && can_try_link_resolution && filter->session->max_resolve_chain_len) {
		num_pass = 1;
		goto restart;
	}
	if ((num_pass==1) && can_reassign_filter) {
		if (filter->session->flags & GF_FS_FLAG_NO_REASSIGN) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, ("PID %s in filter %s not connected, source reassignment was possible but is disabled\n", pid->name, pid->filter->name));
		} else {
			num_pass = 2;
			GF_LOG(GF_LOG_INFO, GF_LOG_FILTER, ("PID %s in filter %s not connected to any loaded filter, trying source reassignment\n", pid->name, pid->filter->name));
			goto restart;
		}
	}

	gf_fs_check_graph_load(filter->session, GF_FALSE);

	gf_list_del(linked_dest_filters);
    gf_list_del(force_link_resolutions);
    gf_list_del(possible_linked_resolutions);
	gf_mx_v(filter->session->filters_mx);

	if (pid->num_destinations && !pid->not_connected) {
		assert(pid->init_task_pending);
		safe_int_dec(&pid->init_task_pending);
		return;
	}
	filter->num_out_pids_not_connected ++;
	//remove sparse info
	if (pid->is_sparse) {
		assert(filter->nb_sparse_pids);
		safe_int_dec(&filter->nb_sparse_pids);
		pid->is_sparse = 0;
	}

	GF_FilterEvent evt;
	if (filter_found_but_pid_excluded) {
		//PID was not included in explicit connection lists
		GF_LOG(GF_LOG_INFO, GF_LOG_FILTER, ("PID %s in filter %s not connected to any loaded filter due to source directives\n", pid->name, pid->filter->name));
		pid->not_connected = 1;
	} else {
		//no filter found for this pid !
		if (!pid->not_connected_ok && (filter->session->flags & GF_FS_FLAG_FULL_LINK) ) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, ("No filter chain found for PID %s in filter %s to any loaded filters - ABORTING!\n", pid->name, pid->filter->name));
			filter->session->last_connect_error = GF_FILTER_NOT_FOUND;
			filter->session->run_status = GF_FILTER_NOT_FOUND;
			filter->session->in_final_flush = GF_TRUE;
			assert(pid->init_task_pending);
			safe_int_dec(&pid->init_task_pending);
			return;
		}

		GF_LOG(pid->not_connected_ok ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_FILTER, ("No filter chain found for PID %s in filter %s to any loaded filters - NOT CONNECTED\n", pid->name, pid->filter->name));

		if (pid->filter->freg->process_event) {
			GF_FEVT_INIT(evt, GF_FEVT_CONNECT_FAIL, pid);
			pid->filter->freg->process_event(filter, &evt);
		}
		pid->not_connected = 1;
	}
	GF_FEVT_INIT(evt, GF_FEVT_PLAY, pid);
	evt.play.initial_broadcast_play = 2;
	gf_filter_pid_send_event_internal(pid, &evt, GF_TRUE);

	GF_FEVT_INIT(evt, GF_FEVT_STOP, pid);
	evt.play.initial_broadcast_play = 2;
	gf_filter_pid_send_event_internal(pid, &evt, GF_TRUE);

	gf_filter_pid_set_eos(pid);
	if (!pid->not_connected_ok
		&& !parent_chain_has_dyn_pids(pid->filter)
		&& (pid->filter->num_out_pids_not_connected == pid->filter->num_output_pids)
	) {
		pid->filter->disabled = GF_FILTER_DISABLED;

		if (can_reassign_filter) {
			gf_filter_setup_failure(pid->filter, GF_FILTER_NOT_FOUND);
		}
	}

	if (!filter_found_but_pid_excluded && !pid->not_connected_ok && !filter->session->max_resolve_chain_len) {
		filter->session->last_connect_error = GF_FILTER_NOT_FOUND;
	}

	assert(pid->init_task_pending);
	safe_int_dec(&pid->init_task_pending);
	return;
}
