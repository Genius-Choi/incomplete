static intptr_t fio_tcp_socket(const char *address, const char *port,
                               uint8_t server) {
  /* TCP/IP socket */
  // setup the address
  struct addrinfo hints = {0};
  struct addrinfo *addrinfo;       // will point to the results
  memset(&hints, 0, sizeof hints); // make sure the struct is empty
  hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6
  hints.ai_socktype = SOCK_STREAM; // TCP stream sockets
  hints.ai_flags = AI_PASSIVE;     // fill in my IP for me
  if (getaddrinfo(address, port, &hints, &addrinfo)) {
    // perror("addr err");
    return -1;
  }
  // get the file descriptor
  int fd =
      socket(addrinfo->ai_family, addrinfo->ai_socktype, addrinfo->ai_protocol);
  if (fd <= 0) {
    freeaddrinfo(addrinfo);
    return -1;
  }
  // make sure the socket is non-blocking
  if (fio_set_non_block(fd) < 0) {
    freeaddrinfo(addrinfo);
    close(fd);
    return -1;
  }
  if (server) {
    {
      // avoid the "address taken"
      int optval = 1;
      setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));
    }
    // bind the address to the socket
    int bound = 0;
    for (struct addrinfo *i = addrinfo; i != NULL; i = i->ai_next) {
      if (!bind(fd, i->ai_addr, i->ai_addrlen))
        bound = 1;
    }
    if (!bound) {
      // perror("bind err");
      freeaddrinfo(addrinfo);
      close(fd);
      return -1;
    }
#ifdef TCP_FASTOPEN
    {
      // support TCP Fast Open when available
      int optval = 128;
      setsockopt(fd, addrinfo->ai_protocol, TCP_FASTOPEN, &optval,
                 sizeof(optval));
    }
#endif
    if (listen(fd, SOMAXCONN) < 0) {
      freeaddrinfo(addrinfo);
      close(fd);
      return -1;
    }
  } else {
    int one = 1;
    setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &one, sizeof(one));
    errno = 0;
    for (struct addrinfo *i = addrinfo; i; i = i->ai_next) {
      if (connect(fd, i->ai_addr, i->ai_addrlen) == 0 || errno == EINPROGRESS)
        goto socket_okay;
    }
    freeaddrinfo(addrinfo);
    close(fd);
    return -1;
  }
socket_okay:
  fio_lock(&fd_data(fd).protocol_lock);
  fio_clear_fd(fd, 1);
  fio_unlock(&fd_data(fd).protocol_lock);
  fio_tcp_addr_cpy(fd, addrinfo->ai_family, (void *)addrinfo);
  freeaddrinfo(addrinfo);
  return fd2uuid(fd);
}
