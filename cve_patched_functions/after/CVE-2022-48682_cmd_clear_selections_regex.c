int cmd_clear_selections_regex(struct filegroup *groups, int groupcount, wchar_t *commandarguments, struct status_text *status)
{
  size_t size;
  wchar_t *wcsfilename;
  size_t needed;
  int errorcode;
  PCRE2_SIZE erroroffset;
  pcre2_code *code;
  pcre2_match_data *md;
  int matches;
  int g;
  int f;
  int matchedgroupcount = 0;
  int matchedfilecount = 0;
  int groupmatched;
  int filedeselected;
  int selectionsremaining;

  code = pcre2_compile((PCRE2_SPTR)commandarguments, PCRE2_ZERO_TERMINATED, PCRE2_UTF | PCRE2_UCP, &errorcode, &erroroffset, 0);

  if (code == 0)
    return -1;

  pcre2_jit_compile(code, PCRE2_JIT_COMPLETE);

  md = pcre2_match_data_create(1, 0);
  if (md == 0)
    return -1;

  for (g = 0; g < groupcount; ++g)
  {
    groupmatched = 0;
    filedeselected = 0;
    selectionsremaining = 0;

    for (f = 0; f < groups[g].filecount; ++f)
    {
      needed = mbstowcs_escape_invalid(0, groups[g].files[f].file->d_name, 0);

      wcsfilename = (wchar_t*) malloc(needed * sizeof(wchar_t));
      if (wcsfilename == 0)
        continue;

      mbstowcs_escape_invalid(wcsfilename, groups[g].files[f].file->d_name, needed);

      matches = pcre2_match(code, (PCRE2_SPTR)wcsfilename, PCRE2_ZERO_TERMINATED, 0, 0, md, 0);

      free(wcsfilename);

      if (matches > 0)
      {
        if (groups[g].files[f].selected)
        {
          groups[g].files[f].selected = 0;
          filedeselected = 1;
        }

        groupmatched = 1;
        ++matchedfilecount;
      }

      if (groups[g].files[f].selected)
        selectionsremaining = 1;
    }

    if (filedeselected && !selectionsremaining)
      groups[g].selected = 0;

    if (groupmatched)
      ++matchedgroupcount;
  }

  format_status_left(status, L"Matched %d files in %d groups.", matchedfilecount, matchedgroupcount);

  pcre2_code_free(code);

  return 1;
}
