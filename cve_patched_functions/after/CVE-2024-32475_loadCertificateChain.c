void TlsContext::loadCertificateChain(const std::string& data, const std::string& data_path) {
  cert_chain_file_path_ = data_path;
  bssl::UniquePtr<BIO> bio(BIO_new_mem_buf(const_cast<char*>(data.data()), data.size()));
  RELEASE_ASSERT(bio != nullptr, "");
  cert_chain_.reset(PEM_read_bio_X509_AUX(bio.get(), nullptr, nullptr, nullptr));
  if (cert_chain_ == nullptr || !SSL_CTX_use_certificate(ssl_ctx_.get(), cert_chain_.get())) {
    logSslErrorChain();
    throwEnvoyExceptionOrPanic(
        absl::StrCat("Failed to load certificate chain from ", cert_chain_file_path_));
  }
  // Read rest of the certificate chain.
  while (true) {
    bssl::UniquePtr<X509> cert(PEM_read_bio_X509(bio.get(), nullptr, nullptr, nullptr));
    if (cert == nullptr) {
      break;
    }
    if (!SSL_CTX_add_extra_chain_cert(ssl_ctx_.get(), cert.get())) {
      throwEnvoyExceptionOrPanic(
          absl::StrCat("Failed to load certificate chain from ", cert_chain_file_path_));
    }
    // SSL_CTX_add_extra_chain_cert() takes ownership.
    cert.release();
  }
  // Check for EOF.
  const uint32_t err = ERR_peek_last_error();
  if (ERR_GET_LIB(err) == ERR_LIB_PEM && ERR_GET_REASON(err) == PEM_R_NO_START_LINE) {
    ERR_clear_error();
  } else {
    throwEnvoyExceptionOrPanic(
        absl::StrCat("Failed to load certificate chain from ", cert_chain_file_path_));
  }
}
