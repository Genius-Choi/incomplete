run_scheduler(stats *sptr, statement *stmts, uint concur, ulonglong limit)
{
  uint x;
  struct timeval start_time, end_time;
  thread_context con;
  pthread_t mainthread;            /* Thread descriptor */
  pthread_attr_t attr;          /* Thread attributes */
  DBUG_ENTER("run_scheduler");

  con.stmt= stmts;
  con.limit= limit;

  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr,
		  PTHREAD_CREATE_DETACHED);

  pthread_mutex_lock(&counter_mutex);
  thread_counter= 0;

  pthread_mutex_lock(&sleeper_mutex);
  master_wakeup= 1;
  pthread_mutex_unlock(&sleeper_mutex);
  for (x= 0; x < concur; x++)
  {
    /* now you create the thread */
    if (pthread_create(&mainthread, &attr, run_task, 
                       (void *)&con) != 0)
    {
      fprintf(stderr,"%s: Could not create thread\n",
              my_progname);
      exit(0);
    }
    thread_counter++;
  }
  pthread_mutex_unlock(&counter_mutex);
  pthread_attr_destroy(&attr);

  pthread_mutex_lock(&sleeper_mutex);
  master_wakeup= 0;
  pthread_mutex_unlock(&sleeper_mutex);
  pthread_cond_broadcast(&sleep_threshhold);

  gettimeofday(&start_time, NULL);

  /*
    We loop until we know that all children have cleaned up.
  */
  pthread_mutex_lock(&counter_mutex);
  while (thread_counter)
  {
    struct timespec abstime;

    set_timespec(abstime, 3);
    pthread_cond_timedwait(&count_threshhold, &counter_mutex, &abstime);
  }
  pthread_mutex_unlock(&counter_mutex);

  gettimeofday(&end_time, NULL);


  sptr->timing= timedif(end_time, start_time);
  sptr->users= concur;
  sptr->rows= limit;

  DBUG_RETURN(0);
}
