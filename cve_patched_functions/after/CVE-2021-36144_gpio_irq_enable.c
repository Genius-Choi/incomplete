gpio_irq_enable(struct virtio_gpio *gpio, unsigned int pin,
		uint64_t mode)
{
	struct gpioevent_request req;
	struct gpio_line *line;
	struct gpio_irq_chip *chip;
	struct gpio_irq_desc *desc;
	int err;

	chip = &gpio->irq_chip;
	desc = &chip->descs[pin];
	line = desc->gpio;
	DPRINTF(("enable IRQ pin %d, mode %lu <-> chip %s, GPIO %d\n",
		pin, mode, desc->gpio->chip->dev_name, desc->gpio->offset));

	/*
	 * Front-end should set the gpio direction to input before
	 * enable one gpio to irq, so get the gpio value directly
	 * no need to set it to input direction.
	 */
	desc->level = gpio_get_value(gpio, pin);

	/* Release the GPIO line before enable it for IRQ */
	native_gpio_close_line(line);

	memset(&req, 0, sizeof(req));
	if (mode & IRQ_TYPE_EDGE_RISING)
		req.eventflags |= GPIOEVENT_REQUEST_RISING_EDGE;
	if (mode & IRQ_TYPE_EDGE_FALLING)
		req.eventflags |= GPIOEVENT_REQUEST_FALLING_EDGE;

	/*
	 * For level tigger, detect rising and fallling edges to
	 * update the IRQ level value, the value is used to check
	 * the level IRQ is active.
	 */
	if (mode & IRQ_TYPE_LEVEL_MASK)
		req.eventflags |= GPIOEVENT_REQUEST_BOTH_EDGES;
	if (!req.eventflags) {
		WPRINTF(("failed to enable pin %d to IRQ with invalid flags\n",
				pin));
		return;
	}

	desc->mode = mode;
	req.lineoffset = line->offset;
	strncpy(req.consumer_label, "acrn_dm_irq",
			sizeof(req.consumer_label) - 1);
	err = ioctl(line->chip->fd, GPIO_GET_LINEEVENT_IOCTL, &req);
	if (err < 0) {
		WPRINTF(("ioctl GPIO_GET_LINEEVENT_IOCTL error %s\n",
				strerror(errno)));
		goto error;
	}

	desc->fd = req.fd;
	desc->mevt = mevent_add(desc->fd, EVF_READ,
			gpio_irq_set_pin_state, desc,
			gpio_irq_teardown, desc);
	if (!desc->mevt) {
		WPRINTF(("failed to enable IRQ pin %d, mevent add error\n",
				pin));
		goto error;
	}

	return;
error:
	gpio_irq_disable(chip, pin);
}
