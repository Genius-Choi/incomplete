Status GraphDefImporter::ConvertFunctionDef(
    GraphFuncOp func_op,
    const absl::flat_hash_map<StringPiece, StringPiece> &gradient_map,
    const FunctionDef &function) {
  const OpDef &signature = function.signature();
  // TODO(jeffniu): Does the name need to be mangled?

  func_op.body().push_back(new Block);
  Block *body = &func_op.body().front();
  auto builder = OpBuilder::atBlockBegin(func_op.getBody());

  // Convert the attributes.
  NamedAttrList func_attrs;
  TF_RETURN_IF_ERROR(
      ConvertFunctionAttributes(gradient_map, function, func_op, func_attrs));

  SmallVector<Attribute> arg_attrs, res_attrs, control_ret_attrs;
  SmallVector<Type> arg_types, res_types;

  // Convert the arguments and argument attributes.
  for (auto &it : llvm::enumerate(signature.input_arg())) {
    Type dtype;
    TF_RETURN_IF_ERROR(ConvertDataType(it.value().type(), b_, &dtype));
    BlockArgument data =
        body->addArgument(UnrankedTensorType::get(dtype), unknown_loc_);
    BlockArgument ctl =
        body->addArgument(dialect_->getControlType(), data.getLoc());

    NamedAttrList attrs;
    TF_RETURN_IF_ERROR(ConvertArgumentAttributes(it.value(), attrs));
    auto attr_it = function.arg_attr().find(it.index());
    if (attr_it != function.arg_attr().end()) {
      for (const auto &name_attr : attr_it->second.attr()) {
        TF_ASSIGN_OR_RETURN(
            Attribute attr,
            ConvertAttributeValue(name_attr.second, b_, dialect_));
        attrs.append("tf." + name_attr.first, attr);
      }
    }

    arg_attrs.append({attrs.getDictionary(ctx_), b_.getDictionaryAttr({})});
    arg_types.append({data.getType(), ctl.getType()});
  }

  // Iterate over the arguments again and map them. We have to add them first
  // otherwise the ranges will be invalidated.
  ConversionState s(body, placeholder_state_);
  for (const auto &it : llvm::enumerate(signature.input_arg())) {
    s.emplace(
        it.value().name(),
        new ResultInfo{/*resolved=*/true, body->getArgument(it.index() * 2 + 1),
                       body->getArguments().slice(it.index() * 2, 1)});
  }
  TF_RETURN_IF_ERROR(ConvertNodes(builder, s, function.node_def(), body));

  // Convert the results and the result attributes.
  SmallVector<Value> return_operands;
  return_operands.reserve(signature.output_arg_size() +
                          signature.control_output_size());
  for (const OpDef::ArgDef &def : function.signature().output_arg()) {
    Type dtype;
    TF_RETURN_IF_ERROR(ConvertDataType(def.type(), b_, &dtype));
    NamedAttrList attrs;
    TF_RETURN_IF_ERROR(ConvertArgumentAttributes(def, attrs));
    res_attrs.push_back(attrs.getDictionary(ctx_));
    res_types.push_back(UnrankedTensorType::get(dtype));

    auto ret_it = function.ret().find(def.name());
    if (ret_it == function.ret().end()) {
      return InvalidArgument("Output '", def.name(),
                             "' was not found in 'ret'");
    }
    TF_ASSIGN_OR_RETURN(Result result, GetResult(s, ret_it->second));
    if (result.info)
      return InvalidArgument("Return '", ret_it->second, "' was not found");
    if (result.control)
      return InvalidArgument("Unexpected control result: ", ret_it->second);
    return_operands.push_back(result.data);
  }

  // Convert the control results.
  for (const std::string &control_ret : signature.control_output()) {
    auto ret_it = function.control_ret().find(control_ret);
    if (ret_it == function.control_ret().end()) {
      return InvalidArgument("Control output '", control_ret,
                             "' was not found in 'control_ret'");
    }
    std::unique_ptr<ResultInfo> &result = s[ret_it->second];
    if (!result || !result->resolved) {
      return InvalidArgument("Control return ", ret_it->second,
                             " was not found");
    }
    return_operands.push_back(result->control);
    control_ret_attrs.push_back(b_.getDictionaryAttr(NamedAttribute(
        dialect_->getTfgNameAttrIdentifier(), b_.getStringAttr(control_ret))));
  }
  builder.create<ReturnOp>(unknown_loc_, return_operands,
                           b_.getArrayAttr(control_ret_attrs));

  // Finalize the function attributes.
  func_attrs.append(func_op.arg_attrsAttrName(), b_.getArrayAttr(arg_attrs));
  func_attrs.append(func_op.res_attrsAttrName(), b_.getArrayAttr(res_attrs));
  func_attrs.append(func_op.function_typeAttrName(),
                    TypeAttr::get(b_.getFunctionType(arg_types, res_types)));
  func_op->setAttrs(func_attrs.getDictionary(ctx_));

  return ::tensorflow::OkStatus();
}
