deliver(const dav_resource *resource, ap_filter_t *output)
{
  svn_error_t *serr;
  apr_bucket_brigade *bb;
  apr_bucket *bkt;
  apr_status_t status;

  /* Check resource type */
  if (resource->baselined
      || (resource->type != DAV_RESOURCE_TYPE_REGULAR
          && resource->type != DAV_RESOURCE_TYPE_VERSION
          && resource->type != DAV_RESOURCE_TYPE_WORKING
          && resource->info->restype != DAV_SVN_RESTYPE_PARENTPATH_COLLECTION))
    {
      return dav_svn__new_error(resource->pool, HTTP_CONFLICT, 0,
                                "Cannot GET this type of resource.");
    }

  if (resource->collection)
    {
      const int gen_html = !resource->info->repos->xslt_uri;
      apr_hash_t *entries;
      apr_pool_t *entry_pool;
      apr_array_header_t *sorted;
      svn_revnum_t dir_rev = SVN_INVALID_REVNUM;
      int i;

      /* XML schema for the directory index if xslt_uri is set:

         <?xml version="1.0"?>
         <?xml-stylesheet type="text/xsl" href="[info->repos->xslt_uri]"?> */
      static const char xml_index_dtd[] =
        "<!DOCTYPE svn [\n"
        "  <!ELEMENT svn   (index)>\n"
        "  <!ATTLIST svn   version CDATA #REQUIRED\n"
        "                  href    CDATA #REQUIRED>\n"
        "  <!ELEMENT index (updir?, (file | dir)*)>\n"
        "  <!ATTLIST index name    CDATA #IMPLIED\n"
        "                  path    CDATA #IMPLIED\n"
        "                  rev     CDATA #IMPLIED\n"
        "                  base    CDATA #IMPLIED>\n"
        "  <!ELEMENT updir EMPTY>\n"
        "  <!ATTLIST updir href    CDATA #REQUIRED>\n"
        "  <!ELEMENT file  EMPTY>\n"
        "  <!ATTLIST file  name    CDATA #REQUIRED\n"
        "                  href    CDATA #REQUIRED>\n"
        "  <!ELEMENT dir   EMPTY>\n"
        "  <!ATTLIST dir   name    CDATA #REQUIRED\n"
        "                  href    CDATA #REQUIRED>\n"
        "]>\n";

      /* <svn version="1.3.0 (dev-build)"
              href="http://subversion.apache.org">
           <index name="[info->repos->repo_name]"
                  path="[info->repos_path]"
                  rev="[info->root.rev]">
             <file name="foo" href="foo" />
             <dir name="bar" href="bar/" />
           </index>
         </svn> */


      /* ### TO-DO:  check for a new mod_dav_svn directive here also. */
      if (resource->info->restype == DAV_SVN_RESTYPE_PARENTPATH_COLLECTION)
        {
          apr_hash_index_t *hi;
          apr_hash_t *dirents;
          const char *fs_parent_path =
            dav_svn__get_fs_parent_path(resource->info->r);

          serr = svn_io_get_dirents3(&dirents, fs_parent_path, TRUE,
                                     resource->pool, resource->pool);
          if (serr != NULL)
            return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                        "could not fetch dirents of "
                                        "SVNParentPath", resource->pool);

          /* convert an io dirent hash to an fs dirent hash. */
          entries = apr_hash_make(resource->pool);
          for (hi = apr_hash_first(resource->pool, dirents);
               hi; hi = apr_hash_next(hi))
            {
              const void *key;
              void *val;
              svn_io_dirent_t *dirent;
              svn_fs_dirent_t *ent = apr_pcalloc(resource->pool, sizeof(*ent));

              apr_hash_this(hi, &key, NULL, &val);
              dirent = val;

              if (dirent->kind == svn_node_file && dirent->special)
                {
                  svn_node_kind_t resolved_kind;
                  const char *link_path =
                    svn_dirent_join(fs_parent_path, key, resource->pool);

                  serr = svn_io_check_resolved_path(link_path, &resolved_kind,
                                                    resource->pool);
                  if (serr)
                    return dav_svn__convert_err(serr,
                                                HTTP_INTERNAL_SERVER_ERROR,
                                                "could not resolve symlink "
                                                "dirent of SVNParentPath",
                                                resource->pool);
                  if (resolved_kind != svn_node_dir)
                    continue;

                  dirent->kind = svn_node_dir;
                }
              else if (dirent->kind != svn_node_dir)
                continue;

              ent->name = key;
              ent->id = NULL;     /* ### does it matter? */
              ent->kind = dirent->kind;

              svn_hash_sets(entries, key, ent);
            }

        }
      else
        {
          dir_rev = svn_fs_revision_root_revision(resource->info->root.root);
          serr = svn_fs_dir_entries(&entries, resource->info->root.root,
                                    resource->info->repos_path, resource->pool);
          if (serr != NULL)
            return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                        "could not fetch directory entries",
                                        resource->pool);
        }

      bb = apr_brigade_create(resource->pool, output->c->bucket_alloc);

      if (gen_html)
        {
          const char *title;
          if (resource->info->repos_path == NULL)
            title = "unknown location";
          else
            title = resource->info->repos_path;

          if (resource->info->restype != DAV_SVN_RESTYPE_PARENTPATH_COLLECTION)
            {
              if (SVN_IS_VALID_REVNUM(resource->info->root.rev))
                title = apr_psprintf(resource->pool,
                                     "Revision %ld: %s",
                                     resource->info->root.rev, title);
              if (resource->info->repos->repo_basename)
                title = apr_psprintf(resource->pool, "%s - %s",
                                     resource->info->repos->repo_basename,
                                     title);
              if (resource->info->repos->repo_name)
                title = apr_psprintf(resource->pool, "%s: %s",
                                     resource->info->repos->repo_name,
                                     title);
            }

          ap_fprintf(output, bb, "<html><head><title>%s</title></head>\n"
                     "<body>\n <h2>%s</h2>\n <ul>\n", title, title);
        }
      else
        {
          const char *name = resource->info->repos->repo_name;
          const char *href = resource->info->repos_path;
          const char *base = resource->info->repos->repo_basename;

          ap_fputs(output, bb, "<?xml version=\"1.0\"?>\n");
          ap_fprintf(output, bb,
                     "<?xml-stylesheet type=\"text/xsl\" href=\"%s\"?>\n",
                     resource->info->repos->xslt_uri);
          ap_fputs(output, bb, xml_index_dtd);
          ap_fputs(output, bb,
                   "<svn version=\"" SVN_VERSION "\"\n"
                   "     href=\"http://subversion.apache.org/\">\n");
          ap_fputs(output, bb, "  <index");
          if (name)
            ap_fprintf(output, bb, " name=\"%s\"",
                       apr_xml_quote_string(resource->pool, name, 1));
          if (SVN_IS_VALID_REVNUM(resource->info->root.rev))
            ap_fprintf(output, bb, " rev=\"%ld\"",
                       resource->info->root.rev);
          if (href)
            ap_fprintf(output, bb, " path=\"%s\"",
                       apr_xml_quote_string(resource->pool,
                                            href,
                                            1));
          if (base)
            ap_fprintf(output, bb, " base=\"%s\"", base);

          ap_fputs(output, bb, ">\n");
        }

      if ((resource->info->restype != DAV_SVN_RESTYPE_PARENTPATH_COLLECTION)
          && resource->info->repos_path
          && ((resource->info->repos_path[1] != '\0')
              || dav_svn__get_list_parentpath_flag(resource->info->r)))
        {
          const char *href;
          if (resource->info->pegged)
            {
              href = apr_psprintf(resource->pool, "../?p=%ld",
                                  resource->info->root.rev);
            }
          else
            {
              href = "../";
            }

          if (gen_html)
            {
              ap_fprintf(output, bb,
                         "  <li><a href=\"%s\">..</a></li>\n", href);
            }
          else
            {
              ap_fprintf(output, bb, "    <updir href=\"%s\"/>\n", href);
            }
        }

      /* get a sorted list of the entries */
      sorted = svn_sort__hash(entries, svn_sort_compare_items_as_paths,
                              resource->pool);

      entry_pool = svn_pool_create(resource->pool);

      for (i = 0; i < sorted->nelts; ++i)
        {
          const svn_sort__item_t *item = &APR_ARRAY_IDX(sorted, i,
                                                        const svn_sort__item_t);
          const svn_fs_dirent_t *entry = item->value;
          const char *name = item->key;
          const char *href = name;
          svn_boolean_t is_dir = (entry->kind == svn_node_dir);
          const char *repos_relpath = NULL;

          svn_pool_clear(entry_pool);

          /* DIR_REV is set to a valid revision if we're looking at
             the entries of a versioned directory.  Otherwise, we're
             looking at a parent-path listing. */
          if (SVN_IS_VALID_REVNUM(dir_rev))
            {
              repos_relpath = svn_fspath__join(resource->info->repos_path,
                                               name, entry_pool);
              if (! dav_svn__allow_read(resource->info->r,
                                        resource->info->repos,
                                        repos_relpath,
                                        dir_rev,
                                        entry_pool))
                continue;
            }
          else
            {
                if (! dav_svn__allow_list_repos(resource->info->r,
                                                entry->name, entry_pool))
                  continue;
            }

          /* append a trailing slash onto the name for directories. we NEED
             this for the href portion so that the relative reference will
             descend properly. for the visible portion, it is just nice. */
          /* ### The xml output doesn't like to see a trailing slash on
             ### the visible portion, so avoid that. */
          if (is_dir)
            href = apr_pstrcat(entry_pool, href, "/", SVN_VA_NULL);

          if (gen_html)
            name = href;

          /* We quote special characters in both XML and HTML. */
          name = apr_xml_quote_string(entry_pool, name, !gen_html);

          /* According to httpd-2.0.54/include/httpd.h, ap_os_escape_path()
             behaves differently on different platforms.  It claims to
             "convert an OS path to a URL in an OS dependant way".
             Nevertheless, there appears to be only one implementation
             of the function in httpd, and the code seems completely
             platform independent, so we'll assume it's appropriate for
             mod_dav_svn to use it to quote outbound paths. */
          href = ap_os_escape_path(entry_pool, href, 0);
          href = apr_xml_quote_string(entry_pool, href, 1);

          if (gen_html)
            {
              /* If our directory was access using the public peg-rev
                 CGI query interface, we'll let its dirents carry that
                 peg-rev, too. */
              if (resource->info->pegged)
                {
                  ap_fprintf(output, bb,
                             "  <li><a href=\"%s?p=%ld\">%s</a></li>\n",
                             href, resource->info->root.rev, name);
                }
              else
                {
                  ap_fprintf(output, bb,
                             "  <li><a href=\"%s\">%s</a></li>\n",
                             href, name);
                }
            }
          else
            {
              const char *const tag = (is_dir ? "dir" : "file");

              /* This is where we could search for props */

              /* If our directory was access using the public peg-rev
                 CGI query interface, we'll let its dirents carry that
                 peg-rev, too. */
              if (resource->info->pegged)
                {
                  ap_fprintf(output, bb,
                             "    <%s name=\"%s\" href=\"%s?p=%ld\" />\n",
                             tag, name, href, resource->info->root.rev);
                }
              else
                {
                  ap_fprintf(output, bb,
                             "    <%s name=\"%s\" href=\"%s\" />\n",
                             tag, name, href);
                }
            }
        }

      svn_pool_destroy(entry_pool);

      if (gen_html)
        {
          if (strcmp(ap_psignature("FOO", resource->info->r), "") != 0)
            {
              /* Apache's signature generation code didn't eat our prefix.
                 ServerSignature must be enabled.  Print our version info.

                 WARNING: This is a kludge!! ap_psignature() doesn't promise
                 to return the empty string when ServerSignature is off.  We
                 know it does by code inspection, but this behavior is subject
                 to change. (Perhaps we should try to get the Apache folks to
                 make this promise, though.  Seems harmless/useful enough...)
              */
              ap_fputs(output, bb,
                       " </ul>\n <hr noshade><em>Powered by "
                       "<a href=\"http://subversion.apache.org/\">"
                       "Apache Subversion"
                       "</a> version " SVN_VERSION "."
                       "</em>\n</body></html>");
            }
          else
            ap_fputs(output, bb, " </ul>\n</body></html>");
        }
      else
        ap_fputs(output, bb, "  </index>\n</svn>\n");

      bkt = apr_bucket_eos_create(output->c->bucket_alloc);
      APR_BRIGADE_INSERT_TAIL(bb, bkt);
      if ((status = ap_pass_brigade(output, bb)) != APR_SUCCESS)
        return dav_svn__new_error(resource->pool, HTTP_INTERNAL_SERVER_ERROR, 0,
                                  "Could not write EOS to filter.");

      return NULL;
    }


  /* If we have a base for a delta, then we want to compute an svndiff
     between the provided base and the requested resource. For a simple
     request, then we just grab the file contents. */
  if (resource->info->delta_base != NULL)
    {
      dav_svn__uri_info info;
      svn_fs_root_t *root;
      svn_boolean_t is_file;
      svn_txdelta_stream_t *txd_stream;
      svn_stream_t *o_stream;
      svn_txdelta_window_handler_t handler;
      void * h_baton;
      diff_ctx_t dc = { 0 };

      /* First order of business is to parse it. */
      serr = dav_svn__simple_parse_uri(&info, resource,
                                       resource->info->delta_base,
                                       resource->pool);

      /* If we successfully parse the base URL, then send an svndiff. */
      if ((serr == NULL) && (info.rev != SVN_INVALID_REVNUM))
        {
          /* We are always accessing the base resource by ID, so open
             an ID root. */
          serr = svn_fs_revision_root(&root, resource->info->repos->fs,
                                      info.rev, resource->pool);
          if (serr != NULL)
            return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                        "could not open a root for the base",
                                        resource->pool);

          /* verify that it is a file */
          serr = svn_fs_is_file(&is_file, root, info.repos_path,
                                resource->pool);
          if (serr != NULL)
            return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                        "could not determine if the base "
                                        "is really a file",
                                        resource->pool);
          if (!is_file)
            return dav_svn__new_error(resource->pool, HTTP_BAD_REQUEST, 0,
                                      apr_psprintf(resource->pool,
                                      "the delta base of '%s' does not refer "
                                      "to a file in revision %ld",
                                      info.repos_path, info.rev));

          /* Okay. Let's open up a delta stream for the client to read. */
          serr = svn_fs_get_file_delta_stream(&txd_stream,
                                              root, info.repos_path,
                                              resource->info->root.root,
                                              resource->info->repos_path,
                                              resource->pool);
          if (serr != NULL)
            return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                        "could not prepare to read a delta",
                                        resource->pool);

          /* create a stream that svndiff data will be written to,
             which will copy it to the network */
          dc.output = output;
          dc.pool = resource->pool;
          o_stream = svn_stream_create(&dc, resource->pool);
          svn_stream_set_write(o_stream, write_to_filter);
          svn_stream_set_close(o_stream, close_filter);

          /* get a handler/baton for writing into the output stream */
          svn_txdelta_to_svndiff3(&handler, &h_baton,
                                  o_stream, resource->info->svndiff_version,
                                  dav_svn__get_compression_level(resource->info->r),
                                  resource->pool);

          /* got everything set up. read in delta windows and shove them into
             the handler, which pushes data into the output stream, which goes
             to the network. */
          serr = svn_txdelta_send_txstream(txd_stream, handler, h_baton,
                                           resource->pool);
          if (serr != NULL)
            return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                        "could not deliver the txdelta stream",
                                        resource->pool);


          return NULL;
        }
      else
        {
          svn_error_clear(serr);
        }
    }

  /* resource->info->delta_base is NULL, or we had an invalid base URL */
    {
      svn_stream_t *stream;
      char *block;

      serr = svn_fs_file_contents(&stream,
                                  resource->info->root.root,
                                  resource->info->repos_path,
                                  resource->pool);
      if (serr != NULL)
        {
          return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                      "could not prepare to read the file",
                                      resource->pool);
        }

      /* Perform keywords substitution if requested by client */
      if (resource->info->keyword_subst)
        {
          svn_string_t *keywords;

          serr = svn_fs_node_prop(&keywords,
                                  resource->info->root.root,
                                  resource->info->repos_path,
                                  SVN_PROP_KEYWORDS,
                                  resource->pool);
          if (serr != NULL)
            return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                        "could not get fetch '"
                                        SVN_PROP_KEYWORDS "' property for "
                                        "for keywords substitution",
                                        resource->pool);

          if (keywords)
            {
              apr_hash_t *kw;
              svn_revnum_t cmt_rev;
              const char *str_cmt_rev, *str_uri, *str_root;
              const char *cmt_date, *cmt_author;
              apr_time_t when = 0;

              serr = svn_repos_get_committed_info(&cmt_rev,
                                                  &cmt_date,
                                                  &cmt_author,
                                                  resource->info->root.root,
                                                  resource->info->repos_path,
                                                  resource->pool);
              if (serr != NULL)
                return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                            "could not fetch committed info "
                                            "for keywords substitution",
                                            resource->pool);

              serr = svn_time_from_cstring(&when, cmt_date, resource->pool);
              if (serr != NULL)
                return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                            "could not parse committed date "
                                            "for keywords substitution",
                                            resource->pool);
              str_cmt_rev = apr_psprintf(resource->pool, "%ld", cmt_rev);
              str_uri = apr_pstrcat(resource->pool,
                                    resource->info->repos->base_url,
                                    ap_escape_uri(resource->pool,
                                                  resource->info->r->uri),
                                    SVN_VA_NULL);
              str_root = apr_pstrcat(resource->pool,
                                     resource->info->repos->base_url,
                                     resource->info->repos->root_path,
                                     SVN_VA_NULL);

              serr = svn_subst_build_keywords3(&kw, keywords->data,
                                               str_cmt_rev, str_uri, str_root,
                                               when, cmt_author,
                                               resource->pool);
              if (serr != NULL)
                return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                            "could not perform keywords "
                                            "substitution", resource->pool);

              /* Replace the raw file STREAM with a wrapper that
                 handles keyword translation. */
              stream = svn_subst_stream_translated(
                           svn_stream_disown(stream, resource->pool),
                           NULL, FALSE, kw, TRUE, resource->pool);
            }
        }

      /* ### one day in the future, we can create a custom bucket type
         ### which will read from the FS stream on demand */

      block = apr_palloc(resource->pool, SVN__STREAM_CHUNK_SIZE);
      while (1) {
        apr_size_t bufsize = SVN__STREAM_CHUNK_SIZE;

        /* read from the FS ... */
        serr = svn_stream_read(stream, block, &bufsize);
        if (serr != NULL)
          {
            return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                        "could not read the file contents",
                                        resource->pool);
          }
        if (bufsize == 0)
          break;

        /* build a brigade and write to the filter ... */
        bb = apr_brigade_create(resource->pool, output->c->bucket_alloc);
        bkt = apr_bucket_transient_create(block, bufsize,
                                          output->c->bucket_alloc);
        APR_BRIGADE_INSERT_TAIL(bb, bkt);
        if ((status = ap_pass_brigade(output, bb)) != APR_SUCCESS) {
          /* ### what to do with status; and that HTTP code... */
          return dav_svn__new_error(resource->pool,
                                    HTTP_INTERNAL_SERVER_ERROR, 0,
                                    "Could not write data to filter.");
        }
      }

      /* done with the file. write an EOS bucket now. */
      bb = apr_brigade_create(resource->pool, output->c->bucket_alloc);
      bkt = apr_bucket_eos_create(output->c->bucket_alloc);
      APR_BRIGADE_INSERT_TAIL(bb, bkt);
      if ((status = ap_pass_brigade(output, bb)) != APR_SUCCESS) {
        /* ### what to do with status; and that HTTP code... */
        return dav_svn__new_error(resource->pool,
                                  HTTP_INTERNAL_SERVER_ERROR, 0,
                                  "Could not write EOS to filter.");
      }

      return NULL;
    }
}
