static GF_Err DumpIndexInsert(GF_SceneDumper *sdump, GF_Command *com)
{
	GF_Err e;
	GF_FieldInfo field, sffield;
	GF_CommandField *inf;
	char posname[20];
	if (!gf_list_count(com->command_fields)) return GF_OK;
	inf = (GF_CommandField *) gf_list_get(com->command_fields, 0);

	switch (inf->pos) {
	case 0:
		strcpy(posname, "BEGIN");
		break;
	case -1:
		strcpy(posname, "END");
		break;
	default:
		sprintf(posname, "%d", inf->pos);
		break;
	}

	e = gf_node_get_field(com->node, inf->fieldIndex, &field);
	if (e) return e;
	if (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;

	DUMP_IND(sdump);
	if (sdump->XMLDump) {
		gf_fprintf(sdump->trace, "<Insert atNode=\"");
		scene_dump_vrml_id(sdump, com->node);
		gf_fprintf(sdump->trace, "\" atField=\"%s\" position=\"%s\"", field.name, posname);
	} else {
		if (inf->pos==-1) {
			gf_fprintf(sdump->trace, "APPEND TO ");
		}
		else gf_fprintf(sdump->trace, "INSERT AT ");
		scene_dump_vrml_id(sdump, com->node);
		gf_fprintf(sdump->trace, ".%s", field.name);
		if (inf->pos!=-1) gf_fprintf(sdump->trace, "[%d]", inf->pos);
		gf_fprintf(sdump->trace, " ");
	}

	memcpy(&sffield, &field, sizeof(GF_FieldInfo));
	sffield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);

	if (field.fieldType==GF_SG_VRML_MFNODE) {
		if (sdump->XMLDump) gf_fprintf(sdump->trace, ">\n");
		gf_dump_vrml_node(sdump, inf->new_node, 0, NULL);
		if (sdump->XMLDump) gf_fprintf(sdump->trace, "</Insert>");
		gf_fprintf(sdump->trace, "\n");
	} else {
		sffield.far_ptr = inf->field_ptr;
		gf_dump_vrml_simple_field(sdump, sffield, com->node);
		if (sdump->XMLDump) gf_fprintf(sdump->trace, "/>");
		gf_fprintf(sdump->trace, "\n");
	}
	return e;
}
