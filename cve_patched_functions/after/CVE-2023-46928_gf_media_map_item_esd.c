GF_ESD *gf_media_map_item_esd(GF_ISOFile *mp4, u32 item_id)
{
	u32 item_type;
	u32 prot_scheme, prot_scheme_version;
	Bool is_self_ref;
	const char *name;
	const char *mime;
	const char *encoding;
	const char *url;
	const char *urn;
	GF_ESD *esd;
	GF_Err e;

	u32 item_idx = gf_isom_get_meta_item_by_id(mp4, GF_TRUE, 0, item_id);
	if (!item_idx) return NULL;

	e = gf_isom_get_meta_item_info(mp4, GF_TRUE, 0, item_idx, &item_id, &item_type, &prot_scheme, &prot_scheme_version, &is_self_ref, &name, &mime, &encoding, &url, &urn);
	if (e != GF_OK) return NULL;

	if (item_type == GF_ISOM_SUBTYPE_HVC1) {
		GF_ImageItemProperties props;
		esd = gf_odf_desc_esd_new(0);
		if (!esd) return NULL;

		if (item_id > (1 << 16)) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CORE, ("Item ID greater than 16 bits, does not fit on ES ID\n"));
		}
		esd->ESID = (u16)item_id;
		esd->OCRESID = esd->ESID;
		esd->decoderConfig->streamType = GF_STREAM_VISUAL;
		esd->decoderConfig->objectTypeIndication = GF_CODECID_HEVC;
		e = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);
		if (e == GF_OK && props.config) {
			gf_odf_hevc_cfg_write(((GF_HEVCConfigurationBox *)props.config)->config, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);
		}
		esd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;
		esd->slConfig->useTimestampsFlag = 1;
		esd->slConfig->timestampResolution = 1000;
		return esd;
	}

	if (item_type == GF_ISOM_SUBTYPE_AVC_H264) {
		GF_ImageItemProperties props;
		esd = gf_odf_desc_esd_new(0);
		if (!esd) return NULL;

		if (item_id > (1 << 16)) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CORE, ("Item ID greater than 16 bits, does not fit on ES ID\n"));
		}
		esd->ESID = (u16)item_id;
		esd->OCRESID = esd->ESID;
		esd->decoderConfig->streamType = GF_STREAM_VISUAL;
		esd->decoderConfig->objectTypeIndication = GF_CODECID_AVC;
		e = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);
		if (e == GF_OK && props.config) {
			gf_odf_avc_cfg_write(((GF_AVCConfigurationBox *)props.config)->config, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);
		}
		esd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;
		esd->slConfig->useTimestampsFlag = 1;
		esd->slConfig->timestampResolution = 1000;
		return esd;
	}

	if (item_type == GF_ISOM_SUBTYPE_AV01) {
		GF_ImageItemProperties props;
		esd = gf_odf_desc_esd_new(0);
		if (!esd) return NULL;
		if (item_id > (1 << 16)) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CORE, ("Item ID greater than 16 bits, does not fit on ES ID\n"));
		}
		esd->ESID = (u16)item_id;
		esd->OCRESID = esd->ESID;
		esd->decoderConfig->streamType = GF_STREAM_VISUAL;
		esd->decoderConfig->objectTypeIndication = GF_CODECID_AV1;
		e = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);
		if (e == GF_OK && props.config) {
			gf_odf_av1_cfg_write( ((GF_AV1ConfigurationBox *)props.config)->config, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);
		}
		esd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;
		esd->slConfig->useTimestampsFlag = 1;
		esd->slConfig->timestampResolution = 1000;
		return esd;
	}

	if ((item_type == GF_ISOM_SUBTYPE_JPEG) || (mime && !strcmp(mime, "image/jpeg")) ){
		GF_ImageItemProperties props;
		esd = gf_odf_desc_esd_new(0);
		if (!esd) return NULL;

		if (item_id > (1 << 16)) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CORE, ("Item ID greater than 16 bits, does not fit on ES ID\n"));
		}
		esd->ESID = (u16)item_id;
		esd->OCRESID = esd->ESID;
		esd->decoderConfig->streamType = GF_STREAM_VISUAL;
		esd->decoderConfig->objectTypeIndication = GF_CODECID_JPEG;
		e = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);
		if (e == GF_OK && props.config) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CORE, ("JPEG image item decoder config not supported, patch welcome\n"));
		}
		esd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;
		esd->slConfig->useTimestampsFlag = 1;
		esd->slConfig->timestampResolution = 1000;
		return esd;
	}

	if ((item_type == GF_ISOM_SUBTYPE_PNG) || (mime && !strcmp(mime, "image/png")) ){
		GF_ImageItemProperties props;
		esd = gf_odf_desc_esd_new(0);
		if (!esd) return NULL;

		if (item_id > (1 << 16)) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CORE, ("Item ID greater than 16 bits, does not fit on ES ID\n"));
		}
		esd->ESID = (u16)item_id;
		esd->OCRESID = esd->ESID;
		esd->decoderConfig->streamType = GF_STREAM_VISUAL;
		esd->decoderConfig->objectTypeIndication = GF_CODECID_PNG;
		e = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);
		if (e) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CORE, ("Error fetching item properties %s\n", gf_error_to_string(e) ));
		}
		esd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;
		esd->slConfig->useTimestampsFlag = 1;
		esd->slConfig->timestampResolution = 1000;
		return esd;
	}

	if (item_type == GF_ISOM_SUBTYPE_VVC1) {
		GF_ImageItemProperties props;
		esd = gf_odf_desc_esd_new(0);
		if (!esd) return NULL;

		if (item_id > (1 << 16)) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CORE, ("Item ID greater than 16 bits, does not fit on ES ID\n"));
		}
		esd->ESID = (u16)item_id;
		esd->OCRESID = esd->ESID;
		esd->decoderConfig->streamType = GF_STREAM_VISUAL;
		esd->decoderConfig->objectTypeIndication = GF_CODECID_VVC;
		e = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, NULL);
		if (e == GF_OK && props.config) {
			gf_odf_vvc_cfg_write(((GF_VVCConfigurationBox *)props.config)->config, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);
		}
		esd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;
		esd->slConfig->useTimestampsFlag = 1;
		esd->slConfig->timestampResolution = 1000;
		return esd;
	}
	if ((item_type == GF_ISOM_SUBTYPE_UNCV) || (item_type == GF_ISOM_ITEM_TYPE_UNCI)) {
		GF_ImageItemProperties props;
		esd = gf_odf_desc_esd_new(0);
		if (!esd) return NULL;

		if (item_id > (1 << 16)) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CORE, ("Item ID greater than 16 bits, does not fit on ES ID\n"));
		}
		esd->ESID = (u16)item_id;
		esd->OCRESID = esd->ESID;
		esd->decoderConfig->streamType = GF_STREAM_VISUAL;
		esd->decoderConfig->objectTypeIndication = GF_CODECID_RAW;
		GF_List *other_props = gf_list_new();
		e = gf_isom_get_meta_image_props(mp4, GF_TRUE, 0, item_id, &props, other_props);
#ifndef GPAC_DISABLE_ISOM_WRITE
		if ((e == GF_OK) && gf_list_count(other_props)) {
			GF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
			gf_isom_box_array_write(NULL, other_props, bs);
			gf_bs_get_content(bs, &esd->decoderConfig->decoderSpecificInfo->data, &esd->decoderConfig->decoderSpecificInfo->dataLength);
			gf_bs_del(bs);
		}
#endif // GPAC_DISABLE_ISOM_WRITE
		gf_list_del(other_props);
		esd->slConfig->hasRandomAccessUnitsOnlyFlag = 1;
		esd->slConfig->useTimestampsFlag = 1;
		esd->slConfig->timestampResolution = 1000;
		return esd;
	}


	return NULL;
}
