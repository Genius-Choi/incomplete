sasl_input_startauth(const struct sasl_message *const restrict smsg, struct sasl_session *const restrict p)
{
	if (strcmp(smsg->parv[0], "EXTERNAL") == 0)
	{
		if (smsg->parc < 2)
		{
			(void) slog(LG_DEBUG, "%s: client %s starting EXTERNAL authentication without a "
			                      "fingerprint", MOWGLI_FUNC_NAME, p->uid);
			return false;
		}

		(void) sfree(p->certfp);

		p->certfp = sstrdup(smsg->parv[1]);
		p->flags |= ASASL_SFLAG_CLIENT_SECURE;
	}

	struct user *const u = user_find(p->uid);

	if (u && u->myuser)
	{
		/* If the user is already on the network, they're doing an IRCv3.2 SASL
		 * reauthentication. This means that if the user is logged in, we need
		 * to call the user_can_logout hooks and maybe abort the exchange now.
		 */
		(void) slog(LG_DEBUG, "%s: user %s ('%s') is logged in as '%s' -- executing user_can_logout hooks",
		                      MOWGLI_FUNC_NAME, p->uid, u->nick, entity(u->myuser)->name);

		struct hook_user_logout_check req = {
			.si      = p->si,
			.u       = u,
			.allowed = true,
			.relogin = true,
		};

		(void) hook_call_user_can_logout(&req);

		if (! req.allowed)
		{
			(void) notice(saslsvs->nick, u->nick,
			              "You cannot log out \2%s\2 because the server configuration disallows it.",
			              entity(u->myuser)->name);
			return false;
		}
	}

	if (u)
		u->flags |= UF_DOING_SASL;

	return sasl_process_packet(p, smsg->parv[0], 0);
}
