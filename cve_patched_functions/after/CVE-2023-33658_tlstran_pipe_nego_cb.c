tlstran_pipe_nego_cb(void *arg)
{
	tlstran_pipe *p   = arg;
	tlstran_ep *  ep  = p->ep;
	nni_aio *     aio = p->negoaio;
	nni_aio *     uaio;
	nni_iov       iov;
	uint32_t      len;
	int           rv, len_of_varint = 0;

	log_trace("start tlstran_pipe_nego_cb max len %ld pipe_addr %p\n",
	    NANO_CONNECT_PACKET_LEN, p);
	nni_mtx_lock(&ep->mtx);

	if ((rv = nni_aio_result(aio)) != 0) {
		log_warn(" nego aio error %s", nng_strerror(rv));
		goto error;
	}

	// calculate number of bytes received
	if (p->gotrxhead < p->wantrxhead) {
		p->gotrxhead += nni_aio_count(aio);
	}

	// recv fixed header
	if (p->gotrxhead < NNI_NANO_MAX_HEADER_SIZE) {
		nni_iov iov;
		iov.iov_len = NNI_NANO_MAX_HEADER_SIZE - p->gotrxhead;
		iov.iov_buf = &p->rxlen[p->gotrxhead];
		nni_aio_set_iov(aio, 1, &iov);
		nng_stream_recv(p->conn, aio);
		nni_mtx_unlock(&ep->mtx);
		return;
	}
	if (p->gotrxhead == NNI_NANO_MAX_HEADER_SIZE) {
		if (p->rxlen[0] != CMD_CONNECT) {
			log_warn("CMD TYPE %x", p->rxlen[0]);
			rv = NNG_EPROTO;
			goto error;
		}
		len =
		    get_var_integer(p->rxlen + 1, (uint32_t *) &len_of_varint);
		p->wantrxhead = len + 1 + len_of_varint;
		rv            = (p->wantrxhead >= NANO_CONNECT_PACKET_LEN) ? 0
		                                                           : NNG_EPROTO;
		if (rv != 0) {
			goto error;
		}
	}

	// we have finished the fixed header
	if (p->gotrxhead < p->wantrxhead) {
		nni_iov iov;
		iov.iov_len = p->wantrxhead - p->gotrxhead;
		if (p->conn_buf == NULL) {
			p->conn_buf = nng_alloc(p->wantrxhead);
			memcpy(p->conn_buf, p->rxlen, p->gotrxhead);
		}
		iov.iov_buf = &p->conn_buf[p->gotrxhead];
		nni_aio_set_iov(aio, 1, &iov);
		nng_stream_recv(p->conn, aio);
		nni_mtx_unlock(&ep->mtx);
		return;
	}

	// We have both sent and received the CONNECT headers.
	// CONNECT packet serialization

	if (p->gotrxhead >= p->wantrxhead) {
		if (p->tcp_cparam == NULL) {
			conn_param_alloc(&p->tcp_cparam);
		}
		if (conn_handler(p->conn_buf, p->tcp_cparam, p->wantrxhead) == 0) {
			nng_free(p->conn_buf, p->wantrxhead);
			p->conn_buf = NULL;
			// we don't need to alloc a new msg, just use pipe.
			// We are all ready now.  We put this in the wait list,
			// and then try to run the matcher.

			// Connection is accepted.
			if (p->tcp_cparam->pro_ver == 5) {
				p->qsend_quota = p->tcp_cparam->rx_max;
			}
			nni_list_remove(&ep->negopipes, p);
			nni_list_append(&ep->waitpipes, p);
			tlstran_ep_match(ep);
			if (p->tcp_cparam->max_packet_size == 0) {
				// set default max packet size for client
				p->tcp_cparam->max_packet_size = p->conf == NULL?
				NANO_MAX_RECV_PACKET_SIZE : p->conf->client_max_packet_size;
			}
			nni_mtx_unlock(&ep->mtx);
			return;
		} else {
			nng_free(p->conn_buf, p->wantrxhead);
			if (p->tcp_cparam->pro_ver == 5) {
				goto close;
			} else {
				goto error;
			}
		}
	}

	nni_mtx_unlock(&ep->mtx);
	log_trace("^^^^^^^^^^end of tlstran_pipe_nego_cb^^^^^^^^^^\n");
	return;

close:
	// if a malformated CONNECT packet is received
	// reply CONNACK here for MQTT V5
	// otherwise deal with it in protocol layer
	p->txlen[0] = CMD_CONNACK;
	p->txlen[1] = 0x03;
	p->txlen[2] = 0x00;
	p->txlen[3] = rv;
	p->txlen[4] = 0x00;
	iov.iov_len = 5;
	iov.iov_buf = &p->txlen;
	// send connack down...
	nni_aio_set_iov(p->rpaio, 1, &iov);
	nng_stream_send(p->conn, p->rpaio);
	nng_aio_wait(p->rpaio);
error:
	// If the connection is closed, we need to pass back a different
	// error code.  This is necessary to avoid a problem where the
	// closed status is confused with the accept file descriptor
	// being closed.
	conn_param_free(p->tcp_cparam);
	if (rv == NNG_ECLOSED) {
		rv = NNG_ECONNSHUT;
	}
	nng_stream_close(p->conn);

	if ((uaio = ep->useraio) != NULL) {
		ep->useraio = NULL;
		nni_aio_finish_error(uaio, rv);
	}
	nni_mtx_unlock(&ep->mtx);
	tlstran_pipe_reap(p);
	log_error("connect nego error rv: %s(%d)", nng_strerror(rv), rv);
}
