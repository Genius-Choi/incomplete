ASC_getPresentationContext(T_ASC_Parameters * params,
                           int listPosition,
                           T_ASC_PresentationContext * presentationContext)
{
    DUL_PRESENTATIONCONTEXT *pc;
    DUL_TRANSFERSYNTAX *transfer;
    LST_HEAD **l;
    int count = 0;

    /* make the presentation context structure clean */
    memset((char*)presentationContext, 0, sizeof(*presentationContext));

    if (params->DULparams.requestedPresentationContext == NULL)
    {
      char buf[256];
      sprintf(buf, "ASC Bad presentation context position: %d", listPosition);
      return makeDcmnetCondition(ASCC_BADPRESENTATIONCONTEXTPOSITION, OF_error, buf);
    }
    l = &(params->DULparams.requestedPresentationContext);
    if (*l == NULL)
    {
      char buf[256];
      sprintf(buf, "ASC Bad presentation context position: %d", listPosition);
      return makeDcmnetCondition(ASCC_BADPRESENTATIONCONTEXTPOSITION, OF_error, buf);
    }
    pc = (DUL_PRESENTATIONCONTEXT*) LST_Head(l);
    (void)LST_Position(l, (LST_NODE*)pc);

    while (pc && count != listPosition) {
        count++;
        pc = (DUL_PRESENTATIONCONTEXT*) LST_Next(l);
    }

    if (pc == NULL)
    {
      char buf[256];
      sprintf(buf, "ASC Bad presentation context position: %d", listPosition);
      return makeDcmnetCondition(ASCC_BADPRESENTATIONCONTEXTPOSITION, OF_error, buf);
    }

    presentationContext->presentationContextID = pc->presentationContextID;
    presentationContext->resultReason = (T_ASC_P_ResultReason) pc->result;
    presentationContext->proposedRole = dulRole2ascRole(pc->proposedSCRole);
    presentationContext->acceptedRole = dulRole2ascRole(pc->acceptedSCRole);
    OFStandard::strlcpy(presentationContext->abstractSyntax,
           pc->abstractSyntax, sizeof(presentationContext->abstractSyntax));
    if (presentationContext->resultReason == ASC_P_ACCEPTANCE) {
        OFStandard::strlcpy(presentationContext->acceptedTransferSyntax,
            pc->acceptedTransferSyntax, sizeof(presentationContext->acceptedTransferSyntax));
    } else {
        presentationContext->acceptedTransferSyntax[0] = '\0';
    }

    /* need to copy the transfer syntaxes */
    count = 0;

    l = &pc->proposedTransferSyntax;
    transfer = (DUL_TRANSFERSYNTAX*) LST_Head(l);
    (void)LST_Position(l, (LST_NODE*)transfer);
    while (transfer != NULL)
    {
        if (count >= DICOM_MAXTRANSFERSYNTAXES)
        {
          return makeDcmnetCondition(ASCC_CODINGERROR, OF_error, "ASC Coding error in ASC_getPresentationContext: too many transfer syntaxes");
        }
        OFStandard::strlcpy(presentationContext->proposedTransferSyntaxes[count],
               transfer->transferSyntax, sizeof(presentationContext->proposedTransferSyntaxes[count]));
        count++;
        transfer = (DUL_TRANSFERSYNTAX*) LST_Next(l);
    }

    presentationContext->transferSyntaxCount = OFstatic_cast(unsigned char, count);

    return EC_Normal;
}
