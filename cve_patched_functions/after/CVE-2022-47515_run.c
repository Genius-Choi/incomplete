    void DrachtioController::run() {
        
      if( m_bDaemonize ) {
          daemonize() ;
      }

      /* now we can initialize logging */
      m_logger.reset( this->createLogger() );
      this->logConfig() ;

        DR_LOG(log_debug) << "DrachtioController::run: Main thread id: " << std::this_thread::get_id() ;
        if (m_bMemoryDebug) DR_LOG(log_notice) << "DrachtioController::run: memory debugging is ON...only use for non-production configurations" ;

       /* open admin connection */
        string adminAddress ;
        m_Config->getAdminAddress(adminAddress);
        unsigned int adminTcpPort = m_Config->getAdminTcpPort() ;
        unsigned int adminTlsPort = m_Config->getAdminTlsPort() ;
        if (!m_adminAddress.empty()) adminAddress = m_adminAddress;
        if( 0 != m_adminTcpPort ) adminTcpPort = m_adminTcpPort ;
        if( 0 != m_adminTlsPort ) adminTlsPort = m_adminTlsPort ;

        if( 0 == m_vecTransports.size() ) {
            m_Config->getTransports( m_vecTransports ) ; 
        }
        if( 0 == m_vecTransports.size() ) {

            DR_LOG(log_notice) << "DrachtioController::run: no sip contacts provided, will listen on 5060 for udp and tcp " ;
            m_vecTransports.push_back( std::make_shared<SipTransport>("sip:*;transport=udp,tcp"));            
        }

        string outboundProxy ;
        if( m_Config->getSipOutboundProxy(outboundProxy) ) {
            DR_LOG(log_notice) << "DrachtioController::run: outbound proxy " << outboundProxy ;
        }

        if (!m_bAggressiveNatDetection) {
            m_bAggressiveNatDetection = m_Config->isAggressiveNatEnabled();
        }

        // tls files
        string tlsKeyFile, tlsCertFile, tlsChainFile, dhParam ;
        int tlsVersionTagValue = TPTLS_VERSION_TLSv1 | TPTLS_VERSION_TLSv1_1 | TPTLS_VERSION_TLSv1_2;
        bool hasTlsFiles = m_Config->getTlsFiles( tlsKeyFile, tlsCertFile, tlsChainFile, dhParam ) ;
        if (!m_tlsKeyFile.empty()) tlsKeyFile = m_tlsKeyFile;
        if (!m_tlsCertFile.empty()) tlsCertFile = m_tlsCertFile;
        if (!m_tlsChainFile.empty()) tlsChainFile = m_tlsChainFile;
        if (!m_dhParam.empty()) dhParam = m_dhParam;
        if (!hasTlsFiles && !tlsKeyFile.empty() && !tlsCertFile.empty()) hasTlsFiles = true;
        if (m_minTlsVersion >= 1.0 || (m_Config->getMinTlsVersion(m_minTlsVersion) && m_minTlsVersion > 1.0)) {
            if (m_minTlsVersion >= 1.2) {
                DR_LOG(log_notice) << "DrachtioController::run: minTls version 1.2";
                tlsVersionTagValue = TPTLS_VERSION_TLSv1_2;
            }
            else if (m_minTlsVersion >= 1.1) {
                DR_LOG(log_notice) << "DrachtioController::run: minTls version 1.1" ;
                tlsVersionTagValue = TPTLS_VERSION_TLSv1_1 | TPTLS_VERSION_TLSv1_2;
            }
        }

        if (hasTlsFiles) {
            DR_LOG(log_notice) << "DrachtioController::run tls key file:         " << tlsKeyFile;
            DR_LOG(log_notice) << "DrachtioController::run tls certificate file: " << tlsCertFile;
            if (!tlsChainFile.empty()) DR_LOG(log_notice) << "DrachtioController::run tls chain file:       " << tlsChainFile;
        }

        if (adminTlsPort) {
            if ((tlsChainFile.empty() && tlsCertFile.empty()) || tlsKeyFile.empty() || dhParam.empty()) {
                DR_LOG(log_notice) << "DrachtioController::run tls was requested on admin connection but either chain file/cert file, private key, or dhParams were not provided";
                throw runtime_error("missing tls settings");
            }
        }

        if (m_adminTcpPort && !m_adminTlsPort) {
            DR_LOG(log_notice) << "DrachtioController::run listening for applications on tcp port " << adminTcpPort << " only";
            m_pClientController.reset(new ClientController(this, adminAddress, adminTcpPort));
        }
        else if (!m_adminTcpPort && m_adminTlsPort) {
            DR_LOG(log_notice) << "DrachtioController::run listening for applications on tls port " << adminTlsPort << " only";
            m_pClientController.reset(new ClientController(this, adminAddress, adminTlsPort, tlsChainFile, tlsCertFile, tlsKeyFile, dhParam));
        }
        else {
             DR_LOG(log_notice) << "DrachtioController::run listening for applications on tcp port " << adminTcpPort << " and tls port " << adminTlsPort ;
           m_pClientController.reset(new ClientController(this, adminAddress, adminTcpPort, adminTlsPort, tlsChainFile, tlsCertFile, tlsKeyFile, dhParam));
        }
        m_pClientController->start();
        
        // mtu
        if (!m_mtu) m_mtu = m_Config->getMtu();
        if (m_mtu > 0 && m_mtu < 1000) {
            DR_LOG(log_notice) << "DrachtioController::run invalid mtu size provided, must be > 1000: " << m_mtu;
            throw runtime_error("invalid mtu setting");
        }
        else if (m_mtu > 0) {
            DR_LOG(log_notice) << "DrachtioController::run mtu size for udp packets: " << m_mtu;            
        }
        
        string captureServer;
        string captureString;
        uint32_t captureId ;
        unsigned int hepVersion;
        unsigned int capturePort ;
        if (!m_strHomerAddress.empty()) {
            captureString = "udp:" + m_strHomerAddress + ":" + boost::lexical_cast<std::string>(m_nHomerPort) + 
                ";hep=3;capture_id=" + boost::lexical_cast<std::string>(m_nHomerId);
            DR_LOG(log_notice) << "DrachtioController::run - sipcapture/Homer enabled: " << captureString;            
        }
        else if (m_Config->getCaptureServer(captureServer, capturePort, captureId, hepVersion)) {
            if (hepVersion < 1 || hepVersion > 3) {
                DR_LOG(log_error) << "DrachtioController::run invalid hep-version " << hepVersion <<
                    "; must be between 1 and 3 inclusive";
            }
            else {
                captureString = "udp:" + captureServer + ":" + boost::lexical_cast<std::string>(capturePort) + 
                    ";hep=" + boost::lexical_cast<std::string>(hepVersion) +
                    ";capture_id=" + boost::lexical_cast<std::string>(captureId);
                DR_LOG(log_notice) << "DrachtioController::run - sipcapture/Homer enabled: " << captureString;
            }

        }

        if (m_strUserAgentAutoAnswerOptions.empty()) {
             m_Config->getAutoAnswerOptionsUserAgent(m_strUserAgentAutoAnswerOptions);
        }

        /* mostly useful for kubernetes deployments, where it is verboten to mess with iptables */
        if (m_redisAddress.empty()) {
            string redisAddress, redisKey;
            unsigned int redisPort, redisRefreshSecs;
            DR_LOG(log_notice) << "DrachtioController::run - blacklist checking config";

            if (m_Config->getBlacklistServer(redisAddress, redisPort, redisKey, redisRefreshSecs)) {
                m_redisAddress = redisAddress;
                m_redisPort = redisPort;
                m_redisKey = redisKey;
                m_redisRefreshSecs = redisRefreshSecs;
            }
        }
        if (m_redisAddress.length() && m_redisKey.length()) {
            DR_LOG(log_notice) << "DrachtioController::run - blacklist is in redis " << m_redisAddress << ":" << m_redisPort 
                << ", key is " << m_redisKey;
            m_pBlacklist = new Blacklist(m_redisAddress, m_redisPort, m_redisKey, m_redisRefreshSecs);
            m_pBlacklist->start();
        }

        // monitoring
        if (m_nPrometheusPort == 0) m_Config->getPrometheusAddress( m_strPrometheusAddress, m_nPrometheusPort ) ;
        if (m_nPrometheusPort != 0) {
            string hostport = m_strPrometheusAddress + ":" + boost::lexical_cast<std::string>(m_nPrometheusPort);
            DR_LOG(log_notice) << "responding to Prometheus on " << hostport;
            m_statsCollector.enablePrometheus(hostport.c_str());
        }
        else {
            DR_LOG(log_notice) << "Prometheus support disabled";
        }
        initStats();

        // tcp keepalive
        if (UINT16_MAX == m_tcpKeepaliveSecs) {
            m_tcpKeepaliveSecs = m_Config->getTcpKeepalive();
        }
        if (0 == m_tcpKeepaliveSecs) {
            DR_LOG(log_notice) << "tcp keep alives have been disabled ";
        }
        else {
            DR_LOG(log_notice) << "tcp keep alives will be sent to clients every " << m_tcpKeepaliveSecs << " seconds";
        }

        int rv = su_init() ;
        if( rv < 0 ) {
            DR_LOG(log_error) << "Error calling su_init: " << rv ;
            return ;
        }
        ::atexit(su_deinit);
        if (sip_update_default_mclass(sip_extend_mclass(NULL)) < 0) {
            DR_LOG(log_error) << "DrachtioController::run: Error calling sip_update_default_mclass"  ;
            return  ;
        }        
        
        m_root = su_root_create( NULL ) ;
        if( NULL == m_root ) {
            DR_LOG(log_error) << "DrachtioController::run: Error calling su_root_create: "  ;
            return  ;
        }
        m_home = su_home_create() ;
        if( NULL == m_home ) {
            DR_LOG(log_error) << "DrachtioController::run: Error calling su_home_create"  ;
        }
        su_log_redirect(NULL, __sofiasip_logger_func, NULL);
        
        /* for now set logging to full debug */
        su_log_set_level(NULL, m_nSofiaLoglevel >= 0 ? (unsigned int) m_nSofiaLoglevel : m_Config->getSofiaLogLevel() ) ;
        setenv("TPORT_LOG", "1", 1) ;
        
        /* this causes su_clone_start to start a new thread */
        su_root_threading( m_root, 0 ) ;
        rv = su_clone_start( m_root, m_clone, this, clone_init, clone_destroy ) ;
        if( rv < 0 ) {
           DR_LOG(log_error) << "DrachtioController::run: Error calling su_clone_start"  ;
           return  ;
        }

        if( m_vecTransports[0]->hasExternalIp() ) {
            DR_LOG(log_notice) << "DrachtioController::run: starting sip stack on local address " << m_vecTransports[0]->getContact() <<    
                " (external address: " << m_vecTransports[0]->getExternalIp() << ")";   
        }
        else {
            DR_LOG(log_notice) << "DrachtioController::run: starting sip stack on " <<  m_vecTransports[0]->getContact() ;   
        }
        string newUrl; 
        m_vecTransports[0]->getBindableContactUri(newUrl) ;
         
         /* create our agent */
        bool tlsTransport = string::npos != m_vecTransports[0]->getContact().find("sips") || string::npos != m_vecTransports[0]->getContact().find("tls") ;
		m_nta = nta_agent_create( m_root,
         URL_STRING_MAKE(newUrl.c_str()),               /* our contact address */
         stateless_callback,                            /* no callback function */
         this,                                      /* therefore no context */
         TAG_IF( !captureString.empty(), TPTAG_CAPT(captureString.c_str())),
         TAG_IF( tlsTransport && hasTlsFiles, TPTAG_TLS_CERTIFICATE_KEY_FILE(tlsKeyFile.c_str())),
         TAG_IF( tlsTransport && hasTlsFiles, TPTAG_TLS_CERTIFICATE_FILE(tlsCertFile.c_str())),
         TAG_IF( tlsTransport && hasTlsFiles && tlsChainFile.length() > 0, TPTAG_TLS_CERTIFICATE_CHAIN_FILE(tlsChainFile.c_str())),
         TAG_IF( tlsTransport &&hasTlsFiles, 
            TPTAG_TLS_VERSION( tlsVersionTagValue )),
         NTATAG_SERVER_RPORT(2),   //force rport even when client does not provide
         NTATAG_CLIENT_RPORT(true), //add rport on Via headers for requests we send
         TAG_NULL(),
         TAG_END() ) ;
        
        if( NULL == m_nta ) {
            DR_LOG(log_error) << "DrachtioController::run: Error calling nta_agent_create"  ;
            return ;
        }

        SipTransport::addTransports(m_vecTransports[0], m_mtu) ;

        for( std::vector< std::shared_ptr<SipTransport> >::iterator it = m_vecTransports.begin() + 1; it != m_vecTransports.end(); it++ ) {
            string contact = (*it)->getContact() ;
            string externalIp = (*it)->getExternalIp() ;
            string newUrl ;

            tlsTransport = string::npos != contact.find("sips") || string::npos != contact.find("tls") ;

            if( externalIp.length() ) {
                DR_LOG(log_info) << "DrachtioController::run: adding additional internal sip address " << contact << " (external address: " << externalIp << ")" ;                
            }
            else {
                DR_LOG(log_info) << "DrachtioController::run: adding additional sip address " << contact  ;                
            }

            (*it)->getBindableContactUri(newUrl) ;

            rv = nta_agent_add_tport(m_nta, URL_STRING_MAKE(newUrl.c_str()),
                 TAG_IF( !captureString.empty(), TPTAG_CAPT(captureString.c_str())),
                 TAG_IF( tlsTransport && hasTlsFiles, TPTAG_TLS_CERTIFICATE_KEY_FILE(tlsKeyFile.c_str())),
                 TAG_IF( tlsTransport && hasTlsFiles, TPTAG_TLS_CERTIFICATE_FILE(tlsCertFile.c_str())),
                 TAG_IF( tlsTransport && hasTlsFiles && !tlsChainFile.empty(), TPTAG_TLS_CERTIFICATE_CHAIN_FILE(tlsChainFile.c_str())),
                 TAG_IF( tlsTransport &&hasTlsFiles, 
                    TPTAG_TLS_VERSION( tlsVersionTagValue )),
                 TAG_NULL(),
                 TAG_END() ) ;

            if( rv < 0 ) {
                DR_LOG(log_error) << "DrachtioController::run: Error adding additional transport"  ;
                return ;            
            }
            SipTransport::addTransports(*it, m_mtu) ;
        }

        SipTransport::logTransports() ;

        m_pDialogController = std::make_shared<SipDialogController>( this, &m_clone ) ;
        m_pProxyController = std::make_shared<SipProxyController>( this, &m_clone ) ;
        m_pPendingRequestController = std::make_shared<PendingRequestController>( this ) ;

        // set sip timers
        unsigned int t1, t2, t4, t1x64 ;
        m_Config->getTimers( t1, t2, t4, t1x64 ); 
        DR_LOG(log_debug) << "DrachtioController::run - sip timers: T1: " << std::dec << t1 << "ms, T2: " << t2 << "ms, T4: " << t4 << "ms, T1X64: " << t1x64 << "ms";        
        nta_agent_set_params(m_nta,
            NTATAG_SIP_T1(t1),
            NTATAG_SIP_T2(t2),
            NTATAG_SIP_T4(t4),
            NTATAG_SIP_T1X64(t1x64),
            TAG_END()
        ) ;
    
        /* sofia event loop */
        DR_LOG(log_notice) << "Starting sofia event loop in main thread: " <<  std::this_thread::get_id()  ;

        /* start a timer */
        m_timer = su_timer_create( su_root_task(m_root), 30000) ;
        su_timer_set_for_ever(m_timer, watchdogTimerHandler, this) ;
 
        su_root_run( m_root ) ;
        DR_LOG(log_notice) << "Sofia event loop ended"  ;
        
        su_root_destroy( m_root ) ;
        m_root = NULL ;
        su_home_unref( m_home ) ;
        su_deinit() ;

        m_Config.reset();
        this->deinitializeLogging() ;

        
    }
