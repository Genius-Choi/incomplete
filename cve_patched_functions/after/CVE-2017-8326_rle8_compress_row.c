static int rle8_compress_row(struct rle_context *rlectx)
{
	size_t i;
	iw_byte dstbuf[2];
	iw_byte next_byte;
	int next_pix_is_trns;
	int num_trns = 0; // number of consecutive transparent pixels seen
	int retval = 0;

	rlectx->pending_data_start=0;
	rlectx->unc_len=0;
	rlectx->run_len=0;

	for(i=0;i<rlectx->img_width;i++) {

		// Read the next byte.
		next_byte = rlectx->srcrow[i];

		next_pix_is_trns = (rlectx->wctx->pal->entry[next_byte].a==0);

		if(num_trns>0 && !next_pix_is_trns) {
			rle_write_trns(rlectx,num_trns);
			num_trns=0;
		}
		else if(next_pix_is_trns) {
			if (rlectx->unc_len>0 || rlectx->run_len>0) {
				rle8_write_unc_and_run(rlectx);
			}
			num_trns++;
			continue;
		}

		// --------------------------------------------------------------
		// Add the byte we just read to either the UNC or the RUN data.

		if(rlectx->run_len>0 && next_byte==rlectx->run_byte) {
			// Byte fits in the current run; add it.
			rlectx->run_len++;
		}
		else if(rlectx->run_len==0) {
			// We don't have a RUN, so we can put this byte there.
			rlectx->run_len = 1;
			rlectx->run_byte = next_byte;
		}
		else if(rlectx->unc_len==0 && rlectx->run_len==1) {
			// We have one previous byte, and it's different from this one.
			// Move it to UNC, and make this one the RUN.
			rlectx->unc_len++;
			rlectx->run_byte = next_byte;
		}
		else if(rlectx->unc_len>0 && rlectx->run_len<(rlectx->unc_len==1 ? 3U : 4U)) {
			// We have a run, but it's not long enough to be beneficial.
			// Convert it to uncompressed bytes.
			// A good rule is that a run length of 4 or more (3 or more if
			// unc_len=1) should always be run-legth encoded.
			rlectx->unc_len += rlectx->run_len;
			rlectx->run_len = 0;
			// If UNC is now odd and >1, add the next byte to it to make it even.
			// Otherwise, add it to RUN.
			if(rlectx->unc_len>=3 && (rlectx->unc_len&0x1)) {
				rlectx->unc_len++;
			}
			else {
				rlectx->run_len = 1;
				rlectx->run_byte = next_byte;
			}
		}
		else {
			// Nowhere to put the byte: write out everything, and start fresh.
			rle8_write_unc_and_run(rlectx);
			rlectx->run_len = 1;
			rlectx->run_byte = next_byte;
		}

		// --------------------------------------------------------------
		// If we hit certain high water marks, write out the current data.

		if(rlectx->unc_len>=254) {
			// Our maximum size for an UNC segment.
			rle8_write_unc(rlectx);
		}
		else if(rlectx->unc_len>0 && (rlectx->unc_len+rlectx->run_len)>254) {
			// It will not be possible to coalesce the RUN into the UNC (it
			// would be too big) so write out the UNC.
			rle8_write_unc(rlectx);
		}
		else if(rlectx->run_len>=255) {
			// The maximum size for an RLE segment.
			rle8_write_unc_and_run(rlectx);
		}

		// --------------------------------------------------------------
		// Sanity checks. These can be removed if we're sure the algorithm
		// is bug-free.

		// We don't allow unc_len to be odd (except temporarily), except
		// that it can be 1.
		// What's special about 1 is that if we add another byte to it, it
		// increases the cost. For 3,5,...,253, we can add another byte for
		// free, so we should never fail to do that.
		if((rlectx->unc_len&0x1) && rlectx->unc_len!=1) {
			iw_set_errorf(rlectx->ctx,"Internal: BMP RLE encode error 1");
			goto done;
		}

		// unc_len can be at most 252 at this point.
		// If it were 254, it should have been written out already.
		if(rlectx->unc_len>252) {
			iw_set_error(rlectx->ctx,"Internal: BMP RLE encode error 2");
			goto done;
		}

		// run_len can be at most 254 at this point.
		// If it were 255, it should have been written out already.
		if(rlectx->run_len>254) {
			iw_set_error(rlectx->ctx,"Internal: BMP RLE encode error 3");
			goto done;
		}
	}

	// End of row. Write out anything left over.
	rle8_write_unc_and_run(rlectx);

	// Write an end-of-line marker (0 0), or if this is the last row,
	// an end-of-bitmap marker (0 1).
	dstbuf[0]=0x00;
	dstbuf[1]= (rlectx->cur_row==0)? 0x01 : 0x00;
	iwbmp_write(rlectx->wctx,dstbuf,2);
	rlectx->total_bytes_written+=2;

	retval = 1;

done:
	return retval;
}
