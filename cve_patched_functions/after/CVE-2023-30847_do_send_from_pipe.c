static void do_send_from_pipe(struct rp_generator_t *self)
{
    h2o_send_state_t send_state = self->had_body_error ? H2O_SEND_STATE_ERROR
                                  : self->res_done     ? H2O_SEND_STATE_FINAL
                                                       : H2O_SEND_STATE_IN_PROGRESS;

    if (self->body_bytes_read == self->body_bytes_sent) {
        if (h2o_send_state_is_in_progress(send_state)) {
            /* resume reading only when we know that the pipe (to which we read) has become empty */
            self->client->update_window(self->client);
        } else {
            h2o_send(self->src_req, NULL, 0, send_state);
        }
        return;
    }

    static const h2o_sendvec_callbacks_t callbacks = {.read_ = from_pipe_read, .send_ = from_pipe_send};
    h2o_sendvec_t vec = {.callbacks = &callbacks};
    if ((vec.len = self->body_bytes_read - self->body_bytes_sent) > H2O_PULL_SENDVEC_MAX_SIZE)
        vec.len = H2O_PULL_SENDVEC_MAX_SIZE;
    vec.cb_arg[0] = (uint64_t)self;
    vec.cb_arg[1] = 0; /* unused */

    self->body_bytes_sent += vec.len;
    self->pipe_inflight = 1;
    h2o_sendvec(self->src_req, &vec, 1, send_state);
}
