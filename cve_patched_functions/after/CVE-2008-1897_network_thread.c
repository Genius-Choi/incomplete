static void *network_thread(void *ignore)
{
	/* Our job is simple: Send queued messages, retrying if necessary.  Read frames 
	   from the network, and queue them for delivery to the channels */
	int res, count, wakeup;
	struct iax_frame *f;

	if (timingfd > -1)
		ast_io_add(io, timingfd, timing_read, AST_IO_IN | AST_IO_PRI, NULL);
	
	for(;;) {
		pthread_testcancel();

		/* Go through the queue, sending messages which have not yet been
		   sent, and scheduling retransmissions if appropriate */
		AST_LIST_LOCK(&frame_queue);
		count = 0;
		wakeup = -1;
		AST_LIST_TRAVERSE_SAFE_BEGIN(&frame_queue, f, list) {
			if (f->sentyet)
				continue;
			
			/* Try to lock the pvt, if we can't... don't fret - defer it till later */
			if (ast_mutex_trylock(&iaxsl[f->callno])) {
				wakeup = 1;
				continue;
			}

			f->sentyet = 1;

			if (iaxs[f->callno]) {
				send_packet(f);
				count++;
			} 

			ast_mutex_unlock(&iaxsl[f->callno]);

			if (f->retries < 0) {
				/* This is not supposed to be retransmitted */
				AST_LIST_REMOVE_CURRENT(list);
				/* Free the iax frame */
				iax_frame_free(f);
			} else {
				/* We need reliable delivery.  Schedule a retransmission */
				f->retries++;
				f->retrans = iax2_sched_add(sched, f->retrytime, attempt_transmit, f);
			}
		}
		AST_LIST_TRAVERSE_SAFE_END;
		AST_LIST_UNLOCK(&frame_queue);

		pthread_testcancel();
		if (count >= 20)
			ast_debug(1, "chan_iax2: Sent %d queued outbound frames all at once\n", count);

		/* Now do the IO, and run scheduled tasks */
		res = ast_io_wait(io, wakeup);
		if (res >= 0) {
			if (res >= 20)
				ast_debug(1, "chan_iax2: ast_io_wait ran %d I/Os all at once\n", res);
		}
	}
	return NULL;
}
