static int tls_new_record ( struct tls_connection *tls, unsigned int type,
			    struct list_head *rx_data ) {
	struct io_buffer *iobuf;
	int ( * handler ) ( struct tls_connection *tls, const void *data,
			    size_t len );
	int rc;

	/* Deliver data records to the plainstream interface */
	if ( type == TLS_TYPE_DATA ) {

		/* Fail unless we are ready to receive data */
		if ( ! tls_ready ( tls ) )
			return -ENOTCONN;

		/* Deliver each I/O buffer in turn */
		while ( ( iobuf = list_first_entry ( rx_data, struct io_buffer,
						     list ) ) ) {
			list_del ( &iobuf->list );
			if ( ( rc = xfer_deliver_iob ( &tls->plainstream,
						       iobuf ) ) != 0 ) {
				DBGC ( tls, "TLS %p could not deliver data: "
				       "%s\n", tls, strerror ( rc ) );
				return rc;
			}
		}
		return 0;
	}

	/* For all other records, merge into a single I/O buffer */
	iobuf = iob_concatenate ( rx_data );
	if ( ! iobuf ) {
		DBGC ( tls, "TLS %p could not concatenate non-data record "
		       "type %d\n", tls, type );
		return -ENOMEM_RX_CONCAT;
	}

	/* Determine handler */
	switch ( type ) {
	case TLS_TYPE_CHANGE_CIPHER:
		handler = tls_new_change_cipher;
		break;
	case TLS_TYPE_ALERT:
		handler = tls_new_alert;
		break;
	case TLS_TYPE_HANDSHAKE:
		handler = tls_new_handshake;
		break;
	default:
		/* RFC4346 says that we should just ignore unknown
		 * record types.
		 */
		handler = NULL;
		DBGC ( tls, "TLS %p ignoring record type %d\n", tls, type );
		break;
	}

	/* Handle record and free I/O buffer */
	rc = ( handler ? handler ( tls, iobuf->data, iob_len ( iobuf ) ) : 0 );
	free_iob ( iobuf );
	return rc;
}
