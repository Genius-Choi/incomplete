static int __unload_module(void)
{
	struct iax2_thread *thread = NULL;
	struct ast_context *con;
	int x;

	/* Make sure threads do not hold shared resources when they are canceled */
	
	/* Grab the sched lock resource to keep it away from threads about to die */
	/* Cancel the network thread, close the net socket */
	if (netthreadid != AST_PTHREADT_NULL) {
		AST_LIST_LOCK(&frame_queue);
		ast_mutex_lock(&sched_lock);
		pthread_cancel(netthreadid);
		ast_cond_signal(&sched_cond);
		ast_mutex_unlock(&sched_lock);	/* Release the schedule lock resource */
		AST_LIST_UNLOCK(&frame_queue);
		pthread_join(netthreadid, NULL);
	}
	if (schedthreadid != AST_PTHREADT_NULL) {
		ast_mutex_lock(&sched_lock);
		pthread_cancel(schedthreadid);
		ast_cond_signal(&sched_cond);
		ast_mutex_unlock(&sched_lock);
		pthread_join(schedthreadid, NULL);
	}

	/* Call for all threads to halt */
	AST_LIST_LOCK(&idle_list);
	while ((thread = AST_LIST_REMOVE_HEAD(&idle_list, list)))
		pthread_cancel(thread->threadid);
	AST_LIST_UNLOCK(&idle_list);

	AST_LIST_LOCK(&active_list);
	while ((thread = AST_LIST_REMOVE_HEAD(&active_list, list)))
		pthread_cancel(thread->threadid);
	AST_LIST_UNLOCK(&active_list);

	AST_LIST_LOCK(&dynamic_list);
	while ((thread = AST_LIST_REMOVE_HEAD(&dynamic_list, list)))
		pthread_cancel(thread->threadid);
	AST_LIST_UNLOCK(&dynamic_list);
	
	/* Wait for threads to exit */
	while(0 < iaxactivethreadcount)
		usleep(10000);
	
	ast_netsock_release(netsock);
	ast_netsock_release(outsock);
	for (x = 0; x < IAX_MAX_CALLS; x++) {
		if (iaxs[x])
			iax2_destroy(x);
	}
	ast_manager_unregister( "IAXpeers" );
	ast_manager_unregister( "IAXpeerlist" );
	ast_manager_unregister( "IAXnetstats" );
	ast_unregister_application(papp);
	ast_cli_unregister_multiple(cli_iax2, sizeof(cli_iax2) / sizeof(struct ast_cli_entry));
	ast_unregister_switch(&iax2_switch);
	ast_channel_unregister(&iax2_tech);
	delete_users();
	iax_provision_unload();
	sched_context_destroy(sched);
	reload_firmware(1);

	for (x = 0; x < IAX_MAX_CALLS; x++)
		ast_mutex_destroy(&iaxsl[x]);

	ao2_ref(peers, -1);
	ao2_ref(users, -1);
	
	con = ast_context_find(regcontext);
	if (con)
		ast_context_destroy(con, "IAX2");
	
	return 0;
}
