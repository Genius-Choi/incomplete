static uint32_t get_hclk(void) {
  struct rcc {
    volatile uint32_t CR, HSICFGR, CRRCR, CSICFGR, CFGR, RESERVED1, D1CFGR,
        D2CFGR, D3CFGR, RESERVED2, PLLCKSELR, PLLCFGR, PLL1DIVR, PLL1FRACR,
        PLL2DIVR, PLL2FRACR, PLL3DIVR, PLL3FRACR, RESERVED3, D1CCIPR, D2CCIP1R,
        D2CCIP2R, D3CCIPR, RESERVED4, CIER, CIFR, CICR, RESERVED5, BDCR, CSR,
        RESERVED6, AHB3RSTR, AHB1RSTR, AHB2RSTR, AHB4RSTR, APB3RSTR, APB1LRSTR,
        APB1HRSTR, APB2RSTR, APB4RSTR, GCR, RESERVED8, D3AMR, RESERVED11[9],
        RSR, AHB3ENR, AHB1ENR, AHB2ENR, AHB4ENR, APB3ENR, APB1LENR, APB1HENR,
        APB2ENR, APB4ENR, RESERVED12, AHB3LPENR, AHB1LPENR, AHB2LPENR,
        AHB4LPENR, APB3LPENR, APB1LLPENR, APB1HLPENR, APB2LPENR, APB4LPENR,
        RESERVED13[4];
  } *rcc = ((struct rcc *) (0x40000000 + 0x18020000 + 0x4400));
  uint32_t clk = 0, hsi = 64000000 /* 64 MHz */, hse = 8000000 /* 8MHz */,
           csi = 4000000 /* 4MHz */;
  unsigned int sel = (rcc->CFGR & (7 << 3)) >> 3;

  if (sel == 1) {
    clk = csi;
  } else if (sel == 2) {
    clk = hse;
  } else if (sel == 3) {
    uint32_t vco, m, n, p;
    unsigned int src = (rcc->PLLCKSELR & (3 << 0)) >> 0;
    m = ((rcc->PLLCKSELR & (0x3F << 4)) >> 4);
    n = ((rcc->PLL1DIVR & (0x1FF << 0)) >> 0) + 1 +
        ((rcc->PLLCFGR & BIT(0)) ? 1 : 0);  // round-up in fractional mode
    p = ((rcc->PLL1DIVR & (0x7F << 9)) >> 9) + 1;
    if (src == 1) {
      clk = csi;
    } else if (src == 2) {
      clk = hse;
    } else {
      clk = hsi;
      clk >>= ((rcc->CR & 3) >> 3);
    }
    vco = (uint32_t) ((uint64_t) clk * n / m);
    clk = vco / p;
  } else {
    clk = hsi;
    clk >>= ((rcc->CR & 3) >> 3);
  }
  const uint8_t cptab[12] = {1, 2, 3, 4, 6, 7, 8, 9};  // log2(div)
  uint32_t d1cpre = (rcc->D1CFGR & (0x0F << 8)) >> 8;
  if (d1cpre >= 8) clk >>= cptab[d1cpre - 8];
  MG_DEBUG(("D1 CLK: %u", clk));
  uint32_t hpre = (rcc->D1CFGR & (0x0F << 0)) >> 0;
  if (hpre < 8) return clk;
  return ((uint32_t) clk) >> cptab[hpre - 8];
}
