static pj_status_t transport_restart(pj_bool_t is_rtp, 
                                     struct transport_udp *udp)
{
    PJ_UNUSED_ARG(udp);
    PJ_UNUSED_ARG(is_rtp);

    return PJ_ENOTSUP;

/* This code is disabled for the following reason (see also #2881):
 * The following code will set ioqueue key to NULL or replace with a new one,
 * and that may introduces issues, e.g:
 * - this code is invoked from on_rx_rtp/rtcp(), which is invoked by
 *   ioqueue_dispatch_read_event(), which may need to unlock ioqueue key
 *   after returning from the callback (when allow_concurrent is false),
 *   if the ioqueue key has been unregistered by this code, a crash may occur
 *   when unlocking the invalid ioqueue key.
 * - this code may set ioqueue key to NULL, while other code may assume
 *   it may never be changed to NULL, and cause crash, e.g: transport_detach().
 */
#if 0

    pj_ioqueue_key_t *key = (is_rtp ? udp->rtp_key : udp->rtcp_key);
    pj_sock_t *sock = (is_rtp ? &udp->rtp_sock : &udp->rtcp_sock);
    pj_status_t status;
    int af;
    pj_sockaddr *addr;
    pj_ioqueue_callback cb;
    pj_ssize_t size;

    PJ_LOG(4, (udp->base.name, "Restarting %s transport", 
              (is_rtp)?"RTP":"RTCP"));

    udp->started = PJ_FALSE;
    /* Destroy existing socket, if any. */    
    if (key) {
        /* This will block the execution if callback is still
         * being called.
         */
        pj_ioqueue_unregister(key);
        if (is_rtp) {
            udp->rtp_key = NULL;
        } else {
            udp->rtcp_key = NULL;
        }
    } else if (*sock != PJ_INVALID_SOCKET) {
        pj_sock_close(*sock);
    }
    *sock = PJ_INVALID_SOCKET;   

    /* Create socket */
    af = udp->rtp_addr_name.addr.sa_family;
    status = pj_sock_socket(af, pj_SOCK_DGRAM(), 0, sock);

    if (status != PJ_SUCCESS)
        goto on_error;

    addr = (is_rtp) ? &udp->rtp_addr_name : &udp->rtcp_addr_name;
    status = pj_sock_bind(*sock, addr, pj_sockaddr_get_len(addr));
    if (status != PJ_SUCCESS)
        goto on_error;

    /* Set buffer size for RTP socket */
#if PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE
    if (is_rtp) {
        unsigned sobuf_size = PJMEDIA_TRANSPORT_SO_RCVBUF_SIZE;

        pj_sock_setsockopt_sobuf(udp->rtp_sock, pj_SO_RCVBUF(), 
                                 PJ_TRUE, &sobuf_size);
    }
#endif
#if PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE
    if (is_rtp) {
        unsigned sobuf_size = PJMEDIA_TRANSPORT_SO_SNDBUF_SIZE;

        pj_sock_setsockopt_sobuf(udp->rtp_sock, pj_SO_SNDBUF(), 
                                 PJ_TRUE, &sobuf_size);
    }
#endif
    pj_bzero(&cb, sizeof(cb));
    if (is_rtp) {
        cb.on_read_complete = &on_rx_rtp;
        cb.on_write_complete = &on_rtp_data_sent;
    } else {
        cb.on_read_complete = &on_rx_rtcp;
    }

    if (is_rtp) {
        status = pj_ioqueue_register_sock(udp->pool, udp->ioqueue, *sock, udp,
                                          &cb, &udp->rtp_key);
    } else {
        status = pj_ioqueue_register_sock(udp->pool, udp->ioqueue, *sock, udp,
                                          &cb, &udp->rtcp_key);    
    }

    if (status != PJ_SUCCESS)
        goto on_error;

    if (is_rtp) {
        size = sizeof(udp->rtp_pkt);
        status = pj_ioqueue_recvfrom(udp->rtp_key, &udp->rtp_read_op,
                                     udp->rtp_pkt, &size, 
                                     PJ_IOQUEUE_ALWAYS_ASYNC,
                                     &udp->rtp_src_addr, &udp->rtp_addrlen);
    } else {
        size = sizeof(udp->rtcp_pkt);
        status = pj_ioqueue_recvfrom(udp->rtcp_key, &udp->rtcp_read_op,
                                     udp->rtcp_pkt, &size, 
                                     PJ_IOQUEUE_ALWAYS_ASYNC,
                                     &udp->rtcp_src_addr, &udp->rtcp_addr_len);
    }
    if (status != PJ_EPENDING)
        goto on_error;

    udp->started = PJ_TRUE;
    PJ_LOG(4, (udp->base.name, "Success restarting %s transport", 
              (is_rtp)?"RTP":"RTCP"));
    return PJ_SUCCESS;
on_error:
    if (*sock != PJ_INVALID_SOCKET) {
        pj_sock_close(*sock);
        *sock = PJ_INVALID_SOCKET;
    }
    PJ_PERROR(1, (udp->base.name, status, 
                 "Error restarting %s transport", (is_rtp)?"RTP":"RTCP"));
    return status;

#endif
}
