captureProcessOutput(const std::string &executable,
                     const std::vector<std::string> &args) {
  auto commandLine = "\"" + executable + "\"";
  for (const auto &arg : args) {
    commandLine += " " + arg;
  }

  LOG.info(std::format("Command Line: {}", commandLine));

  STARTUPINFOA startupInfo;
  PROCESS_INFORMATION processInfo;

  ZeroMemory(&startupInfo, sizeof(startupInfo));
  startupInfo.cb = sizeof(startupInfo);
  startupInfo.dwFlags |= STARTF_USESTDHANDLES;

  // Create pipes for redirecting child process output
  HANDLE hChildStdoutRd, hChildStdoutWr;
  SECURITY_ATTRIBUTES saAttr;
  ZeroMemory(&saAttr, sizeof(saAttr));
  saAttr.nLength = sizeof(saAttr);
  saAttr.bInheritHandle = TRUE;
  CreatePipe(&hChildStdoutRd, &hChildStdoutWr, &saAttr, 0);
  SetHandleInformation(hChildStdoutRd, HANDLE_FLAG_INHERIT, 0);
  startupInfo.hStdOutput = hChildStdoutWr;
  startupInfo.hStdError = hChildStdoutWr;

  ZeroMemory(&processInfo, sizeof(processInfo));
  auto *lpCommandLine = const_cast<char *>(commandLine.c_str());

  if (!CreateProcessA(NULL, lpCommandLine, NULL, NULL, TRUE, 0, NULL, NULL,
                      &startupInfo, &processInfo)) {
    LPSTR messageBuffer = nullptr;
    auto lastError = GetLastError();
    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |
                       FORMAT_MESSAGE_IGNORE_INSERTS,
                   NULL, lastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                   (LPSTR)&messageBuffer, 0, NULL);
    LOG.error(std::format("Failed to create process. Error code: 0x{:x}: {}",
                          lastError, messageBuffer));
    LocalFree(messageBuffer);
    return std::nullopt;
  }

  CloseHandle(hChildStdoutWr);
  char buffer[128];
  DWORD bytesRead;
  std::string output;
  while (ReadFile(hChildStdoutRd, buffer, sizeof(buffer), &bytesRead, NULL) &&
         bytesRead != 0) {
    output.append(buffer, bytesRead);

    DWORD bytesAvail = 0;
    if (!PeekNamedPipe(hChildStdoutRd, NULL, 0, NULL, &bytesAvail, NULL)) {
      LOG.error("Failed to call PeekNamedPipe");
    }
    if (!bytesAvail) {
      auto ret = WaitForSingleObject(processInfo.hProcess, 1000);
      if (ret == WAIT_OBJECT_0) {
        break;
      }
    }
  }
  WaitForSingleObject(processInfo.hProcess, INFINITE);

  CloseHandle(processInfo.hProcess);
  CloseHandle(processInfo.hThread);
  CloseHandle(hChildStdoutRd);

  return output;
}
