static void lan78xx_tx_bh(struct lan78xx_net *dev)
{
	int ret;

	/* Start the stack Tx queue if it was stopped
	 */
	netif_tx_lock(dev->net);
	if (netif_queue_stopped(dev->net)) {
		if (lan78xx_tx_pend_data_len(dev) < lan78xx_tx_urb_space(dev))
			netif_wake_queue(dev->net);
	}
	netif_tx_unlock(dev->net);

	/* Go through the Tx pending queue and set up URBs to transfer
	 * the data to the device. Stop if no more pending data or URBs,
	 * or if an error occurs when a URB is submitted.
	 */
	do {
		struct skb_data *entry;
		struct sk_buff *tx_buf;
		unsigned long flags;

		if (skb_queue_empty(&dev->txq_pend))
			break;

		tx_buf = lan78xx_get_tx_buf(dev);
		if (!tx_buf)
			break;

		entry = lan78xx_tx_buf_fill(dev, tx_buf);

		spin_lock_irqsave(&dev->txq.lock, flags);
		ret = usb_autopm_get_interface_async(dev->intf);
		if (ret < 0) {
			spin_unlock_irqrestore(&dev->txq.lock, flags);
			goto out;
		}

		usb_fill_bulk_urb(entry->urb, dev->udev, dev->pipe_out,
				  tx_buf->data, tx_buf->len, tx_complete,
				  tx_buf);

		if (tx_buf->len % dev->maxpacket == 0) {
			/* send USB_ZERO_PACKET */
			entry->urb->transfer_flags |= URB_ZERO_PACKET;
		}

#ifdef CONFIG_PM
		/* if device is asleep stop outgoing packet processing */
		if (test_bit(EVENT_DEV_ASLEEP, &dev->flags)) {
			usb_anchor_urb(entry->urb, &dev->deferred);
			netif_stop_queue(dev->net);
			spin_unlock_irqrestore(&dev->txq.lock, flags);
			netdev_dbg(dev->net,
				   "Delaying transmission for resumption\n");
			return;
		}
#endif
		ret = usb_submit_urb(entry->urb, GFP_ATOMIC);
		switch (ret) {
		case 0:
			netif_trans_update(dev->net);
			lan78xx_queue_skb(&dev->txq, tx_buf, tx_start);
			break;
		case -EPIPE:
			netif_stop_queue(dev->net);
			lan78xx_defer_kevent(dev, EVENT_TX_HALT);
			usb_autopm_put_interface_async(dev->intf);
			break;
		case -ENODEV:
		case -ENOENT:
			netif_dbg(dev, tx_err, dev->net,
				  "tx submit urb err %d (disconnected?)", ret);
			netif_device_detach(dev->net);
			break;
		default:
			usb_autopm_put_interface_async(dev->intf);
			netif_dbg(dev, tx_err, dev->net,
				  "tx submit urb err %d\n", ret);
			break;
		}

		spin_unlock_irqrestore(&dev->txq.lock, flags);

		if (ret) {
			netdev_warn(dev->net, "failed to tx urb %d\n", ret);
out:
			dev->net->stats.tx_dropped += entry->num_of_packet;
			lan78xx_release_tx_buf(dev, tx_buf);
		}
	} while (ret == 0);
}
