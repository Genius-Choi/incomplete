static pj_status_t verify_ice_sdp(struct transport_ice *tp_ice,
                                  pj_pool_t *tmp_pool,
                                  const pjmedia_sdp_session *rem_sdp,
                                  unsigned media_index,
                                  pj_ice_sess_role current_ice_role,
                                  struct sdp_state *sdp_state)
{
    const pjmedia_sdp_media *rem_m;
    const pjmedia_sdp_attr *ufrag_attr, *pwd_attr;
    const pjmedia_sdp_conn *rem_conn;
    pj_bool_t comp1_found=PJ_FALSE, comp2_found=PJ_FALSE, has_rtcp=PJ_FALSE;
    pj_sockaddr rem_conn_addr, rtcp_addr;
    unsigned i;
    int rem_af = 0;
    pj_status_t status;

    rem_m = rem_sdp->media[media_index];

    /* Check if remote wants RTCP mux */
    if (tp_ice->enable_rtcp_mux) {
        pjmedia_sdp_attr *attr;

        attr = pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr, 
                                     &STR_RTCP_MUX, NULL);
        tp_ice->use_rtcp_mux = (attr? PJ_TRUE: PJ_FALSE);
    }

    /* Get the "ice-ufrag" and "ice-pwd" attributes */
    get_ice_attr(rem_sdp, rem_m, &ufrag_attr, &pwd_attr);

    /* If "ice-ufrag" or "ice-pwd" are not found, disable ICE */
    if (ufrag_attr==NULL || pwd_attr==NULL) {
        sdp_state->match_comp_cnt = 0;
        return PJ_SUCCESS;
    }

    /* Verify that default target for each component matches one of the 
     * candidate for the component. Otherwise stop ICE with ICE ice_mismatch 
     * error.
     */

    /* Component 1 is the c= line */
    rem_conn = rem_m->conn;
    if (rem_conn == NULL)
        rem_conn = rem_sdp->conn;
    if (!rem_conn)
        return PJMEDIA_SDP_EMISSINGCONN;

    /* Verify address family matches */
    /*
    if ((tp_ice->af==pj_AF_INET() && 
         pj_strcmp(&rem_conn->addr_type, &STR_IP4)!=0) ||
        (tp_ice->af==pj_AF_INET6() && 
         pj_strcmp(&rem_conn->addr_type, &STR_IP6)!=0))
    {
        return PJMEDIA_SDP_ETPORTNOTEQUAL;
    }
    */

    /* Get remote address family */
    if (pj_strcmp(&rem_conn->addr_type, &STR_IP4)==0)
        rem_af = pj_AF_INET();
    else if (pj_strcmp(&rem_conn->addr_type, &STR_IP6)==0)
        rem_af = pj_AF_INET6();
    else
        pj_assert(!"Unsupported address family");

    /* Assign remote connection address */
    status = pj_sockaddr_init(rem_af, &rem_conn_addr, &rem_conn->addr,
                              (pj_uint16_t)rem_m->desc.port);
    if (status != PJ_SUCCESS)
        return status;

    if (tp_ice->comp_cnt > 1) {
        const pjmedia_sdp_attr *attr;

        /* Get default RTCP candidate from a=rtcp line, if present, otherwise
         * calculate default RTCP candidate from default RTP target.
         */
        attr = pjmedia_sdp_attr_find(rem_m->attr_count, rem_m->attr, 
                                     &STR_RTCP, NULL);
        has_rtcp = (attr != NULL);

        if (attr) {
            pjmedia_sdp_rtcp_attr rtcp_attr;

            status = pjmedia_sdp_attr_get_rtcp(attr, &rtcp_attr);
            if (status != PJ_SUCCESS) {
                /* Error parsing a=rtcp attribute */
                return status;
            }
        
            if (rtcp_attr.addr.slen) {
                /* Verify address family matches */
                /*
                if ((tp_ice->af==pj_AF_INET() && 
                     pj_strcmp(&rtcp_attr.addr_type, &STR_IP4)!=0) ||
                    (tp_ice->af==pj_AF_INET6() && 
                     pj_strcmp(&rtcp_attr.addr_type, &STR_IP6)!=0))
                {
                    return PJMEDIA_SDP_ETPORTNOTEQUAL;
                }
                */

                /* Assign RTCP address */
                status = pj_sockaddr_init(rem_af, &rtcp_addr,
                                          &rtcp_attr.addr,
                                          (pj_uint16_t)rtcp_attr.port);
                if (status != PJ_SUCCESS) {
                    return PJMEDIA_SDP_EINRTCP;
                }
            } else {
                /* Assign RTCP address */
                status = pj_sockaddr_init(rem_af, &rtcp_addr, 
                                          NULL, 
                                          (pj_uint16_t)rtcp_attr.port);
                if (status != PJ_SUCCESS) {
                    return PJMEDIA_SDP_EINRTCP;
                }
                pj_sockaddr_copy_addr(&rtcp_addr, &rem_conn_addr);
            }
        } else {
            unsigned rtcp_port;
        
            rtcp_port = pj_sockaddr_get_port(&rem_conn_addr) + 1;
            pj_sockaddr_cp(&rtcp_addr, &rem_conn_addr);
            pj_sockaddr_set_port(&rtcp_addr, (pj_uint16_t)rtcp_port);
        }
    }

    /* Find the default addresses in a=candidate attributes. 
     */
    for (i=0; i<rem_m->attr_count; ++i) {
        pj_ice_sess_cand cand;
        unsigned disable_ice_mismatch = tp_ice->options &
                                        PJMEDIA_ICE_DISABLE_ICE_MISMATCH;

        if (pj_strcmp(&rem_m->attr[i]->name, &STR_CANDIDATE)!=0)
            continue;

        status = parse_cand(tp_ice->base.name, tmp_pool, 
                            &rem_m->attr[i]->value, &cand);
        if (status != PJ_SUCCESS) {
            PJ_PERROR(4,(tp_ice->base.name, status,
                         "Error in parsing SDP candidate attribute '%.*s', "
                         "candidate is ignored",
                         (int)rem_m->attr[i]->value.slen, 
                         rem_m->attr[i]->value.ptr));
            continue;
        }

        if (!comp1_found && cand.comp_id==COMP_RTP)
        {
            if ((disable_ice_mismatch) ||
                (pj_sockaddr_cmp(&rem_conn_addr, &cand.addr) == 0))
            {
                comp1_found = PJ_TRUE;
            }
        } else if (!comp2_found && cand.comp_id==COMP_RTCP)
        {
            if ((disable_ice_mismatch) ||
                (pj_sockaddr_cmp(&rtcp_addr, &cand.addr) == 0))
            {
                comp2_found = PJ_TRUE;
            }
        }

        if (cand.comp_id == COMP_RTCP)
            has_rtcp = PJ_TRUE;

        if (comp1_found && (comp2_found || tp_ice->comp_cnt==1))
            break;
    }

    /* Check matched component count and ice_mismatch */
    if (comp1_found &&
        (tp_ice->comp_cnt==1 || !has_rtcp || tp_ice->use_rtcp_mux))
    {
        sdp_state->match_comp_cnt = 1;
        sdp_state->ice_mismatch = PJ_FALSE;
    } else if (comp1_found && comp2_found) {
        sdp_state->match_comp_cnt = 2;
        sdp_state->ice_mismatch = PJ_FALSE;
    } else {
        sdp_state->match_comp_cnt = (tp_ice->comp_cnt > 1 && has_rtcp)? 2 : 1;
        sdp_state->ice_mismatch = PJ_TRUE;
    }


    /* Detect remote restarting session */
    if (pj_ice_strans_has_sess(tp_ice->ice_st) &&
        (pj_ice_strans_sess_is_running(tp_ice->ice_st) ||
         pj_ice_strans_sess_is_complete(tp_ice->ice_st))) 
    {
        pj_str_t rem_run_ufrag, rem_run_pwd;
        pj_ice_strans_get_ufrag_pwd(tp_ice->ice_st, NULL, NULL,
                                    &rem_run_ufrag, &rem_run_pwd);
        if (pj_strcmp(&ufrag_attr->value, &rem_run_ufrag) ||
            pj_strcmp(&pwd_attr->value, &rem_run_pwd))
        {
            /* Remote offers to restart ICE */
            sdp_state->ice_restart = PJ_TRUE;
        } else {
            sdp_state->ice_restart = PJ_FALSE;
        }
    } else {
        sdp_state->ice_restart = PJ_FALSE;
    }

    /* Detect our role */
    if (pjmedia_sdp_attr_find(rem_sdp->attr_count, rem_sdp->attr,
                              &STR_ICE_LITE, NULL) != NULL)
    {
        /* Remote is ICE lite, set our role as controlling */
        sdp_state->local_role = PJ_ICE_SESS_ROLE_CONTROLLING;
    } else {
        if (current_ice_role==PJ_ICE_SESS_ROLE_CONTROLLING) {
            sdp_state->local_role = PJ_ICE_SESS_ROLE_CONTROLLING;
        } else {
            sdp_state->local_role = PJ_ICE_SESS_ROLE_CONTROLLED;
        }
    }

    /* Check trickle ICE indication */
    if (tp_ice->trickle_ice != PJ_ICE_SESS_TRICKLE_DISABLED) {
        sdp_state->has_trickle = pjmedia_ice_sdp_has_trickle(rem_sdp,
                                                             media_index);

        /* Reset ICE mismatch flag if conn addr is default address */
        if (sdp_state->ice_mismatch && sdp_state->has_trickle) {
            pj_sockaddr def_addr;
            pj_sockaddr_init(rem_af, &def_addr, NULL, 9);
            if (pj_sockaddr_cmp(&rem_conn_addr, &def_addr)==0)
                sdp_state->ice_mismatch = PJ_FALSE;
        }
    } else {
        sdp_state->has_trickle = PJ_FALSE;
    }

    PJ_LOG(4,(tp_ice->base.name, 
              "Processing SDP: support ICE=%u, common comp_cnt=%u, "
              "ice_mismatch=%u, ice_restart=%u, local_role=%s, trickle=%u",
              (sdp_state->match_comp_cnt != 0), 
              sdp_state->match_comp_cnt, 
              sdp_state->ice_mismatch, 
              sdp_state->ice_restart,
              pj_ice_sess_role_name(sdp_state->local_role),
              sdp_state->has_trickle));

    return PJ_SUCCESS;

}
