typedArrayPrototypeSlice(void *, Runtime &runtime, NativeArgs args) {
  if (JSTypedArrayBase::validateTypedArray(runtime, args.getThisHandle()) ==
      ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto self = args.vmcastThis<JSTypedArrayBase>();
  double len = self->getLength();
  auto res = toIntegerOrInfinity(runtime, args.getArgHandle(0));
  if (res == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto relativeStart = res->getNumber();
  double relativeEnd = 0;
  if (args.getArg(1).isUndefined()) {
    relativeEnd = len;
  } else {
    res = toIntegerOrInfinity(runtime, args.getArgHandle(1));
    if (res == ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
    relativeEnd = res->getNumber();
  }
  double k = convertNegativeBoundsRelativeToLength(relativeStart, len);
  double last = convertNegativeBoundsRelativeToLength(relativeEnd, len);
  double count = std::max(last - k, 0.0);
  auto status = JSTypedArrayBase::allocateSpecies(runtime, self, count);
  if (status == ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  if (!self->attached(runtime)) {
    // 15b. If IsDetachedBuffer(srcBuffer) is true, throw a TypeError exception.
    return runtime.raiseTypeError(
        "Detached the buffer in the species constructor");
  }
  auto A = status.getValue();
  if (count > 0) {
    JSTypedArrayBase::setToCopyOfTypedArray(runtime, A, 0, self, k, count);
  }
  return A.getHermesValue();
}
