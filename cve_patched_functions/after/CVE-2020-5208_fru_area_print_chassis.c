fru_area_print_chassis(struct ipmi_intf * intf, struct fru_info * fru,
			uint8_t id, uint32_t offset)
{
	char * fru_area;
	uint8_t * fru_data;
	uint32_t fru_len, i;
	uint8_t tmp[2];
	size_t chassis_type;

	fru_len = 0;

	/* read enough to check length field */
	if (read_fru_area(intf, fru, id, offset, 2, tmp) == 0) {
		fru_len = 8 * tmp[1];
	}

	if (fru_len == 0) {
		return;
	}

	fru_data = malloc(fru_len);
	if (!fru_data) {
		lprintf(LOG_ERR, "ipmitool: malloc failure");
		return;
	}

	memset(fru_data, 0, fru_len);

	/* read in the full fru */
	if (read_fru_area(intf, fru, id, offset, fru_len, fru_data) < 0) {
		free_n(&fru_data);
		return;
	}

	/*
	 * skip first two bytes which specify
	 * fru area version and fru area length
	 */
	i = 2;

	chassis_type = (fru_data[i] > ARRAY_SIZE(chassis_type_desc) - 1)
	               ? 2
	               : fru_data[i];
	printf(" Chassis Type          : %s\n", chassis_type_desc[chassis_type]);

 	i++;

	fru_area = get_fru_area_str(fru_data, &i);
	if (fru_area) {
		if (strlen(fru_area) > 0) {
			printf(" Chassis Part Number   : %s\n", fru_area);
		}
		free_n(&fru_area);
	}

	fru_area = get_fru_area_str(fru_data, &i);
	if (fru_area) {
		if (strlen(fru_area) > 0) {
			printf(" Chassis Serial        : %s\n", fru_area);
		}
		free_n(&fru_area);
	}

	/* read any extra fields */
	while ((i < fru_len) && (fru_data[i] != FRU_END_OF_FIELDS)) {
		int j = i;
		fru_area = get_fru_area_str(fru_data, &i);
		if (fru_area) {
			if (strlen(fru_area) > 0) {
				printf(" Chassis Extra         : %s\n", fru_area);
			}
			free_n(&fru_area);
		}

		if (i == j) {
			break;
		}
	}

	free_n(&fru_data);
}
