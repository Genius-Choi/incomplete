PJ_DEF(pj_status_t) pjmedia_ice_add_ice_cb( pjmedia_transport *tp,
                                            const pjmedia_ice_cb *cb,
                                            void *user_data)
{
    struct transport_ice *tp_ice = (struct transport_ice*)tp;
    ice_listener *il;
    pj_grp_lock_t *grp_lock;

    PJ_ASSERT_RETURN(tp && cb, PJ_EINVAL);
    grp_lock = pjmedia_ice_get_grp_lock(tp);
    PJ_ASSERT_RETURN(grp_lock, PJ_EINVAL);

    pj_grp_lock_acquire(grp_lock);

    if (!pj_list_empty(&tp_ice->listener_empty)) {
        il = tp_ice->listener_empty.next;
        pj_list_erase(il);
        il->cb = *cb;
        il->user_data = user_data;
        pj_list_push_back(&tp_ice->listener, il);
    } else {
        il = PJ_POOL_ZALLOC_T(tp_ice->pool, ice_listener);
        pj_list_init(il);
        il->cb = *cb;
        il->user_data = user_data;
        pj_list_push_back(&tp_ice->listener, il);
    }

    pj_grp_lock_release(grp_lock);

    return PJ_SUCCESS;
}
