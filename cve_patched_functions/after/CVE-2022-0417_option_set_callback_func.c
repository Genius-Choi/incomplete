option_set_callback_func(char_u *optval UNUSED, callback_T *optcb UNUSED)
{
#ifdef FEAT_EVAL
    typval_T	*tv;
    callback_T	cb;

    if (optval == NULL || *optval == NUL)
    {
	free_callback(optcb);
	return OK;
    }

    if (*optval == '{' || (in_vim9script() && *optval == '(')
	    || (STRNCMP(optval, "function(", 9) == 0)
	    || (STRNCMP(optval, "funcref(", 8) == 0))
	// Lambda expression or a funcref
	tv = eval_expr(optval, NULL);
    else
	// treat everything else as a function name string
	tv = alloc_string_tv(vim_strsave(optval));
    if (tv == NULL)
	return FAIL;

    cb = get_callback(tv);
    if (cb.cb_name == NULL || *cb.cb_name == NUL)
    {
	free_tv(tv);
	return FAIL;
    }

    free_callback(optcb);
    set_callback(optcb, &cb);
    free_tv(tv);

    // when using Vim9 style "import.funcname" it needs to be expanded to
    // "import#funcname".
    expand_autload_callback(optcb);

    return OK;
#else
    return FAIL;
#endif
}
