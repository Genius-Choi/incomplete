static int nsim_fib4_prepare_event(struct fib_notifier_info *info,
				   struct nsim_fib_event *fib_event,
				   unsigned long event)
{
	struct nsim_fib_data *data = fib_event->data;
	struct fib_entry_notifier_info *fen_info;
	struct netlink_ext_ack *extack;
	int err = 0;

	fen_info = container_of(info, struct fib_entry_notifier_info,
				info);
	fib_event->fen_info = *fen_info;
	extack = info->extack;

	switch (event) {
	case FIB_EVENT_ENTRY_REPLACE:
		err = nsim_fib_account(&data->ipv4.fib, true);
		if (err) {
			NL_SET_ERR_MSG_MOD(extack, "Exceeded number of supported fib entries");
			return err;
		}
		break;
	case FIB_EVENT_ENTRY_DEL:
		nsim_fib_account(&data->ipv4.fib, false);
		break;
	}

	/* Take reference on fib_info to prevent it from being
	 * freed while event is queued. Release it afterwards.
	 */
	fib_info_hold(fib_event->fen_info.fi);

	return 0;
}
