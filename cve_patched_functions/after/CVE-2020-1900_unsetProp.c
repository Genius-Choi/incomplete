void ObjectData::unsetProp(Class* ctx, const StringData* key) {
  auto const lookup = getPropImpl<true, false, true>(ctx, key);
  auto const prop = lookup.val;

  if (prop && lookup.accessible &&
      (type(prop) != KindOfUninit ||
       (lookup.prop && (lookup.prop->attrs & AttrLateInit)))) {
    if (lookup.slot != kInvalidSlot) {
      // Declared property.
      if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {
        throwMutateConstProp(lookup.slot);
      }
      unsetTypeHint(lookup.prop);
      tvSet(*uninit_variant.asTypedValue(), prop);
    } else {
      // Dynamic property.
      dynPropArray().remove(StrNR(key).asString(), true /* isString */);
    }
    return;
  }

  // Native unset first.
  if (m_cls->rtAttribute(Class::HasNativePropHandler) &&
      invokeNativeUnsetProp(key)) {
    return;
  }

  if (prop && !lookup.accessible) {
    // Defined property that is not accessible.
    raise_error("Cannot unset inaccessible property");
  }

  if (UNLIKELY(!*key->data())) {
    throw_invalid_property_name(StrNR(key));
  }
}
