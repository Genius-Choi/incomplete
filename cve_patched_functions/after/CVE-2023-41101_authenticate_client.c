static int authenticate_client(struct MHD_Connection *connection,
							const char *redirect_url,
							t_client *client)
{
	s_config *config = config_get_config();
	time_t now = time(NULL);
	int seconds = 60 * config->session_timeout;
	unsigned long long int uploadrate = 0;
	unsigned long long int downloadrate = 0;
	unsigned long long int uploadquota = 0;
	unsigned long long int downloadquota = 0;
	int rc;
	int ret;
	char *redirect_url_enc;
	char *querystr;
	const char *custom;

	client->window_counter = 0;
	client->rate_exceeded = 0;
	client->initial_loop = 0;
	client->upload_limiting = 0;
	client->download_limiting = 0;
	client->upload_rate = 0;
	client->download_rate = 0;
	client->uprate = 0;
	client->downrate = 0;
	client->upload_quota = 0;
	client->download_quota = 0;
	client->download_bucket_size = 0;
	client->upload_bucket_size = 0;
	client->inc_packet_limit = 0;
	client->out_packet_limit = 0;

	client->session_start = now;

	if (seconds > 0) {
		client->session_end = now + seconds;
	} else {
		client->session_end = 0;
	}

	debug(LOG_DEBUG, "redirect_url is [ %s ]", redirect_url);

	// get custom string
	custom = MHD_lookup_connection_value(connection, MHD_GET_ARGUMENT_KIND, "custom");

	if (!custom || strlen(custom) == 0) {
		custom="bmE=";
	}

	if (config->binauth) {
		rc = do_binauth(
			connection,
			config->binauth,
			client,
			&seconds,
			&uploadrate,
			&downloadrate,
			&uploadquota,
			&downloadquota,
			redirect_url
		);

		if (rc != 0) {
			/*BinAuth denies access so redirect client back to login/splash page where they can try again.
				If FAS is enabled, this will cause nesting of the contents of redirect_url,
				FAS should account for this if used with BinAuth.
			*/

			redirect_url_enc = safe_calloc(REDIRECT_URL_ENC_BUF);
			uh_urlencode(redirect_url_enc, REDIRECT_URL_ENC_BUF, redirect_url, strlen(redirect_url));

			debug(LOG_DEBUG, "redirect_url after binauth deny: %s", redirect_url);
			debug(LOG_DEBUG, "redirect_url_enc after binauth deny: %s", redirect_url_enc);

			querystr = safe_calloc(QUERYMAXLEN);
			querystr=construct_querystring(connection, client, redirect_url_enc, querystr);
			ret = encode_and_redirect_to_splashpage(connection, client, redirect_url_enc, querystr);
			free(querystr);
			free(redirect_url_enc);
			return ret;
		}
		rc = auth_client_auth(client->id, "client_auth", custom);
	} else {
		rc = auth_client_auth(client->id, NULL, custom);
	}

	// override remaining client values that might have been set by binauth

	if (seconds == 0) {
		seconds = (60 * config->session_timeout);
	}

	debug(LOG_DEBUG, "timeout seconds: %d", seconds);

	if (seconds != (60 * config->session_timeout)) {
		client->session_end = (client->session_start + seconds);
	}

	if (downloadrate > 0) {
		client->download_rate = downloadrate;
	}
	if (uploadrate > 0) {
		client->upload_rate = uploadrate;
	}

	if (downloadquota > 0) {
		client->download_quota = downloadquota;
	}
	if (uploadquota > 0) {
		client->upload_quota = uploadquota;
	}


	// error checking
	if (rc != 0) {
		return send_error(connection, 503);
	}

	if (redirect_url) {
		return send_redirect_temp(connection, client, redirect_url);
	} else {
		return send_error(connection, 200);
	}

	debug(LOG_DEBUG, "authenticate: Session Start - %lu Session End - %lu", client->session_start, client->session_end);
}
