static int manager_iax2_show_peer_list(struct mansession *s, const struct message *m)
{
	struct iax2_peer *peer = NULL;
	int peer_count = 0;
	char nm[20];
	char status[20];
	const char *id = astman_get_header(m,"ActionID");
	char idtext[256] = "";
	struct ao2_iterator i;

	if (!ast_strlen_zero(id))
		snprintf(idtext, sizeof(idtext), "ActionID: %s\r\n", id);

	astman_append(s, "Response: Success\r\n%sMessage: IAX Peer status list will follow\r\n\r\n", idtext);


	i = ao2_iterator_init(peers, 0);
	for (peer = ao2_iterator_next(&i); peer; peer_unref(peer), peer = ao2_iterator_next(&i)) {

		astman_append(s, "Event: PeerEntry\r\n%sChanneltype: IAX\r\n", idtext);
		if (!ast_strlen_zero(peer->username)) {
			astman_append(s, "ObjectName: %s\r\nObjectUsername: %s\r\n", peer->name, peer->username);
		} else {
			astman_append(s, "ObjectName: %s\r\n", peer->name);
		}
		astman_append(s, "ChanObjectType: peer\r\n");
		astman_append(s, "IPaddress: %s\r\n", peer->addr.sin_addr.s_addr ? ast_inet_ntoa(peer->addr.sin_addr) : "-none-");
		ast_copy_string(nm, ast_inet_ntoa(peer->mask), sizeof(nm));
		astman_append(s, "Mask: %s\r\n", nm);
		astman_append(s, "Port: %d\r\n", ntohs(peer->addr.sin_port));
		astman_append(s, "Dynamic: %s\r\n", ast_test_flag(peer, IAX_DYNAMIC) ? "Yes" : "No");
		peer_status(peer, status, sizeof(status));
		astman_append(s, "Status: %s\r\n\r\n", status);
		peer_count++;
	}

	astman_append(s, "Event: PeerlistComplete\r\n%sListItems: %d\r\n\r\n", idtext, peer_count);
	return RESULT_SUCCESS;
}
