static int ip_identify_match_handler(const struct aco_option *opt, struct ast_variable *var, void *obj)
{
	struct ip_identify_match *identify = obj;
	char *input_string = ast_strdupa(var->value);
	char *current_string;

	if (ast_strlen_zero(var->value)) {
		return 0;
	}

	while ((current_string = ast_strip(strsep(&input_string, ",")))) {
		char *mask;
		struct ast_sockaddr address;
		int error = 0;

		if (ast_strlen_zero(current_string)) {
			continue;
		}

		mask = strrchr(current_string, '/');

		/* If it looks like a netmask is present, or we can immediately parse as an IP,
		 * hand things off to the ACL */
		if (mask || ast_sockaddr_parse(&address, current_string, 0)) {
			identify->matches = ast_append_ha_with_port("d", current_string, identify->matches, &error);

			if (!identify->matches || error) {
				ast_log(LOG_ERROR, "Failed to add address '%s' to ip endpoint identifier '%s'\n",
					current_string, ast_sorcery_object_get_id(obj));
				return -1;
			}

			continue;
		}

		if (!identify->hosts) {
			identify->hosts = ast_str_container_alloc_options(AO2_ALLOC_OPT_LOCK_NOLOCK, HOSTS_BUCKETS);
			if (!identify->hosts) {
				ast_log(LOG_ERROR, "Failed to create container to store hosts on ip endpoint identifier '%s'\n",
					ast_sorcery_object_get_id(obj));
				return -1;
			}
		}

		error = ast_str_container_add(identify->hosts, current_string);
		if (error) {
			ast_log(LOG_ERROR, "Failed to store host '%s' for resolution on ip endpoint identifier '%s'\n",
				current_string, ast_sorcery_object_get_id(obj));
			return -1;
		}
	}

	return 0;
}
