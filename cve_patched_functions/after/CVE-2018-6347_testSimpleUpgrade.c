void HTTPDownstreamTest<C>::testSimpleUpgrade(
  const std::string& upgradeHeader,
  CodecProtocol expectedProtocol,
  const std::string& expectedUpgradeHeader) {
  this->rawCodec_->setAllowedUpgradeProtocols({expectedUpgradeHeader});

  auto handler = addSimpleStrictHandler();

  HeaderIndexingStrategy testH2IndexingStrat;
  handler->expectHeaders();
  EXPECT_CALL(mockController_, onSessionCodecChange(httpSession_));
  handler->expectEOM(
    [&handler, expectedProtocol, expectedUpgradeHeader, &testH2IndexingStrat] {
      EXPECT_FALSE(handler->txn_->getSetupTransportInfo().secure);
      EXPECT_EQ(*handler->txn_->getSetupTransportInfo().appProtocol,
                expectedUpgradeHeader);
      if (expectedProtocol == CodecProtocol::HTTP_2) {
        const HTTP2Codec* codec = dynamic_cast<const HTTP2Codec*>(
          &handler->txn_->getTransport().getCodec());
        ASSERT_NE(codec, nullptr);
        EXPECT_EQ(codec->getHeaderIndexingStrategy(), &testH2IndexingStrat);
      }
      handler->sendReplyWithBody(200, 100);
    });
  handler->expectDetachTransaction();

  if (expectedProtocol == CodecProtocol::HTTP_2) {
    EXPECT_CALL(mockController_, getHeaderIndexingStrategy())
      .WillOnce(
        Return(&testH2IndexingStrat)
    );
  }

  HTTPMessage req = getUpgradeRequest(upgradeHeader);
  if (upgradeHeader == http2::kProtocolCleartextString) {
    HTTP2Codec::requestUpgrade(req);
  }
  sendRequest(req);
  flushRequestsAndLoop();

  expect101(expectedProtocol, expectedUpgradeHeader);
  expectResponse();

  gracefulShutdown();
}
