static void __printPattern(RCore *core, const char *_input) {
	char *input = strdup (_input);
	const char *arg = r_str_nextword (input, ' ');
	size_t i, j;
	st64 len = arg? r_num_math (core->num, arg): core->blocksize;
	if (len < 1) {
		R_LOG_ERROR ("Invalid length");
		return;
	}
	switch (input[0]) {
	case 'd': // "ppd"
		// debruijn pattern
		{
			ut8 *buf = (ut8*)r_debruijn_pattern (len, 0, NULL);
			for (i = 0; i < len; i++) {
				r_cons_printf ("%02x", buf[i]);
			}
			r_cons_newline ();
			free (buf);
		}
		break;
	case '1': // "pp1"
		// incremental byte sequence
		{
			int min = (core->offset & 0xff);
			for (i = 0; i < len; i++) {
				r_cons_printf ("%02x", (int)(i + min));
			}
			r_cons_newline ();
		}
		break;
	case '2': // "pp2"
		// incremental half word sequences
		{
			// TODO: honor cfg.bigendian
			int min = (core->offset & 0xffff);
			for (i = 0; i < len; i++) {
				r_cons_printf ("%04x", (int)(i + min));
			}
			r_cons_newline ();
		}
		break;
	case '4': // "pp4"
		// incremental half word sequences
		{
			// TODO: honor cfg.bigendian
			int min = (core->offset & UT32_MAX);
			for (i = 0; i < len; i++) {
				r_cons_printf ("%08x", (int)(i + min));
			}
			r_cons_newline ();
		}
		break;
	case '8': // "pp8"
		// incremental half word sequences
		{
			// TODO: honor cfg.bigendian
			ut64 min = (core->offset);
			for (i = 0; i < len; i++) {
				r_cons_printf ("%016"PFMT64x, i + min);
			}
			r_cons_newline ();
		}
		break;
	case 'f': // "ppf"
		// zero ssled
		{
			ut8 *buf = (ut8*)r_debruijn_pattern (len, 0, NULL);
			for (i = 0; i < len; i++) {
				r_cons_printf ("%02x", 0xff);
			}
			r_cons_newline ();
			free (buf);
		}
		break;
	case '0': // "pp0"
		// zero ssled
		{
			ut8 *buf = (ut8*)r_debruijn_pattern (len, 0, NULL);
			for (i = 0; i < len; i++) {
				r_cons_printf ("%02x", 0);
			}
			r_cons_newline ();
			free (buf);
		}
		break;
	case 'a':
		// TODO
		{
			i = core->offset;
			size_t bs = 4; // XXX hardcoded
			ut8 *buf = calloc (bs, 1);
			// for (;i>0;i--) { incDigitBuffer (buf, bs); }
			for (i = 0; i < len; i++) {
				incAlphaBuffer (buf, bs);
				for (j = 0; j < bs; j++) {
					r_cons_printf ("%c", buf[j]?buf[j]:'A');
				}
				r_cons_printf (" ");
			}
			r_cons_newline ();
			free (buf);
		}
		break;
	case 'n': // "ppn"
		{
			i = core->offset;
			size_t bs = 4; // XXX hardcoded
			ut8 *buf = calloc (bs, 1);
			// for (;i>0;i--) { incDigitBuffer (buf, bs); }
			for (i = 0; i < len; i++) {
				incDigitBuffer (buf, bs);
				for (j = 0; j < bs; j++) {
					r_cons_printf ("%c", buf[j]?buf[j]:'0');
				}
				r_cons_printf (" ");
			}
			r_cons_newline ();
			free (buf);
		}
		break;
	default:
		r_core_cmd_help (core, help_msg_pp);
		break;
	}
	free (input);
}
