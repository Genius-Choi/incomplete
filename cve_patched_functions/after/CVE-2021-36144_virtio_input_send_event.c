virtio_input_send_event(struct virtio_input *vi,
			struct virtio_input_event *event)
{
	struct virtio_vq_info *vq;
	struct iovec iov;
	int n, i;
	uint16_t idx;

	if (!vi->ready)
		return;

	if (vi->event_qindex == vi->event_qsize) {
		vi->event_qsize++;
		vi->event_queue = realloc(vi->event_queue,
			vi->event_qsize *
			sizeof(struct virtio_input_event_elem));
		if (!vi->event_queue) {
			WPRINTF(("virtio_input: realloc memory for vi->event_queue failed!\n"));
			return;
		}
	}
	vi->event_queue[vi->event_qindex].event = *event;
	vi->event_qindex++;

	if (event->type != EV_SYN || event->code != SYN_REPORT)
		return;

	vq = &vi->queues[VIRTIO_INPUT_EVENT_QUEUE];
	for (i = 0; i < vi->event_qindex; i++) {
		if (!vq_has_descs(vq)) {
			while (i-- > 0)
				vq_retchain(vq);
			WPRINTF(("%s: not enough avail descs, dropped:%d\n",
				__func__, vi->event_qindex));
			goto out;
		}
		n = vq_getchain(vq, &idx, &iov, 1, NULL);
		if (n < 0) {
			WPRINTF(("virtio-input: invalid descriptors\n"));
			return;
		}
		if (n == 0) {
			WPRINTF(("virtio-input: get no available desciptors\n"));
			return;
		}
		if (n != 1) {
			WPRINTF(("virtio_input: get wrong number of available descriptors\n"));
			vq_relchain(vq, idx, sizeof(event)); /* Release the chain */
			return;
		}
		vi->event_queue[i].iov = iov;
		vi->event_queue[i].idx = idx;
	}

	for (i = 0; i < vi->event_qindex; i++) {
		memcpy(vi->event_queue[i].iov.iov_base,
			&vi->event_queue[i].event,
			sizeof(struct virtio_input_event));
		vq_relchain(vq, vi->event_queue[i].idx,
			sizeof(struct virtio_input_event));
	}

out:
	vi->event_qindex = 0;
	vq_endchains(vq, 1);
}
