static GF_Err gf_text_import_webvtt(GF_MediaImporter *import)
{
	GF_Err						e;
	u32							track;
	u32							timescale;
	u32							duration;
	u32							descIndex=1;
	u32							ID;
	u32							OCR_ES_ID;
	GF_GenericSubtitleConfig	*cfg;
	GF_WebVTTParser				*vttparser;
	GF_ISOFlusher				flusher;

	cfg	= NULL;
	if (import->esd) {
		if (!import->esd->slConfig)	{
			import->esd->slConfig =	(GF_SLConfig *)	gf_odf_desc_new(GF_ODF_SLC_TAG);
			import->esd->slConfig->predefined =	2;
			import->esd->slConfig->timestampResolution = 1000;
		}
		timescale =	import->esd->slConfig->timestampResolution;
		if (!timescale)	timescale =	1000;

		/*explicit text	config*/
		if (import->esd->decoderConfig && import->esd->decoderConfig->decoderSpecificInfo->tag == GF_ODF_GEN_SUB_CFG_TAG) {
			cfg	= (GF_GenericSubtitleConfig	*) import->esd->decoderConfig->decoderSpecificInfo;
			import->esd->decoderConfig->decoderSpecificInfo	= NULL;
		}
		ID = import->esd->ESID;
		OCR_ES_ID =	import->esd->OCRESID;
	} else {
		timescale =	1000;
		OCR_ES_ID =	ID = 0;
	}

	if (cfg	&& cfg->timescale) timescale = cfg->timescale;
	track =	gf_isom_new_track(import->dest,	ID,	GF_ISOM_MEDIA_TEXT,	timescale);
	if (!track)	{
		return gf_import_message(import, gf_isom_last_error(import->dest), "Error creating WebVTT track");
	}
	gf_isom_set_track_enabled(import->dest, track, 1);
	import->final_trackID = gf_isom_get_track_id(import->dest, track);
	if (import->esd && !import->esd->ESID) import->esd->ESID = import->final_trackID;

	if (OCR_ES_ID) gf_isom_set_track_reference(import->dest, track,	GF_ISOM_REF_OCR, OCR_ES_ID);

	/*setup	track*/
	if (cfg) {
		u32	i;
		u32	count;
		/*set track	info*/
		gf_isom_set_track_layout_info(import->dest,	track, cfg->text_width<<16,	cfg->text_height<<16, 0, 0,	cfg->layer);

		/*and set sample descriptions*/
		count =	gf_list_count(cfg->sample_descriptions);
		for	(i=0; i<count; i++)	{
			gf_isom_new_webvtt_description(import->dest, track, NULL, NULL, NULL, &descIndex);
		}
		gf_import_message(import, GF_OK, "WebVTT import	- text track %d	x %d", cfg->text_width,	cfg->text_height);
		gf_odf_desc_del((GF_Descriptor *)cfg);
	} else {
		u32	w;
		u32	h;

		gf_text_get_video_size(import, &w, &h);
		gf_isom_set_track_layout_info(import->dest,	track, w<<16, h<<16, 0,	0, 0);

		gf_isom_new_webvtt_description(import->dest, track,	NULL, NULL,	NULL, &descIndex);

		gf_import_message(import, GF_OK, "WebVTT import");
	}
	gf_text_import_set_language(import, track);
	duration = (u32) (((Double) import->duration)*timescale/1000.0);

	vttparser = gf_webvtt_parser_new();
	flusher.import = import;
	flusher.timescale = timescale;
	flusher.track = track;
	flusher.descriptionIndex = descIndex;
	e = gf_webvtt_parser_init(vttparser, import->in_name, &flusher, gf_webvtt_import_report, gf_webvtt_flush_sample_to_iso, gf_webvtt_import_header);
	if (e != GF_OK) {
		gf_webvtt_parser_del(vttparser);
		return gf_import_message(import, GF_NOT_SUPPORTED, "Unsupported WebVTT UTF encoding");
	}
	e = gf_webvtt_parser_parse(vttparser, duration);
	if (e != GF_OK) {
		gf_isom_remove_track(import->dest, track);
	}

	/*do not add any empty sample at the end since it modifies track duration and is not needed - it is the player job
	to figure out when to stop displaying the last text sample
	However update the last sample duration*/
	gf_isom_set_last_sample_duration(import->dest, track, (u32) gf_webvtt_parser_last_duration(vttparser));
	
	gf_webvtt_parser_del(vttparser);
	return e;
}
