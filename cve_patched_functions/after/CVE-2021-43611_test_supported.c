static void test_supported(const char* header_name, const char * header_value, const char* values[],size_t number_values) {
	belle_sip_list_t* list;
	belle_sip_header_supported_t* L_tmp;
	belle_sip_header_supported_t* L_supported = BELLE_SIP_HEADER_SUPPORTED(belle_sip_header_create(header_name,header_value));
	char* l_raw_header = belle_sip_object_to_string(BELLE_SIP_OBJECT(L_supported));
	size_t i=0;
	belle_sip_object_unref(BELLE_SIP_OBJECT(L_supported));
	L_tmp = belle_sip_header_supported_parse(l_raw_header);
	L_supported = BELLE_SIP_HEADER_SUPPORTED(belle_sip_object_clone(BELLE_SIP_OBJECT(L_tmp)));
	belle_sip_object_unref(BELLE_SIP_OBJECT(L_tmp));

	belle_sip_free(l_raw_header);

	list = belle_sip_header_supported_get_supported(L_supported);

	for(i=0;i<number_values;i++){
		BC_ASSERT_PTR_NOT_NULL(list);
		if (list) {
			BC_ASSERT_STRING_EQUAL((const char *)(list->data),values[i]);
			list=list->next;
		}
	}
	belle_sip_object_unref(BELLE_SIP_OBJECT(L_supported));
	BC_ASSERT_PTR_NULL(belle_sip_header_supported_parse("nimportequoi"));
}
