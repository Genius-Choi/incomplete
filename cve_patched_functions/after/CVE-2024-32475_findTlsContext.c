ServerContextImpl::findTlsContext(absl::string_view sni, bool client_ecdsa_capable,
                                  bool client_ocsp_capable, bool* cert_matched_sni) {
  bool unused = false;
  if (cert_matched_sni == nullptr) {
    // Avoid need for nullptr checks when this is set.
    cert_matched_sni = &unused;
  }

  // selected_ctx represents the final selected certificate, it should meet all requirements or pick
  // a candidate.
  const Ssl::TlsContext* selected_ctx = nullptr;
  const Ssl::TlsContext* candidate_ctx = nullptr;
  OcspStapleAction ocsp_staple_action;

  auto selected = [&](const Ssl::TlsContext& ctx) -> bool {
    auto action = ocspStapleAction(ctx, client_ocsp_capable);
    if (action == OcspStapleAction::Fail) {
      // The selected ctx must adhere to OCSP policy
      return false;
    }

    if (client_ecdsa_capable == ctx.is_ecdsa_) {
      selected_ctx = &ctx;
      ocsp_staple_action = action;
      return true;
    }

    if (client_ecdsa_capable && !ctx.is_ecdsa_ && candidate_ctx == nullptr) {
      // ECDSA cert is preferred if client is ECDSA capable, so RSA cert is marked as a candidate,
      // searching will continue until exhausting all certs or find a exact match.
      candidate_ctx = &ctx;
      ocsp_staple_action = action;
      return false;
    }

    return false;
  };

  auto select_from_map = [this, &selected](absl::string_view server_name) -> void {
    auto it = server_names_map_.find(server_name);
    if (it == server_names_map_.end()) {
      return;
    }
    const auto& pkey_types_map = it->second;
    for (const auto& entry : pkey_types_map) {
      if (selected(entry.second.get())) {
        break;
      }
    }
  };

  auto tail_select = [&](bool go_to_next_phase) {
    if (selected_ctx == nullptr) {
      selected_ctx = candidate_ctx;
    }

    if (selected_ctx == nullptr && !go_to_next_phase) {
      selected_ctx = &tls_contexts_[0];
      ocsp_staple_action = ocspStapleAction(*selected_ctx, client_ocsp_capable);
    }
  };

  // Select cert based on SNI if SNI is provided by client.
  if (!sni.empty()) {
    // Match on exact server name, i.e. "www.example.com" for "www.example.com".
    select_from_map(sni);
    tail_select(true);

    if (selected_ctx == nullptr) {
      // Match on wildcard domain, i.e. ".example.com" for "www.example.com".
      // https://datatracker.ietf.org/doc/html/rfc6125#section-6.4
      size_t pos = sni.find('.', 1);
      if (pos < sni.size() - 1 && pos != std::string::npos) {
        absl::string_view wildcard = sni.substr(pos);
        select_from_map(wildcard);
      }
    }
    *cert_matched_sni = (selected_ctx != nullptr || candidate_ctx != nullptr);
    tail_select(full_scan_certs_on_sni_mismatch_);
  }
  // Full scan certs if SNI is not provided by client;
  // Full scan certs if client provides SNI but no cert matches to it,
  // it requires full_scan_certs_on_sni_mismatch is enabled.
  if (selected_ctx == nullptr) {
    candidate_ctx = nullptr;
    // Skip loop when there is no cert compatible to key type
    if (client_ecdsa_capable || (!client_ecdsa_capable && has_rsa_)) {
      for (const auto& ctx : tls_contexts_) {
        if (selected(ctx)) {
          break;
        }
      }
    }
    tail_select(false);
  }

  ASSERT(selected_ctx != nullptr);
  return {*selected_ctx, ocsp_staple_action};
}
