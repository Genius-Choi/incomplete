tdirtrunc(struct tmpnode *dir)
{
	struct tdirent *tdp;
	struct tmpnode *tp;
	size_t namelen;
	timestruc_t now;
	int isvattrdir, isdotdot, skip_decr;

	ASSERT(RW_WRITE_HELD(&dir->tn_rwlock));
	ASSERT(dir->tn_type == VDIR);

	isvattrdir = (dir->tn_vnode->v_flag & V_XATTRDIR) ? 1 : 0;
	for (tdp = dir->tn_dir; tdp; tdp = dir->tn_dir) {
		ASSERT(tdp->td_next != tdp);
		ASSERT(tdp->td_prev != tdp);
		ASSERT(tdp->td_tmpnode);

		dir->tn_dir = tdp->td_next;
		namelen = strlen(tdp->td_name) + 1;

		/*
		 * Adjust the link counts to account for this directory
		 * entry removal. Hidden attribute directories may
		 * not be empty as they may be truncated as a side-
		 * effect of removing the parent. We do hold/rele
		 * operations to free up these tmpnodes.
		 *
		 * Skip the link count adjustment for parents of
		 * attribute directories as those link counts
		 * do not include the ".." reference in the hidden
		 * directories.
		 */
		tp = tdp->td_tmpnode;
		isdotdot = (strcmp("..", tdp->td_name) == 0);
		skip_decr = (isvattrdir && isdotdot);
		if (!skip_decr) {
			ASSERT(tp->tn_nlink > 0);
			DECR_COUNT(&tp->tn_nlink, &tp->tn_tlock);
		}

		tmpfs_hash_out(tdp);

		tmp_memfree(tdp, sizeof (struct tdirent) + namelen);
		dir->tn_size -= (sizeof (struct tdirent) + namelen);
		dir->tn_dirents--;
	}

	gethrestime(&now);
	dir->tn_mtime = now;
	dir->tn_ctime = now;

	ASSERT(dir->tn_dir == NULL);
	ASSERT(dir->tn_size == 0);
	ASSERT(dir->tn_dirents == 0);
}
