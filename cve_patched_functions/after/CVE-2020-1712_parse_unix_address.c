static int parse_unix_address(sd_bus *b, const char **p, char **guid) {
        _cleanup_free_ char *path = NULL, *abstract = NULL;
        size_t l;
        int r;

        assert(b);
        assert(p);
        assert(*p);
        assert(guid);

        while (!IN_SET(**p, 0, ';')) {
                r = parse_address_key(p, "guid", guid);
                if (r < 0)
                        return r;
                else if (r > 0)
                        continue;

                r = parse_address_key(p, "path", &path);
                if (r < 0)
                        return r;
                else if (r > 0)
                        continue;

                r = parse_address_key(p, "abstract", &abstract);
                if (r < 0)
                        return r;
                else if (r > 0)
                        continue;

                skip_address_key(p);
        }

        if (!path && !abstract)
                return -EINVAL;

        if (path && abstract)
                return -EINVAL;

        if (path) {
                l = strlen(path);
                if (l >= sizeof(b->sockaddr.un.sun_path)) /* We insist on NUL termination */
                        return -E2BIG;

                b->sockaddr.un = (struct sockaddr_un) {
                        .sun_family = AF_UNIX,
                };

                memcpy(b->sockaddr.un.sun_path, path, l);
                b->sockaddr_size = offsetof(struct sockaddr_un, sun_path) + l + 1;

        } else {
                assert(abstract);

                l = strlen(abstract);
                if (l >= sizeof(b->sockaddr.un.sun_path) - 1) /* We insist on NUL termination */
                        return -E2BIG;

                b->sockaddr.un = (struct sockaddr_un) {
                        .sun_family = AF_UNIX,
                };

                memcpy(b->sockaddr.un.sun_path+1, abstract, l);
                b->sockaddr_size = offsetof(struct sockaddr_un, sun_path) + 1 + l;
        }

        b->is_local = true;

        return 0;
}
