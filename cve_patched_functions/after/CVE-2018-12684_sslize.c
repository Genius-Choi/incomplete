sslize(struct mg_connection *conn,
       SSL_CTX *s,
       int (*func)(SSL *),
       volatile int *stop_server)
{
	int ret, err;
	int short_trust;
	unsigned i;

	if (!conn) {
		return 0;
	}

	short_trust =
	    (conn->dom_ctx->config[SSL_SHORT_TRUST] != NULL)
	    && (mg_strcasecmp(conn->dom_ctx->config[SSL_SHORT_TRUST], "yes") == 0);

	if (short_trust) {
		int trust_ret = refresh_trust(conn);
		if (!trust_ret) {
			return trust_ret;
		}
	}

	conn->ssl = SSL_new(s);
	if (conn->ssl == NULL) {
		return 0;
	}
	SSL_set_app_data(conn->ssl, (char *)conn);

	ret = SSL_set_fd(conn->ssl, conn->client.sock);
	if (ret != 1) {
		err = SSL_get_error(conn->ssl, ret);
		mg_cry_internal(conn, "SSL error %i, destroying SSL context", err);
		SSL_free(conn->ssl);
		conn->ssl = NULL;
/* Avoid CRYPTO_cleanup_all_ex_data(); See discussion:
 * https://wiki.openssl.org/index.php/Talk:Library_Initialization */
#if !defined(OPENSSL_API_1_1)
		ERR_remove_state(0);
#endif
		return 0;
	}

	/* SSL functions may fail and require to be called again:
	 * see https://www.openssl.org/docs/manmaster/ssl/SSL_get_error.html
	 * Here "func" could be SSL_connect or SSL_accept. */
	for (i = 16; i <= 1024; i *= 2) {
		ret = func(conn->ssl);
		if (ret != 1) {
			err = SSL_get_error(conn->ssl, ret);
			if ((err == SSL_ERROR_WANT_CONNECT)
			    || (err == SSL_ERROR_WANT_ACCEPT)
			    || (err == SSL_ERROR_WANT_READ) || (err == SSL_ERROR_WANT_WRITE)
			    || (err == SSL_ERROR_WANT_X509_LOOKUP)) {
				/* Need to retry the function call "later".
				 * See https://linux.die.net/man/3/ssl_get_error
				 * This is typical for non-blocking sockets. */
				if (*stop_server) {
					/* Don't wait if the server is going to be stopped. */
					break;
				}
				mg_sleep(i);

			} else if (err == SSL_ERROR_SYSCALL) {
				/* This is an IO error. Look at errno. */
				err = errno;
				mg_cry_internal(conn, "SSL syscall error %i", err);
				break;

			} else {
				/* This is an SSL specific error, e.g. SSL_ERROR_SSL */
				mg_cry_internal(conn, "sslize error: %s", ssl_error());
				break;
			}

		} else {
			/* success */
			break;
		}
	}

	if (ret != 1) {
		SSL_free(conn->ssl);
		conn->ssl = NULL;
/* Avoid CRYPTO_cleanup_all_ex_data(); See discussion:
 * https://wiki.openssl.org/index.php/Talk:Library_Initialization */
#if !defined(OPENSSL_API_1_1)
		ERR_remove_state(0);
#endif
		return 0;
	}

	return 1;
}
