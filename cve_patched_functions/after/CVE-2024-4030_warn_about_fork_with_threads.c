static void warn_about_fork_with_threads(const char* name) {
    // TODO: Consider making an `os` module API to return the current number
    // of threads in the process. That'd presumably use this platform code but
    // raise an error rather than using the inaccurate fallback.
    Py_ssize_t num_python_threads = 0;
#if defined(__APPLE__) && defined(HAVE_GETPID)
    mach_port_t macos_self = mach_task_self();
    mach_port_t macos_task;
    if (task_for_pid(macos_self, getpid(), &macos_task) == KERN_SUCCESS) {
        thread_array_t macos_threads;
        mach_msg_type_number_t macos_n_threads;
        if (task_threads(macos_task, &macos_threads,
                         &macos_n_threads) == KERN_SUCCESS) {
            num_python_threads = macos_n_threads;
        }
    }
#elif defined(__linux__)
    // Linux /proc/self/stat 20th field is the number of threads.
    FILE* proc_stat = fopen("/proc/self/stat", "r");
    if (proc_stat) {
        size_t n;
        // Size chosen arbitrarily. ~60% more bytes than a 20th column index
        // observed on the author's workstation.
        char stat_line[160];
        n = fread(&stat_line, 1, 159, proc_stat);
        stat_line[n] = '\0';
        fclose(proc_stat);

        char *saveptr = NULL;
        char *field = strtok_r(stat_line, " ", &saveptr);
        unsigned int idx;
        for (idx = 19; idx && field; --idx) {
            field = strtok_r(NULL, " ", &saveptr);
        }
        if (idx == 0 && field) {  // found the 20th field
            num_python_threads = atoi(field);  // 0 on error
        }
    }
#endif
    if (num_python_threads <= 0) {
        // Fall back to just the number our threading module knows about.
        // An incomplete view of the world, but better than nothing.
        PyObject *threading = PyImport_GetModule(&_Py_ID(threading));
        if (!threading) {
            PyErr_Clear();
            return;
        }
        PyObject *threading_active =
                PyObject_GetAttr(threading, &_Py_ID(_active));
        if (!threading_active) {
            PyErr_Clear();
            Py_DECREF(threading);
            return;
        }
        PyObject *threading_limbo =
                PyObject_GetAttr(threading, &_Py_ID(_limbo));
        if (!threading_limbo) {
            PyErr_Clear();
            Py_DECREF(threading);
            Py_DECREF(threading_active);
            return;
        }
        Py_DECREF(threading);
        // Duplicating what threading.active_count() does but without holding
        // threading._active_limbo_lock so our count could be inaccurate if
        // these dicts are mid-update from another thread.  Not a big deal.
        // Worst case if someone replaced threading._active or threading._limbo
        // with non-dicts, we get -1 from *Length() below and undercount.
        // Nobody should, but we're best effort so we clear errors and move on.
        num_python_threads = (PyMapping_Length(threading_active)
                              + PyMapping_Length(threading_limbo));
        PyErr_Clear();
        Py_DECREF(threading_active);
        Py_DECREF(threading_limbo);
    }
    if (num_python_threads > 1) {
        PyErr_WarnFormat(
                PyExc_DeprecationWarning, 1,
#ifdef HAVE_GETPID
                "This process (pid=%d) is multi-threaded, "
#else
                "This process is multi-threaded, "
#endif
                "use of %s() may lead to deadlocks in the child.",
#ifdef HAVE_GETPID
                getpid(),
#endif
                name);
        PyErr_Clear();
    }
}
