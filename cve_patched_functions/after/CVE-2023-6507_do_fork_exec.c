do_fork_exec(char *const exec_array[],
             char *const argv[],
             char *const envp[],
             const char *cwd,
             int p2cread, int p2cwrite,
             int c2pread, int c2pwrite,
             int errread, int errwrite,
             int errpipe_read, int errpipe_write,
             int close_fds, int restore_signals,
             int call_setsid, pid_t pgid_to_set,
             gid_t gid,
             Py_ssize_t extra_group_size, const gid_t *extra_groups,
             uid_t uid, int child_umask,
             const void *child_sigmask,
             int *fds_to_keep, Py_ssize_t fds_to_keep_len,
             PyObject *preexec_fn,
             PyObject *preexec_fn_args_tuple)
{

    pid_t pid;

#ifdef VFORK_USABLE
    PyThreadState *vfork_tstate_save;
    if (child_sigmask) {
        /* These are checked by our caller; verify them in debug builds. */
        assert(uid == (uid_t)-1);
        assert(gid == (gid_t)-1);
        assert(extra_group_size < 0);
        assert(preexec_fn == Py_None);

        /* Drop the GIL so that other threads can continue execution while this
         * thread in the parent remains blocked per vfork-semantics on the
         * child's exec syscall outcome. Exec does filesystem access which
         * can take an arbitrarily long time. This addresses GH-104372.
         *
         * The vfork'ed child still runs in our address space. Per POSIX it
         * must be limited to nothing but exec, but the Linux implementation
         * is a little more usable. See the child_exec() comment - The child
         * MUST NOT re-acquire the GIL.
         */
        vfork_tstate_save = PyEval_SaveThread();
        pid = vfork();
        if (pid != 0) {
            // Not in the child process, reacquire the GIL.
            PyEval_RestoreThread(vfork_tstate_save);
        }
        if (pid == (pid_t)-1) {
            /* If vfork() fails, fall back to using fork(). When it isn't
             * allowed in a process by the kernel, vfork can return -1
             * with errno EINVAL. https://bugs.python.org/issue47151. */
            pid = fork();
        }
    } else
#endif
    {
        pid = fork();
    }

    if (pid != 0) {
        // Parent process.
        return pid;
    }

    /* Child process.
     * See the comment above child_exec() for restrictions imposed on
     * the code below.
     */

    if (preexec_fn != Py_None) {
        /* We'll be calling back into Python later so we need to do this.
         * This call may not be async-signal-safe but neither is calling
         * back into Python.  The user asked us to use hope as a strategy
         * to avoid deadlock... */
        PyOS_AfterFork_Child();
    }

    child_exec(exec_array, argv, envp, cwd,
               p2cread, p2cwrite, c2pread, c2pwrite,
               errread, errwrite, errpipe_read, errpipe_write,
               close_fds, restore_signals, call_setsid, pgid_to_set,
               gid, extra_group_size, extra_groups,
               uid, child_umask, child_sigmask,
               fds_to_keep, fds_to_keep_len,
               preexec_fn, preexec_fn_args_tuple);
    _exit(255);
    return 0;  /* Dead code to avoid a potential compiler warning. */
}
