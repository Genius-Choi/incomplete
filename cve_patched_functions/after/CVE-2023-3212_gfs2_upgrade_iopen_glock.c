static bool gfs2_upgrade_iopen_glock(struct inode *inode)
{
	struct gfs2_inode *ip = GFS2_I(inode);
	struct gfs2_sbd *sdp = GFS2_SB(inode);
	struct gfs2_holder *gh = &ip->i_iopen_gh;
	long timeout = 5 * HZ;
	int error;

	gh->gh_flags |= GL_NOCACHE;
	gfs2_glock_dq_wait(gh);

	/*
	 * If there are no other lock holders, we will immediately get
	 * exclusive access to the iopen glock here.
	 *
	 * Otherwise, the other nodes holding the lock will be notified about
	 * our locking request.  If they do not have the inode open, they are
	 * expected to evict the cached inode and release the lock, allowing us
	 * to proceed.
	 *
	 * Otherwise, if they cannot evict the inode, they are expected to poke
	 * the inode glock (note: not the iopen glock).  We will notice that
	 * and stop waiting for the iopen glock immediately.  The other node(s)
	 * are then expected to take care of deleting the inode when they no
	 * longer use it.
	 *
	 * As a last resort, if another node keeps holding the iopen glock
	 * without showing any activity on the inode glock, we will eventually
	 * time out and fail the iopen glock upgrade.
	 *
	 * Note that we're passing the LM_FLAG_TRY_1CB flag to the first
	 * locking request as an optimization to notify lock holders as soon as
	 * possible.  Without that flag, they'd be notified implicitly by the
	 * second locking request.
	 */

	gfs2_holder_reinit(LM_ST_EXCLUSIVE, LM_FLAG_TRY_1CB | GL_NOCACHE, gh);
	error = gfs2_glock_nq(gh);
	if (error != GLR_TRYFAILED)
		return !error;

	gfs2_holder_reinit(LM_ST_EXCLUSIVE, GL_ASYNC | GL_NOCACHE, gh);
	error = gfs2_glock_nq(gh);
	if (error)
		return false;

	timeout = wait_event_interruptible_timeout(sdp->sd_async_glock_wait,
		!test_bit(HIF_WAIT, &gh->gh_iflags) ||
		test_bit(GLF_DEMOTE, &ip->i_gl->gl_flags),
		timeout);
	if (!test_bit(HIF_HOLDER, &gh->gh_iflags)) {
		gfs2_glock_dq(gh);
		return false;
	}
	return gfs2_glock_holder_ready(gh) == 0;
}
