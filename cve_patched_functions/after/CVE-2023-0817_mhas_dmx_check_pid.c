static void mhas_dmx_check_pid(GF_Filter *filter, GF_MHASDmxCtx *ctx, u32 PL, u32 sample_rate, u32 frame_len, s32 CICPspeakerLayoutIdx, s32 numSpeakers, u8 *dsi, u32 dsi_size)
{
	u32 nb_channels;
	u64 chan_layout;
	if (!ctx->opid) {
		ctx->opid = gf_filter_pid_new(filter);
		mhas_dmx_check_dur(filter, ctx);
	} else {
		if ((ctx->frame_len == frame_len)
			&& (ctx->PL == PL)
			&& (ctx->sample_rate == sample_rate)
			&& (ctx->cicp_layout_idx == CICPspeakerLayoutIdx)
			&& (ctx->num_speakers == numSpeakers)
			&& !ctx->copy_props
		) {
			return;
		}
	}
	ctx->frame_len = frame_len;
	ctx->PL = PL;
	ctx->sample_rate = sample_rate;
	ctx->cicp_layout_idx = CICPspeakerLayoutIdx;
	ctx->num_speakers = numSpeakers;
	ctx->copy_props = GF_FALSE;

	chan_layout = 0;
	nb_channels = 0;
	if (CICPspeakerLayoutIdx>=0) {
		chan_layout = gf_audio_fmt_get_layout_from_cicp(CICPspeakerLayoutIdx);
		nb_channels = gf_audio_fmt_get_num_channels_from_layout(chan_layout);
	} else if (numSpeakers>=0) {
		nb_channels = numSpeakers;
	}

	//copy properties at init or reconfig
	gf_filter_pid_copy_properties(ctx->opid, ctx->ipid);
	gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, & PROP_UINT( GF_STREAM_AUDIO));
	gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_UNFRAMED, NULL );
	if (ctx->is_file && ctx->index) {
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, & PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD) );
	}
	if (ctx->duration.num)
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, & PROP_FRAC64(ctx->duration));
	if (!ctx->timescale)
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CAN_DATAREF, & PROP_BOOL(GF_TRUE ) );

	if (!ctx->timescale) gf_filter_pid_set_name(ctx->opid, "audio");

	if (ctx->mpha) {
		u8 *data = gf_malloc(sizeof(u8) * (dsi_size+5) );
		if (!data) return;
		data[0] = 1;
		data[1] = PL;
		data[2] = CICPspeakerLayoutIdx;
		data[3] = dsi_size>>8;
		data[4] = dsi_size&0xFF;
		memcpy(data+5, dsi, dsi_size);
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT( GF_CODECID_MPHA ) );
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, & PROP_DATA_NO_COPY( data, (dsi_size+5) ) );
	} else {
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, & PROP_UINT( GF_CODECID_MHAS ) );
	}

	gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, & PROP_UINT(ctx->timescale ? ctx->timescale : ctx->sample_rate));
	gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLE_RATE, & PROP_UINT(ctx->sample_rate));
	if (chan_layout)
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CHANNEL_LAYOUT, & PROP_LONGUINT(chan_layout) );
	gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_NUM_CHANNELS, & PROP_UINT(nb_channels) );
	gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_SAMPLES_PER_FRAME, & PROP_UINT(ctx->frame_len) );

	if (ctx->bitrate) {
		gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_BITRATE, & PROP_UINT(ctx->bitrate));
	}
}
