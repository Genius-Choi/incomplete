static int is_quadratic_residue(BIGNUM *val, BIGNUM *p, BIGNUM *qr, BIGNUM *qnr, BN_CTX *bnctx)
{
	int offset, check, ret = 0;
	BIGNUM *r = NULL, *pm1 = NULL, *res = NULL, *qr_or_qnr = NULL;
	unsigned int mask;
	unsigned char *qr_bin = NULL, *qnr_bin = NULL, *qr_or_qnr_bin = NULL;

	if (((r = consttime_BN()) == NULL) ||
	    ((res = consttime_BN()) == NULL) ||
	    ((qr_or_qnr = consttime_BN()) == NULL) ||
	    ((pm1 = consttime_BN()) == NULL)) {
		ret = -2;
		goto fail;
	}

	if (((qr_bin = (unsigned char *)malloc(BN_num_bytes(p))) == NULL) ||
	    ((qnr_bin = (unsigned char *)malloc(BN_num_bytes(p))) == NULL) ||
	    ((qr_or_qnr_bin = (unsigned char *)malloc(BN_num_bytes(p))) == NULL)) {
		ret = -2;
		goto fail;
	}

	/*
	 * we select binary in constant time so make them binary
	 */
	memset(qr_bin, 0, BN_num_bytes(p));
	memset(qnr_bin, 0, BN_num_bytes(p));
	memset(qr_or_qnr_bin, 0, BN_num_bytes(p));

	offset = BN_num_bytes(p) - BN_num_bytes(qr);
	BN_bn2bin(qr, qr_bin + offset);

	offset = BN_num_bytes(p) - BN_num_bytes(qnr);
	BN_bn2bin(qnr, qnr_bin + offset);

	/*
	 * r = (random() mod p-1) + 1
	 */
	BN_sub(pm1, p, BN_value_one());
	BN_rand_range(r, pm1);
	BN_add(r, r, BN_value_one());

	BN_copy(res, val);

	/*
	 * res = val * r * r which ensures res != val but has same quadratic residocity
	 */
	BN_mod_mul(res, res, r, p, bnctx);
	BN_mod_mul(res, res, r, p, bnctx);

	/*
	 * if r is even (mask is -1) then multiply by qnr and our check is qnr
	 * otherwise multiply by qr and our check is qr
	 */
	mask = const_time_is_zero(BN_is_odd(r));
	const_time_select_bin(mask, qnr_bin, qr_bin, BN_num_bytes(p), qr_or_qnr_bin);
	BN_bin2bn(qr_or_qnr_bin, BN_num_bytes(p), qr_or_qnr);
	BN_mod_mul(res, res, qr_or_qnr, p, bnctx);
	check = const_time_select_int(mask, -1, 1);

	if ((ret = legendre(res, p, bnctx)) == -2) {
		ret = -1;	/* just say no it's not */
		goto fail;
	}
	mask = const_time_eq(ret, check);
	ret = const_time_select_int(mask, 1, 0);

fail:
	if (qr_bin != NULL) free(qr_bin);
	if (qnr_bin != NULL) free(qnr_bin);
	if (qr_or_qnr_bin != NULL) free(qr_or_qnr_bin);
	BN_free(r);
	BN_free(res);
	BN_free(qr_or_qnr);
	BN_free(pm1);

	return ret;
}
