pthread_handler_t run_task(void *p)
{
  ulonglong counter= 0, queries;
  ulonglong detach_counter;
  unsigned int commit_counter;
  MYSQL *mysql;
  MYSQL_RES *result;
  MYSQL_ROW row;
  statement *ptr;
  thread_context *con= (thread_context *)p;

  DBUG_ENTER("run_task");
  DBUG_PRINT("info", ("task script \"%s\"", con->stmt ? con->stmt->string : ""));

  pthread_mutex_lock(&sleeper_mutex);
  while (master_wakeup)
  {
    pthread_cond_wait(&sleep_threshhold, &sleeper_mutex);
  }
  pthread_mutex_unlock(&sleeper_mutex);

  if (!(mysql= mysql_init(NULL)))
  {
    fprintf(stderr,"%s: mysql_init() failed ERROR : %s\n",
            my_progname, mysql_error(mysql));
    exit(0);
  }

  if (mysql_thread_init())
  {
    fprintf(stderr,"%s: mysql_thread_init() failed ERROR : %s\n",
            my_progname, mysql_error(mysql));
    exit(0);
  }

  DBUG_PRINT("info", ("trying to connect to host %s as user %s", host, user));

  if (!opt_only_print)
  {
    if (slap_connect(mysql))
      goto end;
  }

  DBUG_PRINT("info", ("connected."));
  if (verbose >= 3)
    printf("connected!\n");
  queries= 0;

  commit_counter= 0;
  if (commit_rate)
    run_query(mysql, "SET AUTOCOMMIT=0", strlen("SET AUTOCOMMIT=0"));

limit_not_met:
    for (ptr= con->stmt, detach_counter= 0; 
         ptr && ptr->length; 
         ptr= ptr->next, detach_counter++)
    {
      if (!opt_only_print && detach_rate && !(detach_counter % detach_rate))
      {
        mysql_close(mysql);

        if (!(mysql= mysql_init(NULL)))
        {
          fprintf(stderr,"%s: mysql_init() failed ERROR : %s\n",
                  my_progname, mysql_error(mysql));
          exit(0);
        }

        if (slap_connect(mysql))
          goto end;
      }

      /* 
        We have to execute differently based on query type. This should become a function.
      */
      if ((ptr->type == UPDATE_TYPE_REQUIRES_PREFIX) ||
          (ptr->type == SELECT_TYPE_REQUIRES_PREFIX))
      {
        int length;
        unsigned int key_val;
        char *key;
        char buffer[HUGE_STRING_LENGTH];

        /* 
          This should only happen if some sort of new engine was
          implemented that didn't properly handle UPDATEs.

          Just in case someone runs this under an experimental engine we don't
          want a crash so the if() is placed here.
        */
        DBUG_ASSERT(primary_keys_number_of);
        if (primary_keys_number_of)
        {
          key_val= (unsigned int)(random() % primary_keys_number_of);
          key= primary_keys[key_val];

          DBUG_ASSERT(key);

          length= snprintf(buffer, HUGE_STRING_LENGTH, "%.*s '%s'", 
                           (int)ptr->length, ptr->string, key);

          if (run_query(mysql, buffer, length))
          {
            fprintf(stderr,"%s: Cannot run query %.*s ERROR : %s\n",
                    my_progname, (uint)length, buffer, mysql_error(mysql));
            exit(0);
          }
        }
      }
      else
      {
        if (run_query(mysql, ptr->string, ptr->length))
        {
          fprintf(stderr,"%s: Cannot run query %.*s ERROR : %s\n",
                  my_progname, (uint)ptr->length, ptr->string, mysql_error(mysql));
          exit(0);
        }
      }

      do
      {
        if (mysql_field_count(mysql))
        {
          if (!(result= mysql_store_result(mysql)))
            fprintf(stderr, "%s: Error when storing result: %d %s\n",
                    my_progname, mysql_errno(mysql), mysql_error(mysql));
          else
          {
            while ((row= mysql_fetch_row(result)))
              counter++;
            mysql_free_result(result);
          }
        }
      } while(mysql_next_result(mysql) == 0);
      queries++;

      if (commit_rate && (++commit_counter == commit_rate))
      {
        commit_counter= 0;
        run_query(mysql, "COMMIT", strlen("COMMIT"));
      }

      if (con->limit && queries == con->limit)
        goto end;
    }

    if (con->limit && queries < con->limit)
      goto limit_not_met;

end:
  if (commit_rate)
    run_query(mysql, "COMMIT", strlen("COMMIT"));

  if (!opt_only_print) 
    mysql_close(mysql);

  mysql_thread_end();

  pthread_mutex_lock(&counter_mutex);
  thread_counter--;
  pthread_cond_signal(&count_threshhold);
  pthread_mutex_unlock(&counter_mutex);

  DBUG_RETURN(0);
}
