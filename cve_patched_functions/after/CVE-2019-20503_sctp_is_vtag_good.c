sctp_is_vtag_good(uint32_t tag, uint16_t lport, uint16_t rport, struct timeval *now)
{
	/*
	 * This function serves two purposes. It will see if a TAG can be
	 * re-used and return 1 for yes it is ok and 0 for don't use that
	 * tag. A secondary function it will do is purge out old tags that
	 * can be removed.
	 */
	struct sctpvtaghead *chain;
	struct sctp_tagblock *twait_block;
	struct sctpasochead *head;
	struct sctp_tcb *stcb;
	int i;

	SCTP_INP_INFO_RLOCK();
	head = &SCTP_BASE_INFO(sctp_asochash)[SCTP_PCBHASH_ASOC(tag,
								SCTP_BASE_INFO(hashasocmark))];
	LIST_FOREACH(stcb, head, sctp_asocs) {
		/* We choose not to lock anything here. TCB's can't be
		 * removed since we have the read lock, so they can't
		 * be freed on us, same thing for the INP. I may
		 * be wrong with this assumption, but we will go
		 * with it for now :-)
		 */
		if (stcb->sctp_ep->sctp_flags & SCTP_PCB_FLAGS_SOCKET_ALLGONE) {
			continue;
		}
		if (stcb->asoc.my_vtag == tag) {
			/* candidate */
			if (stcb->rport != rport) {
				continue;
			}
			if (stcb->sctp_ep->sctp_lport != lport) {
				continue;
			}
			/* Its a used tag set */
			SCTP_INP_INFO_RUNLOCK();
			return (0);
		}
	}
	chain = &SCTP_BASE_INFO(vtag_timewait)[(tag % SCTP_STACK_VTAG_HASH_SIZE)];
	/* Now what about timed wait ? */
	LIST_FOREACH(twait_block, chain, sctp_nxt_tagblock) {
		/*
		 * Block(s) are present, lets see if we have this tag in the
		 * list
		 */
		for (i = 0; i < SCTP_NUMBER_IN_VTAG_BLOCK; i++) {
			if (twait_block->vtag_block[i].v_tag == 0) {
				/* not used */
				continue;
			} else if ((long)twait_block->vtag_block[i].tv_sec_at_expire  <
				   now->tv_sec) {
				/* Audit expires this guy */
				twait_block->vtag_block[i].tv_sec_at_expire = 0;
				twait_block->vtag_block[i].v_tag = 0;
				twait_block->vtag_block[i].lport = 0;
				twait_block->vtag_block[i].rport = 0;
			} else if ((twait_block->vtag_block[i].v_tag == tag) &&
				   (twait_block->vtag_block[i].lport == lport) &&
				   (twait_block->vtag_block[i].rport == rport)) {
				/* Bad tag, sorry :< */
				SCTP_INP_INFO_RUNLOCK();
				return (0);
			}
		}
	}
	SCTP_INP_INFO_RUNLOCK();
	return (1);
}
