static int create_relay_connection(turn_turnserver* server,
				   ts_ur_super_session *ss, uint32_t lifetime,
				   int address_family, uint8_t transport,
				   int even_port, uint64_t in_reservation_token, uint64_t *out_reservation_token,
				   int *err_code, const uint8_t **reason,
				   accept_cb acb) {

	if (server && ss && ss->client_socket && !ioa_socket_tobeclosed(ss->client_socket)) {

		allocation* a = get_allocation_ss(ss);
		relay_endpoint_session* newelem = NULL;
		ioa_socket_handle rtcp_s = NULL;

		if (in_reservation_token) {

			ioa_socket_handle s = NULL;

			if ((get_ioa_socket_from_reservation(server->e, in_reservation_token,&s) < 0)||
				!s ||
				ioa_socket_tobeclosed(s)) {

				IOA_CLOSE_SOCKET(s);
				*err_code = 404;
				*reason = (const uint8_t *)"Cannot find reserved socket";
				return -1;
			}

			int family = get_ioa_socket_address_family(s);

			newelem = get_relay_session_ss(ss,family);

			if(newelem->s != s) {

				IOA_CLOSE_SOCKET(newelem->s);

				bzero(newelem, sizeof(relay_endpoint_session));
				newelem->s = s;
			}

			addr_debug_print(server->verbose, get_local_addr_from_ioa_socket(newelem->s), "Local relay addr (RTCP)");

		} else {
			int family = get_family(address_family,server->e,ss->client_socket);

			newelem = get_relay_session_ss(ss,family);


			IOA_CLOSE_SOCKET(newelem->s);

			bzero(newelem, sizeof(relay_endpoint_session));
			newelem->s = NULL;

			int res = create_relay_ioa_sockets(server->e,
							ss->client_socket,
							address_family, transport,
							even_port, &(newelem->s), &rtcp_s, out_reservation_token,
							err_code, reason, acb, ss);
			if (res < 0) {
				if(!(*err_code))
					*err_code = 508;
				if(!(*reason))
					*reason = (const uint8_t *)"Cannot create socket";
				IOA_CLOSE_SOCKET(newelem->s);
				IOA_CLOSE_SOCKET(rtcp_s);
				return -1;
			}
		}

		if (newelem->s == NULL) {
			IOA_CLOSE_SOCKET(rtcp_s);
			*err_code = 508;
			*reason = (const uint8_t *)"Cannot create relay socket";
			return -1;
		}

		if (rtcp_s) {
			if (out_reservation_token && *out_reservation_token) {
				/* OK */
			} else {
				IOA_CLOSE_SOCKET(newelem->s);
				IOA_CLOSE_SOCKET(rtcp_s);
				*err_code = 500;
				*reason = (const uint8_t *)"Wrong reservation tokens (internal error)";
				return -1;
			}
		}

		/* RFC6156: do not use DF when IPv6 is involved: */
		if((get_ioa_socket_address_family(newelem->s) == AF_INET6) ||
		   (get_ioa_socket_address_family(ss->client_socket) == AF_INET6))
			set_do_not_use_df(newelem->s);

		if(get_ioa_socket_type(newelem->s) != TCP_SOCKET) {
			if(register_callback_on_ioa_socket(server->e, newelem->s, IOA_EV_READ,peer_input_handler, ss, 0)<0) {
				return -1;
			}
		}

		if (lifetime<1)
			lifetime = STUN_DEFAULT_ALLOCATE_LIFETIME;
		else if(lifetime>(uint32_t)*(server->max_allocate_lifetime))
			lifetime = (uint32_t)*(server->max_allocate_lifetime);

		ioa_timer_handle ev = set_ioa_timer(server->e, lifetime, 0,
				client_ss_allocation_timeout_handler, newelem, 0,
				"client_ss_allocation_timeout_handler");
		set_allocation_lifetime_ev(a, server->ctime + lifetime, ev, get_ioa_socket_address_family(newelem->s));

		set_ioa_socket_session(newelem->s, ss);
	}

	return 0;
}
