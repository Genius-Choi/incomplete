static int mc_fixup_mac_addr(void *blob, int nodeoffset,
#ifdef CONFIG_DM_ETH
			     const char *propname, struct udevice *eth_dev,
#else
			     const char *propname, struct eth_device *eth_dev,
#endif
			     enum mc_fixup_type type)
{
#ifdef CONFIG_DM_ETH
	struct eth_pdata *plat = dev_get_plat(eth_dev);
	unsigned char *enetaddr = plat->enetaddr;
	int eth_index = dev_seq(eth_dev);
#else
	unsigned char *enetaddr = eth_dev->enetaddr;
	int eth_index = eth_dev->index;
#endif
	int err = 0, len = 0, size, i;
	unsigned char env_enetaddr[ARP_HLEN];
	unsigned int enetaddr_32[ARP_HLEN];
	void *val = NULL;

	switch (type) {
	case MC_FIXUP_DPL:
		/* DPL likes its addresses on 32 * ARP_HLEN bits */
		for (i = 0; i < ARP_HLEN; i++)
			enetaddr_32[i] = cpu_to_fdt32(enetaddr[i]);
		val = enetaddr_32;
		len = sizeof(enetaddr_32);
		break;
	case MC_FIXUP_DPC:
		val = enetaddr;
		len = ARP_HLEN;
		break;
	}

	/* MAC address property present */
	if (fdt_get_property(blob, nodeoffset, propname, NULL)) {
		/* u-boot MAC addr randomly assigned - leave the present one */
		if (!eth_env_get_enetaddr_by_index("eth", eth_index,
						   env_enetaddr))
			return err;
	} else {
		size = MC_DT_INCREASE_SIZE + strlen(propname) + len;
		/* make room for mac address property */
		err = fdt_increase_size(blob, size);
		if (err) {
			printf("fdt_increase_size: err=%s\n",
			       fdt_strerror(err));
			return err;
		}
	}

	err = fdt_setprop(blob, nodeoffset, propname, val, len);
	if (err) {
		printf("fdt_setprop: err=%s\n", fdt_strerror(err));
		return err;
	}

	return err;
}
