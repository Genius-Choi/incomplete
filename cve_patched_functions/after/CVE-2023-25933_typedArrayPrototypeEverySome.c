typedArrayPrototypeEverySome(void *ctx, Runtime &runtime, NativeArgs args) {
  // NOTE: this was implemented as separate from Array.prototype.every to take
  // advantage of the known contiguous memory region.
  GCScope gcScope(runtime);
  auto every = static_cast<bool>(ctx);
  if (JSTypedArrayBase::validateTypedArray(runtime, args.getThisHandle()) ==
      ExecutionStatus::EXCEPTION) {
    return ExecutionStatus::EXCEPTION;
  }
  auto self = args.vmcastThis<JSTypedArrayBase>();
  auto callbackfn = args.dyncastArg<Callable>(0);
  if (!callbackfn) {
    return runtime.raiseTypeError("callbackfn must be a Callable");
  }
  auto thisArg = args.getArgHandle(1);
  // Run the callback over every element.
  auto marker = gcScope.createMarker();
  for (JSTypedArrayBase::size_type i = 0; i < self->getLength(); ++i) {
    HermesValue val =
        JSObject::getOwnIndexed(createPseudoHandle(self.get()), runtime, i);
    auto callRes = Callable::executeCall3(
        callbackfn,
        runtime,
        thisArg,
        val,
        HermesValue::encodeNumberValue(i),
        self.getHermesValue());
    if (callRes == ExecutionStatus::EXCEPTION) {
      return ExecutionStatus::EXCEPTION;
    }
    gcScope.flushToMarker(marker);
    auto testResult = toBoolean(callRes->get());
    if (every && !testResult) {
      return HermesValue::encodeBoolValue(false);
    } else if (!every && testResult) {
      return HermesValue::encodeBoolValue(true);
    }
  }
  // If we're looking for every, then we finished without returning true.
  // If we're looking for some, then we finished without returning false.
  return HermesValue::encodeBoolValue(every);
}
