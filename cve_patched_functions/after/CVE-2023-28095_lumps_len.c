int lumps_len(struct sip_msg* msg, struct lump* lumps,
								struct socket_info* send_sock, int max_offset)
{
	unsigned int s_offset, new_len;
	unsigned int last_del;
	struct lump *t, *r;
	str *send_address_str, *send_port_str;
	str *rcv_address_str=NULL;
	str *rcv_port_str=NULL;

#define SUBST_LUMP_LEN(subst_l) \
		switch((subst_l)->u.subst){ \
			case SUBST_RCV_IP: \
				if (msg->rcv.bind_address){ \
					new_len+=rcv_address_str->len; \
				} else \
					LM_BUG("null bind address 1"); \
				break; \
			case SUBST_RCV_PORT: \
				if (msg->rcv.bind_address){ \
					new_len+=rcv_port_str->len; \
				} else \
					LM_BUG("null bind address 2"); \
				break; \
			case SUBST_RCV_PROTO: \
				if (msg->rcv.bind_address){ \
					switch(msg->rcv.bind_address->proto){ \
						/* TODO change this to look in proto !*/ \
						case PROTO_NONE: \
						case PROTO_UDP: \
						case PROTO_TCP: \
						case PROTO_TLS: \
						case PROTO_WSS: \
								new_len+=3; \
								break; \
						case PROTO_SCTP: \
								new_len+=4; \
								break; \
						case PROTO_WS: \
								new_len+=2; \
								break; \
						default: \
						LM_CRIT("unknown proto %d\n", \
								msg->rcv.bind_address->proto); \
					}\
				} else \
					LM_BUG("null bind address 3"); \
				break; \
			case SUBST_RCV_ALL: \
				if (msg->rcv.bind_address){ \
					new_len+=rcv_address_str->len; \
					if (msg->rcv.bind_address->port_no!=SIP_PORT || (rcv_port_str!=&(msg->rcv.bind_address->port_no_str))){ \
						/* add :port_no */ \
						new_len+=1+rcv_port_str->len; \
					}\
						/*add;transport=xxx*/ \
					switch(msg->rcv.bind_address->proto){ \
						case PROTO_NONE: \
						case PROTO_UDP: \
								break; /* udp is the default */ \
						case PROTO_TCP: \
						case PROTO_TLS: \
						case PROTO_WSS: \
								new_len+=TRANSPORT_PARAM_LEN+3; \
								break; \
						case PROTO_SCTP: \
								new_len+=TRANSPORT_PARAM_LEN+4; \
								break; \
						case PROTO_WS: \
								new_len+=TRANSPORT_PARAM_LEN+2; \
								break; \
						default: \
						LM_CRIT("unknown proto %d\n", \
								msg->rcv.bind_address->proto); \
					}\
				} else \
					LM_BUG("null bind address 4"); \
				break; \
			case SUBST_SND_IP: \
				if (send_sock){ \
					new_len+=send_address_str->len; \
				} else \
					LM_BUG("null send_socket 1"); \
				break; \
			case SUBST_SND_PORT: \
				if (send_sock){ \
					new_len+=send_port_str->len; \
				} else \
					LM_BUG("null send_socket 2"); \
				break; \
			case SUBST_SND_PROTO: \
				if (send_sock){ \
					switch(send_sock->proto){ \
						case PROTO_NONE: \
						case PROTO_UDP: \
						case PROTO_TCP: \
						case PROTO_TLS: \
						case PROTO_WSS: \
								new_len+=3; \
								break; \
						case PROTO_SCTP: \
								new_len+=4; \
								break; \
						case PROTO_WS: \
								new_len+=2; \
								break; \
						default: \
						LM_CRIT("unknown proto %d\n", \
								send_sock->proto); \
					}\
				} else \
					LM_BUG("null send_socket 3"); \
				break; \
			case SUBST_SND_ALL: \
				if (send_sock){ \
					new_len+=send_address_str->len; \
					if ((send_sock->port_no!=SIP_PORT) || \
							(send_port_str!=&(send_sock->port_no_str))){ \
						/* add :port_no */ \
						new_len+=1+send_port_str->len; \
					}\
					/*add;transport=xxx*/ \
					switch(send_sock->proto){ \
						case PROTO_NONE: \
						case PROTO_UDP: \
								break; /* udp is the default */ \
						case PROTO_TCP: \
						case PROTO_TLS: \
						case PROTO_WSS: \
								new_len+=TRANSPORT_PARAM_LEN+3; \
								break; \
						case PROTO_SCTP: \
								new_len+=TRANSPORT_PARAM_LEN+4; \
								break; \
						case PROTO_WS: \
								new_len+=TRANSPORT_PARAM_LEN+2; \
								break; \
						default: \
						LM_CRIT("unknown proto %d\n", \
								send_sock->proto); \
					}\
				} else \
					LM_BUG("null send_socket 4"); \
				break; \
			case SUBST_NOP: /* do nothing */ \
				break; \
			default: \
				LM_CRIT("unknown subst type %d\n", \
						(subst_l)->u.subst); \
		}


	s_offset=0;
	new_len=0;
	last_del=0;

	/* init send_address_str & send_port_str */
	if(send_sock && send_sock->adv_name_str.len)
		send_address_str=&(send_sock->adv_name_str);
	else if (msg->set_global_address.s)
		send_address_str=&(msg->set_global_address);
	else if (default_global_address->s)
		send_address_str=default_global_address;
	else
		send_address_str=&(send_sock->address_str);

	if(send_sock && send_sock->adv_port_str.len)
		send_port_str=&(send_sock->adv_port_str);
	else if (msg->set_global_port.s)
		send_port_str=&(msg->set_global_port);
	else if (default_global_port->s)
		send_port_str=default_global_port;
	else
		send_port_str=&(send_sock->port_no_str);

	/* init rcv_address_str & rcv_port_str */
	if(msg->rcv.bind_address) {
		if(msg->rcv.bind_address->adv_name_str.len)
			rcv_address_str=&(msg->rcv.bind_address->adv_name_str);
		else if (default_global_address->s)
			rcv_address_str=default_global_address;
		else
			rcv_address_str=&(msg->rcv.bind_address->address_str);
		if(msg->rcv.bind_address->adv_port_str.len)
			rcv_port_str=&(msg->rcv.bind_address->adv_port_str);
		else if (default_global_port->s)
			rcv_port_str=default_global_port;
		else
			rcv_port_str=&(msg->rcv.bind_address->port_no_str);
	}

	for (t = lumps; t && t->u.offset<(unsigned int)max_offset ; t = t->next) {
		/* is this lump still valid? (it must not be anchored in a deleted area */
		if (t->u.offset < s_offset && t->u.offset != last_del) {
			LM_DBG("skip a %d, buffer offset=%d, lump offset=%d, last_del=%d\n",
				t->op,s_offset, t->u.offset,last_del);
			continue;
		}

		for (r = t->before; r; r = r->before) {
			switch (r->op) {
				case LUMP_ADD:
					new_len += r->len;
					break;
				case LUMP_ADD_SUBST:
					SUBST_LUMP_LEN(r);
					break;
				case LUMP_ADD_OPT:
					/* skip if this is an OPT lump and the condition is
					 * not satisfied */
					if (!lump_check_opt(r, msg, send_sock))
						goto skip_before;
					break;
				case LUMP_SKIP:
					/* if a SKIP lump, go to the last in the list*/
					if (!r->before || !r->before->before)
						continue;
					for (; r->before->before; r = r->before)
						;
					break;
				default:
					/* only ADD allowed for before/after */
						LM_CRIT("invalid op for data lump (%x)\n", r->op);
			}
		}
skip_before:
		switch (t->op) {
			case LUMP_DEL:
				last_del=t->u.offset;

				if (t->u.offset < s_offset) {
					if (t->u.offset + t->len > s_offset) {
						new_len -= t->len - (s_offset - t->u.offset);
						s_offset = t->u.offset + t->len;
					}
				} else {
					new_len -= t->len;
					s_offset = t->u.offset + t->len;
				}

				break;
			case LUMP_NOP:
				/* do nothing */
				break;
			case LUMP_ADD:
				/* FIXME: inconsistent with process_lumps() */
				new_len += t->len;
				break;
			case LUMP_ADD_OPT:
				LM_BUG("LUMP_ADD_OPT");
				/* we don't do anything here, it's only a condition for
				 * before & after */
				break;
			case LUMP_SKIP:
				LM_BUG("LUMP_SKIP");
				/* we don't do anything here, it's only a condition for
				 * before & after */
				break;
			case LUMP_ADD_SUBST:
				LM_BUG("LUMP_ADD_SUBST");
				SUBST_LUMP_LEN(t);
				break;
			default:
				LM_BUG("op for data lump (%x)", r->op);
		}

		for (r = t->after; r; r = r->after) {
			switch (r->op) {
				case LUMP_ADD:
					new_len+=r->len;
					break;
				case LUMP_ADD_SUBST:
					SUBST_LUMP_LEN(r);
					break;
				case LUMP_ADD_OPT:
					/* skip if this is an OPT lump and the condition is
					 * not satisfied */
					if (!lump_check_opt(r, msg, send_sock))
						goto skip_after;
					break;
				case LUMP_SKIP:
					/* if a SKIP lump, go to the last in the list*/
					if (!r->after || !r->after->after)
						continue;
					for (; r->after->after; r = r->after)
						;
					break;
				default:
					/* only ADD allowed for before/after */
					LM_CRIT("invalid op for data lump (%x)\n", r->op);
			}
		}
skip_after:
		; /* to make gcc 3.* happy */
	}
	return new_len;
}
