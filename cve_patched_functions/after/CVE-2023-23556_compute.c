static OperationStatus compute(
    MutableBigIntRef quoc,
    MutableBigIntRef rem,
    ImmutableBigIntRef lhs,
    ImmutableBigIntRef rhs) {
  assert(
      ((quoc.digits != nullptr) != (rem.digits != nullptr)) &&
      "untested -- calling with both or neither quoc and rem");

  const uint32_t resultSize = divideResultSize(lhs, rhs);
  // set quoc's and rem's numDigits if their digits buffer is nullptr, which
  // allows querying either for determining the result size.
  if (quoc.digits == nullptr) {
    quoc.numDigits = resultSize;
  } else {
    rem.numDigits = resultSize;
  }

  // Ensure quoc is large enough; rem is the same size.
  if (quoc.numDigits < resultSize) {
    return OperationStatus::DEST_TOO_SMALL;
  }

  // make sure to drop any extraneous digits.
  quoc.numDigits = resultSize;
  rem.numDigits = resultSize;

  // Signal division by zero.
  if (compare(rhs, 0) == 0) {
    return OperationStatus::DIVISION_BY_ZERO;
  }

  // tcDivide operates on unsigned number, so just like multiply, the operands
  // must be negated (and the result as well, if appropriate) if they are
  // negative.
  const bool isLhsNegative = isNegative(lhs);
  const bool isRhsNegative = isNegative(rhs);

  // If rhs has fewer digits than quoc/rem it must be resized.
  const bool needToResizeRhs = rhs.numDigits < resultSize;

  // Figure out which temporary buffers are needed -- this determines how much
  // temporary storage will be allocated for the division.
  const bool needTmpQuoc = quoc.digits == nullptr;
  const bool needTmpRem = rem.digits == nullptr;
  const bool needTmpRhs = isRhsNegative || needToResizeRhs;

  uint32_t tmpStorageSizeScratch = resultSize;
  uint32_t tmpStorageSizeQuoc = needTmpQuoc ? resultSize : 0;
  uint32_t tmpStorageSizeRem = needTmpRem ? resultSize : 0;
  uint32_t tmpStorageSizeRhs = needTmpRhs ? resultSize : 0;

  const uint32_t tmpStorageSize = tmpStorageSizeScratch + tmpStorageSizeQuoc +
      tmpStorageSizeRem + tmpStorageSizeRhs;

  TmpStorage tmpStorage(tmpStorageSize);

  BigIntDigitType *scratch = tmpStorage.requestNumDigits(tmpStorageSizeScratch);

  if (needTmpQuoc) {
    assert(quoc.numDigits == tmpStorageSizeQuoc);
    quoc.digits = tmpStorage.requestNumDigits(tmpStorageSizeQuoc);
  } else {
    assert(rem.numDigits == tmpStorageSizeRem);
    rem.digits = tmpStorage.requestNumDigits(tmpStorageSizeRem);
  }

  if (needTmpRhs) {
    MutableBigIntRef tmpRhs{
        tmpStorage.requestNumDigits(tmpStorageSizeRhs), tmpStorageSizeRhs};
    auto res = initNonCanonicalWithReadOnlyBigInt(tmpRhs, rhs);
    assert(res == OperationStatus::RETURNED && "temporary array is too small");
    (void)res;
    if (isRhsNegative) {
      llvh::APInt::tcNegate(tmpRhs.digits, tmpRhs.numDigits);
    }
    rhs = ImmutableBigIntRef{tmpRhs.digits, tmpRhs.numDigits};
  }

  // tcDivide is in-place (i.e. quoc is lhs), so division will be expressed as
  //
  // quoc = signExt(lhs)
  // quoc, rem, scratch /= signExt(rhs)
  auto res = initNonCanonicalWithReadOnlyBigInt(quoc, lhs);
  assert(res == OperationStatus::RETURNED && "quoc array is too small");
  (void)res;

  // lhs can't be modified, but it has been sign-extended into quoc; thus, if
  // lhs < 0 negate quoc.
  if (isLhsNegative) {
    llvh::APInt::tcNegate(quoc.digits, quoc.numDigits);
  }

  llvh::APInt::tcDivide(
      quoc.digits, rhs.digits, rem.digits, scratch, resultSize);

  // post-process quoc if no space was allocated for it in the temporary storage
  // -- i.e., the caller wants the quoc.
  if (!needTmpQuoc) {
    // quoc must be negated if lhs' and rhs' signs don't match.
    const bool negateQuoc = isLhsNegative != isRhsNegative;
    if (negateQuoc) {
      llvh::APInt::tcNegate(quoc.digits, quoc.numDigits);
    }
    ensureCanonicalResult(quoc);
  }

  // post-process rem if no space was allocated for it in the temporary storage
  // -- i.e., the caller wants the rem.
  if (!needTmpRem) {
    // rem must be negated if lhs is negative.
    if (isLhsNegative) {
      llvh::APInt::tcNegate(rem.digits, rem.numDigits);
    }
    ensureCanonicalResult(rem);
  }

  return OperationStatus::RETURNED;
}
