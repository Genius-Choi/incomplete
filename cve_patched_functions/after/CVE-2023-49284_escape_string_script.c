static void escape_string_script(const wchar_t *orig_in, size_t in_len, wcstring &out,
                                 escape_flags_t flags) {
    const wchar_t *in = orig_in;
    const bool escape_printables = !(flags & ESCAPE_NO_PRINTABLES);
    const bool no_quoted = static_cast<bool>(flags & ESCAPE_NO_QUOTED);
    const bool no_tilde = static_cast<bool>(flags & ESCAPE_NO_TILDE);
    const bool no_qmark = feature_test(features_t::qmark_noglob);
    const bool symbolic = static_cast<bool>(flags & ESCAPE_SYMBOLIC) && (MB_CUR_MAX > 1);
    assert((!symbolic || !escape_printables) && "symbolic implies escape-no-printables");

    bool need_escape = false;
    bool need_complex_escape = false;

    if (!no_quoted && in_len == 0) {
        out.assign(L"''");
        return;
    }

    for (size_t i = 0; i < in_len; i++) {
        if ((*in >= ENCODE_DIRECT_BASE) && (*in < ENCODE_DIRECT_BASE + 256)) {
            int val = *in - ENCODE_DIRECT_BASE;
            int tmp;

            out += L'\\';
            out += L'X';

            tmp = val / 16;
            out += tmp > 9 ? L'a' + (tmp - 10) : L'0' + tmp;

            tmp = val % 16;
            out += tmp > 9 ? L'a' + (tmp - 10) : L'0' + tmp;
            need_escape = need_complex_escape = true;

        } else {
            wchar_t c = *in;
            switch (c) {
                case L'\t': {
                    if (symbolic)
                        out += L'␉';
                    else
                        out += L"\\t";
                    need_escape = need_complex_escape = true;
                    break;
                }
                case L'\n': {
                    if (symbolic)
                        out += L'␤';
                    else
                        out += L"\\n";
                    need_escape = need_complex_escape = true;
                    break;
                }
                case L'\b': {
                    if (symbolic)
                        out += L'␈';
                    else
                        out += L"\\b";
                    need_escape = need_complex_escape = true;
                    break;
                }
                case L'\r': {
                    if (symbolic)
                        out += L'␍';
                    else
                        out += L"\\r";
                    need_escape = need_complex_escape = true;
                    break;
                }
                case L'\x1B': {
                    if (symbolic)
                        out += L'␛';
                    else
                        out += L"\\e";
                    need_escape = need_complex_escape = true;
                    break;
                }
                case L'\x7F': {
                    if (symbolic)
                        out += L'␡';
                    else
                        out += L"\\x7f";
                    need_escape = need_complex_escape = true;
                    break;
                }
                case L'\\':
                case L'\'': {
                    need_escape = need_complex_escape = true;
                    if (escape_printables || (c == L'\\' && !symbolic)) out += L'\\';
                    out += *in;
                    break;
                }
                case ANY_CHAR: {
                    // See #1614
                    out += L'?';
                    break;
                }
                case ANY_STRING: {
                    out += L'*';
                    break;
                }
                case ANY_STRING_RECURSIVE: {
                    out += L"**";
                    break;
                }

                case L'&':
                case L'$':
                case L' ':
                case L'#':
                case L'<':
                case L'>':
                case L'(':
                case L')':
                case L'[':
                case L']':
                case L'{':
                case L'}':
                case L'?':
                case L'*':
                case L'|':
                case L';':
                case L'"':
                case L'%':
                case L'~': {
                    bool char_is_normal = (c == L'~' && no_tilde) || (c == L'?' && no_qmark);
                    if (!char_is_normal) {
                        need_escape = true;
                        if (escape_printables) out += L'\\';
                    }
                    out += *in;
                    break;
                }

                default: {
                    if (*in >= 0 && *in < 32) {
                        need_escape = need_complex_escape = true;

                        if (symbolic) {
                            out += L'\u2400' + *in;
                            break;
                        }

                        if (*in < 27 && *in != 0) {
                            out += L'\\';
                            out += L'c';
                            out += L'a' + *in - 1;
                            break;
                        }

                        int tmp = (*in) % 16;
                        out += L'\\';
                        out += L'x';
                        out += ((*in > 15) ? L'1' : L'0');
                        out += tmp > 9 ? L'a' + (tmp - 10) : L'0' + tmp;
                    } else {
                        out += *in;
                    }
                    break;
                }
            }
        }

        in++;
    }

    // Use quoted escaping if possible, since most people find it easier to read.
    if (!no_quoted && need_escape && !need_complex_escape && escape_printables) {
        wchar_t single_quote = L'\'';
        out.clear();
        out.reserve(2 + in_len);
        out.push_back(single_quote);
        out.append(orig_in, in_len);
        out.push_back(single_quote);
    }
}
