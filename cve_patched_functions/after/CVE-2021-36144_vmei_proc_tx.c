vmei_proc_tx(struct virtio_mei *vmei, struct virtio_vq_info *vq)
{
	struct iovec iov[VMEI_TX_SEGS + 1];
	uint16_t idx;
	size_t tlen;
	int n;

	struct mei_msg_hdr *hdr;
	uint8_t *data;
	size_t data_len;
	uint8_t i_idx;
	struct vmei_circular_iobufs *bufs;

	struct vmei_host_client *hclient  = NULL;

	/*
	 * Obtain chain of descriptors.
	 * The first one is hdr, the second is for payload.
	 */
	n = vq_getchain(vq, &idx, iov, VMEI_TX_SEGS, NULL);
	if (n != VMEI_TX_SEGS) {
		if (n == -1 || n == 0)
			pr_err("%s: fail to getchain!\n", __func__);
		else {
			pr_warn("%s: invalid chain, desc number %d!\n", __func__, n);
			vq_relchain(vq, idx, 0);
		}
		return;
	}

	tlen = iov[0].iov_len + iov[1].iov_len;

	if (iov[0].iov_len < sizeof(*hdr)) {
		pr_err("%s: supplied buffer has invalid size");
		goto failed;
	}
	hdr = (struct mei_msg_hdr *)iov[0].iov_base;
	data = (uint8_t *)iov[1].iov_base;
	data_len = iov[1].iov_len;


	DPRINTF("TX: UOS->DM, hdr[h=%02d me=%02d comp=%1d] length[%d]\n",
		hdr->host_addr, hdr->me_addr, hdr->msg_complete, hdr->length);
	vmei_dbg_print_hex("TX: UOS->DM", data, data_len);

	if (hdr->length < data_len) {
		pr_err("%s: supplied buffer has invalid size");
		goto failed;
	}

	if (hdr_is_hbm(hdr)) {
		if (vmei_hbm_handler(vmei, data, data_len)) {
			pr_err("%s: supplied buffer has invalid size");
			goto failed;
		}
		goto out;
	}

	/* general client client
	 * must be in active_clients list.
	 */
	hclient = vmei_find_host_client(vmei, hdr->me_addr, hdr->host_addr);
	if (!hclient) {
		DPRINTF("TX: ME[%02d:%02d] NOT found!\n",
			hdr->host_addr,  hdr->host_addr);
		goto failed;
	}

	pthread_mutex_lock(&vmei->tx_mutex);
	bufs = &hclient->send_bufs;
	i_idx = bufs->i_idx;
	HCL_DBG(hclient, "TX: client found complete = %d\n",
		bufs->complete[i_idx]);
	/* check for overflow
	 * here there are 2 types of possible overflows :
	 *  (1) no available buffers (all buffers are taken) and
	 *  (2) no space in the current buffer
	 */
	if ((i_idx + 1) % VMEI_IOBUFS_MAX == bufs->r_idx ||
	    (bufs->buf_sz - bufs->bufs[i_idx].iov_len < hdr->length)) {
		HCL_DBG(hclient, "TX: overflow\n");
		/* close the connection according to spec */
		/* FIXME need to remove the clinet */
		vmei_hbm_disconnect_client(hclient);
		pthread_mutex_unlock(&vmei->tx_mutex);
		vmei_host_client_put(hclient);
		goto out;
	}
	/* copy buffer from virtqueue to send_buf */
	memcpy(bufs->bufs[i_idx].iov_base + bufs->bufs[i_idx].iov_len,
	       data, hdr->length);

	bufs->bufs[i_idx].iov_len += hdr->length;
	if (hdr->msg_complete) {
		/* send complete msg to HW */
		HCL_DBG(hclient, "TX: completed, sening msg to FW\n");
		bufs->complete[i_idx] = 1;
		bufs->i_idx++;
		if (bufs->i_idx >= VMEI_IOBUFS_MAX) /* wraparound */
			bufs->i_idx = 0;
		pthread_cond_signal(&vmei->tx_cond);
	}
	pthread_mutex_unlock(&vmei->tx_mutex);
	vmei_host_client_put(hclient);
out:
	/* chain is processed, release it and set tlen */
	vq_relchain(vq, idx, tlen);
	DPRINTF("TX: release OUT-vq idx[%d]\n", idx);

	pthread_mutex_lock(&vmei->rx_mutex);
	if (vmei->rx_need_sched)
		pthread_cond_signal(&vmei->rx_cond);
	pthread_mutex_unlock(&vmei->rx_mutex);

	return;

failed:
	if (vmei->status == VMEI_STS_PENDING_RESET) {
		vmei_virtual_fw_reset(vmei);
		/* Let's wait 100ms for HBM enumeration done */
		usleep(100000);
		virtio_config_changed(&vmei->base);
	}
	/* drop the data */
	vq_relchain(vq, idx, tlen);
}
