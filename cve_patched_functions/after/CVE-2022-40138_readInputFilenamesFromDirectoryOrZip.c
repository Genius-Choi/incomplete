::hermes::parser::JSONObject *readInputFilenamesFromDirectoryOrZip(
    llvh::StringRef inputPath,
    SegmentTable &fileBufs,
    std::vector<uint32_t> &segmentIDs,
    ::hermes::parser::JSLexer::Allocator &alloc,
    struct zip_t *zip) {
  auto metadataBuf = getFileFromDirectoryOrZip(zip, inputPath, "metadata.json");
  if (!metadataBuf) {
    llvh::errs()
        << "Failed to read metadata: Input must contain a metadata.json file\n";
    return nullptr;
  }

  auto *metadataVal = parseJSONFile(metadataBuf, alloc);
  if (!metadataVal) {
    // parseJSONFile prints any error messages.
    return nullptr;
  }

  // Pull data from the metadata JSON object into C++ data structures.
  // The metadata format is documented at doc/Modules.md.

  auto *metadata = dyn_cast<parser::JSONObject>(metadataVal);
  if (!metadata) {
    llvh::errs() << "Metadata must be a JSON object\n";
    return nullptr;
  }

  auto *segments =
      llvh::dyn_cast_or_null<parser::JSONObject>(metadata->get("segments"));
  if (!segments) {
    llvh::errs() << "Metadata must contain segment information\n";
    return nullptr;
  }

  // Module IDs in metadata, None if none could be read.
  auto externalModuleIDs = readModuleIDs(metadata);
  // Module ID table used for assigning auto-incrementing module IDs if we
  // don't have external module IDs.
  ModuleIDsTable automaticModuleIDs;
  uint32_t nextAutomaticModuleID = 0;

  for (auto it : *segments) {
    uint32_t segmentID;
    if (it.first->str().getAsInteger(10, segmentID)) {
      // getAsInteger returns true to signal error.
      llvh::errs() << "Metadata segment IDs must be unsigned integers: Found "
                   << it.first->str() << '\n';
      return nullptr;
    }

    auto *segment = llvh::dyn_cast_or_null<parser::JSONArray>(it.second);
    if (!segment) {
      llvh::errs() << "Metadata segment information must be an array\n";
      return nullptr;
    }

    SegmentTableEntry segmentBufs{};
    for (auto val : *segment) {
      auto *relPath = llvh::dyn_cast_or_null<parser::JSONString>(val);
      if (!relPath) {
        llvh::errs() << "Segment paths must be strings\n";
        return nullptr;
      }
      auto filename = llvh::sys::path::remove_leading_dotslash(relPath->str());
      auto fileBuf = getFileFromDirectoryOrZip(zip, inputPath, filename);
      if (!fileBuf) {
        return nullptr;
      }
      auto mapBuf = getFileFromDirectoryOrZip(
          zip, inputPath, llvh::Twine(filename, ".map"), true);
      uint32_t moduleID;
      if (externalModuleIDs.hasValue()) {
        auto itr = externalModuleIDs->find(filename);
        if (itr == externalModuleIDs->end()) {
          llvh::errs() << "Module is missing in externalModuleIDs: " << filename
                       << "\n";
          return nullptr;
        }
        moduleID = itr->second;
      } else {
        auto emplaceRes =
            automaticModuleIDs.try_emplace(filename, nextAutomaticModuleID);
        if (emplaceRes.second) {
          ++nextAutomaticModuleID;
        }
        moduleID = emplaceRes.first->second;
      }
      // mapBuf is optional, so simply pass it through if it's null.
      segmentBufs.push_back({moduleID, std::move(fileBuf), std::move(mapBuf)});
    }

    auto emplaceRes = fileBufs.emplace(segmentID, std::move(segmentBufs));
    if (!emplaceRes.second) {
      llvh::errs() << "Duplicate segment entry in metadata: " << segment
                   << "\n";
      return nullptr;
    }

    segmentIDs.push_back(segmentID);
  }

  return metadata;
}
