Result AuthenticationFeature::loadJwtSecretFolder() try {
  TRI_ASSERT(!_jwtSecretFolderProgramOption.empty());

  LOG_TOPIC("4922f", INFO, arangodb::Logger::AUTHENTICATION)
      << "loading JWT secrets from folder " << _jwtSecretFolderProgramOption;

  auto list = basics::FileUtils::listFiles(_jwtSecretFolderProgramOption);

  // filter out empty filenames, hidden files, tmp files and symlinks
  list.erase(std::remove_if(list.begin(), list.end(),
      [this](std::string const& file) {
        if (file.empty() || file[0] == '.') {
          return true;
        }
        if (file.size() >= 4 && file.substr(file.size() - 4, 4) == ".tmp") {
          return true;
        }
        auto p = basics::FileUtils::buildFilename(_jwtSecretFolderProgramOption, file);
        if (basics::FileUtils::isSymbolicLink(p)) {
          return true;
        }
        return false;
      }),
      list.end());

  if (list.empty()) {
    return Result(TRI_ERROR_BAD_PARAMETER, "empty JWT secrets directory");
  }

  auto slurpy = [&](std::string const& file) {
    auto p = basics::FileUtils::buildFilename(_jwtSecretFolderProgramOption, file);
    std::string contents = basics::FileUtils::slurp(p);
    return basics::StringUtils::trim(contents, " \t\n\r");
  };

  std::sort(std::begin(list), std::end(list));
  std::string activeSecret = slurpy(list[0]);

  const std::string msg = "Given JWT secret too long. Max length is 64";
  if (activeSecret.length() > _maxSecretLength) {
    return Result(TRI_ERROR_BAD_PARAMETER, msg);
  }

#ifdef USE_ENTERPRISE
  std::vector<std::string> passiveSecrets;
  if (list.size() > 1) {
    list.erase(list.begin());
    for (auto const& file : list) {
      std::string secret = slurpy(file);
      if (secret.length() > _maxSecretLength) {
        return Result(TRI_ERROR_BAD_PARAMETER, msg);
      }
      if (!secret.empty()) {  // ignore
        passiveSecrets.push_back(std::move(secret));
      }
    }
  }
  _jwtPassiveSecrets = std::move(passiveSecrets);

  LOG_TOPIC("4a34f", INFO, arangodb::Logger::AUTHENTICATION)
      << "have " << _jwtPassiveSecrets.size() << " passive JWT secrets";
#endif

  _jwtSecretProgramOption = std::move(activeSecret);

  return Result();
} catch (basics::Exception const& ex) {
  std::string msg("unable to read content of jwt-secret-folder '");
  msg.append(_jwtSecretFolderProgramOption)
      .append("': ")
      .append(ex.what())
      .append(". please make sure the file/directory is readable for the ")
      .append("arangod process and user");
  return Result(TRI_ERROR_CANNOT_READ_FILE, std::move(msg));
}
