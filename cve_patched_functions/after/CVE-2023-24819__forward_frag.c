static int _forward_frag(gnrc_pktsnip_t *pkt, gnrc_pktsnip_t *frag_hdr,
                         gnrc_sixlowpan_frag_vrb_t *vrbe, unsigned page)
{
    /* remove rewritten netif header (forwarding implementation must do this
     * anyway) */
    pkt = gnrc_pktbuf_remove_snip(pkt, pkt);
    if (IS_USED(MODULE_GNRC_SIXLOWPAN_FRAG_MINFWD) &&
        sixlowpan_frag_is(frag_hdr->data)) {
        return gnrc_sixlowpan_frag_minfwd_forward(pkt, frag_hdr->data, vrbe,
                                                  page);
    }
    /* the following is just debug output for testing without any forwarding
     * scheme */
#ifdef MODULE_GNRC_SIXLOWPAN_FRAG_SFR
    if (sixlowpan_sfr_rfrag_is(frag_hdr->data)) {
        return gnrc_sixlowpan_frag_sfr_forward(pkt, frag_hdr->data, vrbe, page);
    }
#endif  /* MODULE_GNRC_SIXLOWPAN_FRAG_SFR */
    DEBUG("6lo iphc: Do not know how to forward fragment from (%s, %u) ",
          gnrc_netif_addr_to_str(vrbe->super.src, vrbe->super.src_len,
                                 addr_str), vrbe->super.tag);
    DEBUG("to (%s, %u)\n",
          gnrc_netif_addr_to_str(vrbe->super.dst, vrbe->super.dst_len,
                                 addr_str), vrbe->out_tag);
    if (IS_ACTIVE(ENABLE_DEBUG) && IS_USED(MODULE_OD)) {
        DEBUG("Original fragmentation header:\n");
        od_hex_dump(frag_hdr->data, frag_hdr->size, OD_WIDTH_DEFAULT);
        DEBUG("IPHC headers + payload:\n");
        frag_hdr = pkt;
        while (frag_hdr) {
            od_hex_dump(frag_hdr->data, frag_hdr->size, OD_WIDTH_DEFAULT);
            frag_hdr = frag_hdr->next;
        }
    }
    gnrc_pktbuf_release(pkt);
    (void)frag_hdr;
    (void)page;
    return -ENOTSUP;
}
