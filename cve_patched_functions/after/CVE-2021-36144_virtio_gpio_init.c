virtio_gpio_init(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	struct virtio_gpio *gpio;
	pthread_mutexattr_t attr;
	int rc, i;

	/* Just support one bdf */
	if (virtio_gpio_is_active)
		return -1;

	if (!opts) {
		WPRINTF(("%s", "virtio gpio: needs gpio information\n"));
		rc = -EINVAL;
		goto init_fail;
	}

	gpio = calloc(1, sizeof(struct virtio_gpio));
	if (!gpio) {
		WPRINTF(("%s", "virtio gpio: failed to calloc virtio_gpio\n"));
		rc = -ENOMEM;
		goto init_fail;
	}

	rc = native_gpio_init(gpio, opts);
	if (rc) {
		WPRINTF(("%s", "virtio gpio: failed to initialize gpio\n"));
		goto gpio_fail;
	}

	rc = gpio_irq_init(gpio);
	if (rc) {
		WPRINTF(("%s", "virtio gpio: failed to initialize gpio irq\n"));
		goto irq_fail;
	}

	/* init mutex attribute properly to avoid deadlock */
	rc = pthread_mutexattr_init(&attr);
	if (rc) {
		WPRINTF(("mutexattr init failed with error %d!\n", rc));
		goto mtx_fail;
	}
	rc = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
	if (rc) {
		WPRINTF(("mutexattr_settype failed with error %d!\n", rc));
		goto fail;
	}

	rc = pthread_mutex_init(&gpio->mtx, &attr);
	if (rc) {
		WPRINTF(("pthread_mutex_init failed with error %d!\n", rc));
		goto fail;
	}

	virtio_linkup(&gpio->base, &virtio_gpio_ops, gpio, dev, gpio->queues,
			BACKEND_VBSU);

	/* gpio base for frontend gpio chip */
	gpio->config.base = 0;

	/* gpio numbers for frontend gpio chip */
	gpio->config.ngpio = gpio->nvline;

	gpio->base.device_caps = VIRTIO_GPIO_S_HOSTCAPS;
	gpio->base.mtx = &gpio->mtx;
	gpio->queues[0].qsize = 64;
	gpio->queues[0].notify = virtio_gpio_notify;
	gpio->queues[1].qsize = 64;
	gpio->queues[1].notify = virtio_irq_notify;
	gpio->queues[2].qsize = 64;
	gpio->queues[2].notify = virtio_irq_evt_notify;

	/* initialize config space */
	pci_set_cfgdata16(dev, PCIR_DEVICE, VIRTIO_DEV_GPIO);
	pci_set_cfgdata16(dev, PCIR_VENDOR, INTEL_VENDOR_ID);
	pci_set_cfgdata8(dev, PCIR_CLASS, PCIC_BASEPERIPH);
	pci_set_cfgdata16(dev, PCIR_SUBDEV_0, VIRTIO_TYPE_GPIO);
	pci_set_cfgdata16(dev, PCIR_SUBVEND_0, INTEL_VENDOR_ID);

	/* use BAR 1 to map MSI-X table and PBA, if we're using MSI-X */
	if (virtio_interrupt_init(&gpio->base, virtio_uses_msix())) {
		rc = -1;
		goto fail;
	}

	/* Allocate PIO space for GPIO */
	virtio_gpio_ops.cfgsize = sizeof(struct virtio_gpio_config) + GPIO_PIO_SIZE;

	/* use BAR 0 to map config regs in IO space */
	virtio_set_io_bar(&gpio->base, 0);

	gpio_pio_start = dev->bar[0].addr + VIRTIO_PCI_CONFIG_OFF(1) +
		sizeof(struct virtio_gpio_config);

	virtio_gpio_is_active = true;

	/* dump gpio information */
	print_gpio_info(gpio);
	return 0;

fail:
	pthread_mutex_destroy(&gpio->mtx);

mtx_fail:
	gpio_irq_deinit(gpio);

irq_fail:
	for (i = 0; i < gpio->nchip; i++)
		native_gpio_close_chip(&gpio->chips[i]);

gpio_fail:
	free(gpio);
	dev->arg = NULL;

init_fail:
	return rc;
}
