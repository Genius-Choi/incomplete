static int tls_send_plaintext ( struct tls_connection *tls, unsigned int type,
				const void *data, size_t len ) {
	struct tls_cipherspec *cipherspec = &tls->tx_cipherspec;
	struct tls_cipher_suite *suite = cipherspec->suite;
	struct cipher_algorithm *cipher = suite->cipher;
	struct digest_algorithm *digest = suite->digest;
	struct {
		uint8_t fixed[suite->fixed_iv_len];
		uint8_t record[suite->record_iv_len];
	} __attribute__ (( packed )) iv;
	struct tls_auth_header authhdr;
	struct tls_header *tlshdr;
	void *plaintext = NULL;
	size_t plaintext_len = len;
	struct io_buffer *ciphertext = NULL;
	size_t ciphertext_len;
	size_t padding_len;
	uint8_t mac[digest->digestsize];
	void *tmp;
	int rc;

	/* Construct initialisation vector */
	memcpy ( iv.fixed, cipherspec->fixed_iv, sizeof ( iv.fixed ) );
	tls_generate_random ( tls, iv.record, sizeof ( iv.record ) );

	/* Construct authentication data */
	authhdr.seq = cpu_to_be64 ( tls->tx_seq );
	authhdr.header.type = type;
	authhdr.header.version = htons ( tls->version );
	authhdr.header.length = htons ( len );

	/* Calculate padding length */
	plaintext_len += suite->mac_len;
	if ( is_block_cipher ( cipher ) ) {
		padding_len = ( ( ( cipher->blocksize - 1 ) &
				  -( plaintext_len + 1 ) ) + 1 );
	} else {
		padding_len = 0;
	}
	plaintext_len += padding_len;

	/* Allocate plaintext */
	plaintext = malloc ( plaintext_len );
	if ( ! plaintext ) {
		DBGC ( tls, "TLS %p could not allocate %zd bytes for "
		       "plaintext\n", tls, plaintext_len );
		rc = -ENOMEM_TX_PLAINTEXT;
		goto done;
	}

	/* Assemble plaintext */
	tmp = plaintext;
	memcpy ( tmp, data, len );
	tmp += len;
	if ( suite->mac_len )
		tls_hmac ( cipherspec, &authhdr, data, len, mac );
	memcpy ( tmp, mac, suite->mac_len );
	tmp += suite->mac_len;
	memset ( tmp, ( padding_len - 1 ), padding_len );
	tmp += padding_len;
	assert ( tmp == ( plaintext + plaintext_len ) );
	DBGC2 ( tls, "Sending plaintext data:\n" );
	DBGC2_HD ( tls, plaintext, plaintext_len );

	/* Set initialisation vector */
	cipher_setiv ( cipher, cipherspec->cipher_ctx, &iv, sizeof ( iv ) );

	/* Allocate ciphertext */
	ciphertext_len = ( sizeof ( *tlshdr ) + sizeof ( iv.record ) +
			   plaintext_len );
	ciphertext = xfer_alloc_iob ( &tls->cipherstream, ciphertext_len );
	if ( ! ciphertext ) {
		DBGC ( tls, "TLS %p could not allocate %zd bytes for "
		       "ciphertext\n", tls, ciphertext_len );
		rc = -ENOMEM_TX_CIPHERTEXT;
		goto done;
	}

	/* Assemble ciphertext */
	tlshdr = iob_put ( ciphertext, sizeof ( *tlshdr ) );
	tlshdr->type = type;
	tlshdr->version = htons ( tls->version );
	tlshdr->length = htons ( ciphertext_len - sizeof ( *tlshdr ) );
	memcpy ( iob_put ( ciphertext, sizeof ( iv.record ) ), iv.record,
		 sizeof ( iv.record ) );
	cipher_encrypt ( cipher, cipherspec->cipher_ctx, plaintext,
			 iob_put ( ciphertext, plaintext_len ), plaintext_len );
	assert ( iob_len ( ciphertext ) == ciphertext_len );

	/* Free plaintext as soon as possible to conserve memory */
	free ( plaintext );
	plaintext = NULL;

	/* Send ciphertext */
	if ( ( rc = xfer_deliver_iob ( &tls->cipherstream,
				       iob_disown ( ciphertext ) ) ) != 0 ) {
		DBGC ( tls, "TLS %p could not deliver ciphertext: %s\n",
		       tls, strerror ( rc ) );
		goto done;
	}

	/* Update TX state machine to next record */
	tls->tx_seq += 1;

 done:
	free ( plaintext );
	free_iob ( ciphertext );
	return rc;
}
