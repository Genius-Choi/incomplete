STATIC mp_uint_t poll_set_poll_until_ready_or_timeout(poll_set_t *poll_set, size_t *rwx_num, mp_uint_t timeout) {
    mp_uint_t start_ticks = mp_hal_ticks_ms();
    bool has_timeout = timeout != (mp_uint_t)-1;

    #if MICROPY_PY_SELECT_POSIX_OPTIMISATIONS

    for (;;) {
        MP_THREAD_GIL_EXIT();

        // Compute the timeout.
        int t = MICROPY_PY_SELECT_IOCTL_CALL_PERIOD_MS;
        if (poll_set_all_are_fds(poll_set)) {
            // All our pollables are file descriptors, so we can use a blocking
            // poll and let it (the underlying system) handle the timeout.
            if (timeout == (mp_uint_t)-1) {
                t = -1;
            } else {
                mp_uint_t delta = mp_hal_ticks_ms() - start_ticks;
                if (delta >= timeout) {
                    t = 0;
                } else {
                    t = timeout - delta;
                }
            }
        }

        // Call system poll for those objects that have a file descriptor.
        int n_ready = poll(poll_set->pollfds, poll_set->max_used, t);

        MP_THREAD_GIL_ENTER();

        // The call to poll() may have been interrupted, but per PEP 475 we must retry if the
        // signal is EINTR (this implements a special case of calling MP_HAL_RETRY_SYSCALL()).
        if (n_ready == -1) {
            int err = errno;
            if (err != EINTR) {
                mp_raise_OSError(err);
            }
            n_ready = 0;
        }

        // Explicitly poll any objects that do not have a file descriptor.
        if (!poll_set_all_are_fds(poll_set)) {
            n_ready += poll_set_poll_once(poll_set, rwx_num);
        }

        // Return if an object is ready, or if the timeout expired.
        if (n_ready > 0 || (has_timeout && mp_hal_ticks_ms() - start_ticks >= timeout)) {
            return n_ready;
        }

        // This would be mp_event_wait_ms() but the call to poll() above already includes a delay.
        mp_event_handle_nowait();
    }

    #else

    for (;;) {
        // poll the objects
        mp_uint_t n_ready = poll_set_poll_once(poll_set, rwx_num);
        uint32_t elapsed = mp_hal_ticks_ms() - start_ticks;
        if (n_ready > 0 || (has_timeout && elapsed >= timeout)) {
            return n_ready;
        }
        if (has_timeout) {
            mp_event_wait_ms(timeout - elapsed);
        } else {
            mp_event_wait_indefinite();
        }
    }

    #endif
}
