UpstreamRequest::UpstreamRequest(RouterFilterInterface& parent,
                                 std::unique_ptr<GenericConnPool>&& conn_pool,
                                 bool can_send_early_data, bool can_use_http3)
    : parent_(parent), conn_pool_(std::move(conn_pool)),
      stream_info_(parent_.callbacks()->dispatcher().timeSource(), nullptr),
      start_time_(parent_.callbacks()->dispatcher().timeSource().monotonicTime()),
      calling_encode_headers_(false), upstream_canary_(false), router_sent_end_stream_(false),
      encode_trailers_(false), retried_(false), awaiting_headers_(true),
      outlier_detection_timeout_recorded_(false),
      create_per_try_timeout_on_request_complete_(false), paused_for_connect_(false),
      reset_stream_(false),
      record_timeout_budget_(parent_.cluster()->timeoutBudgetStats().has_value()),
      cleaned_up_(false), had_upstream_(false),
      stream_options_({can_send_early_data, can_use_http3}), grpc_rq_success_deferred_(false),
      upstream_wait_for_response_headers_before_disabling_read_(Runtime::runtimeFeatureEnabled(
          "envoy.reloadable_features.upstream_wait_for_response_headers_before_disabling_read")) {
  if (auto tracing_config = parent_.callbacks()->tracingConfig(); tracing_config.has_value()) {
    if (tracing_config->spawnUpstreamSpan() || parent_.config().start_child_span_) {
      span_ = parent_.callbacks()->activeSpan().spawnChild(
          tracing_config.value().get(),
          absl::StrCat("router ", parent.cluster()->observabilityName(), " egress"),
          parent_.callbacks()->dispatcher().timeSource().systemTime());
      if (parent.attemptCount() != 1) {
        // This is a retry request, add this metadata to span.
        span_->setTag(Tracing::Tags::get().RetryCount, std::to_string(parent.attemptCount() - 1));
      }
    }
  }

  // The router checks that the connection pool is non-null before creating the upstream request.
  auto upstream_host = conn_pool_->host();
  Tracing::HttpTraceContext trace_context(*parent_.downstreamHeaders());
  if (span_ != nullptr) {
    span_->injectContext(trace_context, upstream_host);
  } else {
    // No independent child span for current upstream request then inject the parent span's tracing
    // context into the request headers.
    // The injectContext() of the parent span may be called repeatedly when the request is retried.
    parent_.callbacks()->activeSpan().injectContext(trace_context, upstream_host);
  }

  stream_info_.setUpstreamInfo(std::make_shared<StreamInfo::UpstreamInfoImpl>());
  stream_info_.route_ = parent_.callbacks()->route();
  parent_.callbacks()->streamInfo().setUpstreamInfo(stream_info_.upstreamInfo());

  stream_info_.healthCheck(parent_.callbacks()->streamInfo().healthCheck());
  stream_info_.setIsShadow(parent_.callbacks()->streamInfo().isShadow());
  absl::optional<Upstream::ClusterInfoConstSharedPtr> cluster_info =
      parent_.callbacks()->streamInfo().upstreamClusterInfo();
  if (cluster_info.has_value()) {
    stream_info_.setUpstreamClusterInfo(*cluster_info);
  }

  // Set up the upstream HTTP filter manager.
  filter_manager_callbacks_ = std::make_unique<UpstreamRequestFilterManagerCallbacks>(*this);
  filter_manager_ = std::make_unique<UpstreamFilterManager>(
      *filter_manager_callbacks_, parent_.callbacks()->dispatcher(), connection(),
      parent_.callbacks()->streamId(), parent_.callbacks()->account(), true,
      parent_.callbacks()->decoderBufferLimit(), *parent_.cluster(), *this);
  // Attempt to create custom cluster-specified filter chain
  bool created = parent_.cluster()->createFilterChain(*filter_manager_,
                                                      /*only_create_if_configured=*/true);
  if (!created) {
    // Attempt to create custom router-specified filter chain.
    created = parent_.config().createFilterChain(*filter_manager_);
  }
  if (!created) {
    // Neither cluster nor router have a custom filter chain; add the default
    // cluster filter chain, which only consists of the codec filter.
    created = parent_.cluster()->createFilterChain(*filter_manager_, false);
  }
  // There will always be a codec filter present, which sets the upstream
  // interface. Fast-fail any tests that don't set up mocks correctly.
  ASSERT(created && upstream_interface_.has_value());
}
