void IMAPSession::storeLabels(String * folder, bool identifier_is_uid, IndexSet * identifiers, IMAPStoreFlagsRequestKind kind, Array * labels, ErrorCode * pError)
{
    struct mailimap_set * imap_set;
    struct mailimap_msg_att_xgmlabels * xgmlabels;
    int r;
    clist * setList;

    selectIfNeeded(folder, pError);
    if (* pError != ErrorNone)
        return;

    imap_set = setFromIndexSet(identifiers);
    if (clist_count(imap_set->set_list) == 0) {
        mailimap_set_free(imap_set);
        return;
    }

    setList = splitSet(imap_set, 10);

    xgmlabels = mailimap_msg_att_xgmlabels_new_empty();
    for(unsigned int i = 0 ; i < labels->count() ; i ++) {
        String * label = (String *) labels->objectAtIndex(i);
        mailimap_msg_att_xgmlabels_add(xgmlabels, strdup(label->UTF8Characters()));
    }

    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {
        struct mailimap_set * current_set;
        int fl_sign;

        current_set = (struct mailimap_set *) clist_content(iter);

        switch (kind) {
            case IMAPStoreFlagsRequestKindRemove:
            fl_sign = -1;
            break;
            case IMAPStoreFlagsRequestKindAdd:
            fl_sign = 1;
            break;
            case IMAPStoreFlagsRequestKindSet:
            fl_sign = 0;
            break;
        }
        if (identifier_is_uid) {
            r = mailimap_uid_store_xgmlabels(mImap, current_set, fl_sign, 1, xgmlabels);
        }
        else {
            r = mailimap_store_xgmlabels(mImap, current_set, fl_sign, 1, xgmlabels);
        }
        if (r == MAILIMAP_ERROR_STREAM) {
            mShouldDisconnect = true;
            * pError = ErrorConnection;
            goto release;
        }
        else if (r == MAILIMAP_ERROR_PARSE) {
            mShouldDisconnect = true;
            * pError = ErrorParse;
            goto release;
        }
        else if (hasError(r)) {
            * pError = ErrorStore;
            goto release;
        }
    }
    * pError = ErrorNone;

    release:
    for(clistiter * iter = clist_begin(setList) ; iter != NULL ; iter = clist_next(iter)) {
        struct mailimap_set * current_set;

        current_set = (struct mailimap_set *) clist_content(iter);
        mailimap_set_free(current_set);
    }
    clist_free(setList);
    mailimap_msg_att_xgmlabels_free(xgmlabels);
    mailimap_set_free(imap_set);
}
