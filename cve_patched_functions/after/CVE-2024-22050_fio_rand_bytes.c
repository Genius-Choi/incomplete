void fio_rand_bytes(void *data_, size_t len) {
  if (!data_ || !len)
    return;
  uint8_t *data = data_;
  /* unroll 32 bytes / 256 bit writes */
  for (size_t i = (len >> 5); i; --i) {
    const uint64_t t0 = fio_rand64();
    const uint64_t t1 = fio_rand64();
    const uint64_t t2 = fio_rand64();
    const uint64_t t3 = fio_rand64();
    fio_u2str64(data, t0);
    fio_u2str64(data + 8, t1);
    fio_u2str64(data + 16, t2);
    fio_u2str64(data + 24, t3);
    data += 32;
  }
  uint64_t tmp;
  /* 64 bit steps  */
  switch (len & 24) {
  case 24:
    tmp = fio_rand64();
    fio_u2str64(data + 16, tmp);
    /* fallthrough */
  case 16:
    tmp = fio_rand64();
    fio_u2str64(data + 8, tmp);
    /* fallthrough */
  case 8:
    tmp = fio_rand64();
    fio_u2str64(data, tmp);
    data += len & 24;
  }
  if ((len & 7)) {
    tmp = fio_rand64();
    /* leftover bytes */
    switch ((len & 7)) {
    case 7:
      data[6] = (tmp >> 8) & 0xFF;
      /* fallthrough */
    case 6:
      data[5] = (tmp >> 16) & 0xFF;
      /* fallthrough */
    case 5:
      data[4] = (tmp >> 24) & 0xFF;
      /* fallthrough */
    case 4:
      data[3] = (tmp >> 32) & 0xFF;
      /* fallthrough */
    case 3:
      data[2] = (tmp >> 40) & 0xFF;
      /* fallthrough */
    case 2:
      data[1] = (tmp >> 48) & 0xFF;
      /* fallthrough */
    case 1:
      data[0] = (tmp >> 56) & 0xFF;
    }
  }
}
