abstractEqualityTest_RJS(Runtime &runtime, Handle<> xHandle, Handle<> yHandle) {
  MutableHandle<> x{runtime, xHandle.get()};
  MutableHandle<> y{runtime, yHandle.get()};

  while (true) {
    // Combine tags for use in the switch statement. Use NativeValueTag as a
    // placeholder for numbers.
    assert(
        !x->isNativeValue() && !x->isEmpty() && "invalid value for comparison");
    assert(
        !y->isNativeValue() && !y->isEmpty() && "invalid value for comparison");

    // The following macros are used to generate the switch cases using
    // HermesValue::combineETags; an S in the name means it is a single ETag
    // (e.g., ETag::Bool), while M means it is a multi ETag (e.g., ETag::Object1
    // and ETag::Object2).
#define CASE_S_S(typeA, typeB)    \
  case HermesValue::combineETags( \
      HermesValue::ETag::typeA, HermesValue::ETag::typeB):

#define CASE_S_M(typeA, typeB) \
  CASE_S_S(typeA, typeB##1)    \
  CASE_S_S(typeA, typeB##2)

#define CASE_M_S(typeA, typeB) \
  CASE_S_S(typeA##1, typeB)    \
  CASE_S_S(typeA##2, typeB)

#define CASE_M_M(typeA, typeB) \
  CASE_M_S(typeA, typeB##1)    \
  CASE_M_S(typeA, typeB##2)

// NUMBER_TAG is a "virtual" ETag member that is used to tag numbers (which
// don't have a tag assigned to them). It reuses ETag::Native1 there will
// never be any native values in this part of the code.
#define NUMBER_TAG Native1

    // Tag numbers as with the "virtual" ETag member NUMBER_TAG, and use default
    // tag values for everything else.
    HermesValue::ETag xType =
        x->isNumber() ? HermesValue::ETag::NUMBER_TAG : x->getETag();
    HermesValue::ETag yType =
        y->isNumber() ? HermesValue::ETag::NUMBER_TAG : y->getETag();

    switch (HermesValue::combineETags(xType, yType)) {
      // 1. If Type(x) is the same as Type(y), then
      // a. Return the result of performing Strict Equality Comparison x === y.
      CASE_S_S(Undefined, Undefined)
      CASE_S_S(Null, Null) {
        return true;
      }
      CASE_S_S(NUMBER_TAG, NUMBER_TAG) {
        return x->getNumber() == y->getNumber();
      }
      CASE_M_M(Str, Str) {
        return x->getString()->equals(y->getString());
      }
      CASE_M_M(BigInt, BigInt) {
        return x->getBigInt()->compare(y->getBigInt()) == 0;
      }
      CASE_S_S(Bool, Bool)
      CASE_S_S(Symbol, Symbol)
      CASE_M_M(Object, Object) {
        return x->getRaw() == y->getRaw();
      }
      // 2. If x is null and y is undefined, return true.
      // 3. If x is undefined and y is null, return true.
      CASE_S_S(Undefined, Null)
      CASE_S_S(Null, Undefined) {
        return true;
      }
      // 4. If Type(x) is Number and Type(y) is String, return the result of the
      // comparison x == ! ToNumber(y).
      CASE_S_M(NUMBER_TAG, Str) {
        return x->getNumber() ==
            stringToNumber(runtime, Handle<StringPrimitive>::vmcast(y));
      }
      // 5. If Type(x) is String and Type(y) is Number, return the result of the
      // comparison ! ToNumber(x) == y.
      CASE_M_S(Str, NUMBER_TAG) {
        return stringToNumber(runtime, Handle<StringPrimitive>::vmcast(x)) ==
            y->getNumber();
      }
      // 6. If Type(x) is BigInt and Type(y) is String, then
      CASE_M_M(BigInt, Str) {
        // a. Let n be ! StringToBigInt(y).
        auto n = stringToBigInt_RJS(runtime, y);
        if (LLVM_UNLIKELY(n == ExecutionStatus::EXCEPTION)) {
          return ExecutionStatus::EXCEPTION;
        }
        // b. If n is NaN, return false.
        // N.B.: this has been amended in ES2023 to read
        //       If n is undefined, return false.
        if (n->isUndefined()) {
          return false;
        }
        // c. Return the result of the comparison x == n.
        y = n.getValue();
        break;
      }
      // 7. If Type(x) is String and Type(y) is BigInt, return the result of the
      // comparison y == x.
      CASE_M_M(Str, BigInt) {
        std::swap(x, y);
        break;
      }
      // 8. If Type(x) is Boolean, return the result of the comparison !
      // ToNumber(x) == y.
      CASE_S_S(Bool, NUMBER_TAG) {
        // Do both conversions and check numerical equality.
        return static_cast<double>(x->getBool()) == y->getNumber();
      }
      CASE_S_M(Bool, Str) {
        // Do string parsing and check double equality.
        return static_cast<double>(x->getBool()) ==
            stringToNumber(runtime, Handle<StringPrimitive>::vmcast(y));
      }
      CASE_S_M(Bool, BigInt) {
        return y->getBigInt()->compare(static_cast<int32_t>(x->getBool())) == 0;
      }
      CASE_S_M(Bool, Object) {
        x = HermesValue::encodeDoubleValue(x->getBool());
        break;
      }
      // 9. If Type(y) is Boolean, return the result of the comparison x == !
      // ToNumber(y).
      CASE_S_S(NUMBER_TAG, Bool) {
        return x->getNumber() == static_cast<double>(y->getBool());
      }
      CASE_M_S(Str, Bool) {
        return stringToNumber(runtime, Handle<StringPrimitive>::vmcast(x)) ==
            static_cast<double>(y->getBool());
      }
      CASE_M_S(BigInt, Bool) {
        return x->getBigInt()->compare(static_cast<int32_t>(y->getBool())) == 0;
      }
      CASE_M_S(Object, Bool) {
        y = HermesValue::encodeDoubleValue(y->getBool());
        break;
      }
      // 10. If Type(x) is either String, Number, BigInt, or Symbol and Type(y)
      // is Object, return the result of the comparison x == ToPrimitive(y).
      CASE_M_M(Str, Object)
      CASE_M_M(BigInt, Object)
      CASE_S_M(Symbol, Object)
      CASE_S_M(NUMBER_TAG, Object) {
        auto status = toPrimitive_RJS(runtime, y, PreferredType::NONE);
        if (status == ExecutionStatus::EXCEPTION) {
          return ExecutionStatus::EXCEPTION;
        }
        y = status.getValue();
        break;
      }
      // 11. If Type(x) is Object and Type(y) is either String, Number, BigInt,
      // or Symbol, return the result of the comparison ToPrimitive(x) == y.
      CASE_M_M(Object, Str)
      CASE_M_M(Object, BigInt)
      CASE_M_S(Object, Symbol)
      CASE_M_S(Object, NUMBER_TAG) {
        auto status = toPrimitive_RJS(runtime, x, PreferredType::NONE);
        if (status == ExecutionStatus::EXCEPTION) {
          return ExecutionStatus::EXCEPTION;
        }
        x = status.getValue();
        break;
      }
      // 12. If Type(x) is BigInt and Type(y) is Number, or if Type(x) is
      // Number and Type(y) is BigInt, then a. If x or y are any of NaN, +∞,
      // or -∞, return false. b. If the mathematical value of x is equal to
      // the mathematical value of y, return true; otherwise return false.
      CASE_M_S(BigInt, NUMBER_TAG) {
        std::swap(x, y);
        LLVM_FALLTHROUGH;
      }
      CASE_S_M(NUMBER_TAG, BigInt) {
        if (!isIntegralNumber(x->getNumber())) {
          return false;
        }

        auto xAsBigInt = BigIntPrimitive::fromDouble(runtime, x->getNumber());
        if (LLVM_UNLIKELY(xAsBigInt == ExecutionStatus::EXCEPTION)) {
          return ExecutionStatus::EXCEPTION;
        }
        return xAsBigInt->getBigInt()->compare(y->getBigInt()) == 0;
      }

      // 13. Return false.
      default:
        return false;
    }

#undef CASE_S_S
#undef CASE_S_M
#undef CASE_M_S
#undef CASE_M_M
#undef NUMBER_TAG
  }
}
