format_json(int event_type, struct eventlog_args *args,
    const struct eventlog *evlog, bool compact)
{
    eventlog_json_callback_t info_cb = args->json_info_cb;
    void *info = args->json_info;
    struct json_container jsonc = { 0 };
    struct json_value json_value;
    const char *time_str, *type_str;
    struct timespec now;
    debug_decl(format_json, SUDO_DEBUG_UTIL);

    if (info_cb == NULL) {
	info_cb = default_json_cb;
	info = (void *)evlog;
    }

    if (sudo_gettime_real(&now) == -1) {
	sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO|SUDO_DEBUG_ERRNO,
	    "unable to read the clock");
	debug_return_str(NULL);
    }

    switch (event_type) {
    case EVLOG_ACCEPT:
	type_str = "accept";
	time_str = "submit_time";
	break;
    case EVLOG_REJECT:
	type_str = "reject";
	time_str = "submit_time";
	break;
    case EVLOG_ALERT:
	type_str = "alert";
	time_str = "alert_time";
	break;
    case EVLOG_EXIT:
	type_str = "exit";
	time_str = "exit_time";
	break;
    default:
	sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,
	    "unexpected event type %d", event_type);
	debug_return_str(NULL);
    }

    if (!sudo_json_init(&jsonc, 4, compact, false, false))
	goto bad;
    if (!sudo_json_open_object(&jsonc, type_str))
	goto bad;

    if (evlog != NULL && evlog->uuid_str[0] != '\0') {
	json_value.type = JSON_STRING;
	json_value.u.string = evlog->uuid_str;
	if (!sudo_json_add_value(&jsonc, "uuid", &json_value))
	    goto bad;
    }

    /* Reject and Alert events include a reason and optional error string. */
    if (args->reason != NULL) {
	char *ereason = NULL;

	if (args->errstr != NULL) {
	    const int len = asprintf(&ereason, _("%s: %s"), args->reason,
		args->errstr);
	    if (len == -1) {
		sudo_warnx(U_("%s: %s"), __func__,
		    U_("unable to allocate memory"));
		goto bad;
	    }
	}
	json_value.type = JSON_STRING;
	json_value.u.string = ereason ? ereason : args->reason;
	if (!sudo_json_add_value(&jsonc, "reason", &json_value)) {
	    free(ereason);
	    goto bad;
	}
	free(ereason);
    }

    /* Log event time on server (set earlier) */
    if (!json_add_timestamp(&jsonc, "server_time", &now, true)) {
	sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,
	    "unable format timestamp");
	goto bad;
    }

    /* Log event time from client */
    if (args->event_time != NULL) {
	if (!json_add_timestamp(&jsonc, time_str, args->event_time, true)) {
	    sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,
		"unable format timestamp");
	    goto bad;
	}
    }

    if (event_type == EVLOG_EXIT) {
	/* Exit events don't need evlog details if there is a UUID. */
	if (evlog != NULL && evlog->uuid_str[0] != '\0') {
	    if (args->json_info == NULL)
		info = NULL;
	}

	if (sudo_timespecisset(&evlog->run_time)) {
	    if (!json_add_timestamp(&jsonc, "run_time", &evlog->run_time, false)) {
		sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,
		    "unable format timestamp");
		goto bad;
	    }
	}
	if (evlog->signal_name != NULL) {
	    json_value.type = JSON_STRING;
	    json_value.u.string = evlog->signal_name;
	    if (!sudo_json_add_value(&jsonc, "signal", &json_value))
		goto bad;

	    json_value.type = JSON_BOOL;
	    json_value.u.boolean = evlog->dumped_core;
	    if (!sudo_json_add_value(&jsonc, "dumped_core", &json_value))
		goto bad;
	}
	json_value.type = JSON_NUMBER;
	json_value.u.number = evlog->exit_value;
	if (!sudo_json_add_value(&jsonc, "exit_value", &json_value))
	    goto bad;
    }

     /* Event log info may be missing for alert messages. */
     if (evlog != NULL) {
	if (evlog->peeraddr != NULL) {
	    json_value.type = JSON_STRING;
	    json_value.u.string = evlog->peeraddr;
	    if (!sudo_json_add_value(&jsonc, "peeraddr", &json_value))
		goto bad;
	}

	if (evlog->iolog_path != NULL) {
	    json_value.type = JSON_STRING;
	    json_value.u.string = evlog->iolog_path;
	    if (!sudo_json_add_value(&jsonc, "iolog_path", &json_value))
		goto bad;

	    if (sudo_timespecisset(&evlog->iolog_offset)) {
		if (!json_add_timestamp(&jsonc, "iolog_offset", &evlog->iolog_offset, false)) {
		    sudo_debug_printf(SUDO_DEBUG_ERROR|SUDO_DEBUG_LINENO,
			"unable format timestamp");
		    goto bad;
		}
	    }
	}
    }

    /* Write log info. */
    if (info != NULL) {
	if (!info_cb(&jsonc, info))
	    goto bad;
    }

    if (!sudo_json_close_object(&jsonc))
	goto bad;

    /* Caller is responsible for freeing the buffer. */
    debug_return_str(sudo_json_get_buf(&jsonc));

bad:
    sudo_json_free(&jsonc);
    debug_return_str(NULL);
}
