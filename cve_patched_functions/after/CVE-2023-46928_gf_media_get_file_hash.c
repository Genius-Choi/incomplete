GF_Err gf_media_get_file_hash(const char *file, u8 hash[20])
{
	u8 block[4096];
	u32 read;
	u64 size, tot;
	FILE *in;
	GF_SHA1Context *ctx;
	GF_Err e = GF_OK;
#ifndef GPAC_DISABLE_ISOM
	GF_BitStream *bs = NULL;
	Bool is_isom = gf_isom_probe_file(file);
#endif

	in = gf_fopen(file, "rb");
    if (!in) return GF_URL_ERROR;
	size = gf_fsize(in);

	ctx = gf_sha1_starts();
	tot = 0;
#ifndef GPAC_DISABLE_ISOM
	if (is_isom) bs = gf_bs_from_file(in, GF_BITSTREAM_READ);
#endif

	while (tot<size) {
#ifndef GPAC_DISABLE_ISOM
		if (is_isom) {
			u64 box_size = gf_bs_peek_bits(bs, 32, 0);
			u32 box_type = gf_bs_peek_bits(bs, 32, 4);

			/*64-bit size*/
			if (box_size==1) box_size = gf_bs_peek_bits(bs, 64, 8);
			/*till end of file*/
			if (!box_size) box_size = size - tot;

			/*skip all MutableDRMInformation*/
			if (box_type==GF_ISOM_BOX_TYPE_MDRI) {
				gf_bs_skip_bytes(bs, box_size);
				tot += box_size;
			} else {
				u64 bsize = 0;
				while (bsize<box_size) {
					u32 to_read = (u32) ((box_size-bsize<4096) ? (box_size-bsize) : 4096);
					read = gf_bs_read_data(bs, (char *) block, to_read);
					if (!read || (read != to_read) ) {
						GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, ("corrupted isobmf file, box read "LLU" but expected still "LLU" bytes\n", bsize, box_size));
						break;
					}
					gf_sha1_update(ctx, block, to_read);
					bsize += to_read;
				}
				tot += box_size;
			}
		} else
#endif
		{
			read = (u32) gf_fread(block, 4096, in);
			if ((s32) read <= 0) {
				if (ferror(in))
					e = GF_IO_ERR;
				break;
			}
			gf_sha1_update(ctx, block, read);
			tot += read;
		}
	}
	gf_sha1_finish(ctx, hash);
#ifndef GPAC_DISABLE_ISOM
	if (bs) gf_bs_del(bs);
#endif
	gf_fclose(in);
	return e;
}
