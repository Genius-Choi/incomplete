void fio_state_callback_force(callback_type_e c_type) {
  if ((int)c_type < 0 || c_type > FIO_CALL_NEVER)
    return;
  /* copy collection */
  fio_ls_embd_s copy = FIO_LS_INIT(copy);
  fio_lock(&callback_collection[c_type].lock);
  fio_state_callback_ensure(&callback_collection[c_type]);
  switch (c_type) {            /* the difference between `unshift` and `push` */
  case FIO_CALL_ON_INITIALIZE: /* fallthrough */
  case FIO_CALL_PRE_START:     /* fallthrough */
  case FIO_CALL_BEFORE_FORK:   /* fallthrough */
  case FIO_CALL_AFTER_FORK:    /* fallthrough */
  case FIO_CALL_IN_CHILD:      /* fallthrough */
  case FIO_CALL_IN_MASTER:     /* fallthrough */
  case FIO_CALL_ON_START:      /* fallthrough */
    FIO_LS_EMBD_FOR(&callback_collection[c_type].callbacks, pos) {
      callback_data_s *tmp = fio_malloc(sizeof(*tmp));
      FIO_ASSERT_ALLOC(tmp);
      *tmp = *(FIO_LS_EMBD_OBJ(callback_data_s, node, pos));
      fio_ls_embd_unshift(&copy, &tmp->node);
    }
    break;

  case FIO_CALL_ON_IDLE: /* idle callbacks are orderless and evented */
    FIO_LS_EMBD_FOR(&callback_collection[c_type].callbacks, pos) {
      callback_data_s *tmp = FIO_LS_EMBD_OBJ(callback_data_s, node, pos);
      fio_defer_push_task(fio_state_on_idle_perform,
                          (void *)(uintptr_t)tmp->func, tmp->arg);
    }
    break;

  case FIO_CALL_ON_SHUTDOWN:     /* fallthrough */
  case FIO_CALL_ON_FINISH:       /* fallthrough */
  case FIO_CALL_ON_PARENT_CRUSH: /* fallthrough */
  case FIO_CALL_ON_CHILD_CRUSH:  /* fallthrough */
  case FIO_CALL_AT_EXIT:         /* fallthrough */
  case FIO_CALL_NEVER:           /* fallthrough */
  default:
    FIO_LS_EMBD_FOR(&callback_collection[c_type].callbacks, pos) {
      callback_data_s *tmp = fio_malloc(sizeof(*tmp));
      FIO_ASSERT_ALLOC(tmp);
      *tmp = *(FIO_LS_EMBD_OBJ(callback_data_s, node, pos));
      fio_ls_embd_push(&copy, &tmp->node);
    }
    break;
  }

  fio_unlock(&callback_collection[c_type].lock);
  /* run callbacks + free data */
  while (fio_ls_embd_any(&copy)) {
    callback_data_s *tmp =
        FIO_LS_EMBD_OBJ(callback_data_s, node, fio_ls_embd_pop(&copy));
    if (tmp->func) {
      tmp->func(tmp->arg);
    }
    fio_free(tmp);
  }
}
