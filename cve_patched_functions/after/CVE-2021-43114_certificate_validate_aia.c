certificate_validate_aia(struct rpki_uri *caIssuers, X509 *cert)
{
	struct validation *state;
	struct rpki_uri *parent;

	if (caIssuers == NULL)
		pr_crit("Certificate's AIA was not recorded.");

	state = state_retrieve();
	if (state == NULL)
		return -EINVAL;
	parent = x509stack_peek_uri(validation_certstack(state));
	if (parent == NULL)
		pr_crit("Certificate has no parent.");

	/*
	 * There are two possible issues here, specifically at first level root
	 * certificate's childs:
	 *
	 * - Considering that the root certificate can be published at one or
	 *   more rsync or HTTPS URIs (RFC 8630), the validation is done
	 *   considering the first valid downloaded certificate URI from the
	 *   list of URIs; so, that URI doesn't necessarily matches AIA. And
	 *   this issue is more likely to happen if the 'shuffle-uris' flag
	 *   is active an a TAL has more than one rsync/HTTPS uri.
	 *
	 * - If the TAL has only one URI, and such URI is HTTPS, the root
	 *   certificate will be located at a distinct point that what it's
	 *   expected, so this might be an error if such certificate (root
	 *   certificate) isn't published at an rsync repository. See RFC 6487
	 *   section-4.8.7:
	 *
	 *   "The preferred URI access mechanisms is "rsync", and an rsync URI
	 *   [RFC5781] MUST be specified with an accessMethod value of
	 *   id-ad-caIssuers.  The URI MUST reference the point of publication
	 *   of the certificate where this Issuer is the subject (the issuer's
	 *   immediate superior certificate)."
	 *
	 * As of today, this is a common scenario, since most of the TALs have
	 * an HTTPS URI.
	 */
	if (uri_equals(caIssuers, parent))
		return 0;

	/*
	 * Avoid the check at direct TA childs, otherwise try to match the
	 * immediate superior subject with the current issuer. This will force
	 * an RSYNC of AIA's URI, load the certificate and do the comparison.
	 */
	return certstack_get_x509_num(validation_certstack(state)) == 1 ?
	    0 :
	    force_aia_validation(caIssuers, cert);
}
