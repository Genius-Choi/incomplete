static int _git_ssh_setup_conn(
	ssh_subtransport *t,
	const char *url,
	const char *cmd,
	git_smart_subtransport_stream **stream)
{
	int auth_methods, error = 0, port;
	ssh_stream *s;
	git_credential *cred = NULL;
	LIBSSH2_SESSION *session=NULL;
	LIBSSH2_CHANNEL *channel=NULL;
	LIBSSH2_KNOWNHOSTS *known_hosts = NULL;

	t->current_stream = NULL;

	*stream = NULL;
	if (ssh_stream_alloc(t, cmd, stream) < 0)
		return -1;

	s = (ssh_stream *)*stream;
	s->session = NULL;
	s->channel = NULL;

	if (git_net_str_is_url(url))
		error = git_net_url_parse(&s->url, url);
	else
		error = git_net_url_parse_scp(&s->url, url);

	if (error < 0)
		goto done;

	if ((error = git_socket_stream_new(&s->io, s->url.host, s->url.port)) < 0 ||
	    (error = git_stream_connect(s->io)) < 0)
		goto done;

	/*
	 * Try to parse the port as a number, if we can't then fall back to
	 * default. It would be nice if we could get the port that was resolved
	 * as part of the stream connection, but that's not something that's
	 * exposed.
	 */
	if (git__strntol32(&port, s->url.port, strlen(s->url.port), NULL, 10) < 0)
		port = -1;

	if ((error = _git_ssh_session_create(&session, &known_hosts, s->url.host, port, s->io)) < 0)
		goto done;

	if ((error = check_certificate(session, known_hosts, t->owner->connect_opts.callbacks.certificate_check, t->owner->connect_opts.callbacks.payload, s->url.host, port)) < 0)
		goto done;

	/* we need the username to ask for auth methods */
	if (!s->url.username) {
		if ((error = request_creds(&cred, t, NULL, GIT_CREDENTIAL_USERNAME)) < 0)
			goto done;

		s->url.username = git__strdup(((git_credential_username *) cred)->username);
		cred->free(cred);
		cred = NULL;
		if (!s->url.username)
			goto done;
	} else if (s->url.username && s->url.password) {
		if ((error = git_credential_userpass_plaintext_new(&cred, s->url.username, s->url.password)) < 0)
			goto done;
	}

	if ((error = list_auth_methods(&auth_methods, session, s->url.username)) < 0)
		goto done;

	error = GIT_EAUTH;
	/* if we already have something to try */
	if (cred && auth_methods & cred->credtype)
		error = _git_ssh_authenticate_session(session, cred);

	while (error == GIT_EAUTH) {
		if (cred) {
			cred->free(cred);
			cred = NULL;
		}

		if ((error = request_creds(&cred, t, s->url.username, auth_methods)) < 0)
			goto done;

		if (strcmp(s->url.username, git_credential_get_username(cred))) {
			git_error_set(GIT_ERROR_SSH, "username does not match previous request");
			error = -1;
			goto done;
		}

		error = _git_ssh_authenticate_session(session, cred);

		if (error == GIT_EAUTH) {
			/* refresh auth methods */
			if ((error = list_auth_methods(&auth_methods, session, s->url.username)) < 0)
				goto done;
			else
				error = GIT_EAUTH;
		}
	}

	if (error < 0)
		goto done;

	channel = libssh2_channel_open_session(session);
	if (!channel) {
		error = -1;
		ssh_error(session, "Failed to open SSH channel");
		goto done;
	}

	libssh2_channel_set_blocking(channel, 1);

	s->session = session;
	s->channel = channel;

	t->current_stream = s;

done:
	if (error < 0) {
		ssh_stream_free(*stream);

		if (known_hosts)
			libssh2_knownhost_free(known_hosts);
		if (session)
			libssh2_session_free(session);
	}

	if (cred)
		cred->free(cred);

	return error;
}
