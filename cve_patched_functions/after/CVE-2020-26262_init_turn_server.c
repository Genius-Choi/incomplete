void init_turn_server(turn_turnserver* server,
		turnserver_id id, int verbose, ioa_engine_handle e, turn_credential_type ct,
		int stun_port, int fingerprint, dont_fragment_option_t dont_fragment,
		get_user_key_cb userkeycb,
		check_new_allocation_quota_cb chquotacb,
		release_allocation_quota_cb raqcb,
		ioa_addr *external_ip,
		vintp check_origin,
		vintp no_tcp_relay,
		vintp no_udp_relay,
		vintp stale_nonce,
		vintp max_allocate_lifetime,
		vintp channel_lifetime,
		vintp permission_lifetime,
		vintp stun_only,
		vintp no_stun,
		vintp no_software_attribute,
		vintp web_admin_listen_on_workers,
		turn_server_addrs_list_t *alternate_servers_list,
		turn_server_addrs_list_t *tls_alternate_servers_list,
		turn_server_addrs_list_t *aux_servers_list,
		int self_udp_balance,
		vintp no_multicast_peers, vintp allow_loopback_peers,
		ip_range_list_t* ip_whitelist, ip_range_list_t* ip_blacklist,
		send_socket_to_relay_cb send_socket_to_relay,
		vintp secure_stun, vintp mobility, int server_relay,
		send_turn_session_info_cb send_turn_session_info,
		send_https_socket_cb send_https_socket,
		allocate_bps_cb allocate_bps_func,
		int oauth,
		const char* oauth_server_name,
		const char* acme_redirect,
		int keep_address_family,
		vintp log_binding) {

	if (!server)
		return;

	bzero(server,sizeof(turn_turnserver));

	server->e = e;
	server->id = id;
	server->ctime = turn_time();
	server->session_id_counter = 0;
	server->sessions_map = ur_map_create();
	server->tcp_relay_connections = ur_map_create();
	server->ct = ct;
	server->userkeycb = userkeycb;
	server->chquotacb = chquotacb;
	server->raqcb = raqcb;
	server->no_multicast_peers = no_multicast_peers;
	server->allow_loopback_peers = allow_loopback_peers;
	server->secure_stun = secure_stun;
	server->mobility = mobility;
	server->server_relay = server_relay;
	server->send_turn_session_info = send_turn_session_info;
	server->send_https_socket = send_https_socket;
	server->oauth = oauth;
	if(oauth)
		server->oauth_server_name = oauth_server_name;
	if(mobility)
		server->mobile_connections_map = ur_map_create();
	server->acme_redirect = acme_redirect;

	TURN_LOG_FUNC(TURN_LOG_LEVEL_INFO,"turn server id=%d created\n",(int)id);

	server->check_origin = check_origin;
	server->no_tcp_relay = no_tcp_relay;
	server->no_udp_relay = no_udp_relay;

	server->alternate_servers_list = alternate_servers_list;
	server->tls_alternate_servers_list = tls_alternate_servers_list;
	server->aux_servers_list = aux_servers_list;
	server->self_udp_balance = self_udp_balance;

	server->stale_nonce = stale_nonce;
	server->max_allocate_lifetime = max_allocate_lifetime;
	server->channel_lifetime = channel_lifetime;
	server->permission_lifetime = permission_lifetime;
	server->stun_only = stun_only;
	server->no_stun = no_stun;
	server->no_software_attribute = no_software_attribute;
	server-> web_admin_listen_on_workers = web_admin_listen_on_workers;

	server->dont_fragment = dont_fragment;
	server->fingerprint = fingerprint;
	if(external_ip) {
		addr_cpy(&(server->external_ip), external_ip);
		server->external_ip_set = 1;
	}
	if (stun_port < 1)
		stun_port = DEFAULT_STUN_PORT;

	server->verbose = verbose;

	server->ip_whitelist = ip_whitelist;
	server->ip_blacklist = ip_blacklist;

	server->send_socket_to_relay = send_socket_to_relay;

	server->allocate_bps_func = allocate_bps_func;

	server->keep_address_family = keep_address_family;

	set_ioa_timer(server->e, 1, 0, timer_timeout_handler, server, 1, "timer_timeout_handler");

	server->log_binding = log_binding;
}
