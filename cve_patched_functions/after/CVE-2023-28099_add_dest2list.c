int add_dest2list(int id, str uri, struct socket_info *sock, str *comsock, int state,
							int weight, int prio, str attrs, str description, ds_data_t *d_data)
{
	ds_dest_p dp = NULL;
	ds_set_p  sp = NULL;
	short new_set = 0;
	ds_dest_p dp_it, dp_prev;
	struct sip_uri puri;
	str ds_str = {MI_SSTR("dispatcher")};

	/* For DNS-Lookups */
	struct proxy_l *proxy;
	union sockaddr_union sau;

	/* check uri */
	if(parse_uri(uri.s, uri.len, &puri)!=0 || puri.host.len>254)
	{
		LM_ERR("bad uri [%.*s]\n", uri.len, uri.s);
		goto err;
	}

	/* get dest set */
	for( sp=d_data->sets ; sp ; sp=sp->next) {
		if(sp->id == id)
			break;
	}

	if(sp==NULL)
	{
		sp = (ds_set_p)shm_malloc(sizeof(ds_set_t));
		if(sp==NULL)
		{
			LM_ERR("no more memory.\n");
			return -1;
		}

		new_set = 1;
		memset(sp, 0, sizeof(ds_set_t));
		sp->id = id;
	}

	dp = (ds_dest_p)shm_malloc(sizeof(ds_dest_t));
	if(dp==NULL)
	{
		LM_ERR("no more memory!\n");
		goto err;
	}
	memset(dp, 0, sizeof(ds_dest_t));

	/* store uri and attrs strings */

	dp->uri.len = uri.len;
	if (puri.user.len == 0 && puri.passwd.len == 0 && puri.headers.len == 0) {

		/* The uri from db is good for ds_select_dst */
		dp->uri.s = shm_malloc(uri.len + 1 + attrs.len + 1 + description.len + 1);
		if(dp->uri.s==NULL){
			LM_ERR("no more shm memory!\n");
			goto err;
		}
		dp->dst_uri = dp->uri;
		dp->attrs.s = dp->uri.s + dp->uri.len + 1;
		dp->description.s = dp->uri.s + dp->uri.len + 1 + attrs.len + 1;
	}
	else {
		dp->dst_uri.len = uri_typestrlen(puri.type) + 1 + puri.host.len
						+ (puri.port.len ? puri.port.len + 1 : 0) + puri.params.len;
		dp->uri.s = shm_malloc(uri.len+1 + dp->dst_uri.len + 1 + attrs.len+1
								+ description.len + 1);
		if(dp->uri.s==NULL){
			LM_ERR("no more shm memory!\n");
			goto err;
		}

		dp->description.s = dp->uri.s + dp->uri.len + 1 + dp->dst_uri.len + 1 + attrs.len + 1;
		dp->attrs.s = dp->uri.s + dp->uri.len + 1 + dp->dst_uri.len + 1;
		dp->dst_uri.s = dp->uri.s + dp->uri.len + 1;
		char *p = uri_type2str(puri.type, dp->dst_uri.s);
		*(p++) = ':';

		memcpy(p, puri.host.s, puri.host.len);
		p += puri.host.len;

		if (puri.port.len) {
			*(p++) = ':';
			memcpy(p, puri.port.s, puri.port.len);
		}
		if (puri.params.len) {
			memcpy(p, puri.params.s, puri.params.len);
			p += puri.params.len;
		}
		dp->dst_uri.s[dp->dst_uri.len]='\0';
	}

	memcpy(dp->uri.s, uri.s, dp->uri.len);

	if (attrs.len) {
		memcpy(dp->attrs.s, attrs.s, attrs.len);
		dp->attrs.s[attrs.len]='\0';
		dp->attrs.len = attrs.len;
	}
	else dp->attrs.s = NULL;

	if(description.len){
		memcpy(dp->description.s, description.s, description.len);
		dp->description.s[description.len]='\0';
		dp->description.len = description.len;
	}

	/* copy state, weight & socket */
	dp->sock = sock;
	dp->weight = weight;
	switch (state) {
		case 0:
			dp->flags = 0;
			break;
		case 1:
			dp->flags = DS_INACTIVE_DST;
			break;
		case 2:
			dp->flags = DS_PROBING_DST;
			break;
		default:
			LM_CRIT("BUG: unknown state %d for destination %.*s\n",
				state, uri.len, uri.s);
	}

	/* Do a DNS-Lookup for the Host-Name: */
	proxy = mk_proxy( &puri.host, puri.port_no, puri.proto,
		(puri.type==SIPS_URI_T));
	if (proxy==NULL) {
		LM_ERR("could not resolve %.*s, skipping it\n",
			puri.host.len, puri.host.s);
		goto err;
	}
	hostent2ip_addr( &dp->ips[0], &proxy->host, proxy->addr_idx);
	dp->ports[0] = proxy->port;
	dp->protos[0] = proxy->proto;
	dp->ips_cnt = 1;
	dp->priority = prio;
	LM_DBG("first gw ip addr [%s]:%d\n",
		ip_addr2a(&dp->ips[0]), dp->ports[0]);
	/* get the next available IPs from DNS */
	while (dp->ips_cnt<DS_MAX_IPS && (get_next_su( proxy, &sau, 0)==0) ) {
		su2ip_addr( &dp->ips[dp->ips_cnt], &sau);
		dp->ports[dp->ips_cnt] = proxy->port;
		dp->protos[dp->ips_cnt] = proxy->proto;
		LM_DBG("additional gw ip addr [%s]:%d, proto %d\n",
			ip_addr2a(&dp->ips[dp->ips_cnt]),
			dp->ports[dp->ips_cnt], dp->protos[dp->ips_cnt]);
		/* one more IP found */
		dp->ips_cnt++;
	}
	/* free al the helper structures */
	free_proxy(proxy);
	pkg_free(proxy);

	if (fetch_freeswitch_stats) {
		if (comsock->s && comsock->len > 0) {
			dp->fs_sock = fs_api.get_stats_evs(comsock, &ds_str);
			if (!dp->fs_sock) {
				LM_ERR("failed to create FreeSWITCH stats socket!\n");
			} else {
				dp->weight = max_freeswitch_weight;
				if (sp->redo_weights == 0) {
					for (dp_it = sp->dlist; dp_it; dp_it = dp_it->next) {
						if (dp_it->weight > max_freeswitch_weight) {
							LM_WARN("(set %d) truncating static weight in "
						     "uri %.*s to 'max_freeswitch_weight'! (%d->%d)\n",
							 id, uri.len, uri.s, dp_it->weight, max_freeswitch_weight);
							dp_it->weight = max_freeswitch_weight;
						}
					}
					sp->redo_weights = 1;
				}
			}
		} else if (sp->redo_weights && dp->weight > max_freeswitch_weight) {
			LM_WARN("(set %d) truncating static weight in uri %.*s to"
			           "\"max_freeswitch_weight\"! (%d -> %d)\n", id,
			           uri.len, uri.s, weight, max_freeswitch_weight);
			dp->weight = max_freeswitch_weight;
		}
	}

	/*
	 * search the proper place based on priority
	 * put them in reverse order, since they will be reindexed
	 */
	for (dp_prev = NULL, dp_it = sp->dlist;
		 dp_it && dp_it->priority < prio;
		 dp_prev = dp_it, dp_it = dp_it->next);

	if (!dp_prev) {
		dp->next = sp->dlist;
		sp->dlist = dp;
	} else {
		dp->next = dp_prev->next;
		dp_prev->next = dp;
	}
	sp->nr++;

	if (new_set) {
		sp->next = d_data->sets;
		d_data->sets = sp;
		d_data->sets_no++;
	}

	LM_DBG("dest [%d/%d] <%.*s> <%.*s> successfully loaded\n", sp->id, sp->nr,
			dp->uri.len, dp->uri.s, dp->dst_uri.len, dp->dst_uri.s);

	return 0;
err:
	/* free allocated memory */
	if(dp!=NULL)
	{
		if(dp->uri.s!=NULL)
			shm_free(dp->uri.s);
		shm_free(dp);
	}

	if (sp != NULL && new_set)
		shm_free(sp);

	return -1;
}
