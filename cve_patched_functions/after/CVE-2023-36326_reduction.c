static int reduction(void) {
	int code = RLC_ERR;
	bn_t a, b, c, d, e;

	bn_null(a);
	bn_null(b);
	bn_null(c);
	bn_null(d);
	bn_null(e);

	RLC_TRY {
		bn_new(a);
		bn_new(b);
		bn_new(c);
		bn_new(d);
		bn_new(e);

#if BN_MOD == BASIC || !defined(STRIP)
		TEST_CASE("basic reduction is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG / 2);
			bn_rand(b, RLC_POS, RLC_BN_BITS / 2);
			bn_div_rem(c, d, a, b);
			bn_sqr(c, b);
			if (bn_cmp(a, c) == RLC_LT) {
				bn_mod_basic(e, a, b);
				TEST_ASSERT(bn_cmp(e, d) == RLC_EQ, end);
				bn_neg(a, a);
				bn_mod_basic(e, a, b);
				bn_sub(e, b, e);
				TEST_ASSERT(bn_cmp(e, d) == RLC_EQ, end);
			}
		}
		TEST_END;
#endif

#if BN_MOD == BARRT || !defined(STRIP)
		TEST_CASE("barrett reduction is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG / 2);
			bn_rand(b, RLC_POS, RLC_BN_BITS / 2);
			bn_div_rem(c, d, a, b);
			bn_sqr(c, b);
			if (bn_cmp(a, c) == RLC_LT) {
				bn_mod_pre_barrt(c, b);
				bn_mod_barrt(e, a, b, c);
				TEST_ASSERT(bn_cmp(e, d) == RLC_EQ, end);
				bn_neg(a, a);
				bn_mod_barrt(e, a, b, c);
				bn_sub(e, b, e);
				TEST_ASSERT(bn_cmp(e, d) == RLC_EQ, end);
			}
		}
		TEST_END;
#endif

#if (BN_MOD == MONTY && BN_MUL == BASIC) || !defined(STRIP)
		TEST_CASE("basic montgomery reduction is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG / 2);
			bn_rand(b, RLC_POS, RLC_BN_BITS / 2);
			if (bn_is_even(b)) {
				bn_add_dig(b, b, 1);
			}
			bn_mod(a, a, b);
			bn_mod_monty_conv(c, a, b);
			bn_mod_pre_monty(e, b);
			bn_mod_monty_basic(d, c, b, e);
			TEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);
			bn_neg(a, a);
			bn_mod_monty_conv(c, a, b);
			bn_mod_monty_basic(d, c, b, e);
			bn_add(a, a, b);
			TEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);
		}
		TEST_END;
#endif

#if (BN_MOD == MONTY && BN_MUL == COMBA) || !defined(STRIP)
		TEST_CASE("comba montgomery reduction is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS - RLC_DIG / 2);
			bn_rand(b, RLC_POS, RLC_BN_BITS / 2);
			if (bn_is_even(b)) {
				bn_add_dig(b, b, 1);
			}
			bn_mod(a, a, b);
			bn_mod_monty_conv(c, a, b);
			bn_mod_pre_monty(e, b);
			bn_mod_monty_comba(d, c, b, e);
			TEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);
			bn_neg(a, a);
			bn_mod_monty_conv(c, a, b);
			bn_mod_monty_comba(d, c, b, e);
			bn_add(a, a, b);
			TEST_ASSERT(bn_cmp(a, d) == RLC_EQ, end);
		}
		TEST_END;
#endif

#if BN_MOD == PMERS || !defined(STRIP)
		TEST_CASE("pseudo-mersenne reduction is correct") {
			bn_rand(a, RLC_POS, RLC_BN_BITS);
			bn_rand(b, RLC_POS, RLC_BN_BITS / 2);
			bn_rand(c, RLC_POS, RLC_BN_BITS / 4);
			if (bn_is_zero(c)) {
				bn_set_dig(c, 1);
			}
			bn_set_2b(b, RLC_BN_BITS / 2);
			bn_sub(b, b, c);
			bn_mod(c, a, b);
			bn_mod_pre_pmers(e, b);
			bn_mod_pmers(d, a, b, e);
			TEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);
			bn_neg(a, a);
			bn_mod(c, a, b);
			bn_mod_pmers(d, a, b, e);
			TEST_ASSERT(bn_cmp(c, d) == RLC_EQ, end);
		}
		TEST_END;
#endif

	}
	RLC_CATCH_ANY {
		RLC_ERROR(end);
	}
	code = RLC_OK;
  end:
	bn_free(a);
	bn_free(b);
	bn_free(c);
	bn_free(d);
	bn_free(e);
	return code;
}
