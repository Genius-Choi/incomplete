int wcall_add(struct calling_instance *inst,
	      struct wcall **wcallp,
	      const char *convid,
	      int conv_type)
{	
	struct wcall *wcall;
	struct zapi_ice_server *turnv = NULL;
	size_t turnc = 0;
	struct zapi_ice_server *sftv = NULL;
	size_t sftc = 0;
	size_t i;
	int err;
	char convid_anon[ANON_ID_LEN];

	if (!inst || !wcallp || !convid)
		return EINVAL;

	wcall = wcall_lookup(inst, convid);
	if (wcall) {
		warning("wcall(%p): call_add: already have wcall "
			"for convid=%s\n", wcall, anon_id(convid_anon, convid));

		return EALREADY;
	}

	wcall = mem_zalloc(sizeof(*wcall), destructor);
	if (!wcall)
		return EINVAL;

	wcall->inst = inst;
	wcall->conv_type = conv_type;

	info(APITAG "wcall(%p): added for convid=%s inst=%p\n", wcall,
	     anon_id(convid_anon, convid), inst);
	str_dup(&wcall->convid, convid);

	lock_write_get(inst->lock);

	turnv = config_get_iceservers(inst->cfg, &turnc);
	if (turnc == 0) {
		info("wcall(%p): no turn servers\n", wcall);
	}

	sftv = config_get_sftservers(inst->cfg, &sftc);
	if (sftc == 0) {
		info("wcall(%p): no sft servers\n", wcall);
		if (WCALL_CONV_TYPE_CONFERENCE == conv_type) {
			info("wcall(%p): reverting conference to legacy "
			     "group call due to no SFT servers\n", wcall);
			conv_type = WCALL_CONV_TYPE_GROUP;
		}
	}

	switch (conv_type) {
	case WCALL_CONV_TYPE_ONEONONE: {
		struct ecall* ecall;
		err = ecall_alloc(&ecall, &inst->ecalls,
				  ICALL_CONV_TYPE_ONEONONE,
				  &inst->conf, inst->msys,
				  convid,
				  inst->userid,
				  inst->clientid);
		if (err) {
			warning("wcall(%p): call_add: ecall_alloc "
				"failed: %m\n", wcall, err);
			goto out;
		}

		wcall->icall = ecall_get_icall(ecall);
		icall_set_callbacks(wcall->icall,
				    icall_send_handler,
				    NULL, // icall_sft_handler,
				    icall_start_handler, 
				    icall_answer_handler,
				    icall_media_estab_handler,
				    icall_audio_estab_handler,
				    icall_datachan_estab_handler,
				    icall_media_stopped_handler,
				    NULL, // group_changed_handler
				    NULL, // leave_handler
				    icall_close_handler,
				    NULL, // metrics_handler
				    icall_vstate_handler,
				    icall_audiocbr_handler,
				    icall_muted_changed_handler,
				    icall_quality_handler,
				    NULL, // no_relay_handler,
				    icall_req_clients_handler,
				    icall_aulevel_handler,
				    wcall);		
		}
		break;

	case WCALL_CONV_TYPE_GROUP: {
		struct egcall* egcall;
		err = egcall_alloc(&egcall,
				   &inst->conf,
				   convid,
				   inst->userid,
				   inst->clientid);

		if (err) {
			warning("wcall(%p): add: could not alloc egcall: %m\n",
				wcall, err);
			goto out;
		}

		wcall->icall = egcall_get_icall(egcall);
		icall_set_callbacks(wcall->icall,
				    icall_send_handler,
				    NULL, // icall_sft_handler,
				    icall_start_handler,
				    icall_answer_handler,
				    icall_media_estab_handler,
				    icall_audio_estab_handler,
				    icall_datachan_estab_handler,
				    icall_media_stopped_handler,
				    egcall_group_changed_handler,
				    egcall_leave_handler,
				    icall_close_handler,
				    egcall_metrics_handler,
				    icall_vstate_handler,
				    icall_audiocbr_handler,
				    icall_muted_changed_handler,
				    icall_quality_handler,
				    NULL, // no_relay_handler,
				    icall_req_clients_handler,
				    icall_aulevel_handler,
				    wcall);
		}
		break;

	case WCALL_CONV_TYPE_CONFERENCE: {
		struct ccall* ccall;
		err = ccall_alloc(&ccall,
				   &inst->conf,
				   convid,
				   inst->userid,
				   inst->clientid);

		if (err) {
			warning("wcall(%p): add: could not alloc ccall: %m\n",
				wcall, err);
			goto out;
		}

		wcall->icall = ccall_get_icall(ccall);
		icall_set_callbacks(wcall->icall,
				    icall_send_handler,
				    icall_sft_handler,
				    icall_start_handler,
				    icall_answer_handler,
				    icall_media_estab_handler,
				    icall_audio_estab_handler,
				    icall_datachan_estab_handler,
				    icall_media_stopped_handler,
				    egcall_group_changed_handler,
				    egcall_leave_handler,
				    icall_close_handler,
				    egcall_metrics_handler,
				    icall_vstate_handler,
				    icall_audiocbr_handler,
				    NULL, // muted_changed_handler,
				    icall_quality_handler,
				    NULL, // no_relay_handler,
				    icall_req_clients_handler,
				    icall_aulevel_handler,
				    wcall);

		ccall_set_config(ccall, inst->cfg);

		}
		break;
	}

	err = ICALL_CALLE(wcall->icall, set_quality_interval,
		inst->quality.interval);

	for (i = 0; i < turnc; ++i) {
		struct zapi_ice_server *turn = &turnv[i];

		err = ICALL_CALLE(wcall->icall, add_turnserver,
				  turn);
		if (err) {
			warning("wcall(%p): error adding turnserver (%m)\n",
				wcall, err);
		}
	}

	for (i = 0; i < sftc; ++i) {
		struct zapi_ice_server *sft = &sftv[i];

		err = ICALL_CALLE(wcall->icall, add_sft,
				  sft->url);
		if (err) {
			warning("wcall(%p): error adding sft (%m)\n",
				wcall, err);
		}
	}

	if (inst->media_laddr) {
		err = ICALL_CALLE(wcall->icall, set_media_laddr,
				  inst->media_laddr);
		if (err) {
			warning("wcall(%p): error setting media laddr: %m\n",
				wcall, err);
		}
	}

	wcall->video.recv_state = WCALL_VIDEO_STATE_STOPPED;
	wcall->audio.cbr_state = AUDIO_CBR_STATE_UNSET;

	list_append(&inst->wcalls, &wcall->le, wcall);

 out:
	lock_rel(inst->lock);

	if (err)
		mem_deref(wcall);
	else
		*wcallp = wcall;

	return err;
}
