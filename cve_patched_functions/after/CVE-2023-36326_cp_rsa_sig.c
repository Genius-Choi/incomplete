int cp_rsa_sig(uint8_t *sig, size_t *sig_len, const uint8_t *msg,
		size_t msg_len, int hash, const rsa_t prv) {
	bn_t m, eb;
	int pad_len, size, result = RLC_OK;
	uint8_t h[RLC_MD_LEN];

	if (prv == NULL || msg_len < 0) {
		return RLC_ERR;
	}

	pad_len = (!hash ? RLC_MD_LEN : msg_len);

#if CP_RSAPD == PKCS2
	size = bn_bits(prv->crt->n) - 1;
	size = (size / 8) + (size % 8 > 0);
	if (pad_len > (size - 2)) {
		return RLC_ERR;
	}
#else
	size = bn_size_bin(prv->crt->n);
	if (pad_len > (size - RSA_PAD_LEN)) {
		return RLC_ERR;
	}
#endif

	bn_null(m);
	bn_null(eb);

	RLC_TRY {
		bn_new(m);
		bn_new(eb);

		bn_zero(m);
		bn_zero(eb);

		int operation = (!hash ? RSA_SIG : RSA_SIG_HASH);

#if CP_RSAPD == BASIC
		if (pad_basic(eb, &pad_len, pad_len, size, operation) == RLC_OK) {
#elif CP_RSAPD == PKCS1
		if (pad_pkcs1(eb, &pad_len, pad_len, size, operation) == RLC_OK) {
#elif CP_RSAPD == PKCS2
		if (pad_pkcs2(eb, &pad_len, pad_len, size, operation) == RLC_OK) {
#endif
			if (!hash) {
				md_map(h, msg, msg_len);
				bn_read_bin(m, h, RLC_MD_LEN);
				bn_add(eb, eb, m);
			} else {
				bn_read_bin(m, msg, msg_len);
				bn_add(eb, eb, m);
			}

#if CP_RSAPD == PKCS2
			pad_pkcs2(eb, &pad_len, bn_bits(prv->crt->n), size, RSA_SIG_FIN);
#endif

			bn_copy(m, eb);

#if !defined(CP_CRT)
			bn_mxp(eb, eb, prv->d, prv->crt->n);
#else /* CP_CRT */
			bn_mxp_crt(eb, eb, prv->crt->dp, prv->crt->dq, prv->crt, 0);
#endif /* CP_CRT */

			size = bn_size_bin(prv->crt->n);

			if (size <= *sig_len) {
				memset(sig, 0, size);
				bn_write_bin(sig, size, eb);
				*sig_len = size;
			} else {
				result = RLC_ERR;
			}
		} else {
			result = RLC_ERR;
		}
	}
	RLC_CATCH_ANY {
		RLC_THROW(ERR_CAUGHT);
	}
	RLC_FINALLY {
		bn_free(m);
		bn_free(eb);
	}

	return result;
}
