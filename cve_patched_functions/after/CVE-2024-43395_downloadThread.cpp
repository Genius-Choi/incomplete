static void downloadThread(void* arg) {
#ifdef __APPLE__
    pthread_setname_np("HTTP Download Thread");
#endif
#ifdef __ANDROID__
    Android_JNI_SetupThread();
#endif
    http_param_t* param = (http_param_t*)arg;
    Poco::URI uri;
    HTTPClientSession * session;
    std::string status;
    std::string path;
    param->comp->requests_open++;
downloadThread_entry:
    bool isLocalhost = false;
    {
        if (param->url.find(':') == std::string::npos) status = "Must specify http or https";
        else if (param->url.find("://") == std::string::npos) status = "URL malformed";
        else if (param->url.substr(0, 7) != "http://" && param->url.substr(0, 8) != "https://") status = "Invalid protocol '" + param->url.substr(0, param->url.find("://")) + "'";
        try {
            uri = Poco::URI(param->url);
        } catch (Poco::SyntaxException &e) {
            status = "URL malformed";
        }
        if (status.empty()) {
            size_t pos = param->url.find('/', param->url.find(uri.getHost()));
            size_t hash = pos != std::string::npos ? param->url.find('#', pos) : std::string::npos;
            path = urlEncode(pos != std::string::npos ? param->url.substr(pos, hash - pos) : "/");
            if (uri.getHost() == "localhost") {isLocalhost = true; uri.setHost("127.0.0.1");}
            bool found = false;
            for (const std::string& wclass : config.http_whitelist) {
                if (matchIPClass(uri.getHost(), wclass)) {
                    found = true;
                    for (const std::string& bclass : config.http_blacklist) {
                        if (matchIPClass(uri.getHost(), bclass)) {
                            found = false;
                            break;
                        }
                    }
                    if (!found) break;
                }
            }
            if (!found) status = "Domain not permitted";
            else if (uri.getScheme() == "http") {
                session = new HTTPClientSession(uri.getHost(), uri.getPort());
            } else if (uri.getScheme() == "https") {
                try {
                    Context::Ptr context = new Context(Context::CLIENT_USE, "", Context::VERIFY_RELAXED, 9, true, "ALL:!ADH:!LOW:!EXP:!MD5:@STRENGTH");
                    addSystemCertificates(context);
#if POCO_VERSION >= 0x010A0000
                    context->disableProtocols(Context::PROTO_TLSV1_3); // Some sites break under TLS 1.3 - disable it to maintain compatibility until fixed (pocoproject/poco#3395)
#endif
                    session = new HTTPSClientSession(uri.getHost(), uri.getPort(), context);
                } catch (Poco::Exception &e) {
                    http_handle_t * err = new http_handle_t(NULL);
                    err->url = param->url;
                    err->failureReason = e.message();
                    queueEvent(param->comp, http_failure, err);
                    goto downloadThread_finish;
                }
            } else status = "Invalid protocol '" + uri.getScheme() + "'";
        }
        if (!status.empty()) {
            http_handle_t * err = new http_handle_t(NULL);
            err->url = param->url;
            err->failureReason = status;
            queueEvent(param->comp, http_failure, err);
            goto downloadThread_finish;
        }

        if (!config.http_proxy_server.empty()) session->setProxy(config.http_proxy_server, config.http_proxy_port);
        HTTPRequest request(!param->method.empty() ? param->method : (!param->postData.empty() ? "POST" : "GET"), path, HTTPMessage::HTTP_1_1);
        HTTPResponse * response = new HTTPResponse();
        if (param->timeout > 0) session->setTimeout(Poco::Timespan(param->timeout * 1000000));
        else if (config.http_timeout > 0) session->setTimeout(Poco::Timespan(config.http_timeout * 1000));
        size_t requestSize = param->postData.size();
        for (const auto& h : param->headers) {request.add(h.first, h.second); requestSize += h.first.size() + h.second.size() + 1;}
        if (isLocalhost) request.add("Host", "localhost");
        if (!request.has("User-Agent")) request.add("User-Agent", "computercraft/" CRAFTOSPC_CC_VERSION " CraftOS-PC/" CRAFTOSPC_VERSION);
        if (!request.has("Accept-Charset")) request.add("Accept-Charset", "UTF-8");
        if (!param->postData.empty()) {
            if (request.getContentLength() == HTTPRequest::UNKNOWN_CONTENT_LENGTH) request.setContentLength(param->postData.size());
            if (request.getContentType() == HTTPRequest::UNKNOWN_CONTENT_TYPE) request.setContentType("application/x-www-form-urlencoded; charset=utf-8");
        }
        if (config.http_max_upload > 0 && requestSize > (unsigned)config.http_max_upload) {
            http_handle_t * err = new http_handle_t(NULL);
            err->url = param->url;
            err->failureReason = "Request body is too large";
            queueEvent(param->comp, http_failure, err);
            delete response;
            delete session;
            goto downloadThread_finish;
        }
        try {
            std::ostream& reqs = session->sendRequest(request);
            if (!param->postData.empty()) reqs.write(param->postData.c_str(), param->postData.size());
            if (reqs.bad() || reqs.fail()) {
                http_handle_t * err = new http_handle_t(NULL);
                err->url = param->url;
                err->failureReason = "Failed to send request";
                queueEvent(param->comp, http_failure, err);
                delete response;
                delete session;
                goto downloadThread_finish;
            }
        } catch (Poco::TimeoutException &e) {
            http_handle_t * err = new http_handle_t(NULL);
            err->url = param->url;
            err->failureReason = "Timed out";
            queueEvent(param->comp, http_failure, err);
            delete response;
            delete session;
            goto downloadThread_finish;
        } catch (Poco::Exception &e) {
            fprintf(stderr, "Error while downloading %s: %s\n", param->url.c_str(), e.displayText().c_str());
            http_handle_t * err = new http_handle_t(NULL);
            err->url = param->url;
            err->failureReason = e.name();
            queueEvent(param->comp, http_failure, err);
            delete response;
            delete session;
            goto downloadThread_finish;
        }
        http_handle_t * handle;
        try {
            if (config.standardsMode) {
                // Fix seeking by reading the entire data into a stringstream
                std::istream& instream = session->receiveResponse(*response);
                std::stringstream * ss = new std::stringstream;
                while (!instream.eof()) {
                    char buf[4096];
                    instream.read(buf, 4096);
                    ss->write(buf, instream.gcount());
                }
                handle = new http_handle_t(ss);
            } else handle = new http_handle_t(&session->receiveResponse(*response));
        } catch (Poco::TimeoutException &e) {
            http_handle_t * err = new http_handle_t(NULL);
            err->url = param->url;
            err->failureReason = "Timed out";
            queueEvent(param->comp, http_failure, err);
            delete response;
            delete session;
            goto downloadThread_finish;
        } catch (Poco::Exception &e) {
            fprintf(stderr, "Error while downloading %s: %s\n", param->url.c_str(), e.displayText().c_str());
            http_handle_t * err = new http_handle_t(NULL);
            err->url = param->url;
            err->failureReason = e.name();
            queueEvent(param->comp, http_failure, err);
            delete response;
            delete session;
            goto downloadThread_finish;
        }
        if (config.http_max_download > 0 && response->hasContentLength() && response->getContentLength() > config.http_max_download) {
            http_handle_t * err = new http_handle_t(NULL);
            err->url = param->url;
            err->failureReason = "Response is too large";
            queueEvent(param->comp, http_failure, err);
            if (config.standardsMode) delete (std::stringstream*)handle->stream;
            delete handle;
            delete response;
            delete session;
            goto downloadThread_finish;
        }
        handle->session = session;
        handle->handle = response;
        handle->url = param->old_url;
        if (param->redirect && handle->handle->getStatus() / 100 == 3 && handle->handle->has("Location")) {
            std::string location = handle->handle->get("Location");
            if (location.find("://") == std::string::npos) {
                if (location[0] == '/') location = uri.getScheme() + "://" + uri.getHost() + location;
                else location = uri.getScheme() + "://" + uri.getHost() + path.substr(0, path.find('?')) + "/" + location;
            }
            if (config.standardsMode) delete (std::stringstream*)handle->stream;
            delete handle->handle;
            delete handle->session;
            delete handle;
            param->url = location;
            goto downloadThread_entry;
        }
        if (response->getStatus() >= 400) {
            handle->failureReason = HTTPResponse::getReasonForStatus(response->getStatus());
            queueEvent(param->comp, http_failure, handle);
        } else {
            queueEvent(param->comp, http_success, handle);
        }
    }
downloadThread_finish:
    if (freedComputers.find(param->comp) != freedComputers.end()) return;
    param->comp->httpRequestQueueMutex.lock();
    if (!param->comp->httpRequestQueue.empty()) {
        http_param_t * p = (http_param_t*)param->comp->httpRequestQueue.front();
        param->comp->httpRequestQueue.pop();
        param->comp->httpRequestQueueMutex.unlock();
        delete param;
        param = p;
        goto downloadThread_entry;
    }
    param->comp->requests_open--;
    param->comp->httpRequestQueueMutex.unlock();
    delete param;
}
