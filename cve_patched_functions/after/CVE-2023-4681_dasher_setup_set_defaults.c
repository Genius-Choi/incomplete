static void dasher_setup_set_defaults(GF_DasherCtx *ctx, GF_MPD_AdaptationSet *set)
{
	u32 i, count;
	Bool main_role_set = GF_FALSE;
	//by default setup alignment
	if (ctx->sseg) set->subsegment_alignment = ctx->align;
	else set->segment_alignment = ctx->align;

	//startWithSAP is set when the first packet comes in

	//the rest depends on the various profiles/iop, to check
	count = gf_list_count(set->representations);
	for (i=0; i<count; i++) {
		GF_MPD_Representation *rep = gf_list_get(set->representations, i);
		GF_DashStream *ds = rep->playback.udta;

		if (set->max_width < ds->width) set->max_width = ds->width;
		if (set->max_height < ds->height) set->max_height = ds->height;
/*		if (set->max_bandwidth < ds->rep->bandwidth) set->max_bandwidth = ds->rep->bandwidth;
		if (set->max_framerate * ds->fps.den < ds->fps.num) set->max_framerate = (u32) (ds->fps.num / ds->fps.den);
*/

		/*set trick mode*/
		if (set->intra_only && (ds->stream_type==GF_STREAM_VISUAL)) {
			char value[256];
			GF_MPD_Descriptor* desc;
			sprintf(value, "%d", ds->sync_as_id);
			desc = gf_mpd_descriptor_new(NULL, "http://dashif.org/guidelines/trickmode", value);
			gf_list_add(set->essential_properties, desc);
		}
		/*set role*/
		if (ds->p_role) {
			u32 j, role_count;
			role_count = ds->p_role->value.string_list.nb_items;
			for (j=0; j<role_count; j++) {
				char *role = ds->p_role->value.string_list.vals[j];
				GF_MPD_Descriptor *desc=NULL;
				char *uri=NULL;
				//all roles defined by dash 5th edition
				if (!strcmp(role, "caption") || !strcmp(role, "subtitle") || !strcmp(role, "main")
			        || !strcmp(role, "alternate") || !strcmp(role, "supplementary") || !strcmp(role, "commentary")
			        || !strcmp(role, "dub") || !strcmp(role, "description") || !strcmp(role, "sign")
					 || !strcmp(role, "metadata") || !strcmp(role, "enhanced-audio-intelligibility")
					 || !strcmp(role, "emergency") || !strcmp(role, "forced-subtitle")
					 || !strcmp(role, "easyreader") || !strcmp(role, "karaoke")
				) {
					uri = "urn:mpeg:dash:role:2011";
					if (!strcmp(role, "main")) main_role_set = GF_TRUE;
				} else {
					char *sep = strrchr(role, ':');
					if (sep) {
						sep[0] = 0;
						desc = gf_mpd_descriptor_new(NULL, role, sep+1);
						sep[0] = ':';
					} else {
						GF_LOG(GF_LOG_WARNING, GF_LOG_DASH, ("[Dasher] Unrecognized role %s - using GPAC urn for schemaID\n", role));
						uri = "urn:gpac:dash:role:2013";
					}
				}
				if (!desc)
					desc = gf_mpd_descriptor_new(NULL, uri, role);

				gf_list_add(set->role, desc);
			}
		}
		//set SRD
		if (!i && ds->srd.z && ds->srd.w) {
			char value[256];
			GF_MPD_Descriptor *desc;
			if (ds->dep_id) {
				sprintf(value, "1,%d,%d,%d,%d", ds->srd.x, ds->srd.y, ds->srd.z, ds->srd.w);
				desc = gf_mpd_descriptor_new(NULL, "urn:mpeg:dash:srd:2014", value);
				gf_list_add(set->supplemental_properties, desc);
			} else {
				if (ds->tile_base) {
					sprintf(value, "1,0,0,0,0,%d,%d", ds->srd.z, ds->srd.w);
				} else {
					const GF_PropertyValue *p = gf_filter_pid_get_property(ds->ipid, GF_PROP_PID_SRD_REF);
					if (p) {
						sprintf(value, "1,%d,%d,%d,%d,%d,%d", ds->srd.x, ds->srd.y, ds->srd.z, ds->srd.w, p->value.vec2i.x, p->value.vec2i.y);
					} else {
						sprintf(value, "1,%d,%d,%d,%d", ds->srd.x, ds->srd.y, ds->srd.z, ds->srd.w);
					}
				}
				desc = gf_mpd_descriptor_new(NULL, "urn:mpeg:dash:srd:2014", value);
				gf_list_add(set->essential_properties, desc);
			}
		}
		//set HDR
		if (ds->hdr_type > DASHER_HDR_NONE) {
			char value[256];
			GF_MPD_Descriptor* desc;
			sprintf(value, "9");
			desc = gf_mpd_descriptor_new(NULL, "urn:mpeg:mpegB:cicp:ColourPrimaries", value);
			gf_list_add(set->essential_properties, desc);
			sprintf(value, "9");
			desc = gf_mpd_descriptor_new(NULL, "urn:mpeg:mpegB:cicp:MatrixCoefficients", value);
			gf_list_add(set->essential_properties, desc);

			if (ds->hdr_type==DASHER_HDR_PQ10) {
				sprintf(value, "16");
				desc = gf_mpd_descriptor_new(NULL, "urn:mpeg:mpegB:cicp:TransferCharacteristics", value);
				gf_list_add(set->essential_properties, desc);
			}

			if (ds->hdr_type == DASHER_HDR_HLG) {
				sprintf(value, "14");
				desc = gf_mpd_descriptor_new(NULL, "urn:mpeg:mpegB:cicp:TransferCharacteristics", value);
				gf_list_add(set->essential_properties, desc);
				sprintf(value, "18");
				desc = gf_mpd_descriptor_new(NULL, "urn:mpeg:mpegB:cicp:TransferCharacteristics", value);
				gf_list_add(set->supplemental_properties, desc);
			}
		}
	}
	if (ctx->check_main_role && !main_role_set) {
		GF_MPD_Descriptor *desc;
		desc = gf_mpd_descriptor_new(NULL, "urn:mpeg:dash:role:2011", "main");
		gf_list_add(set->role, desc);
	}
}
