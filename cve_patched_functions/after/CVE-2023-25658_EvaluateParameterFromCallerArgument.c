Status HloEvaluator::EvaluateParameterFromCallerArgument(
    HloInstruction* parameter, const ShapeIndex& shape_index) {
  CHECK(!evaluated_.contains(parameter));
  const HloComputation* parent_computation = parameter->parent();
  std::vector<HloInstruction*> computation_callers =
      call_graph_cache_->GetComputationCallers(parent_computation);
  // If the parent computation has multiple callers, we cannot determine from
  // which caller the arguments are passed.
  if (computation_callers.size() != 1) {
    return tsl::errors::FailedPrecondition(
        "The computation ", parent_computation->name(), " is called by ",
        computation_callers.size(),
        " callers and thus its argument value "
        "cannot be determined statically.");
  }
  HloInstruction* computation_caller = computation_callers[0];
  HloInstruction* caller_operand = computation_caller->mutable_operand(0);
  if (computation_caller->opcode() != HloOpcode::kWhile &&
      computation_caller->opcode() != HloOpcode::kCall) {
    return tsl::errors::FailedPrecondition(
        "The computation ", parent_computation->name(), " is called by ",
        "instruction ", computation_caller->name(),
        ", which is not yet supported.");
  }
  if (computation_caller->opcode() == HloOpcode::kWhile) {
    HloComputation* while_body = computation_caller->while_body();
    TF_ASSIGN_OR_RETURN(
        const LogicalBuffer* logical_buffer,
        tuple_points_to_analysis_cache_->GetBufferDefinedAt(
            while_body->parameter_instruction(parameter->parameter_number()),
            shape_index));
    const TuplePointsToAnalysis::BufferAliasVector& buffer_aliases =
        tuple_points_to_analysis_cache_->GetBufferAliases(*logical_buffer);
    bool unchanged_in_return = false;
    for (const BufferAlias& buffer_alias : buffer_aliases) {
      if (buffer_alias.instruction() == while_body->root_instruction() &&
          buffer_alias.index() == shape_index) {
        unchanged_in_return = true;
      }
    }
    if (!unchanged_in_return) {
      return MakeEvalErrorDueToParamOrInfeed(*parameter);
    }
  }
  TF_RETURN_IF_ERROR(EvaluateInternal(caller_operand, shape_index, true));
  const Literal& caller_operand_literal =
      GetEvaluatedLiteralFor(caller_operand);
  evaluated_[parameter] =
      Literal::CreateFromShapeWithUnknownLeafArrays(parameter->shape());
  TF_RETURN_IF_ERROR(evaluated_[parameter].CopyFrom(
      caller_operand_literal, /*dest_shape_index=*/shape_index,
      /*src_shape_index=*/shape_index));
  return OkStatus();
}
