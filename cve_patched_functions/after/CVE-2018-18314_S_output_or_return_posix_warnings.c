S_output_or_return_posix_warnings(pTHX_ RExC_state_t *pRExC_state, AV* posix_warnings, AV** return_posix_warnings)
{
    /* If the final parameter is NULL, output the elements of the array given
     * by '*posix_warnings' as REGEXP warnings.  Otherwise, the elements are
     * pushed onto it, (creating if necessary) */

    SV * msg;
    const bool first_is_fatal =  ! return_posix_warnings
                                && ckDEAD(packWARN(WARN_REGEXP));

    PERL_ARGS_ASSERT_OUTPUT_OR_RETURN_POSIX_WARNINGS;

    while ((msg = av_shift(posix_warnings)) != &PL_sv_undef) {
        if (return_posix_warnings) {
            if (! *return_posix_warnings) { /* mortalize to not leak if
                                               warnings are fatal */
                *return_posix_warnings = (AV *) sv_2mortal((SV *) newAV());
            }
            av_push(*return_posix_warnings, msg);
        }
        else {
            if (first_is_fatal) {           /* Avoid leaking this */
                av_undef(posix_warnings);   /* This isn't necessary if the
                                               array is mortal, but is a
                                               fail-safe */
                (void) sv_2mortal(msg);
                if (PASS2) {
                    SAVEFREESV(RExC_rx_sv);
                }
            }
            Perl_warner(aTHX_ packWARN(WARN_REGEXP), "%s", SvPVX(msg));
            SvREFCNT_dec_NN(msg);
        }
    }
}
