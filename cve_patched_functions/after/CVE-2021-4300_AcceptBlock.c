bool CBlock::AcceptBlock()
{
    // Check for duplicate
    uint256 hash = GetHash();
    if (mapBlockIndex.count(hash))
        return error("AcceptBlock() : block already in mapBlockIndex");

    // Get prev block index
    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);
    if (mi == mapBlockIndex.end())
        return DoS(10, error("AcceptBlock() : prev block not found"));
    CBlockIndex* pindexPrev = (*mi).second;
    int nHeight = pindexPrev->nHeight+1;

    if(!fTestNet && IsProofOfWork()) {
      if((nHeight > 20000) && (nHeight < nForkOne))
        return DoS(100, error("AcceptBlock() : reject proof-of-work at height %d", nHeight));
    }

    // Check proof-of-work or proof-of-stake
    if(nBits != GetNextTargetRequired(pindexPrev, IsProofOfStake(), false))
      return(DoS(100, error("AcceptBlock() : incorrect proof-of-%s difficulty",
        IsProofOfWork() ? "work" : "stake")));

    uint nOurTime = (uint)GetAdjustedTime();

    /* Check for time stamp (past limit #1) */
    if(nTime <= (uint)pindexPrev->GetMedianTimePast())
      return(DoS(20, error("AcceptBlock() : block %s height %d has a time stamp behind the median",
        hash.ToString().substr(0,20).c_str(), nHeight)));

    if(fTestNet || (!fTestNet && (nHeight > nForkOne))) {

        /* Check for time stamp (future limit) */
        if(nTime > (nOurTime + 5 * 60))
          return(DoS(5, error("AcceptBlock() : block %s height %d has a time stamp too far in the future",
            hash.ToString().substr(0,20).c_str(), nHeight)));

        /* Basic block limiter */
        if(nTime <= ((uint)pindexPrev->GetMedianTimePast() + BLOCK_LIMITER_TIME))
          return(DoS(5, error("AcceptBlock() : block %s height %d rejected by the block limiter",
            hash.ToString().substr(0,20).c_str(), nHeight)));

        /* Future travel detector for the block limiter */
        if((nTime > (nOurTime + 120)) &&
          ((pindexPrev->GetAverageTimePast(5, 40) + BLOCK_LIMITER_TIME) > nOurTime))
          return(DoS(5, error("AcceptBlock() : block %s height %d rejected by the future travel detector",
            hash.ToString().substr(0,20).c_str(), nHeight)));

    }

    /* Check for time stamp (past limit #2) */
    if(nTime <= (pindexPrev->nTime - 10 * 60))
      return(DoS(20, error("AcceptBlock() : block %s height %d has a time stamp too far in the past",
        hash.ToString().substr(0,20).c_str(), nHeight)));

    // Check that all transactions are finalized
    BOOST_FOREACH(const CTransaction& tx, vtx)
        if (!tx.IsFinal(nHeight, GetBlockTime()))
            return DoS(10, error("AcceptBlock() : contains a non-final transaction"));

    // Check that the block chain matches the known block chain up to a checkpoint
    if (!Checkpoints::CheckHardened(nHeight, hash))
        return DoS(100, error("AcceptBlock() : rejected by hardened checkpoint lock-in at %d", nHeight));

    // Verify hash target and signature of coinstake tx
    uint256 hashProofOfStake = 0, targetProofOfStake = 0;
    if (IsProofOfStake())
    {
        if (!CheckProofOfStake(vtx[1], nBits, hashProofOfStake, targetProofOfStake))
        {
            printf("WARNING: ProcessBlock(): check proof-of-stake failed for block %s\n", hash.ToString().c_str());
            return false; // do not error here as we expect this during initial block download
        }
    }

    bool cpSatisfies = Checkpoints::CheckSync(hash, pindexPrev);

    // Check that the block satisfies synchronized checkpoint
    if (CheckpointsMode == Checkpoints::STRICT && !cpSatisfies)
        return error("AcceptBlock() : rejected by synchronized checkpoint");

    if (CheckpointsMode == Checkpoints::ADVISORY && !cpSatisfies)
        strMiscWarning = _("WARNING: syncronized checkpoint violation detected, but skipped!");

    // Enforce rule that the coinbase starts with serialized block height
    CScript expect = CScript() << nHeight;
    if (vtx[0].vin[0].scriptSig.size() < expect.size() ||
        !std::equal(expect.begin(), expect.end(), vtx[0].vin[0].scriptSig.begin()))
        return DoS(100, error("AcceptBlock() : block height mismatch in coinbase"));

    /* Don't accept blocks with bogus version numbers after this point */
    if(fTestNet || (!fTestNet && (nHeight >= nForkOne))) {
        if(nVersion != 2)
          return(DoS(100, error("AcceptBlock() : incorrect block version %u", nVersion)));
    }

    // Write block to history file
    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))
        return error("AcceptBlock() : out of disk space");
    unsigned int nFile = -1;
    unsigned int nBlockPos = 0;
    if (!WriteToDisk(nFile, nBlockPos))
        return error("AcceptBlock() : WriteToDisk failed");
    if (!AddToBlockIndex(nFile, nBlockPos, hashProofOfStake))
        return error("AcceptBlock() : AddToBlockIndex failed");

    // Relay inventory, but don't relay old inventory during initial block download
    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();
    if (hashBestChain == hash)
    {
        LOCK(cs_vNodes);
        BOOST_FOREACH(CNode* pnode, vNodes)
            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))
                pnode->PushInventory(CInv(MSG_BLOCK, hash));
    }

    // ppcoin: check pending sync-checkpoint
    Checkpoints::AcceptPendingSyncCheckpoint();

    return true;
}
