static void tls_init_shutdown(struct tls_transport *tls, pj_status_t status)
{
    pjsip_tp_state_callback state_cb;

    if (tls->close_reason == PJ_SUCCESS)
	tls->close_reason = status;

    if (tls->base.is_shutdown || tls->base.is_destroying)
	return;

    /* Prevent immediate transport destroy by application, as transport
     * state notification callback may be stacked and transport instance
     * must remain valid at any point in the callback.
     */
    pjsip_transport_add_ref(&tls->base);

    /* Notify application of transport disconnected state */
    state_cb = pjsip_tpmgr_get_state_cb(tls->base.tpmgr);
    if (state_cb) {
	pjsip_transport_state_info state_info;
	pjsip_tls_state_info tls_info;
	pj_ssl_sock_info ssl_info;
	
	/* Init transport state info */
	pj_bzero(&state_info, sizeof(state_info));
	state_info.status = tls->close_reason;

	if (tls->ssock && 
	    pj_ssl_sock_get_info(tls->ssock, &ssl_info) == PJ_SUCCESS)
	{
	    pj_bzero(&tls_info, sizeof(tls_info));
	    tls_info.ssl_sock_info = &ssl_info;
	    state_info.ext_info = &tls_info;
	}

	(*state_cb)(&tls->base, PJSIP_TP_STATE_DISCONNECTED, &state_info);
    }

    /* check again */
    if (tls->base.is_shutdown || tls->base.is_destroying) {
        pjsip_transport_dec_ref(&tls->base);
	return;
    }

    /* We can not destroy the transport since high level objects may
     * still keep reference to this transport. So we can only 
     * instruct transport manager to gracefully start the shutdown
     * procedure for this transport.
     */
    pjsip_transport_shutdown(&tls->base);

    /* Now, it is ok to destroy the transport. */
    pjsip_transport_dec_ref(&tls->base);
}
