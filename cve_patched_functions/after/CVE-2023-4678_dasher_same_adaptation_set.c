static Bool dasher_same_adaptation_set(GF_DasherCtx *ctx, GF_DashStream *ds, GF_DashStream *ds_test)
{
	const char *lang1, *lang2;
	const GF_PropertyValue *p1, *p2;

	//in all forward mode we don't rewrite the manifest, make each source file a single as
	if (ctx->forward_mode==DASHER_FWD_ALL)
		return GF_FALSE;
		
	//muxed representations
	if (ds_test->muxed_base) {
		if (ds_test->muxed_base == ds)
			return GF_TRUE;
		//if muxed base rep has been registered with this AdaptationSet, also register this stream
		if (gf_list_find(ds->set->representations, ds_test->muxed_base->rep)>=0)
			return GF_TRUE;
	}

	//otherwise we have to be of same type
	if (ds->stream_type != ds_test->stream_type) return GF_FALSE;

	//not the same roles
	if (!dasher_same_roles(ds, ds_test)) return GF_FALSE;

	//avoid text streams with no roles and same language to be in the same AS
	if (ds->stream_type==GF_STREAM_TEXT) {
		if (ds->codec_id==ds_test->codec_id) return GF_FALSE;
	}

	//intra-only trick mode belongs to a separate AS
	if ((ds->stream_type == GF_STREAM_VISUAL) && (ds->sync_points_type != ds_test->sync_points_type)) {
		//assign trickmode as id for dashif
		if (ds_test->sync_points_type == DASHER_SYNC_NONE) {
			if (!ds->as_id) ds->as_id = dasher_get_next_as_id(ctx);
			ds_test->sync_as_id = ds->as_id;
		}
		else if (ds->sync_points_type == DASHER_SYNC_NONE) {
			if (!ds_test->as_id) ds_test->as_id = dasher_get_next_as_id(ctx);
			ds->sync_as_id = ds_test->as_id;
		}
		return GF_FALSE;
	}

	/* if two inputs don't have the same (number and value) as_desc they don't belong to the same AdaptationSet
	   (use c_as_desc for AdaptationSet descriptors common to all inputs in an AS) */
	if (!ds->p_as_desc && ds_test->p_as_desc)
		return GF_FALSE;
	if (ds->p_as_desc && !ds_test->p_as_desc)
		return GF_FALSE;
	if (ds->p_as_desc && ! gf_props_equal(ds->p_as_desc, ds_test->p_as_desc))
		return GF_FALSE;

	//need same AS ID if specified
	if (ds->as_id && ds_test->as_id &&(ds->as_id != ds_test->as_id) )
		return GF_FALSE;

	//need same dash duration if aligned
	if (ctx->align) {
		if ((u64) ds->dash_dur.num * ds_test->dash_dur.den != (u64) ds_test->dash_dur.num * ds->dash_dur.den) return GF_FALSE;
	}

	//if one of the pid is marked with period resume and the other is not, one is a spliced media the other no
	//cf flist filter
	p1 = gf_filter_pid_get_property_str(ds->ipid, "period_resume");
	p2 = gf_filter_pid_get_property_str(ds_test->ipid, "period_resume");
	if ((!p1 && p2) || (p1 && !p2) || (p1 && gf_props_equal(p1, p2)))
		return GF_FALSE;

	if (ds->srd.x != ds_test->srd.x) return GF_FALSE;
	if (ds->srd.y != ds_test->srd.y) return GF_FALSE;
	if (ds->srd.z != ds_test->srd.z) return GF_FALSE;
	if (ds->srd.w != ds_test->srd.w) return GF_FALSE;

	if (ds->view_id != ds_test->view_id) return GF_FALSE;
	//according to DASH spec mixing interlaced and progressive is OK
	//if (ds->interlaced != ds_test->interlaced) return GF_FALSE;
	if (ds->nb_ch != ds_test->nb_ch) return GF_FALSE;

	lang1 = ds->lang ? ds->lang : "und";
	lang2 = ds_test->lang ? ds_test->lang : "und";
	if (strcmp(lang1, lang2)) return GF_FALSE;

	if (ds->stream_type==GF_STREAM_VISUAL) {
		u32 w, h, tw, th;
		if (ctx->no_sar) {
			w = ds->width;
			h = ds->height;
			tw = ds_test->width;
			th = ds_test->height;
		} else {
			w = ds->width * ds->sar.num;
			h = ds->height * ds->sar.den;
			tw = ds_test->width * ds_test->sar.num;
			th = ds_test->height * ds_test->sar.den;
		}

		//not the same aspect ratio
		if (w * th != h * tw)
			return GF_FALSE;
	} else if (ds->stream_type==GF_STREAM_AUDIO) {
		if (!ctx->mix_codecs && (ds->codec_id != ds_test->codec_id) )
			return GF_FALSE;
		//we allow mix of channels config
	} else {
		if (!ctx->mix_codecs && strcmp(ds->rep->codecs, ds_test->rep->codecs)) return GF_FALSE;
		return GF_TRUE;
	}
	//ok, we are video or audio with mixed codecs
	if (ctx->mix_codecs) return GF_TRUE;
	//we need dependencies, unless SRD case
	if (!ds_test->srd.z && !ds_test->srd.w) {
		if (ds_test->dep_id && (ds_test->src_id==ds->src_id) && gf_list_find(ds->complementary_streams, ds_test) < 0) {
			return GF_FALSE;
		}
	}
	//we should be good
	return GF_TRUE;
}
