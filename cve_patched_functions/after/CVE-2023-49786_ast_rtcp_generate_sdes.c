static int ast_rtcp_generate_sdes(struct ast_rtp_instance *instance, unsigned char *rtcpheader,
		struct ast_rtp_rtcp_report *rtcp_report)
{
	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
	int len = 0;
	uint16_t sdes_packet_len_bytes;
	uint16_t sdes_packet_len_rounded;

	if (!rtp || !rtp->rtcp) {
		return 0;
	}

	if (ast_sockaddr_isnull(&rtp->rtcp->them)) {
		return 0;
	}

	if (!rtcp_report) {
		return -1;
	}

	sdes_packet_len_bytes =
		4 + /* RTCP Header */
		4 + /* SSRC */
		1 + /* Type (CNAME) */
		1 + /* Text Length */
		AST_UUID_STR_LEN /* Text and NULL terminator */
		;

	/* Round to 32 bit boundary */
	sdes_packet_len_rounded = (sdes_packet_len_bytes + 3) & ~0x3;

	put_unaligned_uint32(rtcpheader, htonl((2 << 30) | (1 << 24) | (RTCP_PT_SDES << 16) | ((sdes_packet_len_rounded / 4) - 1)));
	put_unaligned_uint32(rtcpheader + 4, htonl(rtcp_report->ssrc));
	rtcpheader[8] = 0x01; /* CNAME */
	rtcpheader[9] = AST_UUID_STR_LEN - 1; /* Number of bytes of text */
	memcpy(rtcpheader + 10, rtp->cname, AST_UUID_STR_LEN);
	len += 10 + AST_UUID_STR_LEN;

	/* Padding - Note that we don't set the padded bit on the packet. From
	 * RFC 3550 Section 6.5:
	 *
	 *   No length octet follows the null item type octet, but additional null
	 *   octets MUST be included if needd to pad until the next 32-bit
	 *   boundary. Note that this padding is separate from that indicated by
	 *   the P bit in the RTCP header.
	 *
	 * These bytes will already be zeroed out during array initialization.
	 */
	len += (sdes_packet_len_rounded - sdes_packet_len_bytes);

	return len;
}
