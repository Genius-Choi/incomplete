static int measure_square_diff_partial(YV12_BUFFER_CONFIG *source,
                                       YV12_BUFFER_CONFIG *dest,
                                       VP8_COMP *cpi) {
  int i, j;
  int Total = 0;
  int num_blocks = 0;
  int skip = 2;
  int min_consec_zero_last = 10;
  int tot_num_blocks = (source->y_height * source->y_width) >> 8;
  unsigned char *src = source->y_buffer;
  unsigned char *dst = dest->y_buffer;

  /* Loop through the Y plane, every |skip| blocks along rows and colmumns,
   * summing the square differences, and only for blocks that have been
   * zero_last mode at least |x| frames in a row.
   */
  for (i = 0; i < source->y_height; i += 16 * skip) {
    int block_index_row = (i >> 4) * cpi->common.mb_cols;
    for (j = 0; j < source->y_width; j += 16 * skip) {
      int index = block_index_row + (j >> 4);
      if (cpi->consec_zero_last[index] >= min_consec_zero_last) {
        unsigned int sse;
        Total += vpx_mse16x16(src + j, source->y_stride, dst + j,
                              dest->y_stride, &sse);
        num_blocks++;
      }
    }
    src += 16 * skip * source->y_stride;
    dst += 16 * skip * dest->y_stride;
  }
  // Only return non-zero if we have at least ~1/16 samples for estimate.
  if (num_blocks > (tot_num_blocks >> 4)) {
    assert(num_blocks != 0);
    return (Total / num_blocks);
  } else {
    return 0;
  }
}
