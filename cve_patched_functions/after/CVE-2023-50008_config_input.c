static av_cold int config_input(AVFilterLink *inlink)
{
    AVFilterContext *ctx = inlink->dst;
    ColorCorrectContext *s = ctx->priv;
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);

    s->depth = desc->comp[0].depth;
    s->max = (1 << s->depth) - 1;
    s->imax = 1.f / s->max;
    s->do_slice = s->depth <= 8 ? colorcorrect_slice8 : colorcorrect_slice16;

    s->uhistogram = av_calloc(s->max == 255 ? 256 : 65536, sizeof(*s->uhistogram));
    if (!s->uhistogram)
        return AVERROR(ENOMEM);

    s->vhistogram = av_calloc(s->max == 255 ? 256 : 65536, sizeof(*s->vhistogram));
    if (!s->vhistogram)
        return AVERROR(ENOMEM);

    s->analyzeret = av_calloc(inlink->h, sizeof(*s->analyzeret));
    if (!s->analyzeret)
        return AVERROR(ENOMEM);

    switch (s->analyze) {
    case MANUAL:
        break;
    case AVERAGE:
        s->do_analyze = s->depth <= 8 ? average_slice8 : average_slice16;
        break;
    case MINMAX:
        s->do_analyze = s->depth <= 8 ? minmax_slice8  : minmax_slice16;
        break;
    case MEDIAN:
        s->do_analyze = s->depth <= 8 ? median_8       : median_16;
        break;
    default:
        return AVERROR_BUG;
    }

    s->chroma_w = 1 << desc->log2_chroma_w;
    s->chroma_h = 1 << desc->log2_chroma_h;
    s->planeheight[1] = s->planeheight[2] = AV_CEIL_RSHIFT(inlink->h, desc->log2_chroma_h);
    s->planeheight[0] = s->planeheight[3] = inlink->h;
    s->planewidth[1] = s->planewidth[2] = AV_CEIL_RSHIFT(inlink->w, desc->log2_chroma_w);
    s->planewidth[0] = s->planewidth[3] = inlink->w;

    return 0;
}
