static int create_codec_lumps(struct sip_msg * msg)
{

	struct sdp_session_cell * cur_session;
	struct lump * tmp;
	int count;

	/* get the number of streams */
	lumps_len = 0;
	cur_session = get_sdp(msg)->sessions;

	while(cur_session)
	{
		lumps_len += cur_session->streams_num;
		cur_session = cur_session->next;
	}

	if (lumps_len>MAX_STREAMS)
	{
		LM_ERR("Overflow - too many streams (%d), limit is %d\n",
			lumps_len, MAX_STREAMS);
		return -1;
	}
	memset(lumps, 0, MAX_STREAMS * sizeof(struct lump*));

	/* for each stream create a specific lump for deletion, skip
	 * and insertion */

	LM_DBG("creating %d streams\n",lumps_len);

	count = 0;
	cur_session = get_sdp(msg)->sessions;

	while(cur_session)
	{
		struct sdp_stream_cell * cur_cell = cur_session->streams;
		struct lump* l;
		str text;
		str payloads;

		while(cur_cell)
		{
			payloads = cur_cell->payloads;
			/* include the previous whitespaces */
			while (payloads.s > cur_cell->body.s && *(payloads.s-1) == ' ') {
				payloads.s--;
				payloads.len++;
			}

			l = del_lump(msg, payloads.s - msg->buf, payloads.len, 0);

			lumps[count] = l;

			if( l == NULL)
			{
				LM_ERR("Error adding delete lump for m=\n");
				return -1;
			}

			l->flags |= LUMPFLAG_CODEC;

			tmp = insert_skip_lump_after( l );
			if(tmp == NULL)
			{
				LM_ERR("Error adding skip lump for m=\n");
				return -1;
			}

			text.len = payloads.len;
			text.s = (char*)pkg_malloc(payloads.len);

			if( text.s == NULL )
			{
				LM_ERR("Error allocating lump buffer\n");
				return -1;
			}

			memcpy(text.s,payloads.s,payloads.len);

			tmp = insert_new_lump_after( tmp, text.s, text.len, 0);
			if(tmp == NULL)
			{
				LM_ERR("Error adding insert lump for m=\n");
				return -1;
			}

			count ++;
			cur_cell = cur_cell->next;
		}

		cur_session = cur_session->next;

	}

	return 0;
};
