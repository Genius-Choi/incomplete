extern "C" HRESULT CacheGetLocalSourcePaths(
    __in_z LPCWSTR wzRelativePath,
    __in_z LPCWSTR wzSourcePath,
    __in_z LPCWSTR wzDestinationPath,
    __in_z_opt LPCWSTR wzLayoutDirectory,
    __in BURN_CACHE* pCache,
    __in BURN_VARIABLES* pVariables,
    __inout LPWSTR** prgSearchPaths,
    __out DWORD* pcSearchPaths,
    __out DWORD* pdwLikelySearchPath,
    __out DWORD* pdwDestinationSearchPath
    )
{
    AssertSz(pCache->fInitializedCacheSources, "Cache sources weren't initialized");

    HRESULT hr = S_OK;
    LPWSTR sczCurrentPath = NULL;
    LPWSTR sczLastSourceFolder = NULL;
    LPWSTR* psczPath = NULL;
    BOOL fPreferSourcePathLocation = FALSE;
    BOOL fTryLastFolder = FALSE;
    BOOL fTryRelativePath = FALSE;
    BOOL fSourceIsAbsolute = FALSE;
    DWORD cSearchPaths = 0;
    DWORD dwLikelySearchPath = 0;
    DWORD dwDestinationSearchPath = 0;

    hr = GetLastUsedSourceFolder(pVariables, &sczLastSourceFolder);
    fPreferSourcePathLocation = !pCache->fRunningFromCache || FAILED(hr);
    fTryLastFolder = SUCCEEDED(hr) && sczLastSourceFolder && *sczLastSourceFolder && CSTR_EQUAL != ::CompareStringW(LOCALE_NEUTRAL, NORM_IGNORECASE, pCache->sczSourceProcessFolder, -1, sczLastSourceFolder, -1);
    fTryRelativePath = CSTR_EQUAL != ::CompareStringW(LOCALE_NEUTRAL, NORM_IGNORECASE, wzSourcePath, -1, wzRelativePath, -1);
    fSourceIsAbsolute = PathIsRooted(wzSourcePath);

    // If the source path provided is a full path, try that first.
    if (fSourceIsAbsolute)
    {
        hr = MemEnsureArraySize(reinterpret_cast<LPVOID*>(prgSearchPaths), cSearchPaths + 1, sizeof(LPWSTR), BURN_CACHE_MAX_SEARCH_PATHS);
        ExitOnFailure(hr, "Failed to ensure size for search paths array.");

        psczPath = *prgSearchPaths + cSearchPaths;
        ++cSearchPaths;

        hr = StrAllocString(psczPath, wzSourcePath, 0);
        ExitOnFailure(hr, "Failed to copy absolute source path.");
    }
    else
    {
        // If none of the paths exist, then most BAs will want to prompt the user with a possible path.
        // The destination path is a temporary location and so not really a possible path.
        dwLikelySearchPath = 1;
    }

    // Try the destination path next.
    hr = MemEnsureArraySize(reinterpret_cast<LPVOID*>(prgSearchPaths), cSearchPaths + 1, sizeof(LPWSTR), BURN_CACHE_MAX_SEARCH_PATHS);
    ExitOnFailure(hr, "Failed to ensure size for search paths array.");

    dwDestinationSearchPath = cSearchPaths;
    psczPath = *prgSearchPaths + cSearchPaths;
    ++cSearchPaths;

    hr = StrAllocString(psczPath, wzDestinationPath, 0);
    ExitOnFailure(hr, "Failed to copy absolute source path.");

    if (!fSourceIsAbsolute)
    {
        // Calculate the source path location.
        // In the case where we are in the bundle's package cache and
        // couldn't find a last used source that will be the package cache path
        // which isn't likely to have what we are looking for.
        hr = MemEnsureArraySize(reinterpret_cast<LPVOID*>(prgSearchPaths), cSearchPaths + 1, sizeof(LPWSTR), BURN_CACHE_MAX_SEARCH_PATHS);
        ExitOnFailure(hr, "Failed to ensure size for search paths array.");

        hr = PathConcat(pCache->sczSourceProcessFolder, wzSourcePath, &sczCurrentPath);
        ExitOnFailure(hr, "Failed to combine source process folder with source.");

        // If we're not running from cache or we couldn't get the last source,
        // try the source path location next.
        if (fPreferSourcePathLocation)
        {
            (*prgSearchPaths)[cSearchPaths] = sczCurrentPath;
            ++cSearchPaths;
            sczCurrentPath = NULL;
        }

        // If we have a last used source and it is not the source path location,
        // add the last used source to the search path next.
        if (fTryLastFolder)
        {
            hr = MemEnsureArraySize(reinterpret_cast<LPVOID*>(prgSearchPaths), cSearchPaths + 1, sizeof(LPWSTR), BURN_CACHE_MAX_SEARCH_PATHS);
            ExitOnFailure(hr, "Failed to ensure size for search paths array.");

            psczPath = *prgSearchPaths + cSearchPaths;
            ++cSearchPaths;

            hr = PathConcat(sczLastSourceFolder, wzSourcePath, psczPath);
            ExitOnFailure(hr, "Failed to combine last source with source.");
        }

        if (!fPreferSourcePathLocation)
        {
            (*prgSearchPaths)[cSearchPaths] = sczCurrentPath;
            ++cSearchPaths;
            sczCurrentPath = NULL;
        }

        // Also consider the layout directory if doing Layout.
        if (wzLayoutDirectory)
        {
            hr = MemEnsureArraySize(reinterpret_cast<LPVOID*>(prgSearchPaths), cSearchPaths + 1, sizeof(LPWSTR), BURN_CACHE_MAX_SEARCH_PATHS);
            ExitOnFailure(hr, "Failed to ensure size for search paths array.");

            psczPath = *prgSearchPaths + cSearchPaths;
            ++cSearchPaths;

            hr = PathConcat(wzLayoutDirectory, wzSourcePath, psczPath);
            ExitOnFailure(hr, "Failed to combine layout source with source.");
        }
    }

    if (fTryRelativePath)
    {
        hr = MemEnsureArraySize(reinterpret_cast<LPVOID*>(prgSearchPaths), cSearchPaths + 1, sizeof(LPWSTR), BURN_CACHE_MAX_SEARCH_PATHS);
        ExitOnFailure(hr, "Failed to ensure size for search paths array.");

        hr = PathConcat(pCache->sczSourceProcessFolder, wzRelativePath, &sczCurrentPath);
        ExitOnFailure(hr, "Failed to combine source process folder with relative.");

        if (fPreferSourcePathLocation)
        {
            (*prgSearchPaths)[cSearchPaths] = sczCurrentPath;
            ++cSearchPaths;
            sczCurrentPath = NULL;
        }

        if (fTryLastFolder)
        {
            hr = MemEnsureArraySize(reinterpret_cast<LPVOID*>(prgSearchPaths), cSearchPaths + 1, sizeof(LPWSTR), BURN_CACHE_MAX_SEARCH_PATHS);
            ExitOnFailure(hr, "Failed to ensure size for search paths array.");

            psczPath = *prgSearchPaths + cSearchPaths;
            ++cSearchPaths;

            hr = PathConcat(sczLastSourceFolder, wzRelativePath, psczPath);
            ExitOnFailure(hr, "Failed to combine last source with relative.");
        }

        if (!fPreferSourcePathLocation)
        {
            (*prgSearchPaths)[cSearchPaths] = sczCurrentPath;
            ++cSearchPaths;
            sczCurrentPath = NULL;
        }

        if (wzLayoutDirectory)
        {
            hr = MemEnsureArraySize(reinterpret_cast<LPVOID*>(prgSearchPaths), cSearchPaths + 1, sizeof(LPWSTR), BURN_CACHE_MAX_SEARCH_PATHS);
            ExitOnFailure(hr, "Failed to ensure size for search paths array.");

            psczPath = *prgSearchPaths + cSearchPaths;
            ++cSearchPaths;

            hr = PathConcat(wzLayoutDirectory, wzSourcePath, psczPath);
            ExitOnFailure(hr, "Failed to combine layout source with relative.");
        }
    }

LExit:
    ReleaseStr(sczCurrentPath);
    ReleaseStr(sczLastSourceFolder);

    AssertSz(cSearchPaths <= BURN_CACHE_MAX_SEARCH_PATHS, "Got more than BURN_CACHE_MAX_SEARCH_PATHS search paths");
    *pcSearchPaths = cSearchPaths;
    *pdwLikelySearchPath = dwLikelySearchPath;
    *pdwDestinationSearchPath = dwDestinationSearchPath;

    return hr;
}
