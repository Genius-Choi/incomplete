static void rq_model_update(const RATE_QINDEX_HISTORY *rq_history,
                            int target_bits, RATE_QSTEP_MODEL *rq_model) {
  const int recode_count = rq_history->recode_count;
  const double delta = 0.00001;
  if (recode_count >= 2) {
    const int q_index1 = rq_history->q_index_history[recode_count - 2];
    const int q_index2 = rq_history->q_index_history[recode_count - 1];
    const int r1 = rq_history->rate_history[recode_count - 2];
    const int r2 = rq_history->rate_history[recode_count - 1];
    int valid = 0;
    // lower q_index should yield higher bit rate
    if (q_index1 < q_index2) {
      valid = r1 > r2;
    } else if (q_index1 > q_index2) {
      valid = r1 < r2;
    }
    // Only update the model when the q_index and rate behave normally.
    if (valid) {
      // Fit the ratio and bias of rq_model based on last two recode histories.
      const double s1 = vp9_convert_qindex_to_q(q_index1, VPX_BITS_8);
      const double s2 = vp9_convert_qindex_to_q(q_index2, VPX_BITS_8);
      if (fabs(log2(s1) - log2(s2)) > delta) {
        rq_model->ratio = (r2 - r1) / (log2(s1) - log2(s2));
        rq_model->bias = r1 + (rq_model->ratio) * log2(s1);
        if (rq_model->ratio > delta && rq_model->bias > delta) {
          rq_model->ready = 1;
        }
      }
    }
  } else if (recode_count == 1) {
    if (rq_model->ready) {
      // Update the ratio only when the initial model exists and we only have
      // one recode history.
      const int prev_q = rq_history->q_index_history[recode_count - 1];
      const double prev_q_step = vp9_convert_qindex_to_q(prev_q, VPX_BITS_8);
      if (fabs(log2(prev_q_step)) > delta) {
        const int actual_bits = rq_history->rate_history[recode_count - 1];
        rq_model->ratio =
            rq_model->ratio + (target_bits - actual_bits) / log2(prev_q_step);
      }
    }
  }
}
