static pj_bool_t mod_ua_on_rx_response(pjsip_rx_data *rdata)
{
    pjsip_transaction *tsx;
    struct dlg_set *dlg_set;
    pjsip_dialog *dlg;
    pj_status_t status;

    /*
     * Find the dialog instance for the response.
     * All outgoing dialog requests are sent statefully, which means
     * there will be an UAC transaction associated with this response,
     * and the dialog instance will be recorded in that transaction.
     *
     * But even when transaction is found, there is possibility that
     * the response is a forked response.
     */

retry_on_deadlock:

    dlg = NULL;

    /* Lock user agent dlg table before we're doing anything. */
    pj_mutex_lock(mod_ua.mutex);

    /* Check if transaction is present. */
    tsx = pjsip_rdata_get_tsx(rdata);
    if (tsx) {
	/* Check if dialog is present in the transaction. */
	dlg = pjsip_tsx_get_dlg(tsx);
	if (!dlg) {
	    /* Unlock dialog hash table. */
	    pj_mutex_unlock(mod_ua.mutex);
	    return PJ_FALSE;
	}

	/* Get the dialog set. */
	dlg_set = (struct dlg_set*) dlg->dlg_set;

	/* Even if transaction is found and (candidate) dialog has been 
	 * identified, it's possible that the request has forked.
	 */

    } else {
	/* Transaction is not present.
	 * Check if this is a 2xx/OK response to INVITE, which in this
	 * case the response will be handled directly by the
	 * dialog.
	 */
	pjsip_cseq_hdr *cseq_hdr = rdata->msg_info.cseq;

	if (cseq_hdr->method.id != PJSIP_INVITE_METHOD ||
	    rdata->msg_info.msg->line.status.code / 100 != 2)
	{
	    /* Not a 2xx response to INVITE.
	     * This must be some stateless response sent by other modules,
	     * or a very late response.
	     */
	    /* Unlock dialog hash table. */
	    pj_mutex_unlock(mod_ua.mutex);
	    return PJ_FALSE;
	}


	/* Get the dialog set. */
	dlg_set = (struct dlg_set*)
		  pj_hash_get_lower(mod_ua.dlg_table, 
			            rdata->msg_info.from->tag.ptr,
			            (unsigned)rdata->msg_info.from->tag.slen,
			            NULL);

	if (!dlg_set) {
	    /* Unlock dialog hash table. */
	    pj_mutex_unlock(mod_ua.mutex);

	    /* Strayed 2xx response!! */
	    PJ_LOG(4,(THIS_FILE, 
		      "Received strayed 2xx response (no dialog is found)"
		      " from %s:%d: %s",
		      rdata->pkt_info.src_name, rdata->pkt_info.src_port,
		      pjsip_rx_data_get_info(rdata)));

	    return PJ_TRUE;
	}
    }

    /* At this point, we must have the dialog set, and the dialog set
     * must have a dialog in the list.
     */
    pj_assert(dlg_set && !pj_list_empty(&dlg_set->dlg_list));

    /* Check for forked response. 
     * Request will fork only for the initial INVITE request.
     */

    //This doesn't work when there is authentication challenge, since 
    //first_cseq evaluation will yield false.
    //if (rdata->msg_info.cseq->method.id == PJSIP_INVITE_METHOD &&
    //	rdata->msg_info.cseq->cseq == dlg_set->dlg_list.next->local.first_cseq)

    if (rdata->msg_info.cseq->method.id == PJSIP_INVITE_METHOD) {
	
	int st_code = rdata->msg_info.msg->line.status.code;
	pj_str_t *to_tag = &rdata->msg_info.to->tag;

	dlg = dlg_set->dlg_list.next;

	while (dlg != (pjsip_dialog*)&dlg_set->dlg_list) {

	    /* If there is dialog with no remote tag (i.e. dialog has not
	     * been established yet), then send this response to that
	     * dialog.
	     */
	    if (dlg->remote.info->tag.slen == 0)
		break;

	    /* Otherwise find the one with matching To tag. */
	    if (pj_stricmp(to_tag, &dlg->remote.info->tag) == 0)
		break;

	    dlg = dlg->next;
	}

	/* If no dialog with matching remote tag is found, this must be
	 * a forked response. Respond to this ONLY when response is non-100
	 * provisional response OR a 2xx response.
	 */
	if (dlg == (pjsip_dialog*)&dlg_set->dlg_list &&
	    ((st_code/100==1 && st_code!=100) || st_code/100==2)) 
	{

	    PJ_LOG(5,(THIS_FILE, 
		      "Received forked %s for existing dialog %s",
		      pjsip_rx_data_get_info(rdata), 
		      dlg_set->dlg_list.next->obj_name));

	    /* Report to application about forked condition.
	     * Application can either create a dialog or ignore the response.
	     */
	    if (mod_ua.param.on_dlg_forked) {
		dlg = (*mod_ua.param.on_dlg_forked)(dlg_set->dlg_list.next, 
						    rdata);
		if (dlg == NULL) {
		    pj_mutex_unlock(mod_ua.mutex);
		    return PJ_TRUE;
		}
	    } else {
		dlg = dlg_set->dlg_list.next;

		PJ_LOG(4,(THIS_FILE, 
			  "Unhandled forked %s from %s:%d, response will be "
			  "handed over to the first dialog",
			  pjsip_rx_data_get_info(rdata),
			  rdata->pkt_info.src_name, rdata->pkt_info.src_port));
	    }

	} else if (dlg == (pjsip_dialog*)&dlg_set->dlg_list) {

	    /* For 100 or non-2xx response which has different To tag,
	     * pass the response to the first dialog.
	     */

	    dlg = dlg_set->dlg_list.next;

	}

    } else {
	/* Either this is a non-INVITE response, or subsequent INVITE
	 * within dialog. The dialog should have been identified when
	 * the transaction was found.
	 */
	pj_assert(tsx != NULL);
	pj_assert(dlg != NULL);
    }

    /* The dialog must have been found. */
    pj_assert(dlg != NULL);

    /* Put the dialog instance in the rdata. */
    rdata->endpt_info.mod_data[mod_ua.mod.id] = dlg;

    /* Attempt to acquire lock to the dialog. */
    PJ_LOG(6,(dlg->obj_name, "UA layer acquiring dialog lock for response"));
    status = pjsip_dlg_try_inc_lock(dlg);
    if (status != PJ_SUCCESS) {
	/* Failed to acquire dialog mutex. This could indicate a deadlock
	 * situation, and for safety, try to avoid deadlock by releasing
	 * UA mutex, yield, and retry the whole processing once again.
	 */
	pj_mutex_unlock(mod_ua.mutex);
	pj_thread_sleep(0);
	goto retry_on_deadlock;
    }

    /* We're done with processing in the UA layer, we can release the mutex */
    pj_mutex_unlock(mod_ua.mutex);

    /* Pass the response to the dialog. */
    pjsip_dlg_on_rx_response(dlg, rdata);

    /* Unlock the dialog. This may destroy the dialog. */
    pjsip_dlg_dec_lock(dlg);

    /* Done. */
    return PJ_TRUE;
}
