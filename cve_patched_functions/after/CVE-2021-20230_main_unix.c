NOEXPORT int main_unix(int argc, char* argv[]) {
    int configure_status;

#if !defined(__vms) && !defined(USE_OS2)
    int fd;

    fd=open("/dev/null", O_RDWR); /* open /dev/null before chroot */
    if(fd==INVALID_SOCKET)
        fatal("Could not open /dev/null");
#endif
    main_init();
    configure_status=main_configure(argc>1 ? argv[1] : NULL,
        argc>2 ? argv[2] : NULL);
    switch(configure_status) {
    case 1: /* error -> exit with 1 to indicate error */
        close(fd);
        return 1;
    case 2: /* information printed -> exit with 0 to indicate success */
        close(fd);
        return 0;
    }
    if(service_options.next) { /* there are service sections -> daemon mode */
#if !defined(__vms) && !defined(USE_OS2)
        if(daemonize(fd)) {
            close(fd);
            return 1;
        }
        close(fd);
        /* create_pid() must be called after drop_privileges()
         * or it won't be possible to remove the file on exit */
        /* create_pid() must be called after daemonize()
         * since the final pid is not known beforehand */
        if(create_pid())
            return 1;
#endif
#ifndef USE_OS2
        signal(SIGCHLD, signal_handler); /* handle dead children */
        signal(SIGHUP, signal_handler); /* configuration reload */
        signal(SIGUSR1, signal_handler); /* log reopen */
        signal(SIGUSR2, signal_handler); /* connections */
        signal(SIGPIPE, SIG_IGN); /* ignore broken pipe */
        if(signal(SIGTERM, SIG_IGN)!=SIG_IGN)
            signal(SIGTERM, signal_handler); /* fatal */
        if(signal(SIGQUIT, SIG_IGN)!=SIG_IGN)
            signal(SIGQUIT, signal_handler); /* fatal */
        if(signal(SIGINT, SIG_IGN)!=SIG_IGN)
            signal(SIGINT, signal_handler); /* fatal */
#endif
#ifdef USE_FORK
        setpgid(0, 0); /* create a new process group if needed */
#endif
        daemon_loop();
#ifdef USE_FORK
        s_log(LOG_NOTICE, "Terminating service processes");
        signal(SIGCHLD, SIG_IGN);
        signal(SIGTERM, SIG_IGN);
        kill(0, SIGTERM); /* kill the whole process group */
        while(wait(NULL)!=-1)
            ;
        s_log(LOG_NOTICE, "Service processes terminated");
#endif
#if !defined(__vms) && !defined(USE_OS2)
        delete_pid();
#endif /* standard Unix */
    } else { /* inetd mode */
        CLI *c;
#if !defined(__vms) && !defined(USE_OS2)
        close(fd);
#endif /* standard Unix */
#ifndef USE_OS2
        signal(SIGCHLD, SIG_IGN); /* ignore dead children */
        signal(SIGPIPE, SIG_IGN); /* ignore broken pipe */
#endif
        set_nonblock(0, 1); /* stdin */
        set_nonblock(1, 1); /* stdout */
        c=alloc_client_session(&service_options, 0, 1);
        tls_alloc(c, ui_tls, NULL);
        service_up_ref(&service_options);
        client_main(c);
        client_free(c);
    }
    return 0;
}
