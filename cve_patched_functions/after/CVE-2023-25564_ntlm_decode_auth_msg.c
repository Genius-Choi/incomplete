int ntlm_decode_auth_msg(struct ntlm_ctx *ctx,
                         struct ntlm_buffer *buffer,
                         uint32_t flags,
                         struct ntlm_buffer *lm_chalresp,
                         struct ntlm_buffer *nt_chalresp,
                         char **domain_name, char **user_name,
                         char **workstation,
                         struct ntlm_buffer *enc_sess_key,
                         struct ntlm_buffer *target_info,
                         struct ntlm_buffer *mic)
{
    struct wire_auth_msg *msg;
    uint32_t neg_flags;
    size_t payload_offs;
    char *dom = NULL;
    char *usr = NULL;
    char *wks = NULL;
    int ret = 0;

    if (!ctx) return EINVAL;

    if (lm_chalresp) lm_chalresp->data = NULL;
    if (nt_chalresp) nt_chalresp->data = NULL;
    if (enc_sess_key) enc_sess_key->data = NULL;

    msg = (struct wire_auth_msg *)buffer->data;
    payload_offs = (char *)msg->payload - (char *)msg;

    neg_flags = le32toh(msg->neg_flags);
    if ((neg_flags & NTLMSSP_NEGOTIATE_VERSION) == 0) {
        /* adjust the payload offset to point to the
         * version field, for compatibility with older
         * clients that completely omitted the structure
         * on the wire */
        payload_offs -= sizeof(struct wire_version);
    }

    /* Unconditionally copy 16 bytes for the MIC, if it was really
     * added by the client it will be flagged in the AV_PAIR contained
     * in the NT Response, that will be fully decoded later by the caller
     * and the MIC checked otherwise these 16 bytes will just be ignored */
    if (mic) {
        size_t mic_offs = payload_offs;

        if (mic->length < 16) return ERR_DECODE;

        if ((neg_flags & NTLMSSP_NEGOTIATE_VERSION) == 0) {
            struct wire_version zver = {0};
            /* mic is at payload_offs right now, but this offset may be
             * wrongly reduced for compatibility with older clients,
             * if all bytes are zeroed, then it means there was an actual
             * empty version struct */
            if (memcmp(&msg->version, &zver,
                       sizeof(struct wire_version)) == 0) {
                mic_offs += sizeof(struct wire_version);
            }
        }

        if (buffer->length - mic_offs < 16) return ERR_DECODE;
        memcpy(mic->data, &buffer->data[mic_offs], 16);
    }

    if (msg->lm_chalresp.len != 0 && lm_chalresp) {
        ret = ntlm_decode_field(&msg->lm_chalresp, buffer,
                                payload_offs, lm_chalresp);
        if (ret) goto done;
    }
    if (msg->nt_chalresp.len != 0 && nt_chalresp) {
        ret = ntlm_decode_field(&msg->nt_chalresp, buffer,
                                payload_offs, nt_chalresp);
        if (ret) goto done;

        if (target_info) {
            union wire_ntlm_response *resp;
            struct wire_ntlmv2_cli_chal *chal;
            uint8_t *data;
            int len;
            resp = (union wire_ntlm_response *)nt_chalresp->data;
            chal = (struct wire_ntlmv2_cli_chal *)resp->v2.cli_chal;
            len = nt_chalresp->length - sizeof(resp->v2.resp)
                    - offsetof(struct wire_ntlmv2_cli_chal, target_info);
            if (len > 0) {
                data = chal->target_info;
                target_info->data = malloc(len);
                if (!target_info->data) {
                    ret = ENOMEM;
                    goto done;
                }
                memcpy(target_info->data, data, len);
                target_info->length = len;
            }
        }
    }
    if (msg->domain_name.len != 0 && domain_name) {
        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {
            ret = ntlm_decode_u16l_str_hdr(ctx, &msg->domain_name, buffer,
                                           payload_offs, &dom);
        } else {
            ret = ntlm_decode_oem_str(&msg->domain_name, buffer,
                                      payload_offs, &dom);
        }
        if (ret) goto done;
    }
    if (msg->user_name.len != 0 && user_name) {
        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {
            ret = ntlm_decode_u16l_str_hdr(ctx, &msg->user_name, buffer,
                                           payload_offs, &usr);
        } else {
            ret = ntlm_decode_oem_str(&msg->user_name, buffer,
                                      payload_offs, &usr);
        }
        if (ret) goto done;
    }
    if (msg->workstation.len != 0 && workstation) {
        if (flags & NTLMSSP_NEGOTIATE_UNICODE) {
            ret = ntlm_decode_u16l_str_hdr(ctx, &msg->workstation, buffer,
                                           payload_offs, &wks);
        } else {
            ret = ntlm_decode_oem_str(&msg->workstation, buffer,
                                      payload_offs, &wks);
        }
        if (ret) goto done;
    }
    if (msg->enc_sess_key.len != 0 && enc_sess_key) {
        ret = ntlm_decode_field(&msg->enc_sess_key, buffer,
                                payload_offs, enc_sess_key);
    }

    /* ignore returned flags, our flags are authoritative
    flags = le32toh(msg->neg_flags);
    */

done:
    if (ret) {
        if (lm_chalresp) safefree(lm_chalresp->data);
        if (nt_chalresp) safefree(nt_chalresp->data);
        if (enc_sess_key) safefree(enc_sess_key->data);
        safefree(dom);
        safefree(usr);
        safefree(wks);
    } else {
        if (domain_name) *domain_name = dom;
        if (user_name) *user_name = usr;
        if (workstation) *workstation = wks;
    }
    return ret;
}
