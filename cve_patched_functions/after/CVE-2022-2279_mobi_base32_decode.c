MOBI_RET mobi_base32_decode(uint32_t *decoded, const char *encoded) {
    if (!encoded || !decoded) {
        debug_print("Error, null parameter (decoded: %p, encoded: %p)\n", (void *) decoded, (void *) encoded);
        return MOBI_PARAM_ERR;
    }
    /* strip leading zeroes */
    while (*encoded == '0') {
        encoded++;
    }
    size_t encoded_length = strlen(encoded);
    /* Let's limit input to 6 chars. VVVVVV(32) is 0x3FFFFFFF */
    if (encoded_length > 6) {
        debug_print("Base 32 number too big: %s\n", encoded);
        return MOBI_PARAM_ERR;
    }
    const unsigned char *c =  (unsigned char *) encoded;
    unsigned len = (unsigned) encoded_length;
    const unsigned base = 32;
    *decoded = 0;
    unsigned value;
    while (*c) {
        /* FIXME: not portable, should we care? */
        if (*c >= 'A' && *c <= 'V') {
            value = *c - 'A' + 10;
        }
        else if (*c >= '0' && *c <= '9') {
            value = *c - '0';
        }
        else {
            debug_print("Illegal character: \"%c\"\n", *c);
            return MOBI_DATA_CORRUPT;
        }
        *decoded += value * mobi_pow(base, --len);
        c++;
    }
    return MOBI_SUCCESS;
}
