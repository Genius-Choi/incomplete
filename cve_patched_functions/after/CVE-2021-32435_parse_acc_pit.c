char *parse_acc_pit(char *p,
		int *pit,
		int *acc)
{
	/* look for accidental sign */
	switch (*p) {
	case '^':
		p++;
		if (*p == '^') {
			p++;
			*acc = A_DS;
		} else {
			*acc = A_SH;
		}
		break;
	case '=':
		p++;
		*acc = A_NT;
		break;
	case '_':
		p++;
		if (*p == '_') {
			p++;
			*acc = A_DF;
		} else {
			*acc = A_FT;
		}
		break;
	default:
		*acc = 0;
	}

	/* look for microtone value */
	if (*acc != 0
	 && (isdigit((unsigned char) *p)
	  || (*p == '/' && microscale == 0))) {
		int n, d;
		char *q;

		n = d = 1;
		if (*p != '/') {
			n = strtol(p, &q, 10);
			p = q;
		}
		if (*p == '/') {
			p++;
			if (!isdigit((unsigned char) *p)) {
				d = 2;
			} else {
				d = strtol(p, &q, 10);
				p = q;
			}
		}
		if (microscale == 0) {
			d--;
			d += (n - 1) << 8;	/* short [ (n-1) | (d-1) ] */
			if (d == 0) {
				n = MAXMICRO - 1;
			} else {
			    for (n = 1; n < MAXMICRO; n++) {
				if (parse.micro_tb[n] == d)
					break;
				if (parse.micro_tb[n] == 0) {
					parse.micro_tb[n] = d;
					break;
				}
			    }
			}
			if (n == MAXMICRO) {
				syntax("Too many microtone accidentals", p);
				n = 0;
			}
		}
		*acc += (n << 3);
	}

	/* get the pitch */
	{
		char *p_n;

		p_n = strchr(all_notes, *p);
		if (!p_n || *p == '\0') {
			syntax(*acc ? "Missing note after accidental"
				   : "Not a note", p);
			*acc = -1;
			if (*p == '\0')
				p--;
		} else {
			*pit = p_n - all_notes + 16;
		}
		p++;
	}
	while (*p == '\'') {		/* eat up following ' chars */
		*pit += 7;
		p++;
	}
	while (*p == ',') {		/* eat up following , chars */
		*pit -= 7;
		p++;
	}
	return p;
}
