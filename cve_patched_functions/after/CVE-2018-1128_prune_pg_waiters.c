void OSD::ShardedOpWQ::prune_pg_waiters(OSDMapRef osdmap, int whoami)
{
  unsigned pushes_to_free = 0;
  for (auto sdata : shard_list) {
    Mutex::Locker l(sdata->sdata_op_ordering_lock);
    sdata->waiting_for_pg_osdmap = osdmap;
    auto p = sdata->pg_slots.begin();
    while (p != sdata->pg_slots.end()) {
      ShardData::pg_slot& slot = p->second;
      if (!slot.to_process.empty() && slot.num_running == 0) {
	if (osdmap->is_up_acting_osd_shard(p->first, whoami)) {
	  dout(20) << __func__ << "  " << p->first << " maps to us, keeping"
		   << dendl;
	  ++p;
	  continue;
	}
	while (!slot.to_process.empty() &&
	       slot.to_process.front().get_map_epoch() <= osdmap->get_epoch()) {
	  auto& qi = slot.to_process.front();
	  dout(20) << __func__ << "  " << p->first
		   << " item " << qi
		   << " epoch " << qi.get_map_epoch()
		   << " <= " << osdmap->get_epoch()
		   << ", stale, dropping" << dendl;
	  pushes_to_free += qi.get_reserved_pushes();
	  slot.to_process.pop_front();
	}
      }
      if (slot.to_process.empty() &&
	  slot.num_running == 0 &&
	  !slot.pg) {
	dout(20) << __func__ << "  " << p->first << " empty, pruning" << dendl;
	p = sdata->pg_slots.erase(p);
      } else {
	++p;
      }
    }
  }
  if (pushes_to_free > 0) {
    osd->service.release_reserved_pushes(pushes_to_free);
  }
}
