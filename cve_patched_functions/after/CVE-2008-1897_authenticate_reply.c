static int authenticate_reply(struct chan_iax2_pvt *p, struct sockaddr_in *sin, struct iax_ies *ies, const char *override, const char *okey)
{
	struct iax2_peer *peer = NULL;
	/* Start pessimistic */
	int res = -1;
	int authmethods = 0;
	struct iax_ie_data ied;
	uint16_t callno = p->callno;

	memset(&ied, 0, sizeof(ied));
	
	if (ies->username)
		ast_string_field_set(p, username, ies->username);
	if (ies->challenge)
		ast_string_field_set(p, challenge, ies->challenge);
	if (ies->authmethods)
		authmethods = ies->authmethods;
	if (authmethods & IAX_AUTH_MD5)
		merge_encryption(p, ies->encmethods);
	else
		p->encmethods = 0;

	/* Check for override RSA authentication first */
	if (!ast_strlen_zero(override) || !ast_strlen_zero(okey)) {
		/* Normal password authentication */
		res = authenticate(p->challenge, override, okey, authmethods, &ied, sin, &p->ecx, &p->dcx);
	} else {
		struct ao2_iterator i = ao2_iterator_init(peers, 0);
		while ((peer = ao2_iterator_next(&i))) {
			if ((ast_strlen_zero(p->peer) || !strcmp(p->peer, peer->name)) 
			    /* No peer specified at our end, or this is the peer */
			    && (ast_strlen_zero(peer->username) || (!strcmp(peer->username, p->username)))
			    /* No username specified in peer rule, or this is the right username */
			    && (!peer->addr.sin_addr.s_addr || ((sin->sin_addr.s_addr & peer->mask.s_addr) == (peer->addr.sin_addr.s_addr & peer->mask.s_addr)))
			    /* No specified host, or this is our host */
				) {
				res = authenticate(p->challenge, peer->secret, peer->outkey, authmethods, &ied, sin, &p->ecx, &p->dcx);
				if (!res) {
					peer_unref(peer);
					break;
				}
			}
			peer_unref(peer);
		}
		if (!peer) {
			/* We checked our list and didn't find one.  It's unlikely, but possible, 
			   that we're trying to authenticate *to* a realtime peer */
			const char *peer_name = ast_strdupa(p->peer);
			ast_mutex_unlock(&iaxsl[callno]);
			if ((peer = realtime_peer(peer_name, NULL))) {
				ast_mutex_lock(&iaxsl[callno]);
				if (!(p = iaxs[callno])) {
					peer_unref(peer);
					return -1;
				}
				res = authenticate(p->challenge, peer->secret,peer->outkey, authmethods, &ied, sin, &p->ecx, &p->dcx);
				peer_unref(peer);
			}
			if (!peer) {
				ast_mutex_lock(&iaxsl[callno]);
				if (!(p = iaxs[callno]))
					return -1;
			}
		}
	}
	if (ies->encmethods)
		ast_set_flag(p, IAX_ENCRYPTED | IAX_KEYPOPULATED);
	if (!res) {
		struct ast_datastore *variablestore;
		struct ast_variable *var, *prev = NULL;
		AST_LIST_HEAD(, ast_var_t) *varlist;
		varlist = ast_calloc(1, sizeof(*varlist));
		variablestore = ast_channel_datastore_alloc(&iax2_variable_datastore_info, NULL);
		if (variablestore && varlist && p->owner) {
			variablestore->data = varlist;
			variablestore->inheritance = DATASTORE_INHERIT_FOREVER;
			AST_LIST_HEAD_INIT(varlist);
			for (var = ies->vars; var; var = var->next) {
				struct ast_var_t *newvar = ast_var_assign(var->name, var->value);
				if (prev)
					ast_free(prev);
				prev = var;
				if (!newvar) {
					/* Don't abort list traversal, as this would leave ies->vars in an inconsistent state. */
					ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
				} else {
					AST_LIST_INSERT_TAIL(varlist, newvar, entries);
				}
			}
			if (prev)
				ast_free(prev);
			ies->vars = NULL;
			ast_channel_datastore_add(p->owner, variablestore);
		} else {
			if (p->owner)
				ast_log(LOG_ERROR, "Memory allocation error while processing IAX2 variables\n");
			if (variablestore)
				ast_channel_datastore_free(variablestore);
			if (varlist)
				ast_free(varlist);
		}
	}

	if (!res)
		res = send_command(p, AST_FRAME_IAX, IAX_COMMAND_AUTHREP, 0, ied.buf, ied.pos, -1);
	return res;
}
