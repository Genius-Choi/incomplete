bit_check_CRC (Bit_Chain *dat, long unsigned int start_address, uint16_t seed)
{
  uint16_t calculated;
  uint16_t read;
  long size;
  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;

  if (dat->bit > 0)
    {
      dat->byte++;
      dat->bit = 0;
    }

  if (start_address > dat->byte || dat->byte >= dat->size)
    {
      loglevel = dat->opts & DWG_OPTS_LOGLEVEL;
      LOG_ERROR ("%s buffer overflow at pos %lu-%lu, size %lu", __FUNCTION__,
                 start_address, dat->byte, dat->size)
      return 0;
    }

  size = dat->byte - start_address;
  calculated = bit_calc_CRC (seed, &dat->chain[start_address], size);
  read = bit_read_RS (dat);
  LOG_TRACE ("crc: %04X [RSx]\n", read);
  if (calculated == read)
    {
      LOG_HANDLE (" check_CRC %lu-%lu = %ld: %04X == %04X\n", start_address,
                  dat->byte - 2, size, calculated, read)
      return 1;
    }
  else
    {
      LOG_WARN ("check_CRC mismatch %lu-%lu = %ld: %04X <=> %04X\n",
                start_address, dat->byte - 2, size, calculated, read)
      return 0;
    }
}
