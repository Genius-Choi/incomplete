virtio_blk_init(struct vmctx *ctx, struct pci_vdev *dev, char *opts)
{
	bool dummy_bctxt;
	char bident[16];
	struct blockif_ctxt *bctxt;
	MD5_CTX mdctx;
	u_char digest[16];
	struct virtio_blk *blk;
	int i;
	pthread_mutexattr_t attr;
	int rc;

	bctxt = NULL;
	/* Assume the bctxt is valid, until identified otherwise */
	dummy_bctxt = false;

	if (opts == NULL) {
		pr_err("virtio_blk: backing device required\n");
		return -1;
	}

	/*
	 * The supplied backing file has to exist
	 */
	if (snprintf(bident, sizeof(bident), "%d:%d",
				dev->slot, dev->func) >= sizeof(bident)) {
		WPRINTF(("bident error, please check slot and func\n"));
	}

	/*
	 * If "nodisk" keyword is found in opts, this is not a valid backend
	 * file. Skip blockif_open and set dummy bctxt in virtio_blk struct
	 */
	if (strstr(opts, "nodisk") != NULL) {
		dummy_bctxt = true;
	} else {
		bctxt = blockif_open(opts, bident);
		if (bctxt == NULL) {
			pr_err("Could not open backing file");
			return -1;
		}
	}


	blk = calloc(1, sizeof(struct virtio_blk));
	if (!blk) {
		WPRINTF(("virtio_blk: calloc returns NULL\n"));
		return -1;
	}

	blk->bc = bctxt;
	/* Update virtio-blk device struct of dummy ctxt*/
	blk->dummy_bctxt = dummy_bctxt;

	for (i = 0; i < VIRTIO_BLK_RINGSZ; i++) {
		struct virtio_blk_ioreq *io = &blk->ios[i];

		io->req.callback = virtio_blk_done;
		io->req.param = io;
		io->blk = blk;
		io->idx = i;
	}

	/* init mutex attribute properly to avoid deadlock */
	rc = pthread_mutexattr_init(&attr);
	if (rc)
		DPRINTF(("mutexattr init failed with erro %d!\n", rc));
	rc = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
	if (rc)
		DPRINTF(("virtio_blk: mutexattr_settype failed with "
					"error %d!\n", rc));

	rc = pthread_mutex_init(&blk->mtx, &attr);
	if (rc)
		DPRINTF(("virtio_blk: pthread_mutex_init failed with "
					"error %d!\n", rc));

	/* init virtio struct and virtqueues */
	virtio_linkup(&blk->base, &virtio_blk_ops, blk, dev, &blk->vq, BACKEND_VBSU);
	blk->base.mtx = &blk->mtx;

	blk->vq.qsize = VIRTIO_BLK_RINGSZ;
	/* blk->vq.vq_notify = we have no per-queue notify */

	/*
	 * Create an identifier for the backing file. Use parts of the
	 * md5 sum of the filename
	 */
	MD5_Init(&mdctx);
	MD5_Update(&mdctx, opts, strnlen(opts, VIRTIO_BLK_MAX_OPTS_LEN));
	MD5_Final(digest, &mdctx);
	rc = snprintf(blk->ident, sizeof(blk->ident),
		"ACRN--%02X%02X-%02X%02X-%02X%02X", digest[0],
		digest[1], digest[2], digest[3], digest[4], digest[5]);
	if (rc >= sizeof(blk->ident) || rc < 0)
		WPRINTF(("virtio_blk: device name is invalid!\n"));

	/* Setup virtio block config space only for valid backend file*/
	if (!blk->dummy_bctxt)
		virtio_blk_update_config_space(blk);

	/*
	 * Should we move some of this into virtio.c?  Could
	 * have the device, class, and subdev_0 as fields in
	 * the virtio constants structure.
	 */
	pci_set_cfgdata16(dev, PCIR_DEVICE, VIRTIO_DEV_BLOCK);
	pci_set_cfgdata16(dev, PCIR_VENDOR, VIRTIO_VENDOR);
	pci_set_cfgdata8(dev, PCIR_CLASS, PCIC_STORAGE);
	pci_set_cfgdata16(dev, PCIR_SUBDEV_0, VIRTIO_TYPE_BLOCK);
	if (is_winvm == true)
		pci_set_cfgdata16(dev, PCIR_SUBVEND_0, ORACLE_VENDOR_ID);
	else
		pci_set_cfgdata16(dev, PCIR_SUBVEND_0, VIRTIO_VENDOR);

	if (virtio_interrupt_init(&blk->base, virtio_uses_msix())) {
		/* call close only for valid bctxt */
		if (!blk->dummy_bctxt)
			blockif_close(blk->bc);
		free(blk);
		return -1;
	}
	virtio_set_io_bar(&blk->base, 0);

	/*
	 * Register ops for virtio-blk Rescan
	 */
	if (register_vm_monitor_blkrescan == false) {

		register_vm_monitor_blkrescan = true;
		if (monitor_register_vm_ops(&virtio_blk_rescan_ops, ctx,
						"virtio_blk_rescan") < 0)
			pr_err("Rescan registration to VM monitor failed\n");
	}

	return 0;
}
