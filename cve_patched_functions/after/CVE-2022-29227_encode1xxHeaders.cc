void FilterManager::encode1xxHeaders(ActiveStreamEncoderFilter* filter,
                                     ResponseHeaderMap& headers) {
  filter_manager_callbacks_.resetIdleTimer();
  ASSERT(proxy_100_continue_);
  // The caller must guarantee that encode1xxHeaders() is invoked at most once.
  ASSERT(!state_.has_1xx_headers_ || filter != nullptr);
  // Make sure commonContinue continues encode1xxHeaders.
  state_.has_1xx_headers_ = true;

  // Similar to the block in encodeHeaders, run encode1xxHeaders on each
  // filter. This is simpler than that case because 100 continue implies no
  // end-stream, and because there are normal headers coming there's no need for
  // complex continuation logic.
  // 100-continue filter iteration should always start with the next filter if available.
  std::list<ActiveStreamEncoderFilterPtr>::iterator entry =
      commonEncodePrefix(filter, false, FilterIterationStartState::AlwaysStartFromNext);
  for (; entry != encoder_filters_.end(); entry++) {
    if ((*entry)->skipFilter()) {
      continue;
    }

    ASSERT(!(state_.filter_call_state_ & FilterCallState::Encode1xxHeaders));
    state_.filter_call_state_ |= FilterCallState::Encode1xxHeaders;
    FilterHeadersStatus status = (*entry)->handle_->encode1xxHeaders(headers);
    state_.filter_call_state_ &= ~FilterCallState::Encode1xxHeaders;
    ENVOY_STREAM_LOG(trace, "encode 1xx continue headers called: filter={} status={}", *this,
                     static_cast<const void*>((*entry).get()), static_cast<uint64_t>(status));
    if (!(*entry)->commonHandleAfter1xxHeadersCallback(status)) {
      return;
    }
  }

  filter_manager_callbacks_.encode1xxHeaders(headers);
}
