disasm_output_binary(unsigned char *data, int len)
{
    static int ignore_newline;
    static uint16_t er;

    byte plain;
    int i;

    /* in the ASCII portion of a binary section, just save this data */
    if (in_eexec < 0) {
	append_save(data, len);
	return;
    }

    /* eexec initialization */
    if (in_eexec == 0) {
	er = er_default;
	ignore_newline = 0;
	in_eexec = 0;
    }
    if (in_eexec < 4) {
	for (i = 0; i < len && in_eexec < 4; i++, in_eexec++) {
	    byte cipher = data[i];
	    plain = (byte)(cipher ^ (er >> 8));
	    er = (uint16_t)((cipher + er) * c1 + c2);
	    data[i] = plain;
	}
	data += i;
	len -= i;
    }

    /* now make lines: collect until '\n' or '\r' and pass them off to
       eexec_line. */
    i = 0;
    while (in_eexec > 0) {
	int start = i;

	for (; i < len; i++) {
	    byte cipher = data[i];
	    plain = (byte)(cipher ^ (er >> 8));
	    er = (uint16_t)((cipher + er) * c1 + c2);
	    data[i] = plain;
	    if (plain == '\r' || plain == '\n')
		break;
	}

	if (ignore_newline && start < i && data[start] == '\n') {
	    ignore_newline = 0;
	    continue;
	}

	if (i >= len) {
	    if (start < len)
		append_save(data + start, i - start);
	    break;
	}

	i++;
	ignore_newline = eexec_line(data + start, i - start);
    }

    /* if in_eexec < 0, we have some plaintext lines sitting around in a binary
       section of the PFB. save them for later */
    if (in_eexec < 0 && i < len)
	append_save(data + i, len - i);
}
