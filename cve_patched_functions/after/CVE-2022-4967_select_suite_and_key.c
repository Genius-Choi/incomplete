static bool select_suite_and_key(private_tls_server_t *this,
								 tls_cipher_suite_t *suites, int count)
{
	tls_version_t version_min, version_max;
	private_key_t *key;
	auth_cfg_t *auth;
	enumerator_t *enumerator;

	version_min = this->tls->get_version_min(this->tls);
	version_max = this->tls->get_version_max(this->tls);
	enumerator = tls_create_private_key_enumerator(version_min, version_max,
												   this->hashsig, this->server);
	if (!enumerator)
	{
		DBG1(DBG_TLS, "no common signature algorithms found");
		return FALSE;
	}
	if (!enumerator->enumerate(enumerator, &key, &auth))
	{
		DBG1(DBG_TLS, "no usable TLS server certificate found for '%Y'",
			 this->server);
		enumerator->destroy(enumerator);
		return FALSE;
	}

	if (version_max >= TLS_1_3)
	{
		this->suite = this->crypto->select_cipher_suite(this->crypto, suites,
												  		count, KEY_ANY);
	}
	else
	{
		this->suite = this->crypto->select_cipher_suite(this->crypto, suites,
														count, key->get_type(key));
		while (!this->suite &&
			   enumerator->enumerate(enumerator, &key, &auth))
		{	/* find a key and cipher suite for one of the remaining key types */
			this->suite = this->crypto->select_cipher_suite(this->crypto,
															suites, count,
															key->get_type(key));
		}
	}
	if (!this->suite)
	{
		DBG1(DBG_TLS, "received cipher suites or signature schemes unacceptable");
		enumerator->destroy(enumerator);
		return FALSE;
	}
	DBG1(DBG_TLS, "using key of type %N", key_type_names, key->get_type(key));
	DESTROY_IF(this->private);
	this->private = key->get_ref(key);
	this->server_auth->purge(this->server_auth, FALSE);
	this->server_auth->merge(this->server_auth, auth, FALSE);
	enumerator->destroy(enumerator);
	return TRUE;
}
