ahcp_print(netdissect_options *ndo,
           const u_char *cp, u_int len)
{
	uint8_t version;

	ndo->ndo_protocol = "ahcp";
	nd_print_protocol_caps(ndo);
	if (len < 2)
		goto invalid;
	/* Magic */
	if (GET_U_1(cp) != AHCP_MAGIC_NUMBER)
		goto invalid;
	cp += 1;
	len -= 1;
	/* Version */
	version = GET_U_1(cp);
	cp += 1;
	len -= 1;
	switch (version) {
		case AHCP_VERSION_1: {
			ND_PRINT(" Version 1");
			if (len < AHCP1_HEADER_FIX_LEN - 2)
				goto invalid;
			if (!ndo->ndo_vflag) {
				ND_TCHECK_LEN(cp, AHCP1_HEADER_FIX_LEN - 2);
				cp += AHCP1_HEADER_FIX_LEN - 2;
				len -= AHCP1_HEADER_FIX_LEN - 2;
			} else {
				/* Hopcount */
				ND_PRINT("\n\tHopcount %u", GET_U_1(cp));
				cp += 1;
				len -= 1;
				/* Original Hopcount */
				ND_PRINT(", Original Hopcount %u", GET_U_1(cp));
				cp += 1;
				len -= 1;
				/* Nonce */
				ND_PRINT(", Nonce 0x%08x", GET_BE_U_4(cp));
				cp += 4;
				len -= 4;
				/* Source Id */
				ND_PRINT(", Source Id %s", GET_LINKADDR_STRING(cp, LINKADDR_OTHER, 8));
				cp += 8;
				len -= 8;
				/* Destination Id */
				ND_PRINT(", Destination Id %s", GET_LINKADDR_STRING(cp, LINKADDR_OTHER, 8));
				cp += 8;
				len -= 8;
			}
			/* Body */
			ahcp1_body_print(ndo, cp, len);
			break;
		}
		default:
			ND_PRINT(" Version %u (unknown)", version);
			ND_TCHECK_LEN(cp, len);
			break;
	}
	return;

invalid:
	nd_print_invalid(ndo);
	ND_TCHECK_LEN(cp, len);
}
