ts_info_utf16_in(struct stream *s, int src_bytes, char *dst, int dst_len)
{
    int rv = 0;

    LOG_DEVEL(LOG_LEVEL_TRACE, "ts_info_utf16_in: uni_len %d, dst_len %d", src_bytes, dst_len);

    if (!s_check_rem_and_log(s, src_bytes + 2, "ts_info_utf16_in"))
    {
        rv = 1;
    }
    else
    {
        int term;
        int num_chars = in_utf16_le_fixed_as_utf8(s, src_bytes / 2,
                        dst, dst_len);
        if (num_chars > dst_len)
        {
            LOG(LOG_LEVEL_ERROR, "ts_info_utf16_in: output buffer overflow");
            rv = 1;
        }

        // String should be null-terminated. We haven't read the terminator yet
        in_uint16_le(s, term);
        if (term != 0)
        {
            LOG(LOG_LEVEL_ERROR,
                "ts_info_utf16_in: bad terminator. Expected 0, got %d", term);
            rv = 1;
        }
    }

    return rv;
}
