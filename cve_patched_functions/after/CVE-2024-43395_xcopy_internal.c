static void xcopy_internal(lua_State *from, lua_State *to, int n, int copies_slot) {
    for (int i = n - 1; i >= 0; i--) {
        size_t sz = 0;
        switch (lua_type(from, -1-i)) {
            case LUA_TNIL: case LUA_TNONE: lua_pushnil(to); break;
            case LUA_TBOOLEAN: lua_pushboolean(to, lua_toboolean(from, -1-i)); break;
            case LUA_TNUMBER: lua_pushnumber(to, lua_tonumber(from, -1-i)); break;
            case LUA_TSTRING: {
                const char * str = lua_tolstring(from, -1-i, &sz);
                lua_pushlstring(to, str, sz); break;
            } case LUA_TTABLE: {
                const void* ptr = lua_topointer(from, -1-i);
                lua_rawgeti(to, copies_slot, (ptrdiff_t)ptr);
                if (!lua_isnil(to, -1)) continue;
                lua_pop(to, 1);
                lua_newtable(to);
                lua_pushvalue(to, -1);
                lua_rawseti(to, copies_slot, (ptrdiff_t)ptr);
                lua_pushnil(from);
                while (lua_next(from, -2-i) != 0) {
                    xcopy_internal(from, to, 2, copies_slot);
                    lua_settable(to, -3);
                    lua_pop(from, 1);
                }
                break;
            }
            default: {
                if (luaL_callmeta(from, -1-i, "__tostring")) {
                    lua_pushlstring(to, lua_tostring(from, -1), lua_rawlen(from, -1));
                    lua_pop(from, 1);
                } else lua_pushfstring(to, "<%s: %p>", lua_typename(from, lua_type(from, -1-i)), lua_topointer(from, -1-i));
                break;
            }
        }
    }
}
