import_inbound_megolm_session(
  const mtx::events::DeviceEvent<mtx::events::msg::ForwardedRoomKey> &roomKey)
{
    MegolmSessionIndex index;
    index.room_id    = roomKey.content.room_id;
    index.session_id = roomKey.content.session_id;

    try {
        auto megolm_session =
          olm::client()->import_inbound_group_session(roomKey.content.session_key);

        GroupSessionData data{};
        data.forwarding_curve25519_key_chain = roomKey.content.forwarding_curve25519_key_chain;
        data.sender_claimed_ed25519_key      = roomKey.content.sender_claimed_ed25519_key;
        data.sender_key                      = roomKey.content.sender_key;
        // may have come from online key backup, so we can't trust it...
        data.trusted = false;
        // if we got it forwarded from the sender, assume it is trusted. They may still have
        // used key backup, but it is unlikely.
        if (roomKey.content.forwarding_curve25519_key_chain.size() == 1 &&
            roomKey.content.forwarding_curve25519_key_chain.back() == roomKey.content.sender_key) {
            data.trusted = true;
        }

        backup_session_key(index, data, megolm_session);
        cache::saveInboundMegolmSession(index, std::move(megolm_session), data);
    } catch (const lmdb::error &e) {
        nhlog::crypto()->critical("failed to save inbound megolm session: {}", e.what());
        return;
    } catch (const mtx::crypto::olm_exception &e) {
        nhlog::crypto()->critical("failed to import inbound megolm session: {}", e.what());
        return;
    }

    nhlog::crypto()->info(
      "established inbound megolm session ({}, {})", roomKey.content.room_id, roomKey.sender);

    ChatPage::instance()->receivedSessionKey(index.room_id, index.session_id);
}
