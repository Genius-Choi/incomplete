static int create_polydir(struct polydir_s *polyptr,
	struct instance_data *idata)
{
    mode_t mode;
    int rc;
#ifdef WITH_SELINUX
    char *dircon_raw, *oldcon_raw = NULL;
    struct selabel_handle *label_handle;
#endif
    const char *dir = polyptr->dir;
    uid_t uid;
    gid_t gid;

    if (polyptr->mode != (mode_t)ULONG_MAX)
            mode = polyptr->mode;
    else
            mode = 0777;

#ifdef WITH_SELINUX
    if (idata->flags & PAMNS_SELINUX_ENABLED) {
	getfscreatecon_raw(&oldcon_raw);

	label_handle = selabel_open(SELABEL_CTX_FILE, NULL, 0);
	if (!label_handle) {
	    pam_syslog(idata->pamh, LOG_NOTICE,
                       "Unable to initialize SELinux labeling handle: %m");
	} else {
	    rc = selabel_lookup_raw(label_handle, &dircon_raw, dir, S_IFDIR);
	    if (rc) {
		pam_syslog(idata->pamh, LOG_NOTICE,
                       "Unable to get default context for directory %s, check your policy: %m", dir);
	    } else {
		if (idata->flags & PAMNS_DEBUG)
		    pam_syslog(idata->pamh, LOG_DEBUG,
                               "Polydir %s context: %s", dir, dircon_raw);
		if (setfscreatecon_raw(dircon_raw) != 0)
		    pam_syslog(idata->pamh, LOG_NOTICE,
                               "Error setting context for directory %s: %m", dir);
		freecon(dircon_raw);
	    }
	    selabel_close(label_handle);
	}
    }
#endif

    rc = protect_dir(dir, mode, 1, idata);
    if (rc == -1) {
            pam_syslog(idata->pamh, LOG_ERR,
                       "Error creating directory %s: %m", dir);
            return PAM_SESSION_ERR;
    }

#ifdef WITH_SELINUX
    if (idata->flags & PAMNS_SELINUX_ENABLED) {
        if (setfscreatecon_raw(oldcon_raw) != 0)
		pam_syslog(idata->pamh, LOG_NOTICE,
                       "Error resetting fs create context: %m");
        freecon(oldcon_raw);
    }
#endif

    if (idata->flags & PAMNS_DEBUG)
            pam_syslog(idata->pamh, LOG_DEBUG, "Created polydir %s", dir);

    if (polyptr->mode != (mode_t)ULONG_MAX) {
	/* explicit mode requested */
	if (fchmod(rc, mode) != 0) {
		pam_syslog(idata->pamh, LOG_ERR,
			   "Error changing mode of directory %s: %m", dir);
                close(rc);
                umount(dir); /* undo the eventual protection bind mount */
		rmdir(dir);
		return PAM_SESSION_ERR;
	}
    }

    if (polyptr->owner != (uid_t)ULONG_MAX)
	uid = polyptr->owner;
    else
	uid = idata->uid;

    if (polyptr->group != (gid_t)ULONG_MAX)
	gid = polyptr->group;
    else
	gid = idata->gid;

    if (fchown(rc, uid, gid) != 0) {
        pam_syslog(idata->pamh, LOG_ERR,
                   "Unable to change owner on directory %s: %m", dir);
        close(rc);
        umount(dir); /* undo the eventual protection bind mount */
	rmdir(dir);
	return PAM_SESSION_ERR;
    }

    close(rc);

    if (idata->flags & PAMNS_DEBUG)
	pam_syslog(idata->pamh, LOG_DEBUG,
	           "Polydir owner %u group %u", uid, gid);

    return PAM_SUCCESS;
}
