static memcached_return_t binary_read_one_response(memcached_instance_st *instance, char *buffer,
                                                   const size_t buffer_length,
                                                   memcached_result_st *result) {
  memcached_return_t rc;
  protocol_binary_response_header header;

  assert(memcached_is_binary(instance->root));

  if ((rc = memcached_safe_read(instance, &header.bytes, sizeof(header.bytes)))
      != MEMCACHED_SUCCESS) {
    WATCHPOINT_ERROR(rc);
    return rc;
  }

  if (header.response.magic != PROTOCOL_BINARY_RES) {
    return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);
  }

  /*
   ** Convert the header to host local endian!
   */
  header.response.keylen = ntohs(header.response.keylen);
  header.response.status = ntohs(header.response.status);
  header.response.bodylen = ntohl(header.response.bodylen);
  header.response.cas = memcached_ntohll(header.response.cas);
  uint32_t bodylen = header.response.bodylen;

  if (header.response.status == PROTOCOL_BINARY_RESPONSE_SUCCESS
      or header.response.status == PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE)
  {
    switch (header.response.opcode) {
    case PROTOCOL_BINARY_CMD_GETKQ:
      /*
       * We didn't increment the response counter for the GETKQ packet
       * (only the final NOOP), so we need to increment the counter again.
       */
      memcached_server_response_increment(instance);
      /* fall through */
    case PROTOCOL_BINARY_CMD_GETK: {
      uint16_t keylen = header.response.keylen;
      memcached_result_reset(result);
      result->item_cas = header.response.cas;

      if ((rc = memcached_safe_read(instance, &result->item_flags, sizeof(result->item_flags)))
          != MEMCACHED_SUCCESS)
      {
        WATCHPOINT_ERROR(rc);
        return MEMCACHED_UNKNOWN_READ_FAILURE;
      }

      result->item_flags = ntohl(result->item_flags);
      bodylen -= header.response.extlen;

      result->key_length = keylen;
      if (memcached_failed(rc = memcached_safe_read(instance, result->item_key, keylen))) {
        WATCHPOINT_ERROR(rc);
        return MEMCACHED_UNKNOWN_READ_FAILURE;
      }

      // Only bother with doing this if key_length > 0
      if (result->key_length) {
        if (memcached_array_size(instance->root->_namespace)
            and memcached_array_size(instance->root->_namespace) >= result->key_length)
        {
          return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);
        }

        if (memcached_array_size(instance->root->_namespace)) {
          result->key_length -= memcached_array_size(instance->root->_namespace);
          memmove(result->item_key,
                  result->item_key + memcached_array_size(instance->root->_namespace),
                  result->key_length);
        }
      }

      bodylen -= keylen;
      if (memcached_failed(memcached_string_check(&result->value, bodylen))) {
        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;
      }

      char *vptr = memcached_string_value_mutable(&result->value);
      if (memcached_failed(rc = memcached_safe_read(instance, vptr, bodylen))) {
        WATCHPOINT_ERROR(rc);
        return MEMCACHED_UNKNOWN_READ_FAILURE;
      }

      memcached_string_set_length(&result->value, bodylen);
    } break;

    case PROTOCOL_BINARY_CMD_INCREMENT:
    case PROTOCOL_BINARY_CMD_DECREMENT: {
      if (bodylen != sizeof(uint64_t)) {
        result->numeric_value = UINT64_MAX;
        return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);
      }

      uint64_t val;
      if ((rc = memcached_safe_read(instance, &val, sizeof(val))) != MEMCACHED_SUCCESS) {
        result->numeric_value = UINT64_MAX;
        return MEMCACHED_UNKNOWN_READ_FAILURE;
      }

      result->numeric_value = memcached_ntohll(val);
    } break;

    case PROTOCOL_BINARY_CMD_SASL_LIST_MECHS: {
      if (header.response.keylen || bodylen + 1 > buffer_length) {
        return MEMCACHED_UNKNOWN_READ_FAILURE;
      } else {
        if ((rc = memcached_safe_read(instance, buffer, bodylen)) != MEMCACHED_SUCCESS) {
          return MEMCACHED_UNKNOWN_READ_FAILURE;
        }
      }
    } break;

    case PROTOCOL_BINARY_CMD_VERSION: {
      char version_buffer[32]; // @todo document this number
      memset(version_buffer, 0, sizeof(version_buffer));

      if (memcached_safe_read(instance, version_buffer, bodylen) != MEMCACHED_SUCCESS) {
        return MEMCACHED_UNKNOWN_READ_FAILURE;
      }

      char *endptr;
      errno = 0;
      long int version = strtol(version_buffer, &endptr, 10);
      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX
          or version == 0) {
        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;
        return memcached_set_error(
            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,
            memcached_literal_param("strtol() failed to parse major version"));
      }
      instance->major_version = uint8_t(version);

      endptr++;
      errno = 0;
      version = strtol(endptr, &endptr, 10);
      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {
        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;
        return memcached_set_error(
            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,
            memcached_literal_param("strtol() failed to parse minor version"));
      }
      instance->minor_version = uint8_t(version);

      endptr++;
      errno = 0;
      version = strtol(endptr, &endptr, 10);
      if (errno or version == LONG_MIN or version == LONG_MAX or version > UINT8_MAX) {
        instance->major_version = instance->minor_version = instance->micro_version = UINT8_MAX;
        return memcached_set_error(
            *instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT,
            memcached_literal_param("strtol() failed to parse micro version"));
      }
      instance->micro_version = uint8_t(version);
    } break;

    case PROTOCOL_BINARY_CMD_TOUCH: {
      rc = MEMCACHED_SUCCESS;
      if (bodylen == 4) // The four byte read is a bug?
      {
        char touch_buffer[4]; // @todo document this number
        rc = memcached_safe_read(instance, touch_buffer, sizeof(touch_buffer));
#if 0
          fprintf(stderr, "%s:%d %d %d %d %d %.*s(%d)\n", __FILE__, __LINE__,
                  int(touch_buffer[0]),
                  int(touch_buffer[1]),
                  int(touch_buffer[2]),
                  int(touch_buffer[3]),
                  int(bodylen), touch_buffer, int(bodylen));
#endif
      }
      return memcached_set_error(*instance, rc, MEMCACHED_AT);
    }

    case PROTOCOL_BINARY_CMD_FLUSH:
    case PROTOCOL_BINARY_CMD_QUIT:
    case PROTOCOL_BINARY_CMD_SET:
    case PROTOCOL_BINARY_CMD_ADD:
    case PROTOCOL_BINARY_CMD_REPLACE:
    case PROTOCOL_BINARY_CMD_APPEND:
    case PROTOCOL_BINARY_CMD_PREPEND:
    case PROTOCOL_BINARY_CMD_DELETE: {
      WATCHPOINT_ASSERT(bodylen == 0);
      return MEMCACHED_SUCCESS;
    }

    case PROTOCOL_BINARY_CMD_NOOP: {
      WATCHPOINT_ASSERT(bodylen == 0);
      return MEMCACHED_END;
    }

    case PROTOCOL_BINARY_CMD_STAT: {
      if (bodylen == 0) {
        return MEMCACHED_END;
      } else if (bodylen + 1 > buffer_length) {
        /* not enough space in buffer.. should not happen... */
        return MEMCACHED_UNKNOWN_READ_FAILURE;
      } else {
        size_t keylen = header.response.keylen;
        memset(buffer, 0, buffer_length);
        if ((rc = memcached_safe_read(instance, buffer, keylen)) != MEMCACHED_SUCCESS
            || (rc = memcached_safe_read(instance, buffer + keylen + 1, bodylen - keylen))
                != MEMCACHED_SUCCESS)
        {
          WATCHPOINT_ERROR(rc);
          return MEMCACHED_UNKNOWN_READ_FAILURE;
        }
      }
    } break;

    case PROTOCOL_BINARY_CMD_SASL_AUTH:
    case PROTOCOL_BINARY_CMD_SASL_STEP: {
      memcached_result_reset(result);
      result->item_cas = header.response.cas;

      if (memcached_string_check(&result->value, bodylen) != MEMCACHED_SUCCESS)
        return MEMCACHED_MEMORY_ALLOCATION_FAILURE;

      char *vptr = memcached_string_value_mutable(&result->value);
      if ((rc = memcached_safe_read(instance, vptr, bodylen)) != MEMCACHED_SUCCESS) {
        WATCHPOINT_ERROR(rc);
        return MEMCACHED_UNKNOWN_READ_FAILURE;
      }

      memcached_string_set_length(&result->value, bodylen);
    } break;
    default: {
      /* Command not implemented yet! */
      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);
    }
    }
  } else if (header.response.bodylen) {
    /* What should I do with the error message??? just discard it for now */
    char hole[SMALL_STRING_LEN];
    while (bodylen > 0) {
      size_t nr = (bodylen > SMALL_STRING_LEN) ? SMALL_STRING_LEN : bodylen;
      if ((rc = memcached_safe_read(instance, hole, nr)) != MEMCACHED_SUCCESS) {
        WATCHPOINT_ERROR(rc);
        return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);
      }
      bodylen -= (uint32_t) nr;
    }

    /* This might be an error from one of the quiet commands.. if
     * so, just throw it away and get the next one. What about creating
     * a callback to the user with the error information?
     */
    switch (header.response.opcode) {
    case PROTOCOL_BINARY_CMD_SETQ:
    case PROTOCOL_BINARY_CMD_ADDQ:
    case PROTOCOL_BINARY_CMD_REPLACEQ:
    case PROTOCOL_BINARY_CMD_APPENDQ:
    case PROTOCOL_BINARY_CMD_PREPENDQ:
      return MEMCACHED_FETCH_NOTFINISHED;

    default:
      break;
    }
  }

  rc = MEMCACHED_SUCCESS;
  if (header.response.status) {
    switch (header.response.status) {
    case PROTOCOL_BINARY_RESPONSE_KEY_ENOENT:
      rc = MEMCACHED_NOTFOUND;
      break;

    case PROTOCOL_BINARY_RESPONSE_KEY_EEXISTS:
      rc = MEMCACHED_DATA_EXISTS;
      break;

    case PROTOCOL_BINARY_RESPONSE_NOT_STORED:
      rc = MEMCACHED_NOTSTORED;
      break;

    case PROTOCOL_BINARY_RESPONSE_E2BIG:
      rc = MEMCACHED_E2BIG;
      break;

    case PROTOCOL_BINARY_RESPONSE_ENOMEM:
      rc = MEMCACHED_MEMORY_ALLOCATION_FAILURE;
      break;

    case PROTOCOL_BINARY_RESPONSE_AUTH_CONTINUE:
      rc = MEMCACHED_AUTH_CONTINUE;
      break;

    case PROTOCOL_BINARY_RESPONSE_AUTH_ERROR:
      rc = MEMCACHED_AUTH_FAILURE;
      break;

    case PROTOCOL_BINARY_RESPONSE_EINVAL:
    case PROTOCOL_BINARY_RESPONSE_UNKNOWN_COMMAND:
    default:
      return memcached_set_error(*instance, MEMCACHED_UNKNOWN_READ_FAILURE, MEMCACHED_AT);
      break;
    }
  }

  return rc;
}
