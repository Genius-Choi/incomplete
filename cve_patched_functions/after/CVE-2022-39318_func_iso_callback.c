static void LIBUSB_CALL func_iso_callback(struct libusb_transfer* transfer)
{
	ASYNC_TRANSFER_USER_DATA* user_data = (ASYNC_TRANSFER_USER_DATA*)transfer->user_data;
	const UINT32 streamID = stream_id_from_buffer(transfer);
	wArrayList* list = user_data->queue;

	ArrayList_Lock(list);
	switch (transfer->status)
	{
		case LIBUSB_TRANSFER_COMPLETED:
		{
			int i;
			UINT32 index = 0;
			BYTE* dataStart = Stream_Pointer(user_data->data);
			Stream_SetPosition(user_data->data,
			                   40); /* TS_URB_ISOCH_TRANSFER_RESULT IsoPacket offset */

			for (i = 0; i < transfer->num_iso_packets; i++)
			{
				const UINT32 act_len = transfer->iso_packet_desc[i].actual_length;
				Stream_Write_UINT32(user_data->data, index);
				Stream_Write_UINT32(user_data->data, act_len);
				Stream_Write_UINT32(user_data->data, transfer->iso_packet_desc[i].status);

				if (transfer->iso_packet_desc[i].status != USBD_STATUS_SUCCESS)
					user_data->ErrorCount++;
				else
				{
					const unsigned char* packetBuffer =
					    libusb_get_iso_packet_buffer_simple(transfer, i);
					BYTE* data = dataStart + index;

					if (data != packetBuffer)
						memmove(data, packetBuffer, act_len);

					index += act_len;
				}
			}
		}
			/* fallthrough */

		case LIBUSB_TRANSFER_CANCELLED:
		case LIBUSB_TRANSFER_TIMED_OUT:
		case LIBUSB_TRANSFER_ERROR:
		{
			const UINT32 InterfaceId =
			    ((STREAM_ID_PROXY << 30) | user_data->idev->get_ReqCompletion(user_data->idev));

			if (list_contains(list, streamID))
			{
				if (!user_data->noack)
				{
					const UINT32 RequestID = streamID & INTERFACE_ID_MASK;
					user_data->cb(user_data->idev, user_data->callback, user_data->data,
					              InterfaceId, user_data->noack, user_data->MessageId, RequestID,
					              transfer->num_iso_packets, transfer->status,
					              user_data->StartFrame, user_data->ErrorCount,
					              user_data->OutputBufferSize);
					user_data->data = NULL;
				}
				ArrayList_Remove(list, transfer);
			}
		}
		break;
		default:
			break;
	}
	ArrayList_Unlock(list);
}
