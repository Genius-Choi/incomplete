static int parse_frame_header(void *avctx, JXLParseContext *ctx, GetBitContext *gb)
{
    int all_default, do_yCbCr = 0, num_passes = 1, ret;
    int group_size_shift = 1, lf_level = 0, save_as_ref = 0;
    int have_crop = 0, full_frame = 1, resets_canvas = 1, upsampling = 1;
    JXLFrame *frame = &ctx->codestream.frame;
    const FFJXLMetadata *meta = &ctx->codestream.meta;
    int32_t x0 = 0, y0 = 0;
    uint32_t duration = 0, width = meta->coded_width, height = meta->coded_height;
    uint32_t name_len, num_groups, num_lf_groups, group_dim, lf_group_dim, toc_count;
    uint64_t flags = 0;
    int start_len = get_bits_count(gb);

    memset(frame, 0, sizeof(*frame));
    frame->is_last = 1;

    all_default = get_bits1(gb);
    if (!all_default) {
        frame->type = get_bits(gb, 2);
        frame->encoding = get_bits1(gb);
        flags = jxl_u64(gb);
        if (!meta->xyb_encoded)
            do_yCbCr = get_bits1(gb);
        if (!(flags & JXL_FLAG_USE_LF_FRAME)) {
            if (do_yCbCr)
                skip_bits(gb, 6); // jpeg upsampling
            upsampling = jxl_u32(gb, 1, 2, 4, 8, 0, 0, 0, 0);
            skip_bits_long(gb, 2 * meta->num_extra_channels);
            if (get_bits_left(gb) < 0)
                return AVERROR_BUFFER_TOO_SMALL;
        }
        if (frame->encoding == JPEGXL_ENC_MODULAR)
            group_size_shift = get_bits(gb, 2);
        else if (meta->xyb_encoded)
            skip_bits(gb, 6); // xqm and bqm scales
        if (frame->type != JPEGXL_FRAME_REFERENCE_ONLY) {
            num_passes = jxl_u32(gb, 1, 2, 3, 4, 0, 0, 0, 3);
            if (num_passes != 1) {
                int num_ds = jxl_u32(gb, 0, 1, 2, 3, 0, 0, 0, 1);
                skip_bits(gb, 2 * (num_passes - 1)); // shift
                skip_bits(gb, 2 * num_ds); // downsample
                for (int i = 0; i < num_ds; i++)
                    jxl_u32(gb, 0, 1, 2, 0, 0, 0, 0, 3);
            }
        }
        if (frame->type == JPEGXL_FRAME_LF)
            lf_level = 1 + get_bits(gb, 2);
        else
            have_crop = get_bits1(gb);
        if (have_crop) {
            if (frame->type != JPEGXL_FRAME_REFERENCE_ONLY) {
                uint32_t ux0 = jxl_u32(gb, 0, 256, 2304, 18688, 8, 11, 14, 30);
                uint32_t uy0 = jxl_u32(gb, 0, 256, 2304, 18688, 8, 11, 14, 30);
                x0 = unpack_signed(ux0);
                y0 = unpack_signed(uy0);
            }
            width = jxl_u32(gb, 0, 256, 2304, 18688, 8, 11, 14, 30);
            height = jxl_u32(gb, 0, 256, 2304, 18688, 8, 11, 14, 30);
            full_frame = x0 <= 0 && y0 <= 0 && width + x0 >= meta->coded_width
                                            && height + y0 >= meta->coded_height;
        }
        if (get_bits_left(gb) < 0)
            return AVERROR_BUFFER_TOO_SMALL;
        if (frame->type == JPEGXL_FRAME_REGULAR || frame->type == JPEGXL_FRAME_SKIP_PROGRESSIVE) {
            for (int i = 0; i <= meta->num_extra_channels; i++) {
                int mode = jxl_u32(gb, 0, 1, 2, 3, 0, 0, 0, 2);
                if (meta->num_extra_channels && (mode == JPEGXL_BM_BLEND || mode == JPEGXL_BM_MULADD))
                    jxl_u32(gb, 0, 1, 2, 3, 0, 0, 0, 2);
                if (meta->num_extra_channels && (mode == JPEGXL_BM_BLEND || mode == JPEGXL_BM_MULADD
                                              || mode == JPEGXL_BM_MUL))
                    skip_bits1(gb);
                if (!i)
                    resets_canvas = mode == JPEGXL_BM_REPLACE && full_frame;
                if (!resets_canvas)
                    skip_bits(gb, 2);
                if (get_bits_left(gb) < 0)
                    return AVERROR_BUFFER_TOO_SMALL;
            }
            if (meta->animation_offset)
                duration = jxl_u32(gb, 0, 1, 0, 0, 0, 0, 8, 32);
            if (meta->have_timecodes)
                skip_bits_long(gb, 32);
            frame->is_last = get_bits1(gb);
        } else {
            frame->is_last = 0;
        }
        if (frame->type != JPEGXL_FRAME_LF && !frame->is_last)
            save_as_ref = get_bits(gb, 2);
        if (frame->type == JPEGXL_FRAME_REFERENCE_ONLY ||
                (resets_canvas && !frame->is_last && (!duration || save_as_ref)
                && frame->type != JPEGXL_FRAME_LF))
            skip_bits1(gb); // save before color transform
        name_len = 8 * jxl_u32(gb, 0, 0, 16, 48, 0, 4, 5, 10);
        if (get_bits_left(gb) < name_len)
            return AVERROR_BUFFER_TOO_SMALL;
        skip_bits_long(gb, name_len);
    }

    if (!all_default) {
        int restd = get_bits1(gb), gab = 1;
        if (!restd)
            gab = get_bits1(gb);
        if (gab && !restd && get_bits1(gb))
            // gab custom
            skip_bits_long(gb, 16 * 6);
        if (get_bits_left(gb) < 0)
            return AVERROR_BUFFER_TOO_SMALL;
        if (!restd) {
            int epf = get_bits(gb, 2);
            if (epf) {
                if (frame->encoding == JPEGXL_ENC_VARDCT && get_bits1(gb)) {
                    skip_bits_long(gb, 16 * 8); // custom epf sharpness
                    if (get_bits_left(gb) < 0)
                        return AVERROR_BUFFER_TOO_SMALL;
                }
                if (get_bits1(gb)) {
                    skip_bits_long(gb, 3 * 16 + 32); // custom epf weight
                    if (get_bits_left(gb) < 0)
                        return AVERROR_BUFFER_TOO_SMALL;
                }
                if (get_bits1(gb)) { // custom epf sigma
                    if (frame->encoding == JPEGXL_ENC_VARDCT)
                        skip_bits(gb, 16);
                    skip_bits_long(gb, 16 * 3);
                    if (get_bits_left(gb) < 0)
                        return AVERROR_BUFFER_TOO_SMALL;
                }
                if (frame->encoding == JPEGXL_ENC_MODULAR)
                    skip_bits(gb, 16);
            }
            ret = skip_extensions(gb);
            if (ret < 0)
                return ret;
        }
        ret = skip_extensions(gb);
        if (ret < 0)
            return ret;
    }

    width = div_ceil(div_ceil(width, upsampling), 1 << (3 * lf_level));
    height = div_ceil(div_ceil(height, upsampling), 1 << (3 * lf_level));
    group_dim = 128 << group_size_shift;
    lf_group_dim = group_dim << 3;
    num_groups = div_ceil(width, group_dim) * div_ceil(height, group_dim);
    num_lf_groups = div_ceil(width, lf_group_dim) * div_ceil(height, lf_group_dim);
    if (num_groups == 1 && num_passes == 1)
        toc_count = 1;
    else
        toc_count = 2 + num_lf_groups + num_groups * num_passes;

    // permuted toc
    if (get_bits1(gb)) {
        JXLEntropyDecoder dec;
        uint32_t end, lehmer = 0;
        ret = entropy_decoder_init(avctx, gb, &dec, 8);
        if (ret < 0)
            return ret;
        if (get_bits_left(gb) < 0) {
            entropy_decoder_close(&dec);
            return AVERROR_BUFFER_TOO_SMALL;
        }
        end = entropy_decoder_read_symbol(gb, &dec, toc_context(toc_count));
        if (end > toc_count) {
            entropy_decoder_close(&dec);
            return AVERROR_INVALIDDATA;
        }
        for (uint32_t i = 0; i < end; i++) {
            lehmer = entropy_decoder_read_symbol(gb, &dec, toc_context(lehmer));
            if (get_bits_left(gb) < 0) {
                entropy_decoder_close(&dec);
                return AVERROR_BUFFER_TOO_SMALL;
            }
        }
        entropy_decoder_close(&dec);
    }
    align_get_bits(gb);

    for (uint32_t i = 0; i < toc_count; i++) {
        frame->body_length += 8 * jxl_u32(gb, 0, 1024, 17408, 4211712, 10, 14, 22, 30);
        if (get_bits_left(gb) < 0)
            return AVERROR_BUFFER_TOO_SMALL;
    }
    align_get_bits(gb);

    frame->total_length = frame->body_length + get_bits_count(gb) - start_len;

    return 0;
}
