GF_Err mp4_mux_process(GF_Filter *filter)
{
	GF_MP4MuxCtx *ctx = gf_filter_get_udta(filter);
	u32 nb_skip, nb_eos, nb_suspended, i, count = gf_list_count(ctx->tracks);
	nb_skip = 0;
	nb_eos = 0;

	if (ctx->config_timing) {
		mp4_mux_config_timing(ctx);
		if (ctx->config_timing) {
			mp4_mux_format_report(ctx, 0, 0);
			return GF_OK;
		}
	}

	//fragmented mode
	if (ctx->store>=MP4MX_MODE_FRAG) {
		u32 done=0;
		//postpone until no pending connections, otherwise we will create init segment without all tracks
		if (gf_filter_connections_pending(filter))
			return GF_OK;

		if (ctx->seg_flush_state==1) return GF_OK;
		else if (ctx->seg_flush_state==2)
			mp4_mux_flush_seg_events(ctx);

		GF_Err e = mp4_mux_process_fragmented(ctx);
		if (e==GF_EOS) done=100;
		mp4_mux_format_report(ctx, done, done);
		return e;
	}

	//regular mode
	nb_suspended = 0;
	for (i=0; i<count; i++) {
		GF_Err e;
		TrackWriter *tkw = gf_list_get(ctx->tracks, i);
		GF_FilterPacket *pck = gf_filter_pid_get_packet(tkw->ipid);

		if (tkw->suspended) {
			nb_suspended++;
			continue;
		}

		if (!pck) {
			if (gf_filter_pid_is_eos(tkw->ipid) && !gf_filter_pid_is_flush_eos(tkw->ipid)) {
				tkw->suspended = GF_FALSE;
				nb_eos++;
			}
			if (tkw->aborted) {
				nb_eos++;
			}
			if (ctx->store==MP4MX_MODE_FASTSTART) {
				nb_skip++;
			}
			continue;
		}

		if (tkw->aborted) {
			gf_filter_pid_drop_packet(tkw->ipid);
			nb_eos++;
			continue;
		}

		if (ctx->owns_mov) {
			const GF_PropertyValue *p;
			p = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILENUM);
			if (p) {
				mp4mux_check_mpd_start_time(ctx, pck);
				if (!ctx->cur_file_idx_plus_one) {
					ctx->cur_file_idx_plus_one = p->value.uint + 1;
					if (!ctx->cur_file_suffix) {
						p = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);
						if (p && p->value.string) ctx->cur_file_suffix = gf_strdup(p->value.string);
					}
					ctx->notify_filename = GF_TRUE;
				} else if (ctx->cur_file_idx_plus_one == p->value.uint+1) {
				} else if (!tkw->suspended) {
					tkw->suspended = GF_TRUE;
					nb_suspended++;
					ctx->next_file_idx =  p->value.uint + 1;
					p = gf_filter_pck_get_property(pck, GF_PROP_PCK_FILESUF);
					if (p && p->value.string)
						ctx->next_file_suffix = p->value.string;
					continue;
				}
			}
		}

		//basic regulation in case we do on-the-fly interleaving
		//we need to regulate because sources do not produce packets at the same rate
		if (ctx->store==MP4MX_MODE_FASTSTART) {
			u64 cts = gf_filter_pck_get_cts(pck);
			if (ctx->is_rewind)
				cts = tkw->ts_shift - cts;
			else
				cts -= tkw->ts_shift;

			if (!ctx->faststart_ts_regulate.num) {
				ctx->faststart_ts_regulate = ctx->cdur;
			}
			//ahead of our interleaving window, don't write yet
			else if (gf_timestamp_greater(cts, tkw->src_timescale, ctx->faststart_ts_regulate.num, ctx->faststart_ts_regulate.den)) {
				nb_skip++;
				continue;
			}
		}

		if (tkw->cenc_state==CENC_NEED_SETUP)
			mp4_mux_cenc_update(ctx, tkw, pck, CENC_CONFIG, 0, 0);

		if (tkw->is_item) {
			e = mp4_mux_process_item(ctx, tkw, pck);
		} else {
			e = mp4_mux_process_sample(ctx, tkw, pck, GF_FALSE);
		}

		gf_filter_pid_drop_packet(tkw->ipid);
		if (tkw->aborted) {
			nb_eos++;
		}
		if (e) return e;
	}
	mp4_mux_format_report(ctx, 0, 0);

	if (nb_suspended && (nb_suspended+nb_eos==count)) {
		return mp4mx_reload_output(ctx);
	}

	if (count == nb_eos) {
		if (ctx->file) {
			GF_Err e = mp4_mux_done(ctx, GF_TRUE);
			if (e) return e;
		}
		return GF_EOS;
	}
	//done with this interleaving window, start next one
	else if (nb_skip + nb_eos >= count) {
		ctx->faststart_ts_regulate.num += ctx->cdur.num;
	} else if (ctx->importer) {
		u64 prog_done=0, prog_total=0;
		for (i=0; i<count; i++) {
			TrackWriter *tkw = gf_list_get(ctx->tracks, i);
			prog_done += tkw->prog_done;
			prog_total += tkw->prog_total;
		}
		gf_set_progress("Import", prog_done, prog_total);
	}

	return GF_OK;
}
