static ssize_t _hostsock_recvfrom(
    oe_fd_t* sock_,
    void* buf,
    size_t count,
    int flags,
    struct oe_sockaddr* src_addr,
    oe_socklen_t* addrlen)
{
    ssize_t ret = -1;
    sock_t* sock = _cast_sock(sock_);
    oe_socklen_t addrlen_in = 0;
    oe_socklen_t addrlen_out = 0;

    oe_errno = 0;

    /*
     * According to the POSIX specification, when the count is greater
     * than SSIZE_MAX, the result is implementation-defined. OE raises an
     * error in this case.
     * Refer to
     * https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html
     * for more detail.
     */
    if (!sock || (count && !buf) || count > OE_SSIZE_MAX)
        OE_RAISE_ERRNO(OE_EINVAL);

    /*
     * Update the addrlen_in to the value pointed by addrlen
     * only if both src_addr and addrlen are not NULL.
     */
    if (src_addr && addrlen)
        addrlen_in = *addrlen;

    if (oe_syscall_recvfrom_ocall(
            &ret,
            sock->host_fd,
            buf,
            count,
            flags,
            src_addr,
            addrlen_in,
            &addrlen_out) != OE_OK)
    {
        OE_RAISE_ERRNO(OE_EINVAL);
    }

    /*
     * Update the value pointed by addrlen based on the host-set
     * addrlen_out only if both src_addr and addrlen are not NULL.
     */
    if (src_addr && addrlen)
    {
        /*
         * Error out the case if the addrlen_out is greater than the size
         * of sockaddr_storage.
         */
        if (addrlen_out > sizeof(struct oe_sockaddr_storage))
            OE_RAISE_ERRNO(OE_EINVAL);

        /*
         * Note that the returned value can still exceed the supplied one,
         * which indicates a truncation.
         */
        *addrlen = addrlen_out;
    }

    /*
     * Guard the special case that a host sets an arbitrarily large value.
     * The return value should not exceed count.
     */
    if (ret > (ssize_t)count)
    {
        ret = -1;
        OE_RAISE_ERRNO(OE_EINVAL);
    }

done:
    return ret;
}
