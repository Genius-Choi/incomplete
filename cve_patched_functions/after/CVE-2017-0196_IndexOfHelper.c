    Var JavascriptArray::IndexOfHelper(Arguments const & args, ScriptContext *scriptContext)
    {
        RecyclableObject* obj = nullptr;
        JavascriptArray* pArr = nullptr;
        BigIndex length;
        Var trueValue = scriptContext->GetLibrary()->GetTrue();
        Var falseValue = scriptContext->GetLibrary()->GetFalse();

        if (JavascriptArray::Is(args[0]))
        {
#if ENABLE_COPYONACCESS_ARRAY
            JavascriptLibrary::CheckAndConvertCopyOnAccessNativeIntArray<Var>(args[0]);
#endif
            pArr = JavascriptArray::FromVar(args[0]);
            obj = pArr;
        }
        else
        {
            if (!JavascriptConversion::ToObject(args[0], scriptContext, &obj))
            {
                JavascriptError::ThrowTypeError(scriptContext, JSERR_This_NullOrUndefined, _u("Array.prototype.indexOf"));
            }
        }

        if (scriptContext->GetConfig()->IsES6ToLengthEnabled())
        {
            length = (uint64)JavascriptConversion::ToLength(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);
        }
        else
        {
            length = JavascriptConversion::ToUInt32(JavascriptOperators::OP_GetLength(obj, scriptContext), scriptContext);
        }

        if (pArr)
        {
            Var search;
            uint32 fromIndex;
            uint32 len = length.IsUint32Max() ? MaxArrayLength : length.GetSmallIndex();
            if (!GetParamForIndexOf(len, args, search, fromIndex, scriptContext))
            {
                return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);
            }
            int32 index = pArr->HeadSegmentIndexOfHelper(search, fromIndex, len, includesAlgorithm, scriptContext);

            // If we found the search value in the head segment, or if we determined there is no need to search other segments,
            // we stop right here.
            if (index != -1 || fromIndex == -1)
            {
                if (includesAlgorithm)
                {
                    //Array.prototype.includes
                    return (index == -1)? falseValue : trueValue;
                }
                else
                {
                    //Array.prototype.indexOf
                    return JavascriptNumber::ToVar(index, scriptContext);
                }
            }

            //  If we really must search other segments, let's do it now. We'll have to search the slow way (dealing with holes, etc.).

            switch (pArr->GetTypeId())
            {
            case Js::TypeIds_Array:
                return TemplatedIndexOfHelper<includesAlgorithm>(pArr, search, fromIndex, len, scriptContext);
            case Js::TypeIds_NativeIntArray:
                return TemplatedIndexOfHelper<includesAlgorithm>(JavascriptNativeIntArray::FromVar(pArr), search, fromIndex, len, scriptContext);
            case Js::TypeIds_NativeFloatArray:
                return TemplatedIndexOfHelper<includesAlgorithm>(JavascriptNativeFloatArray::FromVar(pArr), search, fromIndex, len, scriptContext);
            default:
                AssertMsg(FALSE, "invalid array typeid");
                return TemplatedIndexOfHelper<includesAlgorithm>(pArr, search, fromIndex, len, scriptContext);
            }
        }

        // source object is not a JavascriptArray but source could be a TypedArray
        if (TypedArrayBase::Is(obj))
        {
            if (length.IsSmallIndex() || length.IsUint32Max())
            {
                Var search;
                uint32 fromIndex;
                uint32 len = length.IsUint32Max() ? MaxArrayLength : length.GetSmallIndex();
                if (!GetParamForIndexOf(len, args, search, fromIndex, scriptContext))
                {
                    return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);
                }
                return TemplatedIndexOfHelper<includesAlgorithm>(TypedArrayBase::FromVar(obj), search, fromIndex, length.GetSmallIndex(), scriptContext);
            }
        }
        if (length.IsSmallIndex())
        {
            Var search;
            uint32 fromIndex;
            if (!GetParamForIndexOf(length.GetSmallIndex(), args, search, fromIndex, scriptContext))
            {
                return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);
            }
            return TemplatedIndexOfHelper<includesAlgorithm>(obj, search, fromIndex, length.GetSmallIndex(), scriptContext);
        }
        else
        {
            Var search;
            uint64 fromIndex;
            if (!GetParamForIndexOf(length.GetBigIndex(), args, search, fromIndex, scriptContext))
            {
                return includesAlgorithm ? falseValue : TaggedInt::ToVarUnchecked(-1);
            }
            return TemplatedIndexOfHelper<includesAlgorithm>(obj, search, fromIndex, length.GetBigIndex(), scriptContext);
        }
    }
