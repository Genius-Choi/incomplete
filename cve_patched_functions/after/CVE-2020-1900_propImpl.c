tv_lval ObjectData::propImpl(TypedValue* tvRef, const Class* ctx,
                             const StringData* key) {
  auto constexpr write = (mode == PropMode::DimForWrite);
  auto constexpr read = (mode == PropMode::ReadNoWarn) ||
                        (mode == PropMode::ReadWarn);
  auto const lookup = getPropImpl<write, read, false>(ctx, key);
  auto const prop = lookup.val;

  if (prop) {
    if (lookup.accessible) {
      auto const checkConstProp = [&]() {
        if (mode == PropMode::DimForWrite) {
          if (UNLIKELY(lookup.isConst) && !isBeingConstructed()) {
            throwMutateConstProp(lookup.slot);
          }
        }
        return prop;
      };

      // Property exists, is accessible, and is not unset.
      if (type(prop) != KindOfUninit) return checkConstProp();

      if (mode == PropMode::ReadWarn) raiseUndefProp(key);
      if (write) return checkConstProp();
      return const_cast<TypedValue*>(&immutable_null_base);
    }

    // Property exists, but it is either protected or private since accessible
    // is false.
    auto const propSlot = m_cls->lookupDeclProp(key);
    auto const attrs = m_cls->declProperties()[propSlot].attrs;
    auto const priv = (attrs & AttrPrivate) ? "private" : "protected";

    raise_error(
      "Cannot access %s property %s::$%s",
      priv,
      m_cls->preClass()->name()->data(),
      key->data()
    );
  }

  // First see if native getter is implemented.
  if (m_cls->rtAttribute(Class::HasNativePropHandler)) {
    if (auto r = invokeNativeGetProp(key)) {
      tvCopy(r.val, *tvRef);
      return tvRef;
    }
  }

  if (UNLIKELY(!*key->data())) {
    throw_invalid_property_name(StrNR(key));
  }

  if (mode == PropMode::ReadWarn) raiseUndefProp(key);
  if (write) return makeDynProp(key);
  return const_cast<TypedValue*>(&immutable_null_base);
}
