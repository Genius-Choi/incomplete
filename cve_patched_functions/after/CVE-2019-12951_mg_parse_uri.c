int mg_parse_uri(const struct mg_str uri, struct mg_str *scheme,
                 struct mg_str *user_info, struct mg_str *host,
                 unsigned int *port, struct mg_str *path, struct mg_str *query,
                 struct mg_str *fragment) {
  struct mg_str rscheme = {0, 0}, ruser_info = {0, 0}, rhost = {0, 0},
                rpath = {0, 0}, rquery = {0, 0}, rfragment = {0, 0};
  unsigned int rport = 0;
  enum {
    P_START,
    P_SCHEME_OR_PORT,
    P_USER_INFO,
    P_HOST,
    P_PORT,
    P_REST
  } state = P_START;

  const char *p = uri.p, *end = p + uri.len;
  while (p < end) {
    switch (state) {
      case P_START:
        /*
         * expecting on of:
         * - `scheme://xxxx`
         * - `xxxx:port`
         * - `[a:b:c]:port`
         * - `xxxx/path`
         */
        if (*p == '[') {
          state = P_HOST;
          break;
        }
        for (; p < end; p++) {
          if (*p == ':') {
            state = P_SCHEME_OR_PORT;
            break;
          } else if (*p == '/') {
            state = P_REST;
            break;
          }
        }
        if (state == P_START || state == P_REST) {
          rhost.p = uri.p;
          rhost.len = p - uri.p;
        }
        break;
      case P_SCHEME_OR_PORT:
        if (end - p >= 3 && strncmp(p, "://", 3) == 0) {
          rscheme.p = uri.p;
          rscheme.len = p - uri.p;
          state = P_USER_INFO;
          p += 3;
        } else {
          rhost.p = uri.p;
          rhost.len = p - uri.p;
          state = P_PORT;
        }
        break;
      case P_USER_INFO:
        ruser_info.p = p;
        for (; p < end; p++) {
          if (*p == '@' || *p == '[' || *p == '/') {
            break;
          }
        }
        if (p == end || *p == '/' || *p == '[') {
          /* backtrack and parse as host */
          p = ruser_info.p;
        }
        ruser_info.len = p - ruser_info.p;
        state = P_HOST;
        break;
      case P_HOST:
        if (*p == '@') p++;
        rhost.p = p;
        if (*p == '[') {
          int found = 0;
          for (; !found && p < end; p++) {
            found = (*p == ']');
          }
          if (!found) return -1;
        } else {
          for (; p < end; p++) {
            if (*p == ':' || *p == '/') break;
          }
        }
        rhost.len = p - rhost.p;
        if (p < end) {
          if (*p == ':') {
            state = P_PORT;
            break;
          } else if (*p == '/') {
            state = P_REST;
            break;
          }
        }
        break;
      case P_PORT:
        p++;
        for (; p < end; p++) {
          if (*p == '/') {
            state = P_REST;
            break;
          }
          rport *= 10;
          rport += *p - '0';
        }
        break;
      case P_REST:
        /* `p` points to separator. `path` includes the separator */
        parse_uri_component(&p, end, "?#", &rpath);
        if (p < end && *(p - 1) == '?') {
          parse_uri_component(&p, end, "#", &rquery);
        }
        parse_uri_component(&p, end, "", &rfragment);
        break;
    }
  }

  if (scheme != 0) *scheme = rscheme;
  if (user_info != 0) *user_info = ruser_info;
  if (host != 0) *host = rhost;
  if (port != 0) *port = rport;
  if (path != 0) *path = rpath;
  if (query != 0) *query = rquery;
  if (fragment != 0) *fragment = rfragment;

  return 0;
}
