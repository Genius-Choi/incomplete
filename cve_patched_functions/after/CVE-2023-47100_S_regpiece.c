S_regpiece(pTHX_ RExC_state_t *pRExC_state, I32 *flagp, U32 depth)
{
    regnode_offset ret;
    char op;
    I32 flags;
    const char * const origparse = RExC_parse;
    I32 min;
    I32 max = REG_INFTY;
#ifdef RE_TRACK_PATTERN_OFFSETS
    char *parse_start;
#endif

    /* Save the original in case we change the emitted regop to a FAIL. */
    const regnode_offset orig_emit = RExC_emit;

    DECLARE_AND_GET_RE_DEBUG_FLAGS;

    PERL_ARGS_ASSERT_REGPIECE;

    DEBUG_PARSE("piec");

    ret = regatom(pRExC_state, &flags, depth+1);
    if (ret == 0) {
        RETURN_FAIL_ON_RESTART_OR_FLAGS(flags, flagp, TRYAGAIN);
        FAIL2("panic: regatom returned failure, flags=%#" UVxf, (UV) flags);
    }

#ifdef RE_TRACK_PATTERN_OFFSETS
    parse_start = RExC_parse;
#endif

    op = *RExC_parse;
    switch (op) {
        const char * regcurly_return[5];

      case '*':
        nextchar(pRExC_state);
        min = 0;
        break;

      case '+':
        nextchar(pRExC_state);
        min = 1;
        break;

      case '?':
        nextchar(pRExC_state);
        min = 0; max = 1;
        break;

      case '{':  /* A '{' may or may not indicate a quantifier; call regcurly()
                    to determine which */
        if (regcurly(RExC_parse, RExC_end, regcurly_return)) {
            const char * min_start = regcurly_return[MIN_S];
            const char * min_end   = regcurly_return[MIN_E];
            const char * max_start = regcurly_return[MAX_S];
            const char * max_end   = regcurly_return[MAX_E];

            if (min_start) {
                min = get_quantifier_value(pRExC_state, min_start, min_end);
            }
            else {
                min = 0;
            }

            if (max_start == max_end) {     /* Was of the form {m,} */
                max = REG_INFTY;
            }
            else if (max_start == min_start) {  /* Was of the form {m} */
                max = min;
            }
            else {  /* Was of the form {m,n} */
                assert(max_end >= max_start);

                max = get_quantifier_value(pRExC_state, max_start, max_end);
            }

            RExC_parse = (char *) regcurly_return[RBRACE];
            nextchar(pRExC_state);

            if (max < min) {    /* If can't match, warn and optimize to fail
                                   unconditionally */
                reginsert(pRExC_state, OPFAIL, orig_emit, depth+1);
                ckWARNreg(RExC_parse, "Quantifier {n,m} with n > m can't match");
                NEXT_OFF(REGNODE_p(orig_emit)) =
                                    regarglen[OPFAIL] + NODE_STEP_REGNODE;
                return ret;
            }
            else if (min == max && *RExC_parse == '?') {
                ckWARN2reg(RExC_parse + 1,
                           "Useless use of greediness modifier '%c'",
                           *RExC_parse);
            }

            break;
        } /* End of is {m,n} */

        /* Here was a '{', but what followed it didn't form a quantifier. */
        /* FALLTHROUGH */

      default:
        *flagp = flags;
        return(ret);
        NOT_REACHED; /*NOTREACHED*/
    }

    /* Here we have a quantifier, and have calculated 'min' and 'max'.
     *
     * Check and possibly adjust a zero width operand */
    if (! (flags & (HASWIDTH|POSTPONED))) {
        if (max > REG_INFTY/3) {
            if (origparse[0] == '\\' && origparse[1] == 'K') {
                vFAIL2utf8f(
                           "%" UTF8f " is forbidden - matches null string"
                           " many times",
                           UTF8fARG(UTF, (RExC_parse >= origparse
                                         ? RExC_parse - origparse
                                         : 0),
                           origparse));
            } else {
                ckWARN2reg(RExC_parse,
                           "%" UTF8f " matches null string many times",
                           UTF8fARG(UTF, (RExC_parse >= origparse
                                         ? RExC_parse - origparse
                                         : 0),
                           origparse));
            }
        }

        /* There's no point in trying to match something 0 length more than
         * once except for extra side effects, which we don't have here since
         * not POSTPONED */
        if (max > 1) {
            max = 1;
            if (min > max) {
                min = max;
            }
        }
    }

    /* If this is a code block pass it up */
    *flagp |= (flags & POSTPONED);

    if (max > 0) {
        *flagp |= (flags & HASWIDTH);
        if (max == REG_INFTY)
            RExC_seen |= REG_UNBOUNDED_QUANTIFIER_SEEN;
    }

    /* 'SIMPLE' operands don't require full generality */
    if ((flags&SIMPLE)) {
        if (max == REG_INFTY) {
            if (min == 0) {
                if (UNLIKELY(RExC_pm_flags & PMf_WILDCARD)) {
                    goto min0_maxINF_wildcard_forbidden;
                }

                reginsert(pRExC_state, STAR, ret, depth+1);
                MARK_NAUGHTY(4);
                goto done_main_op;
            }
            else if (min == 1) {
                reginsert(pRExC_state, PLUS, ret, depth+1);
                MARK_NAUGHTY(3);
                goto done_main_op;
            }
        }

        /* Here, SIMPLE, but not the '*' and '+' special cases */

        MARK_NAUGHTY_EXP(2, 2);
        reginsert(pRExC_state, CURLY, ret, depth+1);
        Set_Node_Offset(REGNODE_p(ret), parse_start+1); /* MJD */
        Set_Node_Cur_Length(REGNODE_p(ret), parse_start);
    }
    else {  /* not SIMPLE */
        const regnode_offset w = reg_node(pRExC_state, WHILEM);

        FLAGS(REGNODE_p(w)) = 0;
        if (!  REGTAIL(pRExC_state, ret, w)) {
            REQUIRE_BRANCHJ(flagp, 0);
        }
        if (RExC_use_BRANCHJ) {
            reginsert(pRExC_state, LONGJMP, ret, depth+1);
            reginsert(pRExC_state, NOTHING, ret, depth+1);
            NEXT_OFF(REGNODE_p(ret)) = 3;        /* Go over LONGJMP. */
        }
        reginsert(pRExC_state, CURLYX, ret, depth+1);
                        /* MJD hk */
        Set_Node_Offset(REGNODE_p(ret), parse_start+1);
        Set_Node_Length(REGNODE_p(ret),
                        op == '{' ? (RExC_parse - parse_start) : 1);

        if (RExC_use_BRANCHJ)
            NEXT_OFF(REGNODE_p(ret)) = 3;   /* Go over NOTHING to
                                               LONGJMP. */
        if (! REGTAIL(pRExC_state, ret, reg_node(pRExC_state,
                                                  NOTHING)))
        {
            REQUIRE_BRANCHJ(flagp, 0);
        }
        RExC_whilem_seen++;
        MARK_NAUGHTY_EXP(1, 4);     /* compound interest */
    }

    /* Finish up the CURLY/CURLYX case */
    FLAGS(REGNODE_p(ret)) = 0;

    ARG1_SET(REGNODE_p(ret), (U16)min);
    ARG2_SET(REGNODE_p(ret), (U16)max);

  done_main_op:

    /* Process any greediness modifiers */
    if (*RExC_parse == '?') {
        nextchar(pRExC_state);
        reginsert(pRExC_state, MINMOD, ret, depth+1);
        if (! REGTAIL(pRExC_state, ret, ret + NODE_STEP_REGNODE)) {
            REQUIRE_BRANCHJ(flagp, 0);
        }
    }
    else if (*RExC_parse == '+') {
        regnode_offset ender;
        nextchar(pRExC_state);
        ender = reg_node(pRExC_state, SUCCEED);
        if (! REGTAIL(pRExC_state, ret, ender)) {
            REQUIRE_BRANCHJ(flagp, 0);
        }
        reginsert(pRExC_state, SUSPEND, ret, depth+1);
        ender = reg_node(pRExC_state, TAIL);
        if (! REGTAIL(pRExC_state, ret, ender)) {
            REQUIRE_BRANCHJ(flagp, 0);
        }
    }

    /* Forbid extra quantifiers */
    if (isQUANTIFIER(RExC_parse, RExC_end)) {
        RExC_parse++;
        vFAIL("Nested quantifiers");
    }

    return(ret);

  min0_maxINF_wildcard_forbidden:

    /* Here we are in a wildcard match, and the minimum match length is 0, and
     * the max could be infinity.  This is currently forbidden.  The only
     * reason is to make it harder to write patterns that take a long long time
     * to halt, and because the use of this construct isn't necessary in
     * matching Unicode property values */
    RExC_parse++;
    /* diag_listed_as: Use of %s is not allowed in Unicode property wildcard
       subpatterns in regex; marked by <-- HERE in m/%s/
     */
    vFAIL("Use of quantifier '*' is not allowed in Unicode property wildcard"
          " subpatterns");

    /* Note, don't need to worry about the input being '{0,}', as a '}' isn't
     * legal at all in wildcards, so can't get this far */

    NOT_REACHED; /*NOTREACHED*/
}
