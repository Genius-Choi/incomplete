bool LightProcess::initShadow(int afdt_lid,
                              const std::string &afdt_filename, int id,
                              const std::vector<int> &inherited_fds) {
  Lock lock(m_procMutex);

  pid_t child = fork();
  if (child == 0) {
    // child
    mprotect_1g_pages(PROT_READ);
    if (s_trackProcessTimes) {
      HardwareCounter::RecordSubprocessTimes();
    }
    Logger::ResetPid();
    pid_t sid = setsid();
    if (sid < 0) {
      Logger::Warning("Unable to setsid");
      _Exit(HPHP_EXIT_FAILURE);
    }
    afdt_error_t err = AFDT_ERROR_T_INIT;
    auto afdt_fd = afdt_connect(afdt_filename.c_str(), &err);
    if (afdt_fd < 0) {
      Logger::Warning("Unable to afdt_connect, filename %s: %d %s",
                      afdt_filename.c_str(),
                      errno, folly::errnoStr(errno).c_str());
      _Exit(HPHP_EXIT_FAILURE);
    }

    // shadow process doesn't use g_procs
    for (int i = 0; i < id; i++) {
      g_procs[i].closeFiles();
    }
    g_procs.reset();
    g_procsCount = 0;
    close_fds(inherited_fds);
    ::close(afdt_lid);
    // Tell the OOM killer never to kill a light process.  Killing it will cause
    // the entire server to exit, and won't free much memory anyway.
    Process::OOMScoreAdj(-1000);
    runShadow(afdt_fd);
  } else if (child < 0) {
    // failed
    Logger::Warning("Unable to fork lightly: %d %s", errno,
                    folly::errnoStr(errno).c_str());
    return false;
  } else {
    // parent
    m_shadowProcess = child;

    sockaddr addr;
    socklen_t addrlen = sizeof(addr);
    m_afdt_fd = accept(afdt_lid, &addr, &addrlen);
    if (m_afdt_fd < 0) {
      Logger::Warning("Unable to establish afdt connection: %d %s",
                      errno, folly::errnoStr(errno).c_str());
      closeShadow();
      return false;
    }
  }
  return true;
}
