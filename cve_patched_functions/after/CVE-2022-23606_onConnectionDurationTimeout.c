void ActiveClient::onConnectionDurationTimeout() {
  // The connection duration timer should only have started after we left the CONNECTING state.
  ENVOY_BUG(state_ != ActiveClient::State::CONNECTING,
            "max connection duration reached while connecting");

  // The connection duration timer should have been disabled and reset in onConnectionEvent
  // for closing connections.
  ENVOY_BUG(state_ != ActiveClient::State::CLOSED, "max connection duration reached while closed");

  // There's nothing to do if the client is connecting, closed or draining.
  // Two of these cases are bugs (see above), but it is safe to no-op either way.
  if (state_ == ActiveClient::State::CONNECTING || state_ == ActiveClient::State::CLOSED ||
      state_ == ActiveClient::State::DRAINING) {
    return;
  }

  ENVOY_CONN_LOG(debug, "max connection duration reached, DRAINING", *this);
  parent_.host()->cluster().stats().upstream_cx_max_duration_reached_.inc();
  parent_.transitionActiveClientState(*this, Envoy::ConnectionPool::ActiveClient::State::DRAINING);

  // Close out the draining client if we no longer have active streams.
  // We have to do this here because there won't be an onStreamClosed (because there are
  // no active streams) to do it for us later.
  if (numActiveStreams() == 0) {
    close();
  }
}
