check_supported(item *new)
{
int c = -1;
int bot = 0;
int top = supported_elements_count;
int mid;
tree_node *tn;
paramstr *param;

while (top > bot)
  {
  mid = (top + bot)/2;
  c = Ustrcmp(new->name, supported_elements[mid].name);
  if (c == 0) break;
  if (c < 0) top = mid; else bot = mid + 1;
  }

/* Element is not recognized; insert in tree if not already there. */

if (c != 0)
  {
  tn = tree_search(unknown_element_tree, new->name);
  if (tn == NULL)
    {
    tn = misc_malloc(sizeof(tree_node) + Ustrlen(new->name));
    Ustrcpy(tn->name, new->name);
    (void)tree_insertnode(&unknown_element_tree, tn);
    }
  return;
  }

/* Element is recognized, check its attributes. Those that start with "#" are
invented internal ones. */

for (param = new->p.param; param != NULL; param = param->next)
  {
  uschar buffer[256];
  uschar **aptr;
  if (param->name[0] == '#') continue;

  /* Check common attributes - check their values */

  if (Ustrcmp(param->name, "revisionflag") == 0)
    {
    if (Ustrcmp(param->value, "changed") == 0) continue;
    (void)sprintf(CS buffer, "+%s=%.*s:%s", param->name, 256 - 2*DBNAMESIZE - 3,
      param->value, new->name);
    }

  /* See if this attribute is listed as supported unless the first item
  in the list is "*", which means the element itself is ignored. */

  else
    {
    aptr = supported_elements[mid].attrs;
    if (aptr != NULL)
      {
      if (Ustrcmp(*aptr, "*") == 0) continue;
      for (; *aptr != NULL; aptr++)
        if (Ustrcmp(*aptr, param->name) == 0) break;
      if (*aptr != NULL) continue;
      }
    (void)sprintf(CS buffer, "+%s:%s", param->name, new->name);
    }

  /* Add to unknown tree */

  tn = tree_search(unknown_element_tree, buffer);
  if (tn == NULL)
    {
    tn = misc_malloc(sizeof(tree_node) + Ustrlen(buffer));
    Ustrcpy(tn->name, buffer);
    (void)tree_insertnode(&unknown_element_tree, tn);
    }
  }
}
