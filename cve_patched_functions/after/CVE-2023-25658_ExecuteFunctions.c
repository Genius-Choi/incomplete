void TPUPartitionedCallOp::ExecuteFunctions(
    const std::vector<DeviceAndFHandle>& functions, OpKernelContext* ctx,
    int device_ordinal, int64_t ordinal_selector_req_id, DoneCallback done) {
  profiler::TraceMe trace_me("TPUPartitionedCallOp-ExecuteFunctions");
  FunctionLibraryRuntime::Options opts(ctx->step_id());
  opts.step_container = ctx->step_container();
  opts.stats_collector = ctx->stats_collector();
  // TODO(akshayka): Consider selecting a runner on a per-device basis,
  // i.e., using device-specific threadpools when available.
  opts.runner = ctx->runner();
  opts.source_device = local_device_name_;
  opts.run_all_kernels_inline = ctx->run_all_kernels_inline();

  OpInputList arguments;
  OP_REQUIRES_OK_ASYNC(ctx, ctx->input_list("args", &arguments), done);

  auto* local_cm = new CancellationManager(ctx->cancellation_manager());
  auto* rendez = new RefCountedIntraProcessRendezvous(device_mgr_);
  opts.cancellation_manager = local_cm;
  opts.rendezvous = rendez;

  StatusCallback callback(
      [rendez = rendez, local_cm, done = std::move(done),
       device_ordinal = device_ordinal, req_id = ordinal_selector_req_id, ctx,
       ordinal_selector = ordinal_selector_](const Status& status) {
        delete local_cm;
        rendez->Unref();
        if (!status.ok()) {
          ctx->SetStatus(status);
        }
        done();
        if (req_id >= 0) {
          ordinal_selector->DequeueFromCoreSelector(device_ordinal, req_id);
        }
      });

  auto* refcounted_done = new ReffedStatusCallback(std::move(callback));
  for (int i = 1; i < functions.size(); ++i) {
    refcounted_done->Ref();
  }
  for (const DeviceAndFHandle& entry : functions) {
    const string& target_device = entry.device;
    FHandle handle = entry.handle;
    VLOG(3) << "Running function shard on device " << target_device
            << " with local device name " << local_device_name_;
    if (target_device == local_device_name_) {
      opts.remote_execution = false;
      ExecuteLocalFunction(opts, arguments, handle, ctx, refcounted_done);
    } else {
      opts.remote_execution = true;
      ExecuteRemoteFunction(opts, handle, ctx, refcounted_done);
    }
  }
}
