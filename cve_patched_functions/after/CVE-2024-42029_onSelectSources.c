void CScreencopyPortal::onSelectSources(sdbus::MethodCall& call) {
    sdbus::ObjectPath requestHandle, sessionHandle;

    call >> requestHandle;
    call >> sessionHandle;

    std::string appID;
    call >> appID;

    Debug::log(LOG, "[screencopy] SelectSources:");
    Debug::log(LOG, "[screencopy]  | {}", requestHandle.c_str());
    Debug::log(LOG, "[screencopy]  | {}", sessionHandle.c_str());
    Debug::log(LOG, "[screencopy]  | appid: {}", appID);

    const auto PSESSION = getSession(sessionHandle);

    if (!PSESSION) {
        Debug::log(ERR, "[screencopy] SelectSources: no session found??");
        auto reply = call.createErrorReply(sdbus::Error{"NOSESSION", "No session found"});
        reply << (uint32_t)1;
        reply.send();
        return;
    }

    std::unordered_map<std::string, sdbus::Variant> options;

    call >> options;

    struct {
        bool        exists = false;
        std::string token, output;
        uint64_t    windowHandle;
        bool        withCursor;
        uint64_t    timeIssued;
    } restoreData;

    for (auto& [key, val] : options) {

        if (key == "cursor_mode") {
            PSESSION->cursorMode = val.get<uint32_t>();
            Debug::log(LOG, "[screencopy] option cursor_mode to {}", PSESSION->cursorMode);
        } else if (key == "restore_data") {
            // suv
            // v -> r(susbt) -> v2
            // v -> a(sv) -> v3
            std::string issuer;
            uint32_t    version;
            auto        suv = val.get<sdbus::Struct<std::string, uint32_t, sdbus::Variant>>();
            issuer          = suv.get<0>();
            version         = suv.get<1>();

            sdbus::Variant data = suv.get<2>();

            if (issuer != "hyprland") {
                Debug::log(LOG, "[screencopy] Restore token from {}, ignoring", issuer);
                continue;
            }

            Debug::log(LOG, "[screencopy] Restore token from {} ver {}", issuer, version);

            if (version != 2 && version != 3) {
                Debug::log(LOG, "[screencopy] Restore token ver unsupported, skipping", issuer);
                continue;
            }

            if (version == 2) {
                auto susbt = data.get<sdbus::Struct<std::string, uint32_t, std::string, bool, uint64_t>>();

                restoreData.exists = true;

                restoreData.token        = susbt.get<0>();
                restoreData.windowHandle = susbt.get<1>();
                restoreData.output       = susbt.get<2>();
                restoreData.withCursor   = susbt.get<3>();
                restoreData.timeIssued   = susbt.get<4>();

                Debug::log(LOG, "[screencopy] Restore token v2 {} with data: {} {} {} {}", restoreData.token, restoreData.windowHandle, restoreData.output, restoreData.withCursor,
                           restoreData.timeIssued);
            } else {
                // ver 3
                auto        sv = data.get<std::unordered_map<std::string, sdbus::Variant>>();

                uint64_t    windowHandle = 0;
                std::string windowClass;

                restoreData.windowHandle = 0;
                restoreData.exists       = true;

                for (auto& [tkkey, tkval] : sv) {
                    if (tkkey == "output") {
                        restoreData.output = tkval.get<std::string>();
                    } else if (tkkey == "windowHandle") {
                        windowHandle = tkval.get<uint64_t>();
                    } else if (tkkey == "windowClass") {
                        windowClass = tkval.get<std::string>();
                    } else if (tkkey == "withCursor") {
                        restoreData.withCursor = (bool)tkval.get<uint32_t>();
                    } else if (tkkey == "timeIssued") {
                        restoreData.timeIssued = tkval.get<uint64_t>();
                    } else if (tkkey == "token") {
                        restoreData.token = tkval.get<std::string>();
                    } else {
                        Debug::log(LOG, "[screencopy] restore token v3, unknown prop {}", tkkey);
                    }
                }

                Debug::log(LOG, "[screencopy] Restore token v3 {} with data: {} {} {} {} {}", restoreData.token, windowHandle, windowClass, restoreData.output,
                           restoreData.withCursor, restoreData.timeIssued);

                // find window
                if (windowHandle != 0 || !windowClass.empty()) {
                    if (windowHandle != 0) {
                        for (auto& h : g_pPortalManager->m_sHelpers.toplevel->m_vToplevels) {
                            if ((uint64_t)h->handle == windowHandle) {
                                restoreData.windowHandle = (uint64_t)h->handle;
                                Debug::log(LOG, "[screencopy] token v3 window found by handle {}", (void*)windowHandle);
                                break;
                            }
                        }
                    }

                    if (restoreData.windowHandle == 0 && !windowClass.empty()) {
                        // try class
                        for (auto& h : g_pPortalManager->m_sHelpers.toplevel->m_vToplevels) {
                            if (h->windowClass == windowClass) {
                                restoreData.windowHandle = (uint64_t)h->handle;
                                Debug::log(LOG, "[screencopy] token v3 window found by class {}", windowClass);
                                break;
                            }
                        }
                    }
                }
            }

        } else if (key == "persist_mode") {
            PSESSION->persistMode = val.get<uint32_t>();
            Debug::log(LOG, "[screencopy] option persist_mode to {}", PSESSION->persistMode);
        } else {
            Debug::log(LOG, "[screencopy] unused option {}", key);
        }
    }

    const bool RESTOREDATAVALID = restoreData.exists &&
        (g_pPortalManager->m_sHelpers.toplevel->exists((zwlr_foreign_toplevel_handle_v1*)restoreData.windowHandle) || g_pPortalManager->getOutputFromName(restoreData.output));

    SSelectionData SHAREDATA;
    if (RESTOREDATAVALID) {
        Debug::log(LOG, "[screencopy] restore data valid, not prompting");

        SHAREDATA.output       = restoreData.output;
        SHAREDATA.windowHandle = (zwlr_foreign_toplevel_handle_v1*)restoreData.windowHandle;
        SHAREDATA.type         = restoreData.windowHandle ? TYPE_WINDOW : TYPE_OUTPUT;
        SHAREDATA.allowToken   = true; // user allowed token before
        PSESSION->cursorMode   = restoreData.withCursor;
    } else {
        Debug::log(LOG, "[screencopy] restore data invalid / missing, prompting");

        SHAREDATA = promptForScreencopySelection();
    }

    Debug::log(LOG, "[screencopy] SHAREDATA returned selection {}", (int)SHAREDATA.type);

    if (SHAREDATA.type == TYPE_WINDOW && !m_sState.toplevel) {
        Debug::log(ERR, "[screencopy] Requested type window for no toplevel export protocol!");
        SHAREDATA.type = TYPE_INVALID;
    } else if (SHAREDATA.type == TYPE_OUTPUT || SHAREDATA.type == TYPE_GEOMETRY) {
        const auto POUTPUT = g_pPortalManager->getOutputFromName(SHAREDATA.output);

        if (POUTPUT) {
            static auto* const* PFPS = (Hyprlang::INT* const*)g_pPortalManager->m_sConfig.config->getConfigValuePtr("screencopy:max_fps")->getDataStaticPtr();

            if (**PFPS <= 0)
                PSESSION->sharingData.framerate = POUTPUT->refreshRate;
            else
                PSESSION->sharingData.framerate = std::clamp(POUTPUT->refreshRate, 1.F, (float)**PFPS);
        }
    }

    PSESSION->selection = SHAREDATA;

    auto reply = call.createReply();
    reply << (uint32_t)(SHAREDATA.type == TYPE_INVALID ? 1 : 0);
    reply << std::unordered_map<std::string, sdbus::Variant>{};
    reply.send();
}
