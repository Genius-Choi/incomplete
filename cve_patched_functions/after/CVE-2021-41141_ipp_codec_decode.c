static pj_status_t ipp_codec_decode( pjmedia_codec *codec, 
				     const struct pjmedia_frame *input,
				     unsigned output_buf_len, 
				     struct pjmedia_frame *output)
{
    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;
    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];
    unsigned samples_per_frame;
    USC_PCMStream out;
    USC_Bitstream in;
    pj_uint8_t pt;

    pt = ippc->pt; 
    samples_per_frame = ippc->samples_per_frame;

    PJ_ASSERT_RETURN(output_buf_len >= samples_per_frame << 1,
		     PJMEDIA_CODEC_EPCMTOOSHORT);

    if (input->type == PJMEDIA_FRAME_TYPE_AUDIO) {
	if (ippc->predecode) {
	    ippc->predecode(codec_data, input, &in);
	} else {
	    /* Most IPP codecs have frametype==0 for speech frame */
	    in.pBuffer = (char*)input->buf;
	    in.nbytes = input->size;
	    in.frametype = 0;
	    in.bitrate = codec_data->info->params.modes.bitrate;
	}

	out.pBuffer = output->buf;
    }

    if (input->type != PJMEDIA_FRAME_TYPE_AUDIO ||
	USC_NoError != ippc->fxns->Decode(codec_data->dec, &in, &out)) 
    {
	pjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);
	output->size = samples_per_frame << 1;
	output->timestamp.u64 = input->timestamp.u64;
	output->type = PJMEDIA_FRAME_TYPE_AUDIO;
	return PJ_SUCCESS;
    }

#if PJMEDIA_HAS_INTEL_IPP_CODEC_G726
    /* For G.726: amplify decoding result (USC G.726 encoder deamplified it) */
    if (pt == PJMEDIA_RTP_PT_G726_16 || pt == PJMEDIA_RTP_PT_G726_24 ||
	pt == PJMEDIA_RTP_PT_G726_32 || pt == PJMEDIA_RTP_PT_G726_40 ||
	pt == PJMEDIA_RTP_PT_G721)
    {
	unsigned i;
	pj_int16_t *s = (pj_int16_t*)output->buf;

	for (i = 0; i < samples_per_frame; ++i)
	    s[i] <<= 2;
    }
#endif

#if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1
    /* For G722.1: adjust the decoder output signal level */
    if (pt >= PJMEDIA_RTP_PT_G722_1_16 && 
	pt <= PJMEDIA_RTP_PT_G7221_RSV2 &&
	codec_data->g7221_pcm_shift)
    {
	unsigned i;
	pj_int16_t *s = (pj_int16_t*)output->buf;

	for (i = 0; i < samples_per_frame; ++i)
	    s[i] <<= codec_data->g7221_pcm_shift;
    }
#endif

    output->type = PJMEDIA_FRAME_TYPE_AUDIO;
    output->size = samples_per_frame << 1;
    output->timestamp.u64 = input->timestamp.u64;

    /* Invoke external PLC if codec has no internal PLC */
    if (codec_data->plc && codec_data->plc_enabled)
	pjmedia_plc_save(codec_data->plc, (pj_int16_t*)output->buf);

    return PJ_SUCCESS;
}
