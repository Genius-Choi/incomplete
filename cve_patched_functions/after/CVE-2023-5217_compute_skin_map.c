static void compute_skin_map(VP8_COMP *cpi) {
  int mb_row, mb_col, num_bl;
  VP8_COMMON *cm = &cpi->common;
  const uint8_t *src_y = cpi->Source->y_buffer;
  const uint8_t *src_u = cpi->Source->u_buffer;
  const uint8_t *src_v = cpi->Source->v_buffer;
  const int src_ystride = cpi->Source->y_stride;
  const int src_uvstride = cpi->Source->uv_stride;

  const SKIN_DETECTION_BLOCK_SIZE bsize =
      (cm->Width * cm->Height <= 352 * 288) ? SKIN_8X8 : SKIN_16X16;

  for (mb_row = 0; mb_row < cm->mb_rows; mb_row++) {
    num_bl = 0;
    for (mb_col = 0; mb_col < cm->mb_cols; mb_col++) {
      const int bl_index = mb_row * cm->mb_cols + mb_col;
      cpi->skin_map[bl_index] =
          vp8_compute_skin_block(src_y, src_u, src_v, src_ystride, src_uvstride,
                                 bsize, cpi->consec_zero_last[bl_index], 0);
      num_bl++;
      src_y += 16;
      src_u += 8;
      src_v += 8;
    }
    src_y += (src_ystride << 4) - (num_bl << 4);
    src_u += (src_uvstride << 3) - (num_bl << 3);
    src_v += (src_uvstride << 3) - (num_bl << 3);
  }

  // Remove isolated skin blocks (none of its neighbors are skin) and isolated
  // non-skin blocks (all of its neighbors are skin). Skip the boundary.
  for (mb_row = 1; mb_row < cm->mb_rows - 1; mb_row++) {
    for (mb_col = 1; mb_col < cm->mb_cols - 1; mb_col++) {
      const int bl_index = mb_row * cm->mb_cols + mb_col;
      int num_neighbor = 0;
      int mi, mj;
      int non_skin_threshold = 8;

      for (mi = -1; mi <= 1; mi += 1) {
        for (mj = -1; mj <= 1; mj += 1) {
          int bl_neighbor_index = (mb_row + mi) * cm->mb_cols + mb_col + mj;
          if (cpi->skin_map[bl_neighbor_index]) num_neighbor++;
        }
      }

      if (cpi->skin_map[bl_index] && num_neighbor < 2)
        cpi->skin_map[bl_index] = 0;
      if (!cpi->skin_map[bl_index] && num_neighbor == non_skin_threshold)
        cpi->skin_map[bl_index] = 1;
    }
  }
}
