toPrimitive_RJS(Runtime &runtime, Handle<> valueHandle, PreferredType hint) {
  assert(!valueHandle->isEmpty() && "empty value is not allowed");
  assert(!valueHandle->isNativeValue() && "native value is not allowed");

  if (!valueHandle->isObject())
    return *valueHandle;

  // 4. Let exoticToPrim be GetMethod(input, @@toPrimitive).
  auto exoticToPrim = getMethod(
      runtime,
      valueHandle,
      runtime.makeHandle(
          Predefined::getSymbolID(Predefined::SymbolToPrimitive)));
  if (LLVM_UNLIKELY(exoticToPrim == ExecutionStatus::EXCEPTION)) {
    return ExecutionStatus::EXCEPTION;
  }
  // 6. If exoticToPrim is not undefined, then
  if (vmisa<Callable>(exoticToPrim->getHermesValue())) {
    auto callable = runtime.makeHandle<Callable>(
        dyn_vmcast<Callable>(exoticToPrim->getHermesValue()));
    CallResult<PseudoHandle<>> resultRes = Callable::executeCall1(
        callable,
        runtime,
        valueHandle,
        HermesValue::encodeStringValue(runtime.getPredefinedString(
            hint == PreferredType::NONE         ? Predefined::defaultStr
                : hint == PreferredType::STRING ? Predefined::string
                                                : Predefined::number)));
    if (LLVM_UNLIKELY(resultRes == ExecutionStatus::EXCEPTION)) {
      return ExecutionStatus::EXCEPTION;
    }
    PseudoHandle<> result = std::move(*resultRes);
    if (!result->isObject()) {
      return result.getHermesValue();
    }
    return runtime.raiseTypeError(
        "Symbol.toPrimitive function must return a primitive");
  }

  // 7. If hint is "default", let hint be "number".
  // 8. Return OrdinaryToPrimitive(input,hint).
  return ordinaryToPrimitive(
      Handle<JSObject>::vmcast(valueHandle),
      runtime,
      hint == PreferredType::NONE ? PreferredType::NUMBER : hint);
}
