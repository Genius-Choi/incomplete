void test_nghttp2_session_recv_data_no_auto_flow_control(void) {
  nghttp2_session *session;
  nghttp2_session_callbacks callbacks;
  my_user_data ud;
  nghttp2_option *option;
  nghttp2_frame_hd hd;
  size_t padlen;
  uint8_t data[8192];
  ssize_t rv;
  size_t sendlen;
  nghttp2_stream *stream;
  size_t i;

  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));
  callbacks.send_callback = null_send_callback;
  callbacks.on_frame_send_callback = on_frame_send_callback;

  nghttp2_option_new(&option);
  nghttp2_option_set_no_auto_window_update(option, 1);

  nghttp2_session_server_new2(&session, &callbacks, &ud, option);

  /* Create DATA frame with length 4KiB + 11 bytes padding*/
  padlen = 11;
  memset(data, 0, sizeof(data));
  hd.length = 4096 + 1 + padlen;
  hd.type = NGHTTP2_DATA;
  hd.flags = NGHTTP2_FLAG_PADDED;
  hd.stream_id = 1;
  nghttp2_frame_pack_frame_hd(data, &hd);
  data[NGHTTP2_FRAME_HDLEN] = (uint8_t)padlen;

  /* First create stream 1, then close it.  Check that data is
     consumed for connection in this situation */
  open_recv_stream(session, 1);

  /* Receive first 100 bytes */
  sendlen = 100;
  rv = nghttp2_session_mem_recv(session, data, sendlen);
  CU_ASSERT((ssize_t)sendlen == rv);

  /* We consumed pad length field (1 byte) */
  CU_ASSERT(1 == session->consumed_size);

  /* close stream here */
  nghttp2_submit_rst_stream(session, NGHTTP2_FLAG_NONE, 1, NGHTTP2_NO_ERROR);
  nghttp2_session_send(session);

  /* stream 1 has been closed, and we disabled auto flow-control, so
     data must be immediately consumed for connection. */
  rv = nghttp2_session_mem_recv(session, data + sendlen,
                                NGHTTP2_FRAME_HDLEN + hd.length - sendlen);
  CU_ASSERT((ssize_t)(NGHTTP2_FRAME_HDLEN + hd.length - sendlen) == rv);

  /* We already consumed pad length field (1 byte), so do +1 here */
  CU_ASSERT((int32_t)(NGHTTP2_FRAME_HDLEN + hd.length - sendlen + 1) ==
            session->consumed_size);

  nghttp2_session_del(session);

  /* Reuse DATA created previously. */

  nghttp2_session_server_new2(&session, &callbacks, &ud, option);

  /* Now we are expecting final response header, which means receiving
     DATA for that stream is illegal. */
  stream = open_recv_stream(session, 1);
  stream->http_flags |= NGHTTP2_HTTP_FLAG_EXPECT_FINAL_RESPONSE;

  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + hd.length);
  CU_ASSERT((ssize_t)(NGHTTP2_FRAME_HDLEN + hd.length) == rv);

  /* Whole payload must be consumed now because HTTP messaging rule
     was not honored. */
  CU_ASSERT((int32_t)hd.length == session->consumed_size);

  nghttp2_session_del(session);

  /* Check window_update_queued flag in both session and stream */
  nghttp2_session_server_new2(&session, &callbacks, &ud, option);

  stream = open_recv_stream(session, 1);

  hd.length = 4096;
  hd.type = NGHTTP2_DATA;
  hd.flags = NGHTTP2_FLAG_NONE;
  hd.stream_id = 1;
  nghttp2_frame_pack_frame_hd(data, &hd);

  /* Receive up to 65535 bytes of DATA */
  for (i = 0; i < 15; ++i) {
    rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4096);
    CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4096 == rv);
  }

  hd.length = 4095;
  nghttp2_frame_pack_frame_hd(data, &hd);

  rv = nghttp2_session_mem_recv(session, data, NGHTTP2_FRAME_HDLEN + 4095);
  CU_ASSERT(NGHTTP2_FRAME_HDLEN + 4095 == rv);

  CU_ASSERT(65535 == session->recv_window_size);
  CU_ASSERT(65535 == stream->recv_window_size);

  /* The first call of nghttp2_session_consume_connection() will queue
     WINDOW_UPDATE.  Next call does not. */
  nghttp2_session_consume_connection(session, 32767);
  nghttp2_session_consume_connection(session, 32768);

  CU_ASSERT(32768 == session->recv_window_size);
  CU_ASSERT(65535 == stream->recv_window_size);
  CU_ASSERT(1 == session->window_update_queued);
  CU_ASSERT(0 == stream->window_update_queued);

  ud.frame_send_cb_called = 0;

  /* This will send WINDOW_UPDATE, and check whether we should send
     WINDOW_UPDATE, and queue and send it at once. */
  CU_ASSERT(0 == nghttp2_session_send(session));
  CU_ASSERT(0 == session->recv_window_size);
  CU_ASSERT(65535 == stream->recv_window_size);
  CU_ASSERT(0 == session->window_update_queued);
  CU_ASSERT(0 == stream->window_update_queued);
  CU_ASSERT(2 == ud.frame_send_cb_called);

  /* Do the same for stream */
  nghttp2_session_consume_stream(session, 1, 32767);
  nghttp2_session_consume_stream(session, 1, 32768);

  CU_ASSERT(0 == session->recv_window_size);
  CU_ASSERT(32768 == stream->recv_window_size);
  CU_ASSERT(0 == session->window_update_queued);
  CU_ASSERT(1 == stream->window_update_queued);

  ud.frame_send_cb_called = 0;

  CU_ASSERT(0 == nghttp2_session_send(session));
  CU_ASSERT(0 == session->recv_window_size);
  CU_ASSERT(0 == stream->recv_window_size);
  CU_ASSERT(0 == session->window_update_queued);
  CU_ASSERT(0 == stream->window_update_queued);
  CU_ASSERT(2 == ud.frame_send_cb_called);

  nghttp2_session_del(session);
  nghttp2_option_del(option);
}
