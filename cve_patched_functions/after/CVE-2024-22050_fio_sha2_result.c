char *fio_sha2_result(fio_sha2_s *s) {
  if (s->type & 1) {
    /* 512 bits derived hashing */

    size_t in_buffer = s->length.words[0] & 127;

    if (in_buffer > 111) {
      memcpy(s->buffer + in_buffer, sha2_padding, 128 - in_buffer);
      fio_sha2_perform_all_rounds(s, s->buffer);
      memcpy(s->buffer, sha2_padding + 1, 112);
    } else if (in_buffer != 111) {
      memcpy(s->buffer + in_buffer, sha2_padding, 112 - in_buffer);
    } else {
      s->buffer[111] = sha2_padding[0];
    }
    /* store the length in BITS - alignment should be promised by struct */
    /* this must the number in BITS, encoded as a BIG ENDIAN 64 bit number */

    s->length.words[1] = (s->length.words[1] << 3) | (s->length.words[0] >> 61);
    s->length.words[0] = s->length.words[0] << 3;
    s->length.words[0] = fio_lton64(s->length.words[0]);
    s->length.words[1] = fio_lton64(s->length.words[1]);

#if !__BIG_ENDIAN__
    {
      uint_fast64_t tmp = s->length.words[0];
      s->length.words[0] = s->length.words[1];
      s->length.words[1] = tmp;
    }
#endif

    uint64_t *len = (uint64_t *)(s->buffer + 112);
    len[0] = s->length.words[0];
    len[1] = s->length.words[1];
    fio_sha2_perform_all_rounds(s, s->buffer);

    /* change back to little endian */
    s->digest.i64[0] = fio_ntol64(s->digest.i64[0]);
    s->digest.i64[1] = fio_ntol64(s->digest.i64[1]);
    s->digest.i64[2] = fio_ntol64(s->digest.i64[2]);
    s->digest.i64[3] = fio_ntol64(s->digest.i64[3]);
    s->digest.i64[4] = fio_ntol64(s->digest.i64[4]);
    s->digest.i64[5] = fio_ntol64(s->digest.i64[5]);
    s->digest.i64[6] = fio_ntol64(s->digest.i64[6]);
    s->digest.i64[7] = fio_ntol64(s->digest.i64[7]);
    // set NULL bytes for SHA-2 Type
    switch (s->type) {
    case SHA_512_224:
      s->digest.str[28] = 0;
      break;
    case SHA_512_256:
      s->digest.str[32] = 0;
      break;
    case SHA_384:
      s->digest.str[48] = 0;
      break;
    default:
      s->digest.str[64] =
          0; /* sometimes the optimizer messes the NUL sequence */
      break;
    }
    // fprintf(stderr, "result requested, in hex, is:");
    // for (size_t i = 0; i < ((s->type & 1) ? 64 : 32); i++)
    //   fprintf(stderr, "%02x", (unsigned int)(s->digest.str[i] & 0xFF));
    // fprintf(stderr, "\r\n");
    return (char *)s->digest.str;
  }

  size_t in_buffer = s->length.words[0] & 63;
  if (in_buffer > 55) {
    memcpy(s->buffer + in_buffer, sha2_padding, 64 - in_buffer);
    fio_sha2_perform_all_rounds(s, s->buffer);
    memcpy(s->buffer, sha2_padding + 1, 56);
  } else if (in_buffer != 55) {
    memcpy(s->buffer + in_buffer, sha2_padding, 56 - in_buffer);
  } else {
    s->buffer[55] = sha2_padding[0];
  }
  /* store the length in BITS - alignment should be promised by struct */
  /* this must the number in BITS, encoded as a BIG ENDIAN 64 bit number */
  uint64_t *len = (uint64_t *)(s->buffer + 56);
  *len = s->length.words[0] << 3;
  *len = fio_lton64(*len);
  fio_sha2_perform_all_rounds(s, s->buffer);

  /* change back to little endian, if required */

  s->digest.i32[0] = fio_ntol32(s->digest.i32[0]);
  s->digest.i32[1] = fio_ntol32(s->digest.i32[1]);
  s->digest.i32[2] = fio_ntol32(s->digest.i32[2]);
  s->digest.i32[3] = fio_ntol32(s->digest.i32[3]);
  s->digest.i32[4] = fio_ntol32(s->digest.i32[4]);
  s->digest.i32[5] = fio_ntol32(s->digest.i32[5]);
  s->digest.i32[6] = fio_ntol32(s->digest.i32[6]);
  s->digest.i32[7] = fio_ntol32(s->digest.i32[7]);

  // set NULL bytes for SHA_224
  if (s->type == SHA_224)
    s->digest.str[28] = 0;
  // fprintf(stderr, "SHA-2 result requested, in hex, is:");
  // for (size_t i = 0; i < ((s->type & 1) ? 64 : 32); i++)
  //   fprintf(stderr, "%02x", (unsigned int)(s->digest.str[i] & 0xFF));
  // fprintf(stderr, "\r\n");
  return (char *)s->digest.str;
}
