static int rtp_raw_write(struct ast_rtp_instance *instance, struct ast_frame *frame, int codec)
{
	struct ast_rtp *rtp = ast_rtp_instance_get_data(instance);
	int pred, mark = 0;
	unsigned int ms = calc_txstamp(rtp, &frame->delivery);
	struct ast_sockaddr remote_address = { {0,} };
	int rate = ast_rtp_get_rate(frame->subclass.format) / 1000;
	unsigned int seqno;
#ifdef TEST_FRAMEWORK
	struct ast_rtp_engine_test *test = ast_rtp_instance_get_test(instance);
#endif

	if (ast_format_cmp(frame->subclass.format, ast_format_g722) == AST_FORMAT_CMP_EQUAL) {
		frame->samples /= 2;
	}

	if (rtp->sending_digit) {
		return 0;
	}

#ifdef TEST_FRAMEWORK
	if (test && test->send_report) {
		test->send_report = 0;
		ast_rtcp_write(instance);
		return 0;
	}
#endif

	if (frame->frametype == AST_FRAME_VOICE) {
		pred = rtp->lastts + frame->samples;

		/* Re-calculate last TS */
		rtp->lastts = rtp->lastts + ms * rate;
		if (ast_tvzero(frame->delivery)) {
			/* If this isn't an absolute delivery time, Check if it is close to our prediction,
			   and if so, go with our prediction */
			if (abs((int)rtp->lastts - pred) < MAX_TIMESTAMP_SKEW) {
				rtp->lastts = pred;
			} else {
				ast_debug_rtp(3, "(%p) RTP audio difference is %d, ms is %u\n",
					instance, abs((int)rtp->lastts - pred), ms);
				mark = 1;
			}
		}
	} else if (frame->frametype == AST_FRAME_VIDEO) {
		mark = frame->subclass.frame_ending;
		pred = rtp->lastovidtimestamp + frame->samples;
		/* Re-calculate last TS */
		rtp->lastts = rtp->lastts + ms * 90;
		/* If it's close to our prediction, go for it */
		if (ast_tvzero(frame->delivery)) {
			if (abs((int)rtp->lastts - pred) < 7200) {
				rtp->lastts = pred;
				rtp->lastovidtimestamp += frame->samples;
			} else {
				ast_debug_rtp(3, "(%p) RTP video difference is %d, ms is %u (%u), pred/ts/samples %u/%d/%d\n",
					instance, abs((int)rtp->lastts - pred), ms, ms * 90, rtp->lastts, pred, frame->samples);
				rtp->lastovidtimestamp = rtp->lastts;
			}
		}
	} else {
		pred = rtp->lastotexttimestamp + frame->samples;
		/* Re-calculate last TS */
		rtp->lastts = rtp->lastts + ms;
		/* If it's close to our prediction, go for it */
		if (ast_tvzero(frame->delivery)) {
			if (abs((int)rtp->lastts - pred) < 7200) {
				rtp->lastts = pred;
				rtp->lastotexttimestamp += frame->samples;
			} else {
				ast_debug_rtp(3, "(%p) RTP other difference is %d, ms is %u, pred/ts/samples %u/%d/%d\n",
					instance, abs((int)rtp->lastts - pred), ms, rtp->lastts, pred, frame->samples);
				rtp->lastotexttimestamp = rtp->lastts;
			}
		}
	}

	/* If we have been explicitly told to set the marker bit then do so */
	if (ast_test_flag(rtp, FLAG_NEED_MARKER_BIT)) {
		mark = 1;
		ast_clear_flag(rtp, FLAG_NEED_MARKER_BIT);
	}

	/* If the timestamp for non-digt packets has moved beyond the timestamp for digits, update the digit timestamp */
	if (rtp->lastts > rtp->lastdigitts) {
		rtp->lastdigitts = rtp->lastts;
	}

	/* Assume that the sequence number we expect to use is what will be used until proven otherwise */
	seqno = rtp->seqno;

	/* If the frame contains sequence number information use it to influence our sequence number */
	if (ast_test_flag(frame, AST_FRFLAG_HAS_SEQUENCE_NUMBER)) {
		if (rtp->expectedseqno != -1) {
			/* Determine where the frame from the core is in relation to where we expected */
			int difference = frame->seqno - rtp->expectedseqno;

			/* If there is a substantial difference then we've either got packets really out
			 * of order, or the source is RTP and it has cycled. If this happens we resync
			 * the sequence number adjustments to this frame. If we also have packet loss
			 * things won't be reflected correctly but it will sort itself out after a bit.
			 */
			if (abs(difference) > 100) {
				difference = 0;
			}

			/* Adjust the sequence number being used for this packet accordingly */
			seqno += difference;

			if (difference >= 0) {
				/* This frame is on time or in the future */
				rtp->expectedseqno = frame->seqno + 1;
				rtp->seqno += difference;
			}
		} else {
			/* This is the first frame with sequence number we've seen, so start keeping track */
			rtp->expectedseqno = frame->seqno + 1;
		}
	} else {
		rtp->expectedseqno = -1;
	}

	if (ast_test_flag(frame, AST_FRFLAG_HAS_TIMING_INFO)) {
		rtp->lastts = frame->ts * rate;
	}

	ast_rtp_instance_get_remote_address(instance, &remote_address);

	/* If we know the remote address construct a packet and send it out */
	if (!ast_sockaddr_isnull(&remote_address)) {
		int hdrlen = 12;
		int res;
		int ice;
		int ext = 0;
		int abs_send_time_id;
		int packet_len;
		unsigned char *rtpheader;

		/* If the abs-send-time extension has been negotiated determine how much space we need */
		abs_send_time_id = ast_rtp_instance_extmap_get_id(instance, AST_RTP_EXTENSION_ABS_SEND_TIME);
		if (abs_send_time_id != -1) {
			/* 4 bytes for the shared information, 1 byte for identifier, 3 bytes for abs-send-time */
			hdrlen += 8;
			ext = 1;
		}

		packet_len = frame->datalen + hdrlen;
		rtpheader = (unsigned char *)(frame->data.ptr - hdrlen);

		put_unaligned_uint32(rtpheader, htonl((2 << 30) | (ext << 28) | (codec << 16) | (seqno) | (mark << 23)));
		put_unaligned_uint32(rtpheader + 4, htonl(rtp->lastts));
		put_unaligned_uint32(rtpheader + 8, htonl(rtp->ssrc));

		/* We assume right now that we will only ever have the abs-send-time extension in the packet
		 * which simplifies things a bit.
		 */
		if (abs_send_time_id != -1) {
			unsigned int now_msw;
			unsigned int now_lsw;

			/* This happens before being placed into the retransmission buffer so that when we
			 * retransmit we only have to update the timestamp, not everything else.
			 */
			put_unaligned_uint32(rtpheader + 12, htonl((0xBEDE << 16) | 1));
			rtpheader[16] = (abs_send_time_id << 4) | 2;

			timeval2ntp(ast_tvnow(), &now_msw, &now_lsw);
			put_unaligned_time24(rtpheader + 17, now_msw, now_lsw);
		}

		/* If retransmissions are enabled, we need to store this packet for future use */
		if (rtp->send_buffer) {
			struct ast_rtp_rtcp_nack_payload *payload;

			payload = ast_malloc(sizeof(*payload) + packet_len);
			if (payload) {
				payload->size = packet_len;
				memcpy(payload->buf, rtpheader, packet_len);
				if (ast_data_buffer_put(rtp->send_buffer, rtp->seqno, payload) == -1) {
					ast_free(payload);
				}
			}
		}

		res = rtp_sendto(instance, (void *)rtpheader, packet_len, 0, &remote_address, &ice);
		if (res < 0) {
			if (!ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_NAT) || (ast_rtp_instance_get_prop(instance, AST_RTP_PROPERTY_NAT) && (ast_test_flag(rtp, FLAG_NAT_ACTIVE) == FLAG_NAT_ACTIVE))) {
				ast_debug_rtp(1, "(%p) RTP transmission error of packet %d to %s: %s\n",
					  instance, rtp->seqno,
					  ast_sockaddr_stringify(&remote_address),
					  strerror(errno));
			} else if (((ast_test_flag(rtp, FLAG_NAT_ACTIVE) == FLAG_NAT_INACTIVE) || ast_debug_rtp_packet_is_allowed) && !ast_test_flag(rtp, FLAG_NAT_INACTIVE_NOWARN)) {
				/* Only give this error message once if we are not RTP debugging */
				if (ast_debug_rtp_packet_is_allowed)
					ast_debug(0, "(%p) RTP NAT: Can't write RTP to private address %s, waiting for other end to send audio...\n",
						instance, ast_sockaddr_stringify(&remote_address));
				ast_set_flag(rtp, FLAG_NAT_INACTIVE_NOWARN);
			}
		} else {
			if (rtp->rtcp && rtp->rtcp->schedid < 0) {
				ast_debug_rtcp(2, "(%s) RTCP starting transmission in %u ms\n",
					ast_rtp_instance_get_channel_id(instance), ast_rtcp_calc_interval(rtp));
				ao2_ref(instance, +1);
				rtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, instance);
				if (rtp->rtcp->schedid < 0) {
					ao2_ref(instance, -1);
					ast_log(LOG_WARNING, "scheduling RTCP transmission failed.\n");
				}
			}
		}

		if (rtp_debug_test_addr(&remote_address)) {
			ast_verbose("Sent RTP packet to      %s%s (type %-2.2d, seq %-6.6d, ts %-6.6u, len %-6.6d)\n",
				    ast_sockaddr_stringify(&remote_address),
				    ice ? " (via ICE)" : "",
				    codec, rtp->seqno, rtp->lastts, res - hdrlen);
		}
	}

	/* If the sequence number that has been used doesn't match what we expected then this is an out of
	 * order late packet, so we don't need to increment as we haven't yet gotten the expected frame from
	 * the core.
	 */
	if (seqno == rtp->seqno) {
		rtp->seqno++;
	}

	return 0;
}
