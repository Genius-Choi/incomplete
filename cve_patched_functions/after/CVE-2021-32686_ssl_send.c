static pj_status_t ssl_send (pj_ssl_sock_t *ssock, 
			     pj_ioqueue_op_key_t *send_key,
			     const void *data,
			     pj_ssize_t size,
			     unsigned flags)
{
    pj_status_t status;
    int nwritten;

    /* Write the plain data to SSL, after SSL encrypts it, the buffer will
     * contain the secured data to be sent via socket. Note that re-
     * negotitation may be on progress, so sending data should be delayed
     * until re-negotiation is completed.
     */
    pj_lock_acquire(ssock->write_mutex);
    /* Don't write to SSL if send buffer is full and some data is in
     * write buffer already, just return PJ_ENOMEM.
     */
    if (ssock->send_buf_pending.data_len) {
	pj_lock_release(ssock->write_mutex);
	return PJ_ENOMEM;
    }
    status = ssl_write(ssock, data, size, &nwritten);
    pj_lock_release(ssock->write_mutex);
    
    if (status == PJ_SUCCESS && nwritten == size) {
	/* All data written, flush write buffer to network socket */
	status = flush_circ_buf_output(ssock, send_key, size, flags);
    } else if (status == PJ_EEOF) {
        /* Re-negotiation is on progress, flush re-negotiation data */
	status = flush_circ_buf_output(ssock, &ssock->handshake_op_key, 0, 0);
	if (status == PJ_SUCCESS || status == PJ_EPENDING) {
	    /* Just return PJ_EBUSY when re-negotiation is on progress */
	    status = PJ_EBUSY;
	}
    }

    return status;
}
