int zfp_acc_compress(const uint8_t *input, int32_t input_len, uint8_t *output,
                     int32_t output_len, uint8_t meta, blosc2_cparams *cparams, const void *chunk) {
  BLOSC_UNUSED_PARAM(chunk);
  ZFP_ERROR_NULL(input);
  ZFP_ERROR_NULL(output);
  ZFP_ERROR_NULL(cparams);
  ZFP_ERROR_NULL(cparams->schunk);

  double tol = (int8_t) meta;
  int8_t ndim;
  int64_t *shape = malloc(8 * sizeof(int64_t));
  int32_t *chunkshape = malloc(8 * sizeof(int32_t));
  int32_t *blockshape = malloc(8 * sizeof(int32_t));
  uint8_t *smeta;
  int32_t smeta_len;
  if (blosc2_meta_get(cparams->schunk, "b2nd", &smeta, &smeta_len) < 0) {
    free(shape);
    free(chunkshape);
    free(blockshape);
    BLOSC_TRACE_ERROR("b2nd layer not found!");
    return BLOSC2_ERROR_FAILURE;
  }
  deserialize_meta(smeta, smeta_len, &ndim, shape, chunkshape, blockshape);
  free(smeta);

  for(int i = 0; i < ndim; i++) {
    if (blockshape[i] < 4) {
      BLOSC_TRACE_ERROR("ZFP does not support blocks smaller than cells (4x...x4");
      return BLOSC2_ERROR_FAILURE;
    }
  }

  zfp_type type;     /* array scalar type */
  zfp_field *field;  /* array meta data */
  zfp_stream *zfp;   /* stream containing the real output buffer */
  zfp_stream *zfp_aux;   /* auxiliary compressed stream */
  bitstream *stream; /* bit stream to write to or read from */
  bitstream *stream_aux; /* auxiliary bit stream to write to or read from */
  size_t zfpsize;    /* byte size of compressed stream */
  double tolerance = pow(10, tol);

  int32_t typesize = cparams->typesize;

  switch (typesize) {
    case sizeof(float):
      type = zfp_type_float;
      break;
    case sizeof(double):
      type = zfp_type_double;
      break;
    default:
      free(shape);
      free(chunkshape);
      free(blockshape);
      BLOSC_TRACE_ERROR("ZFP is not available for typesize: %d", typesize);
      return BLOSC2_ERROR_FAILURE;
  }

  zfp = zfp_stream_open(NULL);
  zfp_stream_set_accuracy(zfp, tolerance);
  stream = stream_open(output, output_len);
  zfp_stream_set_bit_stream(zfp, stream);
  zfp_stream_rewind(zfp);

  switch (ndim) {
    case 1:
      field = zfp_field_1d((void *) input, type, blockshape[0]);
      break;
    case 2:
      field = zfp_field_2d((void *) input, type, blockshape[1], blockshape[0]);
      break;
    case 3:
      field = zfp_field_3d((void *) input, type, blockshape[2], blockshape[1], blockshape[0]);
      break;
    case 4:
      field = zfp_field_4d((void *) input, type, blockshape[3], blockshape[2], blockshape[1], blockshape[0]);
      break;
    default:
      free(shape);
      free(chunkshape);
      free(blockshape);
      BLOSC_TRACE_ERROR("ZFP is not available for ndims: %d", ndim);
      return BLOSC2_ERROR_FAILURE;
  }

  int zfp_maxout = (int) zfp_stream_maximum_size(zfp, field);
  zfp_stream_close(zfp);
  stream_close(stream);
  uint8_t *aux_out = malloc(zfp_maxout);
  zfp_aux = zfp_stream_open(NULL);
  zfp_stream_set_accuracy(zfp_aux, tolerance);
  stream_aux = stream_open(aux_out, zfp_maxout);
  zfp_stream_set_bit_stream(zfp_aux, stream_aux);
  zfp_stream_rewind(zfp_aux);

  zfpsize = zfp_compress(zfp_aux, field);

  /* clean up */
  zfp_field_free(field);
  zfp_stream_close(zfp_aux);
  stream_close(stream_aux);
  free(shape);
  free(chunkshape);
  free(blockshape);

  if (zfpsize == 0) {
    BLOSC_TRACE_ERROR("\n ZFP: Compression failed\n");
    free(aux_out);
    return (int) zfpsize;
  }
  if ((int32_t) zfpsize >= input_len) {
    BLOSC_TRACE_ERROR("\n ZFP: Compressed data is bigger than input! \n");
    free(aux_out);
    return 0;
  }

  memcpy(output, aux_out, zfpsize);
  free(aux_out);

  return (int) zfpsize;
}
