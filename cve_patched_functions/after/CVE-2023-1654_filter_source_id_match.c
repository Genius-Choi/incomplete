static Bool filter_source_id_match(GF_FilterPid *src_pid, const char *id, GF_Filter *dst_filter, Bool *pid_excluded, Bool *needs_clone)
{
	const char *source_ids;
	char *resolved_source_ids = NULL;
	Bool result = GF_FALSE;
	Bool first_pass = GF_TRUE;
	Bool has_default_match;
	Bool is_pid_excluded;
	*pid_excluded = GF_FALSE;
	if (!dst_filter->source_ids)
		return GF_TRUE;
	if (!id)
		return GF_FALSE;

sourceid_reassign:
	source_ids = resolved_source_ids ? resolved_source_ids : dst_filter->source_ids;
	if (!first_pass) {
		assert(dst_filter->dynamic_source_ids);
		source_ids = dst_filter->dynamic_source_ids;
	}
	has_default_match = GF_FALSE;
	is_pid_excluded = GF_FALSE;

	while (source_ids) {
		Bool all_matched = GF_TRUE;
		Bool all_frags_not_found = GF_TRUE;
		u32 len, sublen;
		Bool last=GF_FALSE;
		char *frag_name, *frag_clone;
		char *sep;
		Bool use_neg = GF_FALSE;
		if (source_ids[0] == src_pid->filter->session->sep_neg) {
			source_ids++;
			use_neg = GF_TRUE;
		}

		sep = strchr(source_ids, src_pid->filter->session->sep_list);
		if (sep) {
			len = (u32) (sep - source_ids);
		} else {
			len = (u32) strlen(source_ids);
			last=GF_TRUE;
		}

		frag_name = strchr(source_ids, src_pid->filter->session->sep_frag);
		if (frag_name > source_ids + len) frag_name = NULL;
		sublen = frag_name ? (u32) (frag_name - source_ids) : len;
		//skip frag char
		if (frag_name) frag_name++;

		//any ID, always match
		if (source_ids[0]=='*') { }
		// id does not match
		else {
			Bool res = strncmp(id, source_ids, sublen) ? GF_FALSE : GF_TRUE;
			if (use_neg) res = !res;
			if (!res) {
				source_ids += len+1;
				if (last) break;
				continue;
			}
		}
		//no fragment or fragment match pid name, OK
		if (!frag_name || !strcmp(src_pid->name, frag_name)) {
			result = GF_TRUE;
			break;
		}
		frag_clone = NULL;
		if (!last) {
			frag_clone = gf_strdup(frag_name);
			char *nsep = strchr(frag_clone, src_pid->filter->session->sep_list);
			assert(nsep);
			nsep[0] = 0;
			frag_name = frag_clone;
		}

		//for all listed fragment extensions
		while (frag_name && all_matched) {
			char prop_dump_buffer[GF_PROP_DUMP_ARG_SIZE];
			Bool needs_resolve = GF_FALSE;
			Bool prop_not_found = GF_FALSE;
			Bool local_pid_excluded = GF_FALSE;
			char *next_frag = strchr(frag_name, src_pid->filter->session->sep_frag);
			if (next_frag) next_frag[0] = 0;

			if (! filter_pid_check_fragment(src_pid, frag_name, &local_pid_excluded, &needs_resolve, &prop_not_found, prop_dump_buffer)) {
				if (needs_resolve) {
					if (first_pass) {
						char *sid = resolved_source_ids ? resolved_source_ids : dst_filter->source_ids;
						char *frag_sep = strchr(frag_name, dst_filter->session->sep_name);
						assert(frag_sep);
						if (next_frag) next_frag[0] = src_pid->filter->session->sep_frag;

						char *new_source_ids = gf_malloc(sizeof(char) * (strlen(sid) + strlen(prop_dump_buffer)+1));
						u32 clen = (u32) (1+frag_sep - sid);
						strncpy(new_source_ids, sid, clen);
						new_source_ids[clen]=0;
						strcat(new_source_ids, prop_dump_buffer);
						if (next_frag) strcat(new_source_ids, next_frag);

						if (resolved_source_ids) gf_free(resolved_source_ids);
						resolved_source_ids = new_source_ids;
						if (frag_clone) gf_free(frag_clone);
						goto sourceid_reassign;
					}
				}
				else {
					all_matched = GF_FALSE;
					//remember we failed because PID was excluded by sourceID
					if (local_pid_excluded)
						is_pid_excluded = GF_TRUE;
				}
			} else {
				//remember we succeed because PID has no matching property
				if (!prop_not_found)
					all_frags_not_found = GF_FALSE;
			}

			if (!next_frag) break;

			next_frag[0] = src_pid->filter->session->sep_frag;
			frag_name = next_frag+1;
		}
		if (frag_clone) gf_free(frag_clone);
		if (all_matched) {
			//exact match on one or more properties, don't look any further
			if (!all_frags_not_found) {
				result = GF_TRUE;
				break;
			}
			//remember we had a default match, but don't set result yet and parse other SIDs
			has_default_match = GF_TRUE;
		}
		*needs_clone = GF_FALSE;
		if (!sep) break;
		source_ids = sep+1;
	}

	if (!result) {
		//we had a default match and pid was not excluded by any SIDs, consider we pass
		if (has_default_match && !is_pid_excluded)
			result = GF_TRUE;
	}

	if (!result) {
		if (resolved_source_ids) gf_free(resolved_source_ids);
		if (dst_filter->dynamic_source_ids && first_pass) {
			first_pass = GF_FALSE;
			goto sourceid_reassign;
		}
		*pid_excluded = is_pid_excluded;
		return GF_FALSE;
	}
	if (resolved_source_ids) {
		if (!dst_filter->dynamic_source_ids) {
			dst_filter->dynamic_source_ids = dst_filter->source_ids;
			dst_filter->source_ids = resolved_source_ids;
		} else {
			gf_free(dst_filter->source_ids);
			dst_filter->source_ids = resolved_source_ids;
		}
	}
	if (!first_pass) {
		*needs_clone = GF_TRUE;
	}
	return GF_TRUE;
}
