_pdfioStreamCreate(
    pdfio_obj_t    *obj,		// I - Object
    pdfio_obj_t    *length_obj,		// I - Length object, if any
    pdfio_filter_t compression)		// I - Compression to apply
{
  pdfio_stream_t	*st;		// Stream


  // Allocate a new stream object...
  if ((st = (pdfio_stream_t *)calloc(1, sizeof(pdfio_stream_t))) == NULL)
  {
    _pdfioFileError(obj->pdf, "Unable to allocate memory for a stream.");
    return (NULL);
  }

  st->pdf        = obj->pdf;
  st->obj        = obj;
  st->length_obj = length_obj;
  st->filter     = compression;
  st->bufptr     = st->buffer;
  st->bufend     = st->buffer + sizeof(st->buffer);

  if (obj->pdf->encryption)
  {
    uint8_t	iv[64];			// Initialization vector
    size_t	ivlen = sizeof(iv);	// Length of initialization vector, if any

    if ((st->crypto_cb = _pdfioCryptoMakeWriter(st->pdf, obj, &st->crypto_ctx, iv, &ivlen)) == NULL)
    {
      // TODO: Add error message?
      free(st);
      return (NULL);
    }

    if (ivlen > 0)
      _pdfioFileWrite(st->pdf, iv, ivlen);
  }

  if (compression == PDFIO_FILTER_FLATE)
  {
    // Flate compression
    pdfio_dict_t *params = pdfioDictGetDict(obj->value.value.dict, "DecodeParms");
					// Decoding parameters
    int bpc = (int)pdfioDictGetNumber(params, "BitsPerComponent");
					// Bits per component
    int colors = (int)pdfioDictGetNumber(params, "Colors");
					// Number of colors
    int columns = (int)pdfioDictGetNumber(params, "Columns");
					// Number of columns
    int predictor = (int)pdfioDictGetNumber(params, "Predictor");
					// Predictory value, if any
    int status;				// ZLIB status code

    PDFIO_DEBUG("_pdfioStreamCreate: FlateDecode - BitsPerComponent=%d, Colors=%d, Columns=%d, Predictor=%d\n", bpc, colors, columns, predictor);

    if (bpc == 0)
    {
      bpc = 8;
    }
    else if (bpc < 1 || bpc == 3 || (bpc > 4 && bpc < 8) || (bpc > 8 && bpc < 16) || bpc > 16)
    {
      _pdfioFileError(st->pdf, "Unsupported BitsPerColor value %d.", bpc);
      free(st);
      return (NULL);
    }

    if (colors == 0)
    {
      colors = 1;
    }
    else if (colors < 0 || colors > 4)
    {
      _pdfioFileError(st->pdf, "Unsupported Colors value %d.", colors);
      free(st);
      return (NULL);
    }

    if (columns == 0)
    {
      columns = 1;
    }
    else if (columns < 0)
    {
      _pdfioFileError(st->pdf, "Unsupported Columns value %d.", columns);
      free(st);
      return (NULL);
    }

    if ((predictor > 1 && predictor < 10) || predictor > 15)
    {
      _pdfioFileError(st->pdf, "Unsupported Predictor function %d.", predictor);
      free(st);
      return (NULL);
    }
    else if (predictor)
    {
      // Using a PNG predictor function
      st->predictor = (_pdfio_predictor_t)predictor;
      st->pbpixel   = (size_t)(bpc * colors + 7) / 8;
      st->pbsize    = (size_t)(bpc * colors * columns + 7) / 8;
      if (predictor >= 10)
	st->pbsize ++;		// Add PNG predictor byte

      if ((st->prbuffer = calloc(1, st->pbsize - 1)) == NULL || (st->psbuffer = calloc(1, st->pbsize)) == NULL)
      {
	_pdfioFileError(st->pdf, "Unable to allocate %lu bytes for Predictor buffers.", (unsigned long)st->pbsize);
	free(st->prbuffer);
	free(st->psbuffer);
	free(st);
	return (NULL);
      }
    }
    else
      st->predictor = _PDFIO_PREDICTOR_NONE;

    st->flate.next_out  = (Bytef *)st->cbuffer;
    st->flate.avail_out = (uInt)sizeof(st->cbuffer);

    if ((status = deflateInit(&(st->flate), 9)) != Z_OK)
    {
      _pdfioFileError(st->pdf, "Unable to start Flate filter: %s", zstrerror(status));
      free(st->prbuffer);
      free(st->psbuffer);
      free(st);
      return (NULL);
    }
  }

  return (st);
}
