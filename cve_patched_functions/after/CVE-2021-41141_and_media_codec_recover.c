static pj_status_t  and_media_codec_recover(pjmedia_codec *codec,
					    unsigned output_buf_len,
					    struct pjmedia_frame *output)
{
    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;
    struct and_media_codec *and_media_data =
					&and_media_codec[codec_data->codec_idx];
    unsigned samples_per_frame;
    pj_bool_t generate_plc = (codec_data->plc_enabled && codec_data->plc);

    PJ_UNUSED_ARG(output_buf_len);

    samples_per_frame = and_media_data->samples_per_frame;
    output->type = PJMEDIA_FRAME_TYPE_AUDIO;
    output->size = samples_per_frame << 1;

    if (generate_plc)
	pjmedia_plc_generate(codec_data->plc, (pj_int16_t*)output->buf);
    else
	pjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);

    return PJ_SUCCESS;
}
