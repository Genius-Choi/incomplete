DltReturnValue dlt_json_filter_save(DltFilter *filter, const char *filename, int verbose)
{
    if ((filter == NULL) || (filename == NULL))
        return DLT_RETURN_WRONG_PARAMETER;

    if(verbose)
        pr_verbose("dlt_json_filter_save()\n");

    char s_app_id[DLT_ID_SIZE + 1];
    char s_context_id[DLT_ID_SIZE + 1];

    json_encoder_t *j_encoder = json_encoder_create();
    json_encoder_start_object(j_encoder, NULL);

    for (int num = 0; num < filter->counter; num++) {
        char filter_name[JSON_FILTER_NAME_SIZE];
        sprintf(filter_name, "filter%i", num);
        json_encoder_start_object(j_encoder, filter_name);

        strncpy(s_app_id, filter->apid[num], DLT_ID_SIZE);

        if (filter->apid[num][DLT_ID_SIZE - 1] != 0)
            s_app_id[DLT_ID_SIZE] = '\0';

        strncpy(s_context_id, filter->ctid[num], DLT_ID_SIZE);

        if (filter->ctid[num][DLT_ID_SIZE - 1] != 0)
            s_context_id[DLT_ID_SIZE] = '\0';

        json_encoder_add_string(j_encoder, "AppId", s_app_id);
        json_encoder_add_string(j_encoder, "ContextId", s_context_id);
        json_encoder_add_int(j_encoder, "LogLevel", filter->log_level[num]);
        json_encoder_add_int(j_encoder, "PayloadMin", filter->payload_min[num]);
        json_encoder_add_int(j_encoder, "PayloadMax", filter->payload_max[num]);

        json_encoder_end_object(j_encoder);
    }

    json_encoder_end_object(j_encoder);

    printf("Saving current filter into '%s'\n", filename);
    FILE *handle = fopen(filename, "w");
    int filter_buffer_size = 100 * (filter->counter);
    char filter_buffer[filter_buffer_size];
    snprintf(filter_buffer, filter_buffer_size, json_encoder_buffer(j_encoder));
    fprintf(handle, filter_buffer);

    fclose(handle);
    json_encoder_destroy(j_encoder);

    return DLT_RETURN_OK;
}
