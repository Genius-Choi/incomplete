void DCR_CLASS dcr_sony_arw2_load_raw(DCRAW* p)
{
	uchar *data, *dp;
	ushort pix[16];
	int row, col, val, max, min, imax, imin, sh, bit, i;

	data = (uchar *) malloc (p->raw_width*p->tiff_bps >> 3);
	dcr_merror (p, data, "sony_arw2_load_raw()");
	for (row=0; row < p->height; row++) {
		dcr_fread(p->obj_, data, 1, p->raw_width*p->tiff_bps >> 3);
		if (p->tiff_bps == 8) {
			for (dp=data, col=0; col < p->width-30; dp+=16) {
				max = 0x7ff & (val = dcr_sget4(p, dp));
				min = 0x7ff & val >> 11;
				imax = 0x0f & val >> 22;
				imin = 0x0f & val >> 26;
				for (sh=0; sh < 4 && 0x80 << sh <= max-min; sh++);
				for (bit=30, i=0; i < 16; i++)
					if      (i == imax) pix[i] = max;
					else if (i == imin) pix[i] = min;
					else {
						pix[i] = ((dcr_sget2(p, dp+(bit >> 3)) >> (bit & 7) & 0x7f) << sh) + min;
						if (pix[i] > 0x7ff) pix[i] = 0x7ff;
						bit += 7;
					}
					for (i=0; i < 16; i++, col+=2)
						BAYER(row,col) = p->curve[pix[i] << 1] >> 1;
					col -= col & 1 ? 1:31;
			}
		} else if (p->tiff_bps == 12)
			for (dp=data, col=0; col < p->width; dp+=3, col+=2) {
				BAYER(row,col)   = ((dp[1] << 8 | dp[0]) & 0xfff) << 1;
				BAYER(row,col+1) =  (dp[2] << 4 | dp[1] >> 4) << 1;
			}
	}
	free (data);
}
