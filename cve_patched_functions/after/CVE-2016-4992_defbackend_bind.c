defbackend_bind( Slapi_PBlock *pb )
{
    int			rc;
    ber_tag_t		method;
    struct berval	*cred;

    LDAPDebug( LDAP_DEBUG_TRACE, "defbackend_bind\n", 0, 0, 0 );

    /*
     * Accept simple binds that do not contain passwords (but do not
     * update the bind DN field in the connection structure since we don't
     * grant access based on these "NULL binds")
     */
    slapi_pblock_get( pb, SLAPI_BIND_METHOD, &method );
    slapi_pblock_get( pb, SLAPI_BIND_CREDENTIALS, &cred );
    if ( method == LDAP_AUTH_SIMPLE && cred->bv_len == 0 ) {
        slapi_counter_increment(g_get_global_snmp_vars()->ops_tbl.dsAnonymousBinds);
        rc = SLAPI_BIND_ANONYMOUS;
    } else {
        Slapi_DN *sdn = NULL;
        char *suffix = NULL;
        char **dns = NULL;
        
        if (pb->pb_op) {
            sdn = operation_get_target_spec(pb->pb_op);
            if (sdn) {
                dns = slapi_ldap_explode_dn(slapi_sdn_get_dn(sdn), 0);
                if (dns) {
                    size_t dnlen = slapi_sdn_get_ndn_len(sdn);
                    size_t len = dnlen + sizeof(DEFBE_NO_SUCH_SUFFIX) + 4;
                    suffix = slapi_ch_malloc(len);
                    if (dnlen) {
                        _defbackend_gen_returntext(suffix, len, dns);
                    } else {
                        PR_snprintf(suffix, len, "%s", DEFBE_NO_SUCH_SUFFIX);
                    }
                }
            }
        }
        if (suffix) {
            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, suffix);
        } else {
            slapi_pblock_set(pb, SLAPI_PB_RESULT_TEXT, DEFBE_NO_SUCH_SUFFIX);
        }
        send_ldap_result(pb, LDAP_INVALID_CREDENTIALS, NULL, "", 0, NULL);
        if (dns) {
            slapi_ldap_value_free(dns);
        }
        slapi_ch_free_string(&suffix);
        rc = SLAPI_BIND_FAIL;
    }

    return( rc );
}
