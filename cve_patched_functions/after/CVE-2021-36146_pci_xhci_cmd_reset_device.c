pci_xhci_cmd_reset_device(struct pci_xhci_vdev *xdev, uint32_t slot)
{
	struct pci_xhci_dev_emu *dev;
	struct xhci_dev_ctx     *dev_ctx;
	struct xhci_endp_ctx    *ep_ctx;
	uint32_t	cmderr;
	int		i;

	cmderr = XHCI_TRB_ERROR_NO_SLOTS;
	if (xdev->portregs == NULL)
		goto done;

	UPRINTF(LDBG, "pci_xhci reset device slot %u\r\n", slot);

	dev = XHCI_SLOTDEV_PTR(xdev, slot);
	if (!dev || dev->dev_slotstate == XHCI_ST_DISABLED)
		cmderr = XHCI_TRB_ERROR_SLOT_NOT_ON;
	else {
		dev->dev_slotstate = XHCI_ST_DEFAULT;

		dev_ctx = pci_xhci_get_dev_ctx(xdev, slot);
		if (!dev_ctx) {
			cmderr = XHCI_TRB_ERROR_SLOT_NOT_ON;
			goto done;
		}

		/* slot state */
		dev_ctx->ctx_slot.dwSctx3 =
			FIELD_REPLACE(dev_ctx->ctx_slot.dwSctx3,
				      XHCI_ST_SLCTX_DEFAULT, 0x1F, 27);

		/* number of contexts */
		dev_ctx->ctx_slot.dwSctx0 =
			FIELD_REPLACE(dev_ctx->ctx_slot.dwSctx0, 1, 0x1F, 27);

		/* reset all eps other than ep-0 */
		for (i = 2; i <= 31; i++) {
			ep_ctx = &dev_ctx->ctx_ep[i];
			ep_ctx->dwEpCtx0 =
				FIELD_REPLACE(ep_ctx->dwEpCtx0,
					      XHCI_ST_EPCTX_DISABLED, 0x7, 0);
		}

		cmderr = XHCI_TRB_ERROR_SUCCESS;
	}

	pci_xhci_reset_slot(xdev, slot);

done:
	return cmderr;
}
