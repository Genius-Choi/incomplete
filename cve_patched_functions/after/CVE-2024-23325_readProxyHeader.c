ReadOrParseState Filter::readProxyHeader(Network::ListenerFilterBuffer& buffer) {
  auto raw_slice = buffer.rawSlice();
  const char* buf = static_cast<const char*>(raw_slice.mem_);

  if (config_.get()->allowRequestsWithoutProxyProtocol()) {
    auto matchv2 = !memcmp(buf, PROXY_PROTO_V2_SIGNATURE,
                           std::min<size_t>(PROXY_PROTO_V2_SIGNATURE_LEN, raw_slice.len_));
    auto matchv1 = !memcmp(buf, PROXY_PROTO_V1_SIGNATURE,
                           std::min<size_t>(PROXY_PROTO_V1_SIGNATURE_LEN, raw_slice.len_));
    if (!matchv2 && !matchv1) {
      // The bytes we have seen so far do not match v1 or v2 proxy protocol, so we can safely
      // short-circuit
      ENVOY_LOG(trace, "request does not use v1 or v2 proxy protocol, forwarding as is");
      return ReadOrParseState::SkipFilter;
    }
  }

  if (raw_slice.len_ >= PROXY_PROTO_V2_HEADER_LEN) {
    const char* sig = PROXY_PROTO_V2_SIGNATURE;
    if (!memcmp(buf, sig, PROXY_PROTO_V2_SIGNATURE_LEN)) {
      header_version_ = V2;
    } else if (memcmp(buf, PROXY_PROTO_V1_SIGNATURE, PROXY_PROTO_V1_SIGNATURE_LEN)) {
      // It is not v2, and can't be v1, so no sense hanging around: it is invalid
      ENVOY_LOG(debug, "failed to read proxy protocol (exceed max v1 header len)");
      return ReadOrParseState::Error;
    }
  }

  if (header_version_ == V2) {
    const int ver_cmd = buf[PROXY_PROTO_V2_SIGNATURE_LEN];
    if (((ver_cmd & 0xf0) >> 4) != PROXY_PROTO_V2_VERSION) {
      ENVOY_LOG(debug, "Unsupported V2 proxy protocol version");
      return ReadOrParseState::Error;
    }
    absl::optional<ssize_t> addr_len_opt = lenV2Address(buf);
    if (!addr_len_opt.has_value()) {
      return ReadOrParseState::Error;
    }
    ssize_t addr_len = addr_len_opt.value();
    uint8_t upper_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 2];
    uint8_t lower_byte = buf[PROXY_PROTO_V2_HEADER_LEN - 1];
    ssize_t hdr_addr_len = (upper_byte << 8) + lower_byte;
    if (hdr_addr_len < addr_len) {
      ENVOY_LOG(debug,
                "incorrect address length, address length = {}, the expected address length = {}",
                hdr_addr_len, addr_len);
      return ReadOrParseState::Error;
    }
    // waiting for more data if there is no enough data for address.
    if (raw_slice.len_ >= static_cast<size_t>(PROXY_PROTO_V2_HEADER_LEN + addr_len)) {
      // The TLV remain, they are parsed in `parseTlvs()` which is called from the
      // parent (if needed).
      if (parseV2Header(buf)) {
        return ReadOrParseState::Done;
      } else {
        return ReadOrParseState::Error;
      }
    }
  } else {
    // continue searching buffer from where we left off
    for (; search_index_ < raw_slice.len_; search_index_++) {
      if (buf[search_index_] == '\n' && buf[search_index_ - 1] == '\r') {
        if (search_index_ == 1) {
          // There is not enough data to determine if it contains the v2 protocol signature, so wait
          // for more data.
          break;
        } else {
          header_version_ = V1;
          search_index_++;
        }
        break;
      }
    }

    if (search_index_ > MAX_PROXY_PROTO_LEN_V1) {
      return ReadOrParseState::Error;
    }

    if (header_version_ == V1) {
      if (parseV1Header(buf, search_index_)) {
        return ReadOrParseState::Done;
      } else {
        return ReadOrParseState::Error;
      }
    }
  }

  return ReadOrParseState::TryAgainLater;
}
