void ByteCodeGenerator::EmitInternalScopedSlotStore(FuncInfo *funcInfo, Js::RegSlot slot, Js::RegSlot symbolRegister)
{
    Assert(slot != Js::Constants::NoProperty);

    Scope* scope = nullptr;
    Js::OpCode opcode;

    Js::PropertyId envIndex = -1;
    if (funcInfo->IsLambda())
    {
        GetEnclosingNonLambdaScope(funcInfo, scope, envIndex);
    }
    else
    {
        scope = funcInfo->GetBodyScope();
    }

    Js::RegSlot scopeLocation = scope->GetLocation();
    opcode = this->GetStSlotOp(scope, envIndex, scopeLocation, false, funcInfo);
    slot += (scope->GetIsObject() ? 0 : Js::ScopeSlots::FirstSlotIndex);

    if (envIndex != -1)
    {
        this->m_writer.SlotI2(opcode, symbolRegister, envIndex + Js::FrameDisplay::GetOffsetOfScopes() / sizeof(Js::Var), slot);
    }
    else if (scopeLocation != Js::Constants::NoRegister &&
        (scopeLocation == funcInfo->frameSlotsRegister || scopeLocation == funcInfo->frameObjRegister))
    {
        this->m_writer.SlotI1(opcode, symbolRegister, slot);
    }
    else if (scope->GetIsObject())
    {
        this->m_writer.Slot(opcode, symbolRegister, scopeLocation, slot);
    }
    else
    {
        this->m_writer.SlotI2(opcode, symbolRegister, scope->GetInnerScopeIndex(), slot);
    }
}
