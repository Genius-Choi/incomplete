int quicly_send(quicly_conn_t *conn, quicly_address_t *dest, quicly_address_t *src, struct iovec *datagrams, size_t *num_datagrams,
                void *buf, size_t bufsize)
{
    quicly_send_context_t s = {.current = {.first_byte = -1},
                               .datagrams = datagrams,
                               .max_datagrams = *num_datagrams,
                               .payload_buf = {.datagram = buf, .end = (uint8_t *)buf + bufsize},
                               .first_packet_number = conn->egress.packet_number};
    int ret;

    lock_now(conn, 0);

    /* bail out if there's nothing is scheduled to be sent */
    if (conn->stash.now < quicly_get_first_timeout(conn)) {
        ret = 0;
        goto Exit;
    }

    QUICLY_PROBE(SEND, conn, conn->stash.now, conn->super.state,
                 QUICLY_PROBE_HEXDUMP(conn->super.remote.cid_set.cids[0].cid.cid, conn->super.remote.cid_set.cids[0].cid.len));
    QUICLY_LOG_CONN(send, conn, {
        PTLS_LOG_ELEMENT_SIGNED(state, conn->super.state);
        PTLS_LOG_ELEMENT_HEXDUMP(dcid, conn->super.remote.cid_set.cids[0].cid.cid, conn->super.remote.cid_set.cids[0].cid.len);
    });

    if (conn->super.state >= QUICLY_STATE_CLOSING) {
        quicly_sentmap_iter_t iter;
        if ((ret = init_acks_iter(conn, &iter)) != 0)
            goto Exit;
        /* check if the connection can be closed now (after 3 pto) */
        if (conn->super.state == QUICLY_STATE_DRAINING ||
            conn->super.stats.num_frames_sent.transport_close + conn->super.stats.num_frames_sent.application_close != 0) {
            if (quicly_sentmap_get(&iter)->packet_number == UINT64_MAX) {
                assert(quicly_num_streams(conn) == 0);
                ret = QUICLY_ERROR_FREE_CONNECTION;
                goto Exit;
            }
        }
        if (conn->super.state == QUICLY_STATE_CLOSING && conn->egress.send_ack_at <= conn->stash.now) {
            /* destroy all streams; doing so is delayed until the emission of CONNECTION_CLOSE frame to allow quicly_close to be
             * called from a stream handler */
            destroy_all_streams(conn, 0, 0);
            /* send CONNECTION_CLOSE in all possible epochs */
            for (size_t epoch = 0; epoch < QUICLY_NUM_EPOCHS; ++epoch) {
                if ((ret = send_connection_close(conn, epoch, &s)) != 0)
                    goto Exit;
            }
            if ((ret = commit_send_packet(conn, &s, 0)) != 0)
                goto Exit;
        }
        /* wait at least 1ms */
        if ((conn->egress.send_ack_at = quicly_sentmap_get(&iter)->sent_at + get_sentmap_expiration_time(conn)) <= conn->stash.now)
            conn->egress.send_ack_at = conn->stash.now + 1;
        ret = 0;
        goto Exit;
    }

    /* emit packets */
    if ((ret = do_send(conn, &s)) != 0)
        goto Exit;

    assert_consistency(conn, 1);

Exit:
    clear_datagram_frame_payloads(conn);
    if (s.num_datagrams != 0) {
        *dest = conn->super.remote.address;
        *src = conn->super.local.address;
    }
    *num_datagrams = s.num_datagrams;
    unlock_now(conn);
    return ret;
}
