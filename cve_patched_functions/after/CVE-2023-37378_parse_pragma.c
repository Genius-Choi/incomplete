int CEXEBuild::parse_pragma(LineParser &line)
{
  const int rvSucc = PS_OK, rvWarn = PS_WARNING, rvErr = PS_WARNING; // rvErr is not PS_ERROR because we want !pragma parsing to be very forgiving.
  const TCHAR badParamMsg[] = _T("Unknown pragma");

  if (line.gettoken_enum(1, _T("internal\0")) == 0)
  {
    if (line.gettoken_enum(2, _T("x\0")) == 0)
    {
      const TCHAR *name = line.gettoken_str(3);
      int succ, num = line.gettoken_intx(4, &succ);SCRIPT_MSG(_T("%#x %d\n"),num,succ);
      return ((succ ? definedlist.set_si32(name, num) : definedlist.set(name, _T(""))), rvSucc);
    }
    return rvErr;
  }

  if (line.gettoken_enum(1, _T("verifyloadimage\0")) == 0)
  {
    bool valid = LoadImageCanLoadFile(line.gettoken_str(2));
    return valid ? rvSucc : (warning_fl(DW_BADFORMAT_EXTERNAL_FILE, _T("Unsupported format %") NPRIs, line.gettoken_str(2)), rvWarn);
  }

  // 2.47 shipped with a corrupted CHM file (bug #1129). This minimal verification command exists because the !searchparse hack we added does not work with codepage 936!
  if (line.gettoken_enum(1, _T("verifychm\0")) == 0)
  {
    struct { UINT32 Sig, Ver, cbH; } chm;
    NIStream f;
    bool valid = f.OpenFileForReading(line.gettoken_str(2), NStreamEncoding::BINARY);
    valid = valid && 12 == f.ReadOctets(&chm, 12);
    valid = valid && FIX_ENDIAN_INT32(chm.Sig) == 0x46535449 && (FIX_ENDIAN_INT32(chm.Ver)|1) == 3; // 'ITSF' v2..3
    return valid ? rvSucc : (ERROR_MSG(_T("Error: Invalid format\n")), PS_ERROR);
  }

  if (line.gettoken_enum(1, _T("w\150i\160\0")) == 0)
  {
    int succ, ec = line.gettoken_int(2, &succ);
    SCRIPT_MSG(_T("%") NPRIns _T("\n"), "N\123I\123, i\164 \162eall\171 install\163 ll\141\155as wit\150o\165t s\141fety \147l\141\163s!");
    exit(succ ? ec : 1);
  }

  if (line.gettoken_enum(1, _T("warning\0")) == -1)
    return (warning_fl(DW_PP_PRAGMA_UNKNOWN, _T("Unknown pragma")), rvErr);

  enum { woperr = 0, wopwar, wopdis, wopena, wopdef, woppus, woppop, invalidwop };
  int warnOp = line.gettoken_enum(2, _T("error\0warning\0disable\0enable\0default\0push\0pop\0")), ret = rvSucc;
  if (warnOp < 0)
    ret = rvErr, warning_fl(DW_PP_PRAGMA_UNKNOWN, badParamMsg); // Unknown warning pragma action
  else if (warnOp == woppus) // warning: push
    diagstate.push();
  else if (warnOp == woppop) // warning: pop
  {
    if (!diagstate.pop())
      ret = rvWarn, warning_fl(DW_PP_PRAGMA_INVALID, _T("Unexpected"));
  }
  else // warning: error/warning/disable/enable/default <%code%|all> [..]
  {
    for (int ti = 3; ti < line.getnumtokens(); ++ti)
    {
      DIAGCODE code = static_cast<DIAGCODE>(line.gettoken_int(ti));
      bool all = line.gettoken_enum(ti, _T("all\0")) == 0, isCode = diagstate.is_valid_code(code);
      switch((isCode||all) ? warnOp : invalidwop)
      {
      case woperr: all ? diagstate.set_all(DiagState::werror) : diagstate.error(code); break;
      case wopwar: all ? diagstate.set_all(DiagState::wwarning) : diagstate.warning(code); break;
      case wopdis: all ? diagstate.set_all(DiagState::wdisabled) : diagstate.disable(code); break;
      case wopena: all ? diagstate.set_all(DiagState::wenabled) : diagstate.enable(code); break;
      case wopdef: all ? diagstate.set_all(DiagState::get_default_state()) : diagstate.def(code); break;
      default: ret = rvWarn, warning_fl(DW_PP_PRAGMA_INVALID, _T("Invalid number: \"%") NPRIs _T("\""), line.gettoken_str(ti));
      }
    }
  }
  return ret;
}
