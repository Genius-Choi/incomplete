insn_t *kvx_next_insn(bundle_t *bundle, ut64 addr, const ut8 *buf, int len) {
	ut32 words[KVX_MAX_BUNDLE_WORDS];
	ut64 start;
	int count, issue = KVX_MAX_BUNDLE_ISSUE;
	int ret;

	if (bundle->addr <= addr && addr < (bundle->addr + bundle->size)) {
		start = bundle->addr;
		issue = 0;
		for (issue = 0; issue < KVX_MAX_BUNDLE_ISSUE; issue++) {
			if (addr == start) {
				break;
			}
			start += bundle->issue[issue].len * sizeof (ut32);
		}
		while (issue < KVX_MAX_BUNDLE_ISSUE && bundle->issue[issue].len == 0) {
			issue++;
		}
	}

	if (issue == KVX_MAX_BUNDLE_ISSUE) {
		memset (bundle, 0, sizeof (*bundle));
		issue = 0;

		count = read_bundle (words, buf, len);
		if (count == 0)
			return NULL;

		bundle->addr = addr;
		bundle->size = count * sizeof (ut32);
		ret = disassemble_bundle (bundle, words, count);
		if (ret)
			return NULL;
	}

	while (issue < KVX_MAX_BUNDLE_ISSUE && bundle->issue[issue].len == 0) {
		issue++;
	}

	if (issue < KVX_MAX_BUNDLE_ISSUE) {
		return &bundle->issue[issue];
	}

	return NULL;
}
