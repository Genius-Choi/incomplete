static size_t mg_tcpip_driver_imxrt1020_tx(const void *buf, size_t len, struct mg_tcpip_if *ifp) {

  if (len > sizeof(tx_data_buffer[ENET_TXBD_NUM])) {
  //  MG_ERROR(("Frame too big, %ld", (long) len));
    len = 0;  // Frame is too big
  } else if ((tx_buffer_descriptor[s_rt1020_txno].control & BIT(15))) {
  MG_ERROR(("No free descriptors"));
    // printf("D0 %lx SR %lx\n", (long) s_txdesc[0][0], (long) ETH->DMASR);
    len = 0;  // All descriptors are busy, fail
  } else {
    memcpy(tx_data_buffer[s_rt1020_txno], buf, len);     // Copy data
    tx_buffer_descriptor[s_rt1020_txno].length = (uint16_t) len;  // Set data len
    tx_buffer_descriptor[s_rt1020_txno].control |= (uint16_t)(BIT(10)); // TC (transmit CRC)
    //  tx_buffer_descriptor[s_rt1020_txno].control &= (uint16_t)(BIT(14) | BIT(12)); // Own doesn't affect HW
    tx_buffer_descriptor[s_rt1020_txno].control |= (uint16_t)(BIT(15) | BIT(11)); // R+L (ready+last)
    ENET->TDAR = BIT(24); // Descriptor updated. Hand over to DMA.
    // INFO
    // Relevant Descriptor bits: 15(R)  Ready
    //                           11(L)  last in frame
    //                           10(TC) transmis CRC
    // __DSB(); // ARM errata 838869 Cortex-M4, M4F, M7, M7F: "store immediate overlapping
                // exception" return might vector to incorrect interrupt.
    if (++s_rt1020_txno >= ENET_TXBD_NUM) s_rt1020_txno = 0;
  }
  (void) ifp;
  return len;
}
