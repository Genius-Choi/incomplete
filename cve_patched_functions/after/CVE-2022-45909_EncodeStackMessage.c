    void EncodeStackMessage( const sip_t* sip, string& encodedMessage ) {
        encodedMessage.clear() ;
        const sip_common_t* p = NULL ;
        if( sip->sip_request ) {
            sip_header_t* hdr = (sip_header_t *) sip->sip_request ;
            p = hdr->sh_common ;
        }
        else if( sip->sip_status ) {
            sip_header_t* hdr = (sip_header_t *) sip->sip_status ;
            p = hdr->sh_common ;
        }

        while( NULL != p) {
            if( NULL != p->h_data ) {
                //take the original fragment if it exists since this will be more efficient
               encodedMessage.append( (char *)p->h_data, p->h_len ) ;            
            }
            else {
                //otherwise, encode the sip header 
                char buf[8192] ;
                issize_t n = msg_header_e(buf, 8192, reinterpret_cast<const msg_header_t *>(p), 0) ;
                encodedMessage.append( buf, n ) ;
            }
            p = p->h_succ->sh_common ;
        }
    }
