static int ast_rtp_bundle(struct ast_rtp_instance *child, struct ast_rtp_instance *parent)
{
	struct ast_rtp *child_rtp = ast_rtp_instance_get_data(child);
	struct ast_rtp *parent_rtp;
	struct rtp_ssrc_mapping mapping;
	struct ast_sockaddr them = { { 0, } };

	if (child_rtp->bundled == parent) {
		return 0;
	}

	/* If this instance was already bundled then remove the SSRC mapping */
	if (child_rtp->bundled) {
		struct ast_rtp *bundled_rtp;

		ao2_unlock(child);

		/* The child lock can't be held while accessing the parent */
		ao2_lock(child_rtp->bundled);
		bundled_rtp = ast_rtp_instance_get_data(child_rtp->bundled);
		AST_VECTOR_REMOVE_CMP_UNORDERED(&bundled_rtp->ssrc_mapping, child, SSRC_MAPPING_ELEM_CMP, AST_VECTOR_ELEM_CLEANUP_NOOP);
		ao2_unlock(child_rtp->bundled);

		ao2_lock(child);
		ao2_ref(child_rtp->bundled, -1);
		child_rtp->bundled = NULL;
	}

	if (!parent) {
		/* We transitioned away from bundle so we need our own transport resources once again */
		rtp_allocate_transport(child, child_rtp);
		return 0;
	}

	parent_rtp = ast_rtp_instance_get_data(parent);

	/* We no longer need any transport related resources as we will use our parent RTP instance instead */
	rtp_deallocate_transport(child, child_rtp);

	/* Children maintain a reference to the parent to guarantee that the transport doesn't go away on them */
	child_rtp->bundled = ao2_bump(parent);

	mapping.ssrc = child_rtp->themssrc;
	mapping.ssrc_valid = child_rtp->themssrc_valid;
	mapping.instance = child;

	ao2_unlock(child);

	ao2_lock(parent);

	AST_VECTOR_APPEND(&parent_rtp->ssrc_mapping, mapping);

#if defined(HAVE_OPENSSL) && (OPENSSL_VERSION_NUMBER >= 0x10001000L) && !defined(OPENSSL_NO_SRTP)
	/* If DTLS-SRTP is already in use then add the local SSRC to it, otherwise it will get added once DTLS
	 * negotiation has been completed.
	 */
	if (parent_rtp->dtls.connection == AST_RTP_DTLS_CONNECTION_EXISTING) {
		dtls_srtp_add_local_ssrc(parent_rtp, parent, 0, child_rtp->ssrc, 0);
	}
#endif

	/* Bundle requires that RTCP-MUX be in use so only the main remote address needs to match */
	ast_rtp_instance_get_remote_address(parent, &them);

	ao2_unlock(parent);

	ao2_lock(child);

	ast_rtp_instance_set_remote_address(child, &them);

	return 0;
}
