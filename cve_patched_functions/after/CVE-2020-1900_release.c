void ObjectData::release(ObjectData* obj, const Class* cls) noexcept {
  assertx(obj->kindIsValid());
  assertx(!obj->hasInstanceDtor());
  assertx(!obj->hasNativeData());
  assertx(obj->getVMClass() == cls);
  assertx(cls->releaseFunc() == &ObjectData::release);
  assertx(obj->props()->checkInvariants(cls->numDeclProperties()));

  // Note: cleanups done in this function are only run for classes without an
  // instanceDtor. Some of these cleanups are duplicated in ~ObjectData, and
  // your instanceDtor may call that to have them run; if you choose not to run
  // ~ObjectData from your instanceDtor you MUST do some of them manually
  // (e.g. invalidate WeakRefs). Some cleanups (e.g. clearing memo caches) are
  // not done from ~ObjectData because it is assumed they're not needed for
  // builtin classes (and in the case of memo caches, since the clearing needs
  // to be done differently when there is native data).
  // Finally, cleanups such as invalidating WeakRefs that have to be done for
  // correctness MUST also be done in Collector::sweep, since none of the code
  // in this function or the instanceDtor will be run when the object is
  // collected by GC.

  // `obj' is being torn down now---be careful about where/how you dereference
  // it from here on.

  obj->props()->release(cls->countablePropsEnd());

  if (UNLIKELY(obj->slowDestroyCheck())) {
    obj->slowDestroyCases();
  } else {
    assertx((obj->m_aux16 & BigAllocSize) == 0);
    auto const memoSize = cls->memoSize();
    auto const ptr = reinterpret_cast<char*>(obj) - memoSize;
    assertx(memoSize == 0 ||
            reinterpret_cast<const MemoNode*>(ptr)->objOff() == memoSize);

    tl_heap->freeSmallIndex(ptr, cls->sizeIdx());
  }

  AARCH64_WALKABLE_FRAME();
}
