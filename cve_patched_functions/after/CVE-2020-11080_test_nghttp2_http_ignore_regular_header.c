void test_nghttp2_http_ignore_regular_header(void) {
  nghttp2_session *session;
  nghttp2_session_callbacks callbacks;
  nghttp2_hd_deflater deflater;
  nghttp2_mem *mem;
  nghttp2_bufs bufs;
  ssize_t rv;
  my_user_data ud;
  const nghttp2_nv bad_reqnv[] = {
      MAKE_NV(":authority", "localhost"),
      MAKE_NV(":scheme", "https"),
      MAKE_NV(":path", "/"),
      MAKE_NV(":method", "GET"),
      MAKE_NV("foo", "\x0zzz"),
      MAKE_NV("bar", "buzz"),
  };
  const nghttp2_nv bad_ansnv[] = {
      MAKE_NV(":authority", "localhost"), MAKE_NV(":scheme", "https"),
      MAKE_NV(":path", "/"), MAKE_NV(":method", "GET"), MAKE_NV("bar", "buzz")};
  size_t proclen;
  size_t i;
  nghttp2_outbound_item *item;

  mem = nghttp2_mem_default();
  frame_pack_bufs_init(&bufs);

  memset(&callbacks, 0, sizeof(nghttp2_session_callbacks));
  callbacks.send_callback = null_send_callback;
  callbacks.on_header_callback = pause_on_header_callback;

  nghttp2_session_server_new(&session, &callbacks, &ud);
  nghttp2_hd_deflate_init(&deflater, mem);

  rv = pack_headers(&bufs, &deflater, 1,
                    NGHTTP2_FLAG_END_HEADERS | NGHTTP2_FLAG_END_STREAM,
                    bad_reqnv, ARRLEN(bad_reqnv), mem);

  CU_ASSERT_FATAL(0 == rv);

  nghttp2_hd_deflate_free(&deflater);

  proclen = 0;

  for (i = 0; i < 4; ++i) {
    rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,
                                  nghttp2_buf_len(&bufs.head->buf) - proclen);
    CU_ASSERT_FATAL(rv > 0);
    proclen += (size_t)rv;
    CU_ASSERT(nghttp2_nv_equal(&bad_ansnv[i], &ud.nv));
  }

  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,
                                nghttp2_buf_len(&bufs.head->buf) - proclen);
  CU_ASSERT_FATAL(rv > 0);
  /* Without on_invalid_frame_recv_callback, bad header causes stream
     reset */
  item = nghttp2_session_get_next_ob_item(session);

  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);

  proclen += (size_t)rv;

  CU_ASSERT(nghttp2_buf_len(&bufs.head->buf) == proclen);

  nghttp2_session_del(session);

  /* use on_invalid_header_callback */
  callbacks.on_invalid_header_callback = pause_on_invalid_header_callback;

  nghttp2_session_server_new(&session, &callbacks, &ud);

  proclen = 0;

  ud.invalid_header_cb_called = 0;

  for (i = 0; i < 4; ++i) {
    rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,
                                  nghttp2_buf_len(&bufs.head->buf) - proclen);
    CU_ASSERT_FATAL(rv > 0);
    proclen += (size_t)rv;
    CU_ASSERT(nghttp2_nv_equal(&bad_ansnv[i], &ud.nv));
  }

  CU_ASSERT(0 == ud.invalid_header_cb_called);

  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,
                                nghttp2_buf_len(&bufs.head->buf) - proclen);

  CU_ASSERT_FATAL(rv > 0);
  CU_ASSERT(1 == ud.invalid_header_cb_called);
  CU_ASSERT(nghttp2_nv_equal(&bad_reqnv[4], &ud.nv));

  proclen += (size_t)rv;

  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos + proclen,
                                nghttp2_buf_len(&bufs.head->buf) - proclen);

  CU_ASSERT(rv > 0);
  CU_ASSERT(nghttp2_nv_equal(&bad_ansnv[4], &ud.nv));

  nghttp2_session_del(session);

  /* make sure that we can reset stream from
     on_invalid_header_callback */
  callbacks.on_header_callback = on_header_callback;
  callbacks.on_invalid_header_callback = reset_on_invalid_header_callback;

  nghttp2_session_server_new(&session, &callbacks, &ud);

  rv = nghttp2_session_mem_recv(session, bufs.head->buf.pos,
                                nghttp2_buf_len(&bufs.head->buf));

  CU_ASSERT(rv == (ssize_t)nghttp2_buf_len(&bufs.head->buf));

  item = nghttp2_session_get_next_ob_item(session);

  CU_ASSERT(NGHTTP2_RST_STREAM == item->frame.hd.type);
  CU_ASSERT(1 == item->frame.hd.stream_id);

  nghttp2_session_del(session);
  nghttp2_bufs_free(&bufs);
}
