int IniParser::parse_helper(IniSection&ini)
{
    string comment = "";
    string key = "";
    string val = "";
    int state = 0;		// 1: precessing a multiline value
    int matched_by = -1;

    string line;
    size_t i;

    // stack of open sections, innermost at front
    list<IniSection *> open_sections;

    //
    // read line
    //
    while (!scanner_get (line))
	{
	    //
	    // check for whole-line comment (always as the first stage)
	    //
	    for (i = 0;i<linecomments.size (); i++)
		{
		    if (RegexMatch (linecomments[i], line, 0))
			{
			    // we have it !!!
			    comment = comment + line + "\n";
			    break;
			}
		}
	    if (i<linecomments.size ()) // found? -> next line
		continue;

	    //
	    // check for comments on line
	    //
	    if (!comments_last)
		{
		    for (i = 0;i<comments.size (); i++)
			{
			    RegexMatch m (comments[i], line);
			    if (m)
			    {
				// we have it !!!
				comment = comment + m[0] + "\n";
				line = m.rest;
				break;
			    }
			}
		}

	    //
	    // are we in broken line?
	    //
	    if (state)
		{
		    RegexMatch m (params[matched_by].end, line);
		    if (m)
		    {    
			// it is the end of broken line
			state = 0;
			val = val + (join_multiline ? " " : "\n") + m[1];
			line = m.rest;
			if (open_sections.empty ())
			    {   // we are in toplevel section, going deeper
				// check for toplevel values allowance
				if (!global_values)
				    scanner_error ("%s: values at the top level not allowed.", key.c_str ());
				else
				    ini.initValue (key, val, comment, matched_by);
			    }
			else {
			    open_sections.front()->initValue(key, val, comment, matched_by);
			}
			comment = "";
		    }
		    else
			val = val + (join_multiline ? " " : "\n") + line;
		}
	    if (!state)
		{
		    //
		    // check for section begin
		    //
		    {
			string found;

			for (i = 0; i < sections.size (); i++)
			    {
				RegexMatch m (sections[i].begin.rx, line);
				if (m)
				{
				    found = m[1];
				    line = m.rest;
				    break;
				}
			    }
			if (i < sections.size ())
			    {
				// section begin found !!! check conditions
				if (!open_sections.empty())
				    {   // there were some sections
					// is there need to close previous section?
					IniSection * cur = open_sections.front();
					if (sectionNeedsEnd(cur->getReadBy()))
					    {
						if(no_nested_sections)
						    {
							scanner_error ("Section %s started but section %s is not finished",
								 found.c_str(),
								 cur->getName());
							open_sections.pop_front();
						    }
					    }
					else
					    open_sections.pop_front();
				    }

				IniSection * parent = NULL;
				if (open_sections.empty())
				    {   // we are in toplevel section, going deeper
					parent = &ini;
				    }
				else
				    {
					if (no_nested_sections)
					    scanner_error ("Attempt to create nested section %s.", found.c_str ());
					else
					{
					    parent = open_sections.front();
					}
				    }

				if (parent)
				    open_sections.push_front (& parent->initSection (found, comment, i));

				comment = "";
			    }
		    } // check for section begin

		    //
		    // check for section end
		    //
		    {
			string found;

			for (i = 0; i < sections.size (); i++)
			    {
				if (!sections[i].end_valid)
				    continue;
				RegexMatch m (sections[i].end.rx, line);
				if (m)
				{
				    found = 1 < m.matches.size () ? m[1]: "";
				    line = m.rest;
				    break;
				}
			    }
			if (i < sections.size ())
			    {
				// we found new section enclosing which
				// means that we can save possible trailing
				// comment
				if (!comment.empty ())
				    {
					if (open_sections.empty())
					    ini.setEndComment (comment.c_str ());
					else
					    {
						open_sections.front()->setEndComment (comment.c_str ());
					    }
					comment = "";
				    }
				if (open_sections.empty ())
				    scanner_error ("Nothing to close.");
				else {
				    list<IniSection *>::iterator
					b = open_sections.begin(),
					e = open_sections.end(),
					it;

				    string name_to_close = found;
				    bool complain = false;

				    if (!name_to_close.empty ())
				    {   // there is a subexpression (section name)
					for (it = b; it != e; ++it) {
					    if ((*it)->getName() == name_to_close)
						break;
					}

					if (it == e) {
					    // no match by name, try matching by type
					    name_to_close = "";
					    complain = true;
					}
				    }
				    
				    if (name_to_close.empty ()) {
					// there was no name or we did not find the specified one
					for (it = b; it != e; ++it) {
					    if ((*it)->getReadBy() == i)
						break;
					}
					if (it == e) {
					    // not even a match by type
					    it = b;
					}

					if (complain)
					    scanner_error ("Unexpected closing %s. Closing section %s.", found.c_str(), (*it)->getName());
				    }
				    open_sections.erase (b, ++it);
				}
			    }
		    }

		    //
		    // check for line
		    //
		    {
			string key,val;
			for (i = 0; i < params.size (); i++)
			{
			    RegexMatch m (params[i].line.rx, line);
			    if (m)
			    {
				key = m[1];
				val = m[2];
				line = m.rest;
				break;
			    }				
			}
			if (i != params.size ())
			    {
				if (open_sections.empty())
				    {   // we are in toplevel section, going deeper
					// check for toplevel values allowance
					if (!global_values)
					    scanner_error ("%s: values at the top level not allowed.", key.c_str ());
					else
					    ini.initValue (key, val, comment, i);
				    }
				else
				    {
					open_sections.front()->initValue(key, val, comment, i);
				    }
				comment = "";
			    }
		    }

		    //
		    // check for broken line
		    //
		    {
			for (i = 0; i < params.size (); i++)
			{
			    if (!params[i].multiline_valid)
				continue;
			    RegexMatch m (params[i].begin, line);
			    if (m)
			    {
				// broken line
				key = m[1];
				val = m[2];
				line = m.rest;
				matched_by = i;
				state = 1;
				break;
			    }
			}
		    }

		    //
		    // check for comments on line
		    //
		    if (comments_last && !comments.empty ())
		    {
			for (i = 0; i < comments.size (); i++)
			{
			    RegexMatch m (comments[i], line);
			    if (m)
			    {
				// we have it !!!
				comment = comment + m[0] + "\n";
				line = m.rest;
				break;
			    }
			}
		    }
		    //
		    // if line is not empty, report it
		    //
		    {
			if (!onlySpaces (line.c_str()))
			    scanner_error ("Extra characters: %s", line.c_str ());
		    }
		}
	}
    if (!comment.empty ())
    {
	if (!no_finalcomment_kill)
	{
	    // kill empty lines at the end of comment
	    int i = comment.length ();
	    const char*p = comment.c_str () + i - 1;
	    while (i)
	    {
		if ('\n' != *p)
		    break;
		i --;
		p --;
	    }
	    if (i > 0)
		i++;
	    comment.resize (i);
	}
	ini.setEndComment (comment.c_str ());
    }

    return 0;
}
