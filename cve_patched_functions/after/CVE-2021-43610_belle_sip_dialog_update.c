int belle_sip_dialog_update(belle_sip_dialog_t *obj, belle_sip_transaction_t* transaction, int as_uas){
	int is_retransmition=FALSE;
	int delete_dialog=FALSE;
	belle_sip_request_t *req=belle_sip_transaction_get_request(transaction);
	belle_sip_response_t *resp=belle_sip_transaction_get_response(transaction);
	int code=0;
	int ret = 0;
	int is_invite = strcmp(belle_sip_request_get_method(req),"INVITE")==0;
	int is_subscribe = strcmp(belle_sip_request_get_method(req),"SUBSCRIBE")==0;
	int is_notify = strcmp(belle_sip_request_get_method(req),"NOTIFY")==0;

	belle_sip_message("Dialog [%p]: now updated by transaction [%p].",obj, transaction);

	if (resp)
		code=belle_sip_response_get_status_code(resp);

	if (as_uas && code == 491) { /**/
		belle_sip_message("Dialog [%p]: don't update last transaction by transaction [%p].",obj, transaction);
	} else {
		belle_sip_object_ref(transaction);
		if (obj->last_transaction) belle_sip_object_unref(obj->last_transaction);
		obj->last_transaction=transaction;
	}
	if (!as_uas){
		belle_sip_header_privacy_t *privacy_header=belle_sip_message_get_header_by_type(req,belle_sip_header_privacy_t);
		SET_OBJECT_PROPERTY(obj,privacy,privacy_header);
	}

	/*first update local/remote cseq*/
	if (as_uas) {
		belle_sip_header_cseq_t* cseq=belle_sip_message_get_header_by_type(BELLE_SIP_MESSAGE(req),belle_sip_header_cseq_t);
		obj->remote_cseq=belle_sip_header_cseq_get_seq_number(cseq);
		if (is_invite && code>=200 && code<300)
			obj->remote_invite_cseq = belle_sip_header_cseq_get_seq_number(cseq);
		/*else ACK is handled by transaction, not dialog*/
	}


	switch (obj->state){
		case BELLE_SIP_DIALOG_NULL:
			/*always establish a dialog*/
			if (code>100 && code<300 && (is_invite || is_subscribe)) {
				belle_sip_dialog_establish(obj,req,resp);
				if (code<200){
					set_state(obj,BELLE_SIP_DIALOG_EARLY);
					if (!as_uas) {
						belle_sip_dialog_process_response_100rel(obj, transaction);
					}
					break;
				}/* no break  for code >200 because need to call belle_sip_dialog_establish_full*/
			}
			BCTBX_NO_BREAK; /*intentionally no break*/
		case BELLE_SIP_DIALOG_EARLY:
			/*don't terminate dialog for UPDATE*/
			if (code>=300 && ((is_invite && code!=407) || is_subscribe)) {
				/*12.3 Termination of a Dialog
			   	   Independent of the method, if a request outside of a dialog generates
			   	   a non-2xx final response, any early dialogs created through
			   	   provisional responses to that request are terminated.  The mechanism
			   	   for terminating confirmed dialogs is method specific.*/
					delete_dialog=TRUE;
					break;
			}
			if (code>=200 && code<300 && (is_invite || is_subscribe)){
				if (belle_sip_dialog_establish_full(obj,req,resp) != 0){
					/*the dialog found this response invalid so notify the transaction layer by returning -1*/
					ret = -1;
					goto end;
				}
			}
			if (is_subscribe){
				if (belle_sip_dialog_schedule_expiration(obj, (belle_sip_message_t*)req) == BELLE_SIP_STOP
					&& (code>=200 || (code==0 && belle_sip_transaction_get_state(transaction)==BELLE_SIP_TRANSACTION_TERMINATED))){
					/*delete the dialog when the 200Ok for a SUBSCRIBE with expires=0 is received or when
					 * no response is received at all*/
					delete_dialog = TRUE;
				}
			}
			if (code < 200 && belle_sip_transaction_get_state(transaction)==BELLE_SIP_TRANSACTION_TERMINATED){
				/*no response establishing the dialog, and transaction terminated (transport errors)*/
				delete_dialog=TRUE;
			}
			if ((code > 100 && code < 200) && !as_uas) {
				if (belle_sip_dialog_process_response_100rel(obj, transaction)) {
					/*retransmition detected, dropping*/
					ret = -1;
					goto end;
				}
			}
			break;
		case BELLE_SIP_DIALOG_CONFIRMED:
			if (code==481 && (is_invite || is_subscribe)) {
				/*Dialog is terminated in such case*/
				delete_dialog=TRUE;
				break;
			}
			/*refreshing target is also true in case of subscribe*/
			if ((is_invite || is_subscribe) && (code>=200 && code<300)) {
				/*refresh the remote_target*/
				belle_sip_header_contact_t *ct;
				if (as_uas){
					ct=belle_sip_message_get_header_by_type(req,belle_sip_header_contact_t);

				}else{
					if (is_invite)
						set_last_out_invite(obj,req);
					ct=belle_sip_message_get_header_by_type(resp,belle_sip_header_contact_t);
				}
				if (ct){
					belle_sip_dialog_update_remote_target(obj, ct);
				}

			}
			if (is_invite){
				if (code>=200 && code<300){
					/*handle possible retransmission of 200Ok */
					if (!as_uas && (is_retransmition=(belle_sip_dialog_handle_200Ok(obj,resp)==0))) {
						return is_retransmition;
					} else {
						if (as_uas)
							belle_sip_dialog_init_200Ok_retrans(obj,resp);
						obj->needs_ack=TRUE; /*REINVITE case, ack needed by both uas and uac*/
					}
				}else if (code>=300){
					/*final response, ack will be automatically sent by transaction layer*/
					/* do not need to do anything because  not set yet or set by previous invite transaction obj->needs_ack=FALSE;*/
				}
			} else if (strcmp(belle_sip_request_get_method(req),"BYE")==0){
				/*15.1.1 UAC Behavior

				   A BYE request is constructed as would any other request within a
				   dialog, as described in Section 12.

				   Once the BYE is constructed, the UAC core creates a new non-INVITE
				   client transaction, and passes it the BYE request.  The UAC MUST
				   consider the session terminated (and therefore stop sending or
				   listening for media) as soon as the BYE request is passed to the
				   client transaction.  If the response for the BYE is a 481
				   (Call/Transaction Does Not Exist) or a 408 (Request Timeout) or no
				   response at all is received for the BYE (that is, a timeout is
				   returned by the client transaction), the UAC MUST consider the
				   session and the dialog terminated. */
				/*what should we do with other reponse >300 ?? */
				if (code>=200 || (code==0 && belle_sip_transaction_get_state(transaction)==BELLE_SIP_TRANSACTION_TERMINATED)){
					obj->needs_ack=FALSE; /*no longuer need ACK*/
					if (obj->terminate_on_bye) delete_dialog=TRUE;
				}
			}else if (is_subscribe){
				if (belle_sip_dialog_schedule_expiration(obj, (belle_sip_message_t*)req) == BELLE_SIP_STOP
					&& (code>=200 || (code==0 && belle_sip_transaction_get_state(transaction)==BELLE_SIP_TRANSACTION_TERMINATED))){
					delete_dialog = TRUE;
				}else if (!as_uas){
					if (code >= 300 || (code==0 && belle_sip_transaction_get_state(transaction)==BELLE_SIP_TRANSACTION_TERMINATED)){
						/*case of a SUBSCRIBE refresh that is rejected or unanswered*/
						if (code != 491){
							/*request pending is not fatal for the dialog*/
							delete_dialog = TRUE;
						}
					}
				}
			}else if (is_notify){
				delete_dialog = belle_sip_dialog_should_terminate_by_notify(obj, transaction, as_uas);
			}
		break;
		case BELLE_SIP_DIALOG_TERMINATED:
			/*ignore*/
		break;
	}

end:
	if (delete_dialog) belle_sip_dialog_delete(obj);
	else {
		belle_sip_dialog_process_queue(obj);
	}
	return ret;
}
