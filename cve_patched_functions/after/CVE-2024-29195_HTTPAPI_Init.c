HTTPAPI_RESULT HTTPAPI_Init(void)
{
    HTTPAPI_RESULT result;

    if (nUsersOfHTTPAPI == 0)
    {
        if ((g_SessionHandle = WinHttpOpen(
            NULL,
            WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
            WINHTTP_NO_PROXY_NAME,
            WINHTTP_NO_PROXY_BYPASS,
            0)) == NULL)
        {
            LogErrorWinHTTPWithGetLastErrorAsString("WinHttpOpen failed.");
            result = HTTPAPI_INIT_FAILED;
        }
        else
        {
            DWORD supportedProtocols = WINHTTP_FLAG_SECURE_PROTOCOL_TLS1 | // TLS 1.0 is support for back-compat reasons (https://docs.microsoft.com/azure/iot-fundamentals/iot-security-deployment)
                WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_1 |
                WINHTTP_FLAG_SECURE_PROTOCOL_TLS1_2;

            if (!WinHttpSetOption(
                g_SessionHandle,
                WINHTTP_OPTION_SECURE_PROTOCOLS,
                &supportedProtocols,
                sizeof(supportedProtocols)
            ))
            {
                LogErrorWinHTTPWithGetLastErrorAsString("unable to WinHttpSetOption (WINHTTP_OPTION_SECURE_PROTOCOLS)");
                (void)WinHttpCloseHandle(g_SessionHandle);
                g_SessionHandle = NULL;
                result = HTTPAPI_INIT_FAILED;
            }
            else if (WinHttpSetStatusCallback(g_SessionHandle, httpapi_WinhttpStatusCallback, WINHTTP_CALLBACK_FLAG_SEND_REQUEST, 0) == WINHTTP_INVALID_STATUS_CALLBACK)
            {
                LogErrorWinHTTPWithGetLastErrorAsString("WinHttpSetStatusCallback failed.");
                (void)WinHttpCloseHandle(g_SessionHandle);
                g_SessionHandle = NULL;
                result = HTTPAPI_INIT_FAILED;
            }
            else
            {
                nUsersOfHTTPAPI++;
                g_HTTPAPIState = HTTPAPI_INITIALIZED;
                result = HTTPAPI_OK;
            }
        }
    }
    else
    {
        nUsersOfHTTPAPI++;
        result = HTTPAPI_OK;
    }

    return result;
}
