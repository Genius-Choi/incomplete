bool TypeInferenceImpl::inferType(Instruction *I) {
  Type originalTy = I->getType();

  switch (I->getKind()) {
    case ValueKind::BinaryOperatorInstKind:
      NumTI += inferBinaryInst(cast<BinaryOperatorInst>(I));
      return I->getType() != originalTy;

    case ValueKind::UnaryOperatorInstKind:
      NumTI += inferUnaryInst(cast<UnaryOperatorInst>(I));
      return I->getType() != originalTy;

    case ValueKind::PhiInstKind:
      NumTI += inferPhiInstInst(cast<PhiInst>(I));
      return I->getType() != originalTy;

    case ValueKind::AllocStackInstKind:
      NumTI += inferMemoryType(cast<AllocStackInst>(I));
      return I->getType() != originalTy;

    case ValueKind::LoadStackInstKind:
      NumTI += inferLoadStackInst(cast<LoadStackInst>(I));
      return I->getType() != originalTy;

    case ValueKind::LoadFrameInstKind:
      NumTI += inferLoadFrameInst(cast<LoadFrameInst>(I));
      return I->getType() != originalTy;

    case ValueKind::CallInstKind:
      NumTI += inferCallInst(cast<CallInst>(I));
      return I->getType() != originalTy;

    case ValueKind::ReturnInstKind:
      NumTI += inferReturnInst(cast<ReturnInst>(I));
      return I->getType() != originalTy;

    case ValueKind::LoadPropertyInstKind:
      NumTI += inferLoadPropertyInst(cast<LoadPropertyInst>(I));
      return I->getType() != originalTy;

    case ValueKind::ThrowIfEmptyInstKind:
      NumTI += inferThrowIfEmptyInst(cast<ThrowIfEmptyInst>(I));
      return I->getType() != originalTy;

    default:
      // Not sure how to infer the type here.
      return false;
  }
}
