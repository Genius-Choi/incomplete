dissect_bgp_update_ext_com(proto_tree *parent_tree, tvbuff_t *tvb, guint16 tlen, guint tvb_off, packet_info *pinfo)
{
    int             offset=0;
    int             end=0;
    guint8          com_type_high_byte;
    guint8          com_stype_low_byte;
    proto_tree      *communities_tree;
    proto_tree      *community_tree;
    proto_tree      *community_type_tree;
    proto_item      *communities_item=NULL;
    proto_item      *community_item=NULL;
    proto_item      *community_type_item=NULL;
    guint32         encaps_tunnel_type;
    afi_safi_data   *data = NULL;

    offset = tvb_off ;
    end = tvb_off + tlen ;
    communities_item = proto_tree_add_item(parent_tree, hf_bgp_ext_communities, tvb, offset, tlen, ENC_NA);
    communities_tree = proto_item_add_subtree(communities_item, ett_bgp_extended_communities);
    proto_item_append_text(communities_item, ": (%u communit%s)", tlen/8, plurality(tlen/8, "y", "ies"));
    while (offset < end) {
        com_type_high_byte = tvb_get_guint8(tvb,offset); /* high community type octet */
        com_stype_low_byte = tvb_get_guint8(tvb,offset+1); /* sub type low community type octet */
        community_item = proto_tree_add_item(communities_tree, hf_bgp_ext_community, tvb, offset, 8, ENC_NA);
        community_tree = proto_item_add_subtree(community_item,ett_bgp_extended_community);

        /* Add the Type octet as a decoded item to the community_tree right away,
         * and also dissect its two top bits in a subtree.
         */

        community_type_item = proto_tree_add_item(community_tree, hf_bgp_ext_com_type_high, tvb, offset, 1, ENC_BIG_ENDIAN);
        community_type_tree = proto_item_add_subtree(community_type_item, ett_bgp_ext_com_type);
        proto_tree_add_item(community_type_tree, hf_bgp_ext_com_type_auth, tvb, offset, 1, ENC_BIG_ENDIAN);
        proto_tree_add_item(community_type_tree, hf_bgp_ext_com_type_tran, tvb, offset, 1, ENC_BIG_ENDIAN);

        /* In the switch(), handlers of individual types and subtypes should
         * add and dissect the remaining 7 octets. Dissectors should use the
         * proto_item_set_text() on the community_item to set the community
         * name in the displayed label as specifically as possible, and
         * proto_item_append_text() to add reasonable details.
         *
         * The intended text label of the community_item for each extended
         * community attribute is:
         *
         * Community Name: Values [General Community Type Name]
         *
         * For example:
         * Route Target: 1:1 [Transitive 2-Octet AS-Specific]
         * Unknown subtype 0x01: 0x8081 0x0000 0x2800 [Non-Transitive Opaque]
         * Unknown type 0x88 subtype 0x00: 0x0000 0x0000 0x0000 [Unknown community]
         *
         * The [] part with general community name is added at the end
         * of the switch().
         *
         * The first option (Route Target) shows a fully recognized and
         * dissected extended community. Note that the line immediately calls
         * the community by its most specific known type (Route Target), while
         * the general type is shown in the brackets. The second option shows a
         * community whose Type is recognized (Non-Transitive Opaque) but whose
         * Subtype is not known. The third option shows an unrecognized
         * extended community.
         *
         * Printing out the community raw value as 3 short ints is intentional:
         * With an unknown community, we cannot assume any particular internal
         * value format, and dumping the value in short ints provides for easy
         * readability.
         */

        switch (com_type_high_byte) {
            case BGP_EXT_COM_TYPE_HIGH_TR_AS2: /* Transitive Two-Octet AS-Specific Extended Community */

                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_tr_as2, tvb, offset+1, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(community_tree, hf_bgp_ext_com_value_as2, tvb, offset+2, 2, ENC_BIG_ENDIAN);
                data = load_afi_safi_data(pinfo);

                if(data && data->afi == AFNUM_L2VPN && data->safi == SAFNUM_EVPN) {
                        static int * const local_admin_flags[] = {
                            &hf_bgp_ext_com_local_admin_auto_derived_flag,
                            &hf_bgp_ext_com_local_admin_type,
                            &hf_bgp_ext_com_local_admin_domain_id,
                            NULL
                        };
                        proto_tree_add_bitmask(community_tree, tvb, offset+4, hf_bgp_ext_com_local_admin_flags,
                                ett_bgp_vxlan, local_admin_flags, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_local_admin_service_id, tvb, offset+5, 3, ENC_BIG_ENDIAN);
                } else {
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_an4, tvb, offset+4, 4, ENC_BIG_ENDIAN);
                }

                proto_item_set_text(community_item, "%s: %u:%u",
                        val_to_str(com_stype_low_byte, bgpext_com_stype_tr_as2, "Unknown subtype 0x%02x"),
                        tvb_get_ntohs(tvb,offset+2), tvb_get_ntohl(tvb, offset+4));
                break;

            case BGP_EXT_COM_TYPE_HIGH_NTR_AS2: /* Non-Transitive Two-Octet AS-Specific Extended Community */
                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_ntr_as2, tvb, offset+1, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(community_tree, hf_bgp_ext_com_value_as2, tvb, offset+2, 2, ENC_BIG_ENDIAN);

                proto_item_set_text(community_item, "%s:",
                        val_to_str(com_stype_low_byte, bgpext_com_stype_ntr_as2, "Unknown subtype 0x%02x"));

                switch (com_stype_low_byte) {
                    case BGP_EXT_COM_STYPE_AS2_LBW:
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_link_bw, tvb, offset+4, 4, ENC_BIG_ENDIAN);

                        proto_item_append_text(community_item, " ASN %u, %.3f Mbps",
                                tvb_get_ntohs(tvb,offset+2),
                                tvb_get_ntohieee_float(tvb,offset+4)*8/1000000);
                        break;

                    default:
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_an4, tvb, offset+4, 4, ENC_BIG_ENDIAN);

                        proto_item_append_text(community_item, " %u:%u",
                                tvb_get_ntohs(tvb,offset+2), tvb_get_ntohl(tvb,offset+4));
                    break;
                }
                break;

            case BGP_EXT_COM_TYPE_HIGH_TR_IP4: /* Transitive IPv4-Address-specific Extended Community */
                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_tr_IP4, tvb, offset+1, 1, ENC_BIG_ENDIAN);

                proto_item_set_text(community_item, "%s: %s:%u",
                        val_to_str(com_stype_low_byte, bgpext_com_stype_tr_IP4, "Unknown subtype 0x%02x"),
                        tvb_ip_to_str(pinfo->pool, tvb, offset+2), tvb_get_ntohs(tvb,offset+6));

                switch(com_stype_low_byte) {
                    case BGP_EXT_COM_STYPE_IP4_OSPF_RID:
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_ospf_rid, tvb, offset+2, 4, ENC_BIG_ENDIAN);
                        break;

                    default:
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_IP4, tvb, offset+2, 4, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_an2, tvb, offset+6, 2, ENC_BIG_ENDIAN);
                        break;
                }
                break;

            case BGP_EXT_COM_TYPE_HIGH_NTR_IP4: /* Non-Transitive IPv4-Address-specific Extended Community */
                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_ntr_IP4, tvb, offset+1, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(community_tree, hf_bgp_ext_com_value_IP4, tvb, offset+2, 4, ENC_BIG_ENDIAN);
                proto_tree_add_item(community_tree, hf_bgp_ext_com_value_an2, tvb, offset+6, 2, ENC_BIG_ENDIAN);

                proto_item_set_text(community_item, "%s: %s:%u",
                        val_to_str(com_stype_low_byte, bgpext_com_stype_ntr_IP4, "Unknown subtype 0x%02x"),
                        tvb_ip_to_str(pinfo->pool, tvb, offset+2), tvb_get_ntohs(tvb,offset+6));
                break;

            case BGP_EXT_COM_TYPE_HIGH_TR_AS4: /* Transitive Four-Octet AS-Specific Extended Community */
                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_tr_as4, tvb, offset+1, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(community_tree, hf_bgp_ext_com_value_as4, tvb, offset+2, 4, ENC_BIG_ENDIAN);
                proto_tree_add_item(community_tree, hf_bgp_ext_com_value_an2, tvb, offset+6, 2, ENC_BIG_ENDIAN);

                proto_item_set_text(community_item, "%s: %u.%u(%u):%u",
                        val_to_str(com_stype_low_byte, bgpext_com_stype_tr_as4, "Unknown subtype 0x%02x"),
                        tvb_get_ntohs(tvb,offset+2), tvb_get_ntohs(tvb,offset+4), tvb_get_ntohl(tvb,offset+2),
                        tvb_get_ntohs(tvb,offset+6));
                break;

            case BGP_EXT_COM_TYPE_HIGH_NTR_AS4: /* Non-Transitive Four-Octet AS-Specific Extended Community */
                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_ntr_as4, tvb, offset+1, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(community_tree, hf_bgp_ext_com_value_as4, tvb, offset+2, 4, ENC_BIG_ENDIAN);
                proto_tree_add_item(community_tree, hf_bgp_ext_com_value_an2, tvb, offset+6, 2, ENC_BIG_ENDIAN);

                proto_item_set_text(community_item, "%s: %u.%u(%u):%u",
                        val_to_str(com_stype_low_byte, bgpext_com_stype_ntr_as4, "Unknown subtype 0x%02x"),
                        tvb_get_ntohs(tvb,offset+2), tvb_get_ntohs(tvb,offset+4), tvb_get_ntohl(tvb,offset+2),
                        tvb_get_ntohs(tvb,offset+6));
                break;

            case BGP_EXT_COM_TYPE_HIGH_TR_OPAQUE: /* Transitive Opaque Extended Community */
                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_tr_opaque, tvb, offset+1, 1, ENC_BIG_ENDIAN);

                proto_item_set_text(community_item, "%s:",
                        val_to_str(com_stype_low_byte, bgpext_com_stype_tr_opaque, "Unknown subtype 0x%02x"));

                switch(com_stype_low_byte) {
                    case BGP_EXT_COM_STYPE_OPA_COST:
                        {
                        proto_item *cost_com_item;
                        proto_tree *cost_com_cid_tree;

                        proto_tree_add_item(community_tree, hf_bgp_ext_com_cost_poi, tvb, offset+2, 1, ENC_BIG_ENDIAN);
                        cost_com_item = proto_tree_add_item(community_tree, hf_bgp_ext_com_cost_cid, tvb, offset+3, 1, ENC_BIG_ENDIAN);
                        cost_com_cid_tree = proto_item_add_subtree(cost_com_item, ett_bgp_ext_com_cost_cid);
                        proto_tree_add_item(cost_com_cid_tree, hf_bgp_ext_com_cost_cid_rep, tvb, offset+3, 1, ENC_BIG_ENDIAN);
                        cost_com_item = proto_tree_add_item(community_tree, hf_bgp_ext_com_cost_cost, tvb,
                            offset+4, 4, ENC_BIG_ENDIAN);
                        proto_item_append_text(cost_com_item, " (%s)",
                            tfs_get_string(tvb_get_guint8(tvb, offset+3) & BGP_EXT_COM_COST_CID_REP, &tfs_cost_replace));

                        proto_item_append_text(community_item, " %u, POI: %s (%s)",
                                tvb_get_ntohl(tvb, offset+4),
                                val_to_str(tvb_get_guint8(tvb, offset+2), bgpext_com_cost_poi_type, "Unknown subtype 0x%02x"),
                                (tvb_get_guint8(tvb, offset+3) & BGP_EXT_COM_COST_CID_REP) ? "Replaces attribute value" : "Evaluated after");
                        }
                        break;

                    case BGP_EXT_COM_STYPE_OPA_OSPF_RT:
                        {
                        proto_item *ospf_rt_opt_item;
                        proto_tree *ospf_rt_opt_tree;

                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_ospf_rt_area, tvb, offset+2, 4, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_ospf_rt_type, tvb, offset+6, 1, ENC_BIG_ENDIAN);
                        ospf_rt_opt_item = proto_tree_add_item(community_tree,
                                hf_bgp_ext_com_value_ospf_rt_options, tvb, offset+7, 1, ENC_BIG_ENDIAN);
                        ospf_rt_opt_tree = proto_item_add_subtree(ospf_rt_opt_item, ett_bgp_ext_com_ospf_rt_opt);
                        proto_tree_add_item(ospf_rt_opt_tree, hf_bgp_ext_com_value_ospf_rt_options_mt,
                                tvb, offset+7, 1, ENC_BIG_ENDIAN);
                        proto_item_append_text(ospf_rt_opt_item, " (Metric: %s)",
                                tfs_get_string(tvb_get_guint8(tvb,offset+7) & BGP_OSPF_RTYPE_METRIC_TYPE, &tfs_ospf_rt_mt));

                        proto_item_append_text(community_item, " Area: %s, Type: %s",
                                tvb_ip_to_str(pinfo->pool, tvb,offset+2),
                                val_to_str_const(tvb_get_guint8(tvb,offset+6), bgpext_com_ospf_rtype, "Unknown"));
                        }
                        break;

                    case BGP_EXT_COM_STYPE_OPA_ENCAP:
                        /* Community octets 2 through 5 are reserved and carry no useful value according to RFC 5512. */
                        proto_tree_add_item_ret_uint(community_tree, hf_bgp_ext_com_tunnel_type, tvb, offset+6, 2, ENC_BIG_ENDIAN, &encaps_tunnel_type);
                        save_path_attr_encaps_tunnel_type(pinfo, encaps_tunnel_type);

                        proto_item_append_text(community_item, " %s",
                                val_to_str_const(tvb_get_ntohs(tvb,offset+6), bgpext_com_tunnel_type, "Unknown"));
                        break;

                    case BGP_EXT_COM_STYPE_OPA_COLOR:
                    case BGP_EXT_COM_STYPE_OPA_DGTW:
                    default:
                        /* The particular Opaque subtype is unknown or the
                         * dissector is not written yet. We will dump the
                         * entire community value in 2-byte short words.
                         */
                        proto_tree_add_uint64_format_value(community_tree, hf_bgp_ext_com_value_raw, tvb, offset+2, 6,
                                tvb_get_ntoh48 (tvb, offset+2), "0x%04x 0x%04x 0x%04x",
                                tvb_get_ntohs(tvb,offset+2),
                                tvb_get_ntohs(tvb,offset+4),
                                tvb_get_ntohs(tvb,offset+6));

                        proto_item_append_text(community_item, " 0x%04x 0x%04x 0x%04x",
                                tvb_get_ntohs(tvb,offset+2), tvb_get_ntohs(tvb,offset+4), tvb_get_ntohs(tvb,offset+6));
                        break;
                }
                break;

            case BGP_EXT_COM_TYPE_HIGH_NTR_OPAQUE: /* Non-Transitive Opaque Extended Community */
                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_ntr_opaque, tvb, offset+1, 1, ENC_BIG_ENDIAN);

                proto_item_set_text(community_item, "%s:",
                        val_to_str(com_stype_low_byte, bgpext_com_stype_ntr_opaque, "Unknown subtype 0x%02x"));

                switch(com_stype_low_byte) {
                    case BGP_EXT_COM_STYPE_OPA_COST:
                        {
                        proto_item *cost_com_item;
                        proto_tree *cost_com_cid_tree;

                        proto_tree_add_item(community_tree, hf_bgp_ext_com_cost_poi, tvb, offset+2, 1, ENC_BIG_ENDIAN);
                        cost_com_item = proto_tree_add_item(community_tree, hf_bgp_ext_com_cost_cid, tvb, offset+3, 1, ENC_BIG_ENDIAN);
                        cost_com_cid_tree = proto_item_add_subtree(cost_com_item, ett_bgp_ext_com_cost_cid);
                        proto_tree_add_item(cost_com_cid_tree, hf_bgp_ext_com_cost_cid_rep, tvb, offset+3, 1, ENC_BIG_ENDIAN);
                        cost_com_item = proto_tree_add_item(community_tree, hf_bgp_ext_com_cost_cost, tvb,
                            offset+4, 4, ENC_BIG_ENDIAN);
                        proto_item_append_text(cost_com_item, " (%s)",
                            tfs_get_string(tvb_get_guint8(tvb, offset+3) & BGP_EXT_COM_COST_CID_REP, &tfs_cost_replace));

                        proto_item_append_text(community_item, " %u, POI: %s (%s)",
                                tvb_get_ntohl(tvb, offset+4),
                                val_to_str(tvb_get_guint8(tvb, offset+2), bgpext_com_cost_poi_type, "Unknown subtype 0x%02x"),
                                (tvb_get_guint8(tvb, offset+3) & BGP_EXT_COM_COST_CID_REP) ? "Replaces attribute value" : "Evaluated after");
                        }
                        break;

                    default:
                            /* The particular Opaque subtype is unknown or the
                             * dissector is not written yet. We will dump the
                             * entire community value in 2-byte short words.
                             */
                        proto_tree_add_uint64_format_value(community_tree, hf_bgp_ext_com_value_raw, tvb, offset+2, 6,
                                tvb_get_ntoh48 (tvb, offset+2), "0x%04x 0x%04x 0x%04x",
                                tvb_get_ntohs(tvb,offset+2),
                                tvb_get_ntohs(tvb,offset+4),
                                tvb_get_ntohs(tvb,offset+6));

                        proto_item_append_text(community_item, " 0x%04x 0x%04x 0x%04x",
                                tvb_get_ntohs(tvb,offset+2), tvb_get_ntohs(tvb,offset+4), tvb_get_ntohs(tvb,offset+6));
                        break;
                }
                break;

            case BGP_EXT_COM_TYPE_HIGH_TR_QOS: /* QoS Marking [Thomas_Martin_Knoll] */
            case BGP_EXT_COM_TYPE_HIGH_NTR_QOS: /* QoS Marking [Thomas_Martin_Knoll] */
                {
                static int * const qos_flags[] = {
                    &hf_bgp_ext_com_qos_flags_remarking,
                    &hf_bgp_ext_com_qos_flags_ignore_remarking,
                    &hf_bgp_ext_com_qos_flags_agg_marking,
                    NULL
                };

                proto_item_set_text(community_item, "QoS Marking");

                proto_tree_add_bitmask(community_tree, tvb, offset, hf_bgp_ext_com_qos_flags,
                        ett_bgp_ext_com_flags, qos_flags, ENC_BIG_ENDIAN);

                proto_tree_add_item(community_tree, hf_bgp_ext_com_qos_set_number, tvb, offset+2, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(community_tree, hf_bgp_ext_com_qos_tech_type, tvb, offset+3, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(community_tree, hf_bgp_ext_com_qos_marking_o, tvb, offset+4, 2, ENC_BIG_ENDIAN);
                proto_tree_add_item(community_tree, hf_bgp_ext_com_qos_marking_a, tvb, offset+6, 1, ENC_BIG_ENDIAN);
                proto_tree_add_item(community_tree, hf_bgp_ext_com_qos_default_to_zero, tvb, offset+7, 1, ENC_BIG_ENDIAN);
                }
                break;

            case BGP_EXT_COM_TYPE_HIGH_TR_COS: /* CoS Capability [Thomas_Martin_Knoll] */
                {
                int i;

                proto_item_set_text(community_item, "CoS Capability");

                for (i=1; i < 8; i++) {
                    static int * const cos_flags[] = {
                        &hf_bgp_ext_com_cos_flags_be,
                        &hf_bgp_ext_com_cos_flags_ef,
                        &hf_bgp_ext_com_cos_flags_af,
                        &hf_bgp_ext_com_cos_flags_le,
                        NULL
                    };

                    proto_tree_add_bitmask(community_tree, tvb, offset+i, hf_bgp_ext_com_cos_flags,
                            ett_bgp_ext_com_flags, cos_flags, ENC_BIG_ENDIAN);
                }
                }
                break;

            case BGP_EXT_COM_TYPE_HIGH_TR_EVPN: /* EVPN (Sub-Types are defined in the "EVPN Extended Community Sub-Types" registry) */
                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_tr_evpn, tvb, offset+1, 1, ENC_BIG_ENDIAN);

                proto_item_set_text(community_item, "%s:",
                        val_to_str(com_stype_low_byte, bgpext_com_stype_tr_evpn, "Unknown subtype 0x%02x"));

                switch (com_stype_low_byte) {
                    case BGP_EXT_COM_STYPE_EVPN_MMAC:
                        {
                        proto_tree *evpn_mmac_flag_tree;
                        proto_item *evpn_mmac_flag_item;

                        evpn_mmac_flag_item = proto_tree_add_item(community_tree, hf_bgp_ext_com_evpn_mmac_flag, tvb, offset+2, 1, ENC_BIG_ENDIAN);
                        evpn_mmac_flag_tree = proto_item_add_subtree(evpn_mmac_flag_item, ett_bgp_ext_com_evpn_mmac_flags);
                        proto_tree_add_item (evpn_mmac_flag_tree, hf_bgp_ext_com_evpn_mmac_flag_sticky, tvb, offset+2, 1, ENC_BIG_ENDIAN);
                        /* Octet at offset 3 is reserved per RFC 7432 Section 7.7 */
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_evpn_mmac_seq, tvb, offset+4, 4, ENC_BIG_ENDIAN);

                        proto_item_append_text(community_item, " %s MAC",
                          (tvb_get_guint8(tvb,offset+2) & BGP_EXT_COM_EVPN_MMAC_STICKY) ? "Sticky" : "Movable");
                        }
                        break;

                    case BGP_EXT_COM_STYPE_EVPN_LABEL:
                        {
                        proto_item *ti;

                        proto_tree_add_item(community_tree, hf_bgp_ext_com_l2_esi_label_flag, tvb, offset+2, 1, ENC_BIG_ENDIAN);
                        /* Octets at offsets 3 and 4 are reserved perf RFC 7432 Section 7.5 */
                        proto_tree_add_item(community_tree, hf_bgp_update_mpls_label_value, tvb, offset+5, 3, ENC_BIG_ENDIAN);
                        ti = proto_tree_add_item(community_tree, hf_bgp_update_mpls_label_value_20bits, tvb, offset+5, 3, ENC_BIG_ENDIAN);
                        proto_item_set_generated(ti);
                        ti = proto_tree_add_item(community_tree, hf_bgp_update_mpls_traffic_class, tvb, offset+5, 3, ENC_BIG_ENDIAN);
                        proto_item_set_generated(ti);
                        ti = proto_tree_add_item(community_tree, hf_bgp_update_mpls_bottom_stack, tvb, offset+5, 3, ENC_BIG_ENDIAN);
                        proto_item_set_generated(ti);

                        proto_item_append_text(community_item, " %s, Label: %u",
                                tfs_get_string(tvb_get_guint8(tvb, offset+2) & BGP_EXT_COM_ESI_LABEL_FLAGS, &tfs_esi_label_flag),
                                tvb_get_ntoh24(tvb,offset+5) >> 4);
                        }
                        break;

                    case BGP_EXT_COM_STYPE_EVPN_IMP:
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_evpn_esirt, tvb, offset+2, 6, ENC_NA);

                        proto_item_append_text(community_item, " RT: %s", tvb_ether_to_str(pinfo->pool, tvb, offset+2));
                        break;

                    case BGP_EXT_COM_STYPE_EVPN_ROUTERMAC:
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_evpn_routermac, tvb, offset+2, 6, ENC_NA);

                        proto_item_append_text(community_item, " Router's MAC: %s", tvb_ether_to_str(pinfo->pool, tvb, offset+2));
                        break;

                    case BGP_EXT_COM_STYPE_EVPN_L2ATTR:
                        {
                        static int * const l2attr_flags[] = {
                            &hf_bgp_ext_com_evpn_l2attr_flag_reserved,
                            &hf_bgp_ext_com_evpn_l2attr_flag_ci,
                            &hf_bgp_ext_com_evpn_l2attr_flag_f,
                            &hf_bgp_ext_com_evpn_l2attr_flag_c,
                            &hf_bgp_ext_com_evpn_l2attr_flag_p,
                            &hf_bgp_ext_com_evpn_l2attr_flag_b,
                            NULL
                        };

                        proto_tree_add_bitmask(community_tree, tvb, offset+2, hf_bgp_ext_com_evpn_l2attr_flags,
                            ett_bgp_ext_com_evpn_l2attr_flags, l2attr_flags, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_evpn_l2attr_l2_mtu, tvb, offset+4, 2, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_evpn_l2attr_reserved, tvb, offset+6, 2, ENC_NA);

                        proto_item_append_text(community_item, " flags: 0x%04x, L2 MTU: %u", tvb_get_ntohs(tvb, offset+2), tvb_get_ntohs(tvb, offset+4));
                        }
                        break;

                    case BGP_EXT_COM_STYPE_EVPN_ETREE:
                        {
                        static int * const etree_flags[] = {
                            &hf_bgp_ext_com_evpn_etree_flag_reserved,
                            &hf_bgp_ext_com_evpn_etree_flag_l,
                            NULL
                        };

                        proto_tree_add_bitmask(community_tree, tvb, offset+2, hf_bgp_ext_com_evpn_etree_flags,
                            ett_bgp_ext_com_evpn_etree_flags, etree_flags, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_evpn_etree_reserved, tvb, offset+3, 2, ENC_NA);

                        proto_tree_add_item(community_tree, hf_bgp_update_mpls_label_value_20bits, tvb, offset+5, 3, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_update_mpls_traffic_class, tvb, offset+5, 3, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_update_mpls_bottom_stack, tvb, offset+5, 3, ENC_BIG_ENDIAN);
                        }
                        break;

                    default:
                        /* The particular EVPN subtype is unknown or the
                         * dissector is not written yet. We will dump the
                         * entire community value in 2-byte short words.
                         */
                        proto_tree_add_uint64_format_value(community_tree, hf_bgp_ext_com_value_raw, tvb, offset+2, 6,
                                tvb_get_ntoh48 (tvb, offset+2), "0x%04x 0x%04x 0x%04x",
                                tvb_get_ntohs(tvb,offset+2),
                                tvb_get_ntohs(tvb,offset+4),
                                tvb_get_ntohs(tvb,offset+6));

                        proto_item_append_text(community_item, " 0x%04x 0x%04x 0x%04x",
                                tvb_get_ntohs(tvb,offset+2), tvb_get_ntohs(tvb,offset+4), tvb_get_ntohs(tvb,offset+6));
                        break;
                }
                break;

            case BGP_EXT_COM_TYPE_HIGH_TR_MUP:
                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_tr_mup, tvb, offset+1, 1, ENC_BIG_ENDIAN);

                proto_item_set_text(community_item, "%s:",
                        val_to_str(com_stype_low_byte, bgpext_com_stype_tr_mup, "Unknown subtype 0x%02x"));
                switch (com_stype_low_byte) {
                    case BGP_EXT_COM_STYPE_MUP_DIRECT_SEG:
                        /* format of this community is open, then display it in 2-byte:4-byte decimal format like route target */
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_mup_segment_id2, tvb, offset+2, 2, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_mup_segment_id4, tvb, offset+4, 4, ENC_BIG_ENDIAN);
                        proto_item_append_text(community_item, " %u:%u", tvb_get_ntohs(tvb,offset+2), tvb_get_ntohl(tvb, offset+4));
                        break;
                    default:
                        proto_tree_add_uint64_format_value(community_tree, hf_bgp_ext_com_value_raw, tvb, offset+2, 6,
                                tvb_get_ntoh48 (tvb, offset+2), "0x%04x 0x%04x 0x%04x",
                                tvb_get_ntohs(tvb,offset+2),
                                tvb_get_ntohs(tvb,offset+4),
                                tvb_get_ntohs(tvb,offset+6));

                        proto_item_append_text(community_item, " 0x%04x 0x%04x 0x%04x",
                                tvb_get_ntohs(tvb,offset+2), tvb_get_ntohs(tvb,offset+4), tvb_get_ntohs(tvb,offset+6));
                        break;
                }
                break;
            case BGP_EXT_COM_TYPE_HIGH_TR_EXP: /* Generic Transitive Experimental Extended Community */
                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_tr_exp, tvb, offset+1, 1, ENC_BIG_ENDIAN);

                proto_item_set_text(community_item, "%s:",
                        val_to_str(com_stype_low_byte, bgpext_com_stype_tr_exp, "Unknown subtype 0x%02x"));

                switch (com_stype_low_byte) {
                    case BGP_EXT_COM_STYPE_EXP_OSPF_RT:
                        {
                        proto_item *ospf_rt_opt_item;
                        proto_tree *ospf_rt_opt_tree;

                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_ospf_rt_area, tvb, offset+2, 4, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_ospf_rt_type, tvb, offset+6, 1, ENC_BIG_ENDIAN);
                        ospf_rt_opt_item = proto_tree_add_item(community_tree,
                                hf_bgp_ext_com_value_ospf_rt_options, tvb, offset+7, 1, ENC_BIG_ENDIAN);
                        ospf_rt_opt_tree = proto_item_add_subtree(ospf_rt_opt_item, ett_bgp_ext_com_ospf_rt_opt);
                        proto_tree_add_item(ospf_rt_opt_tree, hf_bgp_ext_com_value_ospf_rt_options_mt,
                                tvb, offset+7, 1, ENC_BIG_ENDIAN);
                        proto_item_append_text(ospf_rt_opt_item, " (Metric: %s)",
                                tfs_get_string(tvb_get_guint8(tvb,offset+7) & BGP_OSPF_RTYPE_METRIC_TYPE, &tfs_ospf_rt_mt));

                        proto_item_append_text(community_item, " Area: %s, Type: %s",
                                tvb_ip_to_str(pinfo->pool, tvb,offset+2),
                                val_to_str_const(tvb_get_guint8(tvb,offset+6), bgpext_com_ospf_rtype, "Unknown"));
                        }
                        break;

                    case BGP_EXT_COM_STYPE_EXP_OSPF_RID:
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_ospf_rid, tvb, offset+2, 4, ENC_BIG_ENDIAN);

                        proto_item_append_text(community_item, " %s", tvb_ip_to_str(pinfo->pool, tvb, offset+2));
                        break;

                    case BGP_EXT_COM_STYPE_EXP_OSPF_DID:
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_tr_as2, tvb, offset+1, 1, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_as2, tvb, offset+2, 2, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_an4, tvb, offset+4, 4, ENC_BIG_ENDIAN);

                        proto_item_set_text(community_item, "%s: %u:%u",
                                val_to_str(com_stype_low_byte, bgpext_com_stype_tr_exp, "Unknown subtype 0x%02x"),
                                tvb_get_ntohs(tvb,offset+2), tvb_get_ntohl(tvb, offset+4));
                        break;

                    case BGP_EXT_COM_STYPE_EXP_F_TR:  /* Flow spec traffic-rate [RFC5575] */
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_as2,
                                tvb, offset+2, 2, ENC_BIG_ENDIAN);
                        /* remaining 4 bytes gives traffic rate in IEEE floating point */
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_flow_rate_float, tvb, offset+4, 4, ENC_BIG_ENDIAN);

                        proto_item_append_text(community_item, " ASN %u, %.3f Mbps",
                                tvb_get_ntohs(tvb,offset+2),
                                tvb_get_ntohieee_float(tvb,offset+4)*8/1000000);
                        break;

                    case BGP_EXT_COM_STYPE_EXP_F_TA:  /* Flow spec traffic-action [RFC5575] */
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_flow_act_allset, tvb, offset+2, 5, ENC_NA);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_flow_act_samp_act, tvb, offset+7, 1, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_flow_act_term_act, tvb, offset+7, 1, ENC_BIG_ENDIAN);

                        proto_item_append_text(community_item, " Sample: %s, Terminal: %s",
                                tfs_get_string(tvb_get_guint8(tvb,offset+7) & BGP_EXT_COM_FSPEC_ACT_S, &tfs_yes_no),
                                tfs_get_string(tvb_get_guint8(tvb,offset+7) & BGP_EXT_COM_FSPEC_ACT_T, &tfs_yes_no));
                        break;

                    case BGP_EXT_COM_STYPE_EXP_F_RED: /* Flow spec redirect [RFC5575] */
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_as2, tvb, offset+2, 2, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_an4, tvb, offset+4, 4, ENC_BIG_ENDIAN);

                        proto_item_append_text(community_item, " RT %u:%u",
                                tvb_get_ntohs(tvb,offset+2), tvb_get_ntohl(tvb,offset+4));
                        break;

                    case BGP_EXT_COM_STYPE_EXP_F_RMARK: /* Flow spec traffic-remarking [RFC5575] */
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_value_fs_remark, tvb, offset+7, 1, ENC_BIG_ENDIAN);

                        proto_item_append_text(community_item, " %s",
                                val_to_str_ext_const(tvb_get_guint8(tvb,offset+7), &dscp_vals_ext, "Unknown DSCP"));
                        break;

                    case BGP_EXT_COM_STYPE_EXP_L2:
                        {
                        static int * const com_l2_flags[] = {
                            &hf_bgp_ext_com_l2_flag_d,
                            &hf_bgp_ext_com_l2_flag_z1,
                            &hf_bgp_ext_com_l2_flag_f,
                            &hf_bgp_ext_com_l2_flag_z345,
                            &hf_bgp_ext_com_l2_flag_c,
                            &hf_bgp_ext_com_l2_flag_s,
                            NULL
                        };

                        proto_tree_add_item(community_tree, hf_bgp_ext_com_l2_encaps,tvb,offset+2, 1, ENC_BIG_ENDIAN);

                        proto_tree_add_bitmask(community_tree, tvb, offset+3, hf_bgp_ext_com_l2_c_flags, ett_bgp_ext_com_l2_flags, com_l2_flags, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_l2_mtu, tvb, offset+4, 2, ENC_BIG_ENDIAN);
                        }
                        break;

                    case BGP_EXT_COM_STYPE_EXP_ETREE:
                        {
                        static int * const com_etree_flags[] = {
                            &hf_bgp_ext_com_etree_flag_reserved,
                            &hf_bgp_ext_com_etree_flag_p,
                            &hf_bgp_ext_com_etree_flag_v,
                            NULL
                        };

                        proto_tree_add_item(community_tree, hf_bgp_ext_com_etree_root_vlan,tvb,offset+2, 2, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_etree_leaf_vlan,tvb,offset+4, 2, ENC_BIG_ENDIAN);
                        proto_tree_add_bitmask(community_tree, tvb, offset+6, hf_bgp_ext_com_etree_flags, ett_bgp_ext_com_etree_flags, com_etree_flags, ENC_BIG_ENDIAN);
                        }
                        break;

                    default:
                        /* The particular Experimental subtype is unknown or
                         * the dissector is not written yet. We will dump the
                         * entire community value in 2-byte short words.
                         */
                        proto_tree_add_uint64_format_value(community_tree, hf_bgp_ext_com_value_raw, tvb, offset+2, 6,
                                tvb_get_ntoh48 (tvb, offset+2), "0x%04x 0x%04x 0x%04x",
                                tvb_get_ntohs(tvb,offset+2),
                                tvb_get_ntohs(tvb,offset+4),
                                tvb_get_ntohs(tvb,offset+6));

                        proto_item_append_text(community_item, " 0x%04x 0x%04x 0x%04x",
                                tvb_get_ntohs(tvb,offset+2), tvb_get_ntohs(tvb,offset+4), tvb_get_ntohs(tvb,offset+6));
                        break;
                }
                break;

            case BGP_EXT_COM_TYPE_HIGH_TR_EXP_2:
                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_tr_exp_2, tvb, offset+1, 1, ENC_BIG_ENDIAN);

                proto_item_set_text(community_item, "%s:",
                        val_to_str(com_stype_low_byte, bgpext_com_stype_tr_exp_2, "Unknown subtype 0x%02x"));

                switch (com_stype_low_byte) {
                    case BGP_EXT_COM_STYPE_EXP_2_FLOW_RED:
                        {
                                proto_tree_add_item(community_tree, hf_bgp_ext_com_value_IP4, tvb, offset+2, 4, ENC_NA);
                                proto_tree_add_item(community_tree, hf_bgp_ext_com_value_an2, tvb, offset+6, 2, ENC_BIG_ENDIAN);
                        }
                        break;

                    default:
                        /* The particular Experimental subtype is unknown or
                         * the dissector is not written yet. We will dump the
                         * entire community value in 2-byte short words.
                         */
                        proto_tree_add_uint64_format_value(community_tree, hf_bgp_ext_com_value_raw, tvb, offset+2, 6,
                                tvb_get_ntoh48 (tvb, offset+2), "0x%04x 0x%04x 0x%04x",
                                tvb_get_ntohs(tvb,offset+2),
                                tvb_get_ntohs(tvb,offset+4),
                                tvb_get_ntohs(tvb,offset+6));

                        proto_item_append_text(community_item, " 0x%04x 0x%04x 0x%04x",
                                tvb_get_ntohs(tvb,offset+2), tvb_get_ntohs(tvb,offset+4), tvb_get_ntohs(tvb,offset+6));
                        break;
                }
                break;

            case BGP_EXT_COM_TYPE_HIGH_TR_EXP_3:
                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_tr_exp_3, tvb, offset+1, 1, ENC_BIG_ENDIAN);

                proto_item_set_text(community_item, "%s:",
                        val_to_str(com_stype_low_byte, bgpext_com_stype_tr_exp_3, "Unknown subtype 0x%02x"));

                switch (com_stype_low_byte) {
                    case BGP_EXT_COM_STYPE_EXP_3_FLOW_RED:
                        {
                                proto_tree_add_item(community_tree, hf_bgp_ext_com_value_as4, tvb, offset+2, 4, ENC_BIG_ENDIAN);
                                proto_tree_add_item(community_tree, hf_bgp_ext_com_value_an2, tvb, offset+6, 2, ENC_BIG_ENDIAN);
                        }
                        break;

                    default:
                        /* The particular Experimental subtype is unknown or
                         * the dissector is not written yet. We will dump the
                         * entire community value in 2-byte short words.
                         */
                        proto_tree_add_uint64_format_value(community_tree, hf_bgp_ext_com_value_raw, tvb, offset+2, 6,
                                tvb_get_ntoh48 (tvb, offset+2), "0x%04x 0x%04x 0x%04x",
                                tvb_get_ntohs(tvb,offset+2),
                                tvb_get_ntohs(tvb,offset+4),
                                tvb_get_ntohs(tvb,offset+6));

                        proto_item_append_text(community_item, " 0x%04x 0x%04x 0x%04x",
                                tvb_get_ntohs(tvb,offset+2), tvb_get_ntohs(tvb,offset+4), tvb_get_ntohs(tvb,offset+6));
                        break;
                }
                break;

            case BGP_EXT_COM_TYPE_HIGH_TR_EXP_EIGRP:
                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_tr_exp_eigrp, tvb, offset+1, 1, ENC_BIG_ENDIAN);

                proto_item_set_text(community_item, "%s:",
                        val_to_str(com_stype_low_byte, bgpext_com_stype_tr_eigrp, "Unknown subtype 0x%02x"));

                switch(com_stype_low_byte) {
                    case BGP_EXT_COM_STYPE_EXP_EIGRP_FT:
                        {
                        proto_item *eigrp_flags_item;
                        proto_tree *eigrp_flags_tree;

                        eigrp_flags_item = proto_tree_add_item(community_tree, hf_bgp_ext_com_eigrp_flags, tvb, offset+2, 2, ENC_BIG_ENDIAN);
                        eigrp_flags_tree = proto_item_add_subtree(eigrp_flags_item, ett_bgp_ext_com_eigrp_flags);

                        proto_tree_add_item(eigrp_flags_tree, hf_bgp_ext_com_eigrp_flags_rt, tvb, offset+2, 2, ENC_BIG_ENDIAN);
                        proto_item_append_text(eigrp_flags_tree, " (%s)",
                                tfs_get_string(tvb_get_ntohs(tvb, offset+2) & BGP_EXT_COM_EXP_EIGRP_FLAG_RT, &tfs_eigrp_rtype));
                        proto_item_append_text(community_tree, " %s route",
                                tfs_get_string(tvb_get_ntohs(tvb, offset+2) & BGP_EXT_COM_EXP_EIGRP_FLAG_RT, &tfs_eigrp_rtype));

                        proto_tree_add_item(community_tree, hf_bgp_ext_com_eigrp_rtag, tvb, offset+4, 4, ENC_BIG_ENDIAN);
                        proto_item_append_text(community_tree, ", Tag: %u", tvb_get_ntohl(tvb, offset+4));
                        }
                        break;

                    case BGP_EXT_COM_STYPE_EXP_EIGRP_AD:
                        {
                        guint32 raw_value;

                        proto_tree_add_item(community_tree, hf_bgp_ext_com_eigrp_asn, tvb, offset+2, 2, ENC_BIG_ENDIAN);

                        raw_value = tvb_get_ntohl(tvb, offset+4);
                        proto_tree_add_uint_format_value(community_tree, hf_bgp_ext_com_eigrp_delay,
                                tvb, offset+4, 4, raw_value, "%u (%u usec)", raw_value, raw_value * 10 / 256);

                        proto_item_append_text(community_item, " ASN: %u, D: %u",
                                tvb_get_ntohs(tvb, offset+2), raw_value);
                        }
                        break;

                    case BGP_EXT_COM_STYPE_EXP_EIGRP_RHB:
                        {
                        guint32 raw_value;

                        raw_value = tvb_get_guint8(tvb, offset+2);
                        proto_tree_add_uint_format_value(community_tree, hf_bgp_ext_com_eigrp_rly,
                                tvb, offset+2, 1, raw_value, "%u (%u%%)", raw_value, (raw_value * 100) / 255);
                        proto_item_append_text(community_item, " R: %u", raw_value);

                        proto_tree_add_item(community_tree, hf_bgp_ext_com_eigrp_hops, tvb, offset+3, 1, ENC_BIG_ENDIAN);
                        proto_item_append_text(community_tree, ", H: %u", tvb_get_guint8(tvb, offset+3));

                        raw_value = tvb_get_ntohl(tvb, offset+4);
                        proto_tree_add_uint_format_value(community_tree, hf_bgp_ext_com_eigrp_bw,
                                tvb, offset+4, 4, raw_value, "%u (%u Kbps)", raw_value, raw_value ? (2560000000U / raw_value) : 0);
                        proto_item_append_text(community_tree, ", B: %u", raw_value);
                        }
                        break;

                    case BGP_EXT_COM_STYPE_EXP_EIGRP_LM:
                        {
                        guint32 raw_value;

                        raw_value = tvb_get_guint8(tvb, offset+3);
                        proto_tree_add_uint_format_value(community_tree, hf_bgp_ext_com_eigrp_load,
                                tvb, offset+3, 1, raw_value, "%u (%u%%)", raw_value, (raw_value * 100) / 255);
                        proto_item_append_text(community_tree, " L: %u", raw_value);

                        proto_tree_add_item(community_tree, hf_bgp_ext_com_eigrp_mtu, tvb, offset+4, 4, ENC_BIG_ENDIAN);
                        proto_item_append_text(community_tree, ", M: %u", tvb_get_ntohl(tvb, offset+4));
                        }
                        break;

                    case BGP_EXT_COM_STYPE_EXP_EIGRP_EAR:
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_eigrp_e_asn, tvb, offset+2, 2, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_eigrp_e_rid, tvb, offset+4, 4, ENC_BIG_ENDIAN);

                        proto_item_append_text(community_tree, " ASN: %u, RID: %s",
                                tvb_get_ntohs(tvb, offset+2), tvb_ip_to_str(pinfo->pool, tvb, offset+4));
                        break;

                    case BGP_EXT_COM_STYPE_EXP_EIGRP_EPM:
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_eigrp_e_pid, tvb, offset+2, 2, ENC_BIG_ENDIAN);
                        proto_tree_add_item(community_tree, hf_bgp_ext_com_eigrp_e_m, tvb, offset+4, 4, ENC_BIG_ENDIAN);

                        proto_item_append_text(community_tree, " %s, Metric: %u",
                          val_to_str(tvb_get_ntohs(tvb, offset+2), eigrp_proto2string, "Unknown protocol %u"),
                          tvb_get_ntohl(tvb, offset+4));
                        break;

                    case BGP_EXT_COM_STYPE_EXP_EIGRP_RID:
                       proto_tree_add_item(community_tree, hf_bgp_ext_com_eigrp_rid, tvb, offset+4, 4, ENC_NA);
                       proto_item_append_text(community_tree, " %s", tvb_ip_to_str(pinfo->pool, tvb, offset+4));
                     break;
                }
                break;

            case BGP_EXT_COM_TYPE_HIGH_TR_FLOW: /* Flow spec redirect/mirror to IP next-hop [draft-simpson-idr-flowspec-redirect] */
            default:
                proto_tree_add_item(community_tree, hf_bgp_ext_com_stype_low_unknown, tvb, offset+1, 1, ENC_BIG_ENDIAN);

                proto_tree_add_uint64_format_value(community_tree, hf_bgp_ext_com_value_raw, tvb, offset+2, 6,
                        tvb_get_ntoh48 (tvb, offset+2), "0x%04x 0x%04x 0x%04x",
                        tvb_get_ntohs(tvb,offset+2),
                        tvb_get_ntohs(tvb,offset+4),
                        tvb_get_ntohs(tvb,offset+6));

                proto_item_set_text(community_item, "Unknown type 0x%02x subtype 0x%02x: 0x%04x 0x%04x 0x%04x",
                        com_type_high_byte, com_stype_low_byte,
                        tvb_get_ntohs(tvb,offset+2), tvb_get_ntohs(tvb,offset+4), tvb_get_ntohs(tvb,offset+6));
                break;
        }
        proto_item_append_text (community_item, " [%s]", val_to_str_const(com_type_high_byte, bgpext_com_type_high, "Unknown community"));
        offset = offset + 8;
    }
    return(0);
}
