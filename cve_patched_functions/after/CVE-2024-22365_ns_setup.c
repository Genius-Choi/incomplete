static int ns_setup(struct polydir_s *polyptr,
	struct instance_data *idata)
{
    int retval;
    int newdir = 1;
    char *inst_dir = NULL;
    char *instname = NULL;
    struct stat statbuf;
#ifdef WITH_SELINUX
    char *instcontext = NULL, *origcontext = NULL;
#endif

    if (idata->flags & PAMNS_DEBUG)
        pam_syslog(idata->pamh, LOG_DEBUG,
               "Set namespace for directory %s", polyptr->dir);

    retval = protect_dir(polyptr->dir, 0, 0, idata);

    if (retval < 0 && errno != ENOENT) {
	pam_syslog(idata->pamh, LOG_ERR, "Polydir %s access error: %m",
		polyptr->dir);
	return PAM_SESSION_ERR;
    }

    if (retval < 0) {
	if ((polyptr->flags & POLYDIR_CREATE) &&
		create_polydir(polyptr, idata) != PAM_SUCCESS)
		return PAM_SESSION_ERR;
    } else {
	close(retval);
    }

    if (polyptr->method == TMPFS) {
	if (mount("tmpfs", polyptr->dir, "tmpfs", polyptr->mount_flags, polyptr->mount_opts) < 0) {
	    pam_syslog(idata->pamh, LOG_ERR, "Error mounting tmpfs on %s, %m",
		polyptr->dir);
            return PAM_SESSION_ERR;
	}

	if (polyptr->flags & POLYDIR_NOINIT)
	    return PAM_SUCCESS;

	return inst_init(polyptr, "tmpfs", idata, 1);
    }

    if (stat(polyptr->dir, &statbuf) < 0) {
	pam_syslog(idata->pamh, LOG_ERR, "Error stating %s: %m",
		polyptr->dir);
        return PAM_SESSION_ERR;
    }

    /*
     * Obtain the name of instance pathname based on the
     * polyinstantiation method and instance context returned by
     * security policy.
     */
#ifdef WITH_SELINUX
    retval = poly_name(polyptr, &instname, &instcontext,
			&origcontext, idata);
#else
    retval = poly_name(polyptr, &instname, idata);
#endif

    if (retval != PAM_SUCCESS) {
	if (retval != PAM_IGNORE)
		pam_syslog(idata->pamh, LOG_ERR, "Error getting instance name");
        goto cleanup;
    } else {
#ifdef WITH_SELINUX
        if ((idata->flags & PAMNS_DEBUG) &&
            (idata->flags & PAMNS_SELINUX_ENABLED))
            pam_syslog(idata->pamh, LOG_DEBUG, "Inst ctxt %s Orig ctxt %s",
		 instcontext, origcontext);
#endif
    }

    if (asprintf(&inst_dir, "%s%s", polyptr->instance_prefix, instname) < 0)
	goto error_out;

    if (idata->flags & PAMNS_DEBUG)
        pam_syslog(idata->pamh, LOG_DEBUG, "instance_dir %s",
		inst_dir);

    /*
     * Create instance directory with appropriate security
     * contexts, owner, group and mode bits.
     */
#ifdef WITH_SELINUX
    retval = create_instance(polyptr, inst_dir, &statbuf, instcontext,
			 origcontext, idata);
#else
    retval = create_instance(polyptr, inst_dir, &statbuf, idata);
#endif

    if (retval == PAM_IGNORE) {
	newdir = 0;
	retval = PAM_SUCCESS;
    }

    if (retval != PAM_SUCCESS) {
        goto error_out;
    }

    /*
     * Bind mount instance directory on top of the polyinstantiated
     * directory to provide an instance of polyinstantiated directory
     * based on polyinstantiated method.
     */
    if (mount(inst_dir, polyptr->dir, NULL, MS_BIND, NULL) < 0) {
        pam_syslog(idata->pamh, LOG_ERR, "Error mounting %s on %s, %m",
                   inst_dir, polyptr->dir);
        goto error_out;
    }

    if (!(polyptr->flags & POLYDIR_NOINIT))
	retval = inst_init(polyptr, inst_dir, idata, newdir);

    goto cleanup;

    /*
     * various error exit points. Free allocated memory and set return
     * value to indicate a pam session error.
     */
error_out:
    retval = PAM_SESSION_ERR;

cleanup:
    free(inst_dir);
    free(instname);
#ifdef WITH_SELINUX
    freecon(instcontext);
    freecon(origcontext);
#endif
    return retval;
}
