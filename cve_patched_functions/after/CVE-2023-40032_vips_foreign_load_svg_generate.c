vips_foreign_load_svg_generate( VipsRegion *or, 
	void *seq, void *a, void *b, gboolean *stop )
{
	const VipsForeignLoadSvg *svg = (VipsForeignLoadSvg *) a;
	const VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( svg );
	const VipsRect *r = &or->valid;

	cairo_surface_t *surface;
	cairo_t *cr;
	int y;

#ifdef DEBUG
	printf( "vips_foreign_load_svg_generate: %p \n     "
		"left = %d, top = %d, width = %d, height = %d\n", 
		svg,
		r->left, r->top, r->width, r->height ); 
#endif /*DEBUG*/

	/* rsvg won't always paint the background.
	 */
	vips_region_black( or ); 

	surface = cairo_image_surface_create_for_data( 
		VIPS_REGION_ADDR( or, r->left, r->top ), 
		CAIRO_FORMAT_ARGB32, 
		r->width, r->height, 
		VIPS_REGION_LSKIP( or ) );
	cr = cairo_create( surface );
	cairo_surface_destroy( surface );

	/* rsvg is single-threaded, but we don't need to lock since we're
	 * running inside a non-threaded tilecache.
	 */
#if LIBRSVG_CHECK_VERSION( 2, 46, 0 )

{
	RsvgRectangle viewport;
	GError *error = NULL;

	/* No need to scale -- we always set the viewport to the
	 * whole image, and set the region to draw on the surface.
	 */
	cairo_translate( cr, -r->left, -r->top );
	viewport.x = 0;
	viewport.y = 0;
	viewport.width = or->im->Xsize;
	viewport.height = or->im->Ysize;

	if( !rsvg_handle_render_document( svg->page, cr, &viewport, &error ) ) {
		cairo_destroy( cr );
		vips_operation_invalidate( VIPS_OPERATION( svg ) );
		vips_error( class->nickname, 
			"%s", _( "SVG rendering failed" ) );
		vips_g_error( &error );
		return( -1 );
	}

	cairo_destroy( cr );
}

#else /*!LIBRSVG_CHECK_VERSION( 2, 46, 0 )*/

	cairo_scale( cr, svg->cairo_scale, svg->cairo_scale );
	cairo_translate( cr, -r->left / svg->cairo_scale,
		-r->top / svg->cairo_scale );

	if( !rsvg_handle_render_cairo( svg->page, cr ) ) {
		cairo_destroy( cr );
		vips_operation_invalidate( VIPS_OPERATION( svg ) );
		vips_error( class->nickname,
			"%s", _( "SVG rendering failed" ) );
		return( -1 );
	}

	cairo_destroy( cr );

#endif /*LIBRSVG_CHECK_VERSION( 2, 46, 0 )*/

	/* Cairo makes pre-multipled BRGA -- we must byteswap and unpremultiply.
	 */
	for( y = 0; y < r->height; y++ ) 
                vips__premultiplied_bgra2rgba( 
			(guint32 *) VIPS_REGION_ADDR( or, r->left, r->top + y ),
			r->width ); 

	return( 0 ); 
}
