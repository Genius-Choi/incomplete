static SDL_INLINE int Find_GlyphByIndex(TTF_Font *font, FT_UInt idx,
        int want_bitmap, int want_pixmap, int want_color, int want_subpixel,
        int translation, c_glyph **out_glyph, TTF_Image **out_image)
{
    /* cache size is 256, get key by masking */
    c_glyph *glyph = &font->cache[idx & 0xff];

    if (out_glyph) {
        *out_glyph = glyph;
    }

    if (want_pixmap || want_color) {
        *out_image = &glyph->pixmap;
    }

    if (want_bitmap) {
        *out_image = &glyph->bitmap;
    }

    if (want_subpixel)
    {
        /* No a real cache, but if it always advances by integer pixels (eg translation 0 or same as previous),
         * this allows to render as fast as normal mode. */
        int retval;
        int want = CACHED_METRICS | want_bitmap | want_pixmap | want_color | want_subpixel;

        if (glyph->stored && glyph->index != idx) {
            Flush_Glyph(glyph);
        }

        if (glyph->subpixel.translation == translation) {
            want &= ~CACHED_SUBPIX;
        }

        if ((glyph->stored & want) == want) {
            return 0;
        }

        glyph->index = idx;
        retval = Load_Glyph(font, glyph, want, translation);
        if (retval == 0) {
            return 0;
        } else {
            return -1;
        }
    }
    else
    {
        int retval;
        const int want = CACHED_METRICS | want_bitmap | want_pixmap | want_color;

        /* Faster check as it gets inlined */
        if (want_pixmap) {
            if ((glyph->stored & CACHED_PIXMAP) && glyph->index == idx) {
                return 0;
            }
        } else if (want_bitmap) {
            if ((glyph->stored & CACHED_BITMAP) && glyph->index == idx) {
                return 0;
            }
        } else if (want_color) {
            if ((glyph->stored & CACHED_COLOR) && glyph->index == idx) {
                return 0;
            }
        } else {
            /* Get metrics */
            if (glyph->stored && glyph->index == idx) {
                return 0;
            }
        }

        /* Cache cannot contain both PIXMAP and COLOR (unless COLOR is actually not colored). 
           So, if it's already used, clear it */
        if (want_color || want_pixmap) {
            if (glyph->stored & (CACHED_COLOR|CACHED_PIXMAP)) {
                Flush_Glyph(glyph);
            }
        }

        if (glyph->stored && glyph->index != idx) {
            Flush_Glyph(glyph);
        }

        glyph->index = idx;
        retval = Load_Glyph(font, glyph, want, 0);
        if (retval == 0) {
            return 0;
        } else {
            return -1;
        }
    }
}
