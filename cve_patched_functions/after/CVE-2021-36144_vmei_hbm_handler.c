vmei_hbm_handler(struct virtio_mei *vmei, const void *data, size_t len)
{
	struct mei_hbm_cmd *hbm_cmd = NULL;
	struct vmei_me_client *mclient = NULL;
	struct vmei_host_client *hclient = NULL;
	uint8_t status;

	if (len < sizeof(*hbm_cmd)) {
		return -EINVAL;
	}

	hbm_cmd = (struct mei_hbm_cmd *)data;
	DPRINTF("HBM cmd[0x%X] is handling\n", hbm_cmd->cmd);

	switch (hbm_cmd->cmd) {
	case MEI_HBM_HOST_START: {
		const struct mei_hbm_host_ver_req *req = data;

		if (sizeof(*req) < len) {
			return -EINVAL;
		}
		vmei_hbm_version(vmei, req);
	}
	break;
	case MEI_HBM_HOST_ENUM: {
		const struct mei_hbm_host_enum_req *req = data;
		struct mei_hbm_host_enum_res res = {};

		if (sizeof(*req) < len) {
			return -EINVAL;
		}

		res.hbm_cmd = req->hbm_cmd;
		res.hbm_cmd.is_response = 1;
		/* copy valid_addresses for hbm enum request */
		memcpy(res.valid_addresses, &vmei->me_clients_map,
		       sizeof(res.valid_addresses));
		vmei_hbm_response(vmei, &res, sizeof(res));
	}
	break;

	case MEI_HBM_HOST_CLIENT_PROP: {
		const struct mei_hbm_host_client_prop_req *req = data;
		struct mei_hbm_host_client_prop_res res;

		if (sizeof(*req) < len) {
			return -EINVAL;
		}

		res.hbm_cmd = req->hbm_cmd;
		res.hbm_cmd.is_response = 1;
		res.address = req->address;

		mclient = vmei_find_me_client(vmei, req->address);
		if (mclient) {
			memcpy(&res.props, &mclient->props, sizeof(res.props));
			res.status = MEI_HBM_SUCCESS;
		} else {
			res.status = MEI_HBM_CLIENT_NOT_FOUND;
		}

		vmei_dbg_client_properties(&res.props);

		vmei_hbm_response(vmei, &res, sizeof(res));
	}
	break;

	case MEI_HBM_FLOW_CONTROL: {
		/*
		 * FE client is ready, we can send message
		 */
		const struct mei_hbm_flow_ctl *req = data;
		if (sizeof(*req) < len) {
			return -EINVAL;
		}

		hclient = vmei_find_host_client(vmei, req->me_addr, req->host_addr);
		if (hclient) {
			hclient->recv_creds++;
			mevent_enable(hclient->rx_mevp);

			vmei_host_client_put(hclient);

			pthread_mutex_lock(&vmei->rx_mutex);
			vmei->rx_need_sched = true;
			pthread_mutex_unlock(&vmei->rx_mutex);
		} else {
			DPRINTF("client has been released.\n");
		}
	}
	break;

	case MEI_HBM_CLIENT_CONNECT: {

		const struct mei_hbm_client_connect_req *req = data;
		struct mei_hbm_client_connect_res res;

		if (sizeof(*req) < len) {
			return -EINVAL;
		}

		res = *(struct mei_hbm_client_connect_res *)req;
		res.hbm_cmd.is_response = 1;

		mclient = vmei_find_me_client(vmei, req->me_addr);
		if (!mclient) {
			/* NOT FOUND */
			DPRINTF("client with me address %d was not found\n",
				req->me_addr);
			res.status = MEI_HBM_CLIENT_NOT_FOUND;
			vmei_hbm_response(vmei, &res, sizeof(res));
			break;
		}

		hclient = vmei_me_client_get_host_client(mclient,
							 req->host_addr);
		if (hclient) {
			DPRINTF("client alread exists return BUSY!\n");
			res.status = MEI_HBM_ALREADY_EXISTS;
			vmei_host_client_put(hclient);
			hclient = NULL;
			vmei_hbm_response(vmei, &res, sizeof(res));
			break;
		}

		/* create a new host client and add ito the list */
		hclient = vmei_host_client_create(mclient, req->host_addr);
		if (!hclient) {
			res.status = MEI_HBM_REJECTED;
			vmei_hbm_response(vmei, &res, sizeof(res));
			break;
		}

		status = vmei_host_client_native_connect(hclient);
		res.status = status;
		vmei_hbm_response(vmei, &res, sizeof(res));

		if (status) {
			vmei_host_client_put(hclient);
			hclient = NULL;
			break;
		}

		vmei_hbm_flow_ctl_req(hclient);
	}
	break;

	case MEI_HBM_CLIENT_DISCONNECT: {

		const struct mei_hbm_client_disconnect_req *req = data;
		struct mei_hbm_client_disconnect_res res;

		if (sizeof(*req) < len) {
			return -EINVAL;
		}

		hclient = vmei_find_host_client(vmei, req->me_addr, req->host_addr);
		if (hclient) {
			vmei_host_client_put(hclient);
			vmei_host_client_put(hclient);
			hclient = NULL;
			status = MEI_HBM_SUCCESS;
		} else {
			status = MEI_HBM_CLIENT_NOT_FOUND;
		}

		if (hbm_cmd->is_response)
			break;

		memset(&res, 0, sizeof(res));
		res.hbm_cmd.cmd = MEI_HBM_CLIENT_DISCONNECT;
		res.hbm_cmd.is_response = 1;
		res.me_addr = req->me_addr;
		res.host_addr = req->host_addr;
		res.status = status;
		vmei_hbm_response(vmei, &res, sizeof(res));
	}
	break;

	case MEI_HBM_PG_ISOLATION_ENTRY: {

		struct mei_hbm_power_gate res;

		memset(&res, 0, sizeof(res));
		res.hbm_cmd.cmd = MEI_HBM_PG_ISOLATION_ENTRY;
		res.hbm_cmd.is_response = 1;
		vmei_hbm_response(vmei, &res, sizeof(res));
	}
	break;

	case MEI_HBM_NOTIFY: {

		const struct mei_hbm_notification_req *req = data;
		struct mei_hbm_notification_res res;

		if (sizeof(*req) < len) {
			return -EINVAL;
		}

		memset(&res, 0, sizeof(res));
		res.hbm_cmd.cmd = MEI_HBM_NOTIFY;
		res.hbm_cmd.is_response = 1;
		res.start = req->start;

		hclient = vmei_find_host_client(vmei, req->me_addr,
						req->host_addr);
		if (hclient) {
			/* The notify is not supported now */
			res.status = MEI_HBM_REJECTED;
			vmei_host_client_put(hclient);
		} else {
			res.status = MEI_HBM_INVALID_PARAMETER;
		}
		vmei_hbm_response(vmei, &res, sizeof(res));
	}
	break;

	case MEI_HBM_HOST_STOP:
		DPRINTF("HBM cmd[%d] not supported\n", hbm_cmd->cmd);
		break;

	case MEI_HBM_ME_STOP:
		DPRINTF("HBM cmd[%d] not supported\n", hbm_cmd->cmd);
		break;

	default:
		DPRINTF("HBM cmd[0x%X] unhandled\n", hbm_cmd->cmd);
	}

	return 0;
}
