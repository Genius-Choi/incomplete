void Monitor::tick()
{
  // ok go.
  dout(11) << "tick" << dendl;
  
  for (vector<PaxosService*>::iterator p = paxos_service.begin(); p != paxos_service.end(); ++p) {
    (*p)->tick();
    (*p)->maybe_trim();
  }
  
  // trim sessions
  utime_t now = ceph_clock_now(g_ceph_context);
  xlist<MonSession*>::iterator p = session_map.sessions.begin();

  bool out_for_too_long = (!exited_quorum.is_zero()
      && now > (exited_quorum + 2*g_conf->mon_lease));

  while (!p.end()) {
    MonSession *s = *p;
    ++p;
    
    // don't trim monitors
    if (s->inst.name.is_mon())
      continue;

    if (s->session_timeout < now && s->con) {
      // check keepalive, too
      s->session_timeout = s->con->get_last_keepalive();
      s->session_timeout += g_conf->mon_session_timeout;
    }
    if (s->session_timeout < now) {
      dout(10) << " trimming session " << s->con << " " << s->inst
	       << " (timeout " << s->session_timeout
	       << " < now " << now << ")" << dendl;
    } else if (out_for_too_long) {
      // boot the client Session because we've taken too long getting back in
      dout(10) << " trimming session " << s->con << " " << s->inst
        << " because we've been out of quorum too long" << dendl;
    } else {
      continue;
    }

    s->con->mark_down();
    remove_session(s);
    logger->inc(l_mon_session_trim);
  }

  sync_trim_providers();

  if (!maybe_wait_for_quorum.empty()) {
    finish_contexts(g_ceph_context, maybe_wait_for_quorum);
  }

  if (is_leader() && paxos->is_active() && fingerprint.is_zero()) {
    // this is only necessary on upgraded clusters.
    MonitorDBStore::TransactionRef t = paxos->get_pending_transaction();
    prepare_new_fingerprint(t);
    paxos->trigger_propose();
  }

  new_tick();
}
