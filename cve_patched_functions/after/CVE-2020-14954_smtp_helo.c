static int smtp_helo(struct Connection *conn, bool esmtp)
{
  Capabilities = 0;

  if (!esmtp)
  {
    /* if TLS or AUTH are requested, use EHLO */
    if (conn->account.flags & MUTT_ACCT_USER)
      esmtp = true;
#ifdef USE_SSL
    if (C_SslForceTls || (C_SslStarttls != MUTT_NO))
      esmtp = true;
#endif
  }

  const char *fqdn = mutt_fqdn(false);
  if (!fqdn)
    fqdn = NONULL(ShortHostname);

  char buf[1024];
  snprintf(buf, sizeof(buf), "%s %s\r\n", esmtp ? "EHLO" : "HELO", fqdn);
  /* XXX there should probably be a wrapper in mutt_socket.c that
   * repeatedly calls conn->write until all data is sent.  This
   * currently doesn't check for a short write.  */
  if (mutt_socket_send(conn, buf) == -1)
    return SMTP_ERR_WRITE;
  return smtp_get_resp(conn);
}
