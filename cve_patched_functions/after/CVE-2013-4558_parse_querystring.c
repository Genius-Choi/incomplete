parse_querystring(request_rec *r, const char *query,
                  dav_resource_combined *comb, apr_pool_t *pool)
{
  svn_error_t *serr;
  svn_revnum_t working_rev, peg_rev;
  apr_table_t *pairs = querystring_to_table(query, pool);
  const char *prevstr = apr_table_get(pairs, "p");
  const char *wrevstr;
  const char *keyword_subst;

  /* Will we be doing keyword substitution? */
  keyword_subst = apr_table_get(pairs, "kw");
  if (keyword_subst && (strcmp(keyword_subst, "1") == 0))
    comb->priv.keyword_subst = TRUE;

  if (prevstr)
    {
      while (*prevstr == 'r')
        prevstr++;
      peg_rev = SVN_STR_TO_REV(prevstr);
      if (!SVN_IS_VALID_REVNUM(peg_rev))
        return dav_svn__new_error(pool, HTTP_BAD_REQUEST, 0,
                                  "invalid peg rev in query string");
    }
  else
    {
      /* No peg-rev?  Default to HEAD, just like the cmdline client. */
      serr = svn_fs_youngest_rev(&peg_rev, comb->priv.repos->fs, pool);
      if (serr != NULL)
        return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                    "Couldn't fetch youngest rev.", pool);
    }

  wrevstr = apr_table_get(pairs, "r");
  if (wrevstr)
    {
      while (*wrevstr == 'r')
        wrevstr++;
      working_rev = SVN_STR_TO_REV(wrevstr);
      if (!SVN_IS_VALID_REVNUM(working_rev))
        return dav_svn__new_error(pool, HTTP_BAD_REQUEST, 0,
                                  "invalid working rev in query string");
    }
  else
    {
      /* No working-rev?  Assume it's equal to the peg-rev, just
         like the cmdline client does. */
      working_rev = peg_rev;
    }

  /* If WORKING_REV is younger than PEG_REV, we have a problem.
     Our node-tracing algorithms can't handle that scenario, so we'll
     disallow it here. */
  if (working_rev > peg_rev)
    return dav_svn__new_error(pool, HTTP_BAD_REQUEST, 0,
                              "working rev greater than peg rev.");

  /* If WORKING_REV and PEG_REV are equivalent, we want to return the
     resource at the revision.  Otherwise, WORKING_REV is older than
     PEG_REV, so we need to crawl back through the history of
     REPOS_PATH@PEG_REV until we hit WORKING_REV.  We'll then redirect
     the client to the new location/revision pair found by that crawl. */
  if (working_rev == peg_rev)
    {
      comb->priv.root.rev = peg_rev;

      /* Did we have a peg revision?  Remember this little fact (in
         case deliver() needs to know it). */
      if (prevstr)
        comb->priv.pegged = TRUE;
    }
  else
    {
      const char *newpath, *location;
      apr_hash_t *locations;
      apr_array_header_t *loc_revs = apr_array_make(pool, 1,
                                                    sizeof(svn_revnum_t));

      dav_svn__authz_read_baton *arb = apr_pcalloc(pool, sizeof(*arb));
      arb->r = comb->priv.r;
      arb->repos = comb->priv.repos;

      APR_ARRAY_PUSH(loc_revs, svn_revnum_t) = working_rev;
      if ((serr = svn_repos_trace_node_locations(comb->priv.repos->fs,
                                                 &locations,
                                                 comb->priv.repos_path,
                                                 peg_rev,
                                                 loc_revs,
                                                 dav_svn__authz_read_func(arb),
                                                 arb,
                                                 pool)))
        return dav_svn__convert_err(serr, HTTP_INTERNAL_SERVER_ERROR,
                                    "Couldn't trace history.", pool);

      newpath = apr_hash_get(locations, &working_rev, sizeof(svn_revnum_t));
      if (! newpath)
        return dav_svn__new_error(pool, HTTP_NOT_FOUND, 0,
                                  "path doesn't exist in that revision.");

      /* Redirect folks to a canonical, peg-revision-only location.
         If they used a peg revision in this request, we can use a
         permanent redirect.  If they didn't (peg-rev is HEAD), we can
         only use a temporary redirect.  In either case, preserve the
         "keyword_subst" state in the redirected location, too.  */
      location = ap_construct_url(r->pool,
                                  apr_psprintf(r->pool, "%s%s?p=%ld%s",
                                               (comb->priv.repos->root_path[1]
                                                ? comb->priv.repos->root_path
                                                : ""),
                                               newpath, working_rev,
                                               keyword_subst ? "&kw=1" : ""),
                                  r);
      apr_table_setn(r->headers_out, "Location", location);
      return dav_svn__new_error(r->pool,
                                prevstr ? HTTP_MOVED_PERMANENTLY
                                        : HTTP_MOVED_TEMPORARILY,
                                0, "redirecting to canonical location");
    }

  return NULL;
}
