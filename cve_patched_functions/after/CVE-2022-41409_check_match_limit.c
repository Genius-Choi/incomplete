check_match_limit(uint8_t *pp, PCRE2_SIZE ulen, int errnumber, const char *msg)
{
int capcount;
uint32_t min = 0;
uint32_t mid = 64;
uint32_t max = UINT32_MAX;

PCRE2_SET_MATCH_LIMIT(dat_context, max);
PCRE2_SET_DEPTH_LIMIT(dat_context, max);
PCRE2_SET_HEAP_LIMIT(dat_context, max);

for (;;)
  {
  uint32_t stack_start = 0;

  /* If we are checking the heap limit, free any frames vector that is cached
  in the match_data so we always start without one. */

  if (errnumber == PCRE2_ERROR_HEAPLIMIT)
    {
    PCRE2_SET_HEAP_LIMIT(dat_context, mid);

#ifdef SUPPORT_PCRE2_8
    if (code_unit_size == 1)
      {
      match_data8->memctl.free(match_data8->heapframes,
        match_data8->memctl.memory_data);
      match_data8->heapframes = NULL;
      match_data8->heapframes_size = 0;
      }
#endif

#ifdef SUPPORT_PCRE2_16
    if (code_unit_size == 2)
      {
      match_data16->memctl.free(match_data16->heapframes,
        match_data16->memctl.memory_data);
      match_data16->heapframes = NULL;
      match_data16->heapframes_size = 0;
      }
#endif

#ifdef SUPPORT_PCRE2_32
    if (code_unit_size == 4)
      {
      match_data32->memctl.free(match_data32->heapframes,
        match_data32->memctl.memory_data);
      match_data32->heapframes = NULL;
      match_data32->heapframes_size = 0;
      }
#endif
    }

  /* No need to mess with the frames vector for match or depth limits. */

  else if (errnumber == PCRE2_ERROR_MATCHLIMIT)
    {
    PCRE2_SET_MATCH_LIMIT(dat_context, mid);
    }
  else
    {
    PCRE2_SET_DEPTH_LIMIT(dat_context, mid);
    }

  /* Do the appropriate match */

  if ((dat_datctl.control & CTL_DFA) != 0)
    {
    stack_start = DFA_START_RWS_SIZE/1024;
    if (dfa_workspace == NULL)
      dfa_workspace = (int *)malloc(DFA_WS_DIMENSION*sizeof(int));
    if (dfa_matched++ == 0)
      dfa_workspace[0] = -1;  /* To catch bad restart */
    PCRE2_DFA_MATCH(capcount, compiled_code, pp, ulen, dat_datctl.offset,
      dat_datctl.options, match_data,
      PTR(dat_context), dfa_workspace, DFA_WS_DIMENSION);
    }

  else if ((pat_patctl.control & CTL_JITFAST) != 0)
    PCRE2_JIT_MATCH(capcount, compiled_code, pp, ulen, dat_datctl.offset,
      dat_datctl.options, match_data, PTR(dat_context));

  else
    {
    PCRE2_MATCH(capcount, compiled_code, pp, ulen, dat_datctl.offset,
      dat_datctl.options, match_data, PTR(dat_context));
    }

  if (capcount == errnumber)
    {
    if ((mid & 0x80000000u) != 0)
      {
      fprintf(outfile, "Can't find minimum %s limit: check pattern for "
        "restriction\n", msg);
      break;
      }

    min = mid;
    mid = (mid == max - 1)? max : (max != UINT32_MAX)? (min + max)/2 : mid*2;
    }
  else if (capcount >= 0 ||
           capcount == PCRE2_ERROR_NOMATCH ||
           capcount == PCRE2_ERROR_PARTIAL)
    {
    /* If we've not hit the error with a heap limit less than the size of the
    initial stack frame vector (for pcre2_match()) or the initial stack
    workspace vector (for pcre2_dfa_match()), the heap is not being used, so
    the minimum limit is zero; there's no need to go on. The other limits are
    always greater than zero. */

    if (errnumber == PCRE2_ERROR_HEAPLIMIT && mid < stack_start)
      {
      fprintf(outfile, "Minimum %s limit = 0\n", msg);
      break;
      }
    if (mid == min + 1)
      {
      fprintf(outfile, "Minimum %s limit = %d\n", msg, mid);
      break;
      }
    max = mid;
    mid = (min + max)/2;
    }
  else break;    /* Some other error */
  }

return capcount;
}
