void fx_TypedArray_prototype_join(txMachine* the)
{
	mxTypedArrayDeclarations;
	txInteger delta = dispatch->value.typedArray.dispatch->size;
	txInteger offset = view->value.dataView.offset;
	txInteger limit = offset + (length << dispatch->value.typedArray.dispatch->shift);
	txString string;
	txSlot* list = fxNewInstance(the);
	txSlot* slot = list;
	txBoolean comma = 0;
	txInteger size = 0;
	if ((mxArgc > 0) && (mxArgv(0)->kind != XS_UNDEFINED_KIND)) {
		mxPushSlot(mxArgv(0));
		string = fxToString(the, the->stack);
		the->stack->kind += XS_KEY_KIND - XS_STRING_KIND;
		the->stack->value.key.sum = mxStringLength(the->stack->value.string);
	}
	else {
		mxPushStringX(",");
		the->stack->kind += XS_KEY_KIND - XS_STRING_KIND;
		the->stack->value.key.sum = 1;
	}
	length = offset + fxGetDataViewSize(the, view, buffer);
	while (offset < limit) {
		if (comma) {
			slot = fxNextSlotProperty(the, slot, the->stack, XS_NO_ID, XS_NO_FLAG);
            size = fxAddChunkSizes(the, size, slot->value.key.sum);
		}
		else
			comma = 1;
		if (offset < length) {
			mxPushUndefined();
			(*dispatch->value.typedArray.dispatch->getter)(the, buffer->value.reference->next, offset, the->stack, EndianNative);
			slot = fxNextSlotProperty(the, slot, the->stack, XS_NO_ID, XS_NO_FLAG);
			string = fxToString(the, slot);
			slot->kind += XS_KEY_KIND - XS_STRING_KIND;
			slot->value.key.sum = mxStringLength(string);
			size = fxAddChunkSizes(the, size, slot->value.key.sum);
			mxPop();
		}
		offset += delta;
	}
	mxPop();
	string = mxResult->value.string = fxNewChunk(the, fxAddChunkSizes(the, size, 1));
	slot = list->next;
	while (slot) {
		c_memcpy(string, slot->value.key.string, slot->value.key.sum);
		string += slot->value.key.sum;
		slot = slot->next;
	}
	*string = 0;
	mxResult->kind = XS_STRING_KIND;
	mxPop();
}
