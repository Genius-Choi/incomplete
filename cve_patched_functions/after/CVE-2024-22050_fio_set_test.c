FIO_FUNC void fio_set_test(void) {
  fio_set_test_s s = FIO_SET_INIT;
  fio_hash_test_s h = FIO_SET_INIT;
  fprintf(
      stderr,
      "=== Testing Core ordered Set (re-including fio.h with FIO_SET_NAME)\n");
  fprintf(stderr, "* Inserting %lu items\n", FIO_SET_TEST_COUNT);

  FIO_ASSERT(fio_set_test_count(&s) == 0, "empty set should have zero objects");
  FIO_ASSERT(fio_set_test_capa(&s) == 0, "empty set should have no capacity");
  FIO_ASSERT(fio_hash_test_capa(&h) == 0, "empty hash should have no capacity");
  FIO_ASSERT(!fio_set_test_is_fragmented(&s),
             "empty set shouldn't be considered fragmented");
  FIO_ASSERT(!fio_hash_test_is_fragmented(&h),
             "empty hash shouldn't be considered fragmented");
  FIO_ASSERT(!fio_set_test_last(&s), "empty set shouldn't have a last object");
  FIO_ASSERT(!fio_hash_test_last(&h).key && !fio_hash_test_last(&h).obj,
             "empty hash shouldn't have a last object");

  for (uintptr_t i = 1; i < FIO_SET_TEST_COUNT; ++i) {
    fio_set_test_insert(&s, i, i);
    fio_hash_test_insert(&h, i, i, i + 1, NULL);
    FIO_ASSERT(fio_set_test_find(&s, i, i), "set find failed after insert");
    FIO_ASSERT(fio_hash_test_find(&h, i, i), "hash find failed after insert");
    FIO_ASSERT(i == fio_set_test_find(&s, i, i), "set insertion != find");
    FIO_ASSERT(i + 1 == fio_hash_test_find(&h, i, i), "hash insertion != find");
  }
  fprintf(stderr, "* Seeking %lu items\n", FIO_SET_TEST_COUNT);
  for (unsigned long i = 1; i < FIO_SET_TEST_COUNT; ++i) {
    FIO_ASSERT((i == fio_set_test_find(&s, i, i)),
               "set insertion != find (seek)");
    FIO_ASSERT((i + 1 == fio_hash_test_find(&h, i, i)),
               "hash insertion != find (seek)");
  }
  {
    fprintf(stderr, "* Testing order for %lu items in set\n",
            FIO_SET_TEST_COUNT);
    uintptr_t i = 1;
    FIO_SET_FOR_LOOP(&s, pos) {
      FIO_ASSERT(pos->obj == i, "object order mismatch %lu != %lu.",
                 (unsigned long)i, (unsigned long)pos->obj);
      ++i;
    }
  }
  {
    fprintf(stderr, "* Testing order for %lu items in hash\n",
            FIO_SET_TEST_COUNT);
    uintptr_t i = 1;
    FIO_SET_FOR_LOOP(&h, pos) {
      FIO_ASSERT(pos->obj.obj == i + 1 && pos->obj.key == i,
                 "object order mismatch %lu != %lu.", (unsigned long)i,
                 (unsigned long)pos->obj.key);
      ++i;
    }
  }

  fprintf(stderr, "* Removing odd items from %lu items\n", FIO_SET_TEST_COUNT);
  for (unsigned long i = 1; i < FIO_SET_TEST_COUNT; i += 2) {
    fio_set_test_remove(&s, i, i, NULL);
    fio_hash_test_remove(&h, i, i, NULL);
    FIO_ASSERT(!(fio_set_test_find(&s, i, i)),
               "Removal failed in set (still exists).");
    FIO_ASSERT(!(fio_hash_test_find(&h, i, i)),
               "Removal failed in hash (still exists).");
  }
  {
    fprintf(stderr, "* Testing for %lu / 2 holes\n", FIO_SET_TEST_COUNT);
    uintptr_t i = 1;
    FIO_SET_FOR_LOOP(&s, pos) {
      if (pos->hash == 0) {
        FIO_ASSERT((i & 1) == 1, "deleted object wasn't odd");
      } else {
        FIO_ASSERT(pos->obj == i, "deleted object value mismatch %lu != %lu",
                   (unsigned long)i, (unsigned long)pos->obj);
      }
      ++i;
    }
    i = 1;
    FIO_SET_FOR_LOOP(&h, pos) {
      if (pos->hash == 0) {
        FIO_ASSERT((i & 1) == 1, "deleted object wasn't odd");
      } else {
        FIO_ASSERT(pos->obj.key == i,
                   "deleted object value mismatch %lu != %lu", (unsigned long)i,
                   (unsigned long)pos->obj.key);
      }
      ++i;
    }
    {
      fprintf(stderr, "* Poping two elements (testing pop through holes)\n");
      FIO_ASSERT(fio_set_test_last(&s), "Pop `last` 1 failed - no last object");
      uintptr_t tmp = fio_set_test_last(&s);
      FIO_ASSERT(tmp, "Pop set `last` 1 failed to collect object");
      fio_set_test_pop(&s);
      FIO_ASSERT(
          fio_set_test_last(&s) != tmp,
          "Pop `last` 2 in set same as `last` 1 - failed to collect object");
      tmp = fio_hash_test_last(&h).key;
      FIO_ASSERT(tmp, "Pop hash `last` 1 failed to collect object");
      fio_hash_test_pop(&h);
      FIO_ASSERT(
          fio_hash_test_last(&h).key != tmp,
          "Pop `last` 2 in hash same as `last` 1 - failed to collect object");
      FIO_ASSERT(fio_set_test_last(&s), "Pop `last` 2 failed - no last object");
      FIO_ASSERT(fio_hash_test_last(&h).obj,
                 "Pop `last` 2 failed in hash - no last object");
      fio_set_test_pop(&s);
      fio_hash_test_pop(&h);
    }
    if (1) {
      uintptr_t tmp = 1;
      fio_set_test_remove(&s, tmp, tmp, NULL);
      fio_hash_test_remove(&h, tmp, tmp, NULL);
      size_t count = s.count;
      fio_set_test_overwrite(&s, tmp, tmp, NULL);
      FIO_ASSERT(
          count + 1 == s.count,
          "Re-adding a removed item in set should increase count by 1 (%zu + "
          "1 != %zu).",
          count, (size_t)s.count);
      count = h.count;
      fio_hash_test_insert(&h, tmp, tmp, tmp, NULL);
      FIO_ASSERT(
          count + 1 == h.count,
          "Re-adding a removed item in hash should increase count by 1 (%zu + "
          "1 != %zu).",
          count, (size_t)s.count);
      tmp = fio_set_test_find(&s, tmp, tmp);
      FIO_ASSERT(tmp == 1,
                 "Re-adding a removed item should update the item in the set "
                 "(%lu != 1)!",
                 (unsigned long)fio_set_test_find(&s, tmp, tmp));
      fio_set_test_remove(&s, tmp, tmp, NULL);
      fio_hash_test_remove(&h, tmp, tmp, NULL);
      FIO_ASSERT(count == h.count,
                 "Re-removing an item should decrease count (%zu != %zu).",
                 count, (size_t)s.count);
      FIO_ASSERT(!fio_set_test_find(&s, tmp, tmp),
                 "Re-removing a re-added item should update the item!");
    }
  }
  fprintf(stderr, "* Compacting HashMap to %lu\n", FIO_SET_TEST_COUNT >> 1);
  fio_set_test_compact(&s);
  {
    fprintf(stderr, "* Testing that %lu items are continuous\n",
            FIO_SET_TEST_COUNT >> 1);
    uintptr_t i = 0;
    FIO_SET_FOR_LOOP(&s, pos) {
      FIO_ASSERT(pos->hash != 0, "Found a hole after compact.");
      ++i;
    }
    FIO_ASSERT(i == s.count, "count error (%lu != %lu).", i, s.count);
  }

  fio_set_test_free(&s);
  fio_hash_test_free(&h);
  FIO_ASSERT(!s.map && !s.ordered && !s.pos && !s.capa,
             "HashMap not re-initialized after free.");

  fio_set_test_capa_require(&s, FIO_SET_TEST_COUNT);

  FIO_ASSERT(
      s.map && s.ordered && !s.pos && s.capa >= FIO_SET_TEST_COUNT,
      "capa_require changes state in a bad way (%p, %p, %zu, %zu ?>= %zu)",
      (void *)s.map, (void *)s.ordered, s.pos, s.capa, FIO_SET_TEST_COUNT);

  for (unsigned long i = 1; i < FIO_SET_TEST_COUNT; ++i) {
    fio_set_test_insert(&s, i, i);
    FIO_ASSERT(fio_set_test_find(&s, i, i),
               "find failed after insert (2nd round)");
    FIO_ASSERT(i == fio_set_test_find(&s, i, i),
               "insertion (2nd round) != find");
    FIO_ASSERT(i == s.count, "count error (%lu != %lu) post insertion.", i,
               s.count);
  }
  fio_set_test_free(&s);
  /* full/partial collision attack against set and test response */
  if (1) {
    fio_set_attack_s as = FIO_SET_INIT;
    time_t start_ok = clock();
    for (uintptr_t i = 0; i < FIO_SET_TEST_COUNT; ++i) {
      fio_set_attack_insert(&as, i, i + 1);
      FIO_ASSERT(fio_set_attack_find(&as, i, i + 1) == i + 1,
                 "set attack verctor failed sanity test (seek != insert)");
    }
    time_t end_ok = clock();
    FIO_ASSERT(fio_set_attack_count(&as) == FIO_SET_TEST_COUNT,
               "set attack verctor failed sanity test (count error %zu != %zu)",
               fio_set_attack_count(&as), FIO_SET_TEST_COUNT);
    fio_set_attack_free(&as);

    /* full collision attack */
    time_t start_bad = clock();
    for (uintptr_t i = 0; i < FIO_SET_TEST_COUNT; ++i) {
      fio_set_attack_insert(&as, 1, i + 1);
    }
    time_t end_bad = clock();
    FIO_ASSERT(fio_set_attack_count(&as) != FIO_SET_TEST_COUNT,
               "set attack success! too many full-collisions inserts!");
    FIO_LOG_DEBUG("set full-collision attack final count/capa = %zu / %zu",
                  fio_set_attack_count(&as), fio_set_attack_capa(&as));
    FIO_LOG_DEBUG("set full-collision attack timing impact (attack vs. normal) "
                  "%zu vs. %zu",
                  end_bad - start_bad, end_ok - start_ok);
    fio_set_attack_free(&as);

    /* partial collision attack */
    start_bad = clock();
    for (uintptr_t i = 0; i < FIO_SET_TEST_COUNT; ++i) {
      fio_set_attack_insert(&as, ((i << 20) | 1), i + 1);
    }
    end_bad = clock();
    FIO_ASSERT(fio_set_attack_count(&as) == FIO_SET_TEST_COUNT,
               "partial collision resolusion failed, not enough inserts!");
    FIO_LOG_DEBUG("set partial collision attack final count/capa = %zu / %zu",
                  fio_set_attack_count(&as), fio_set_attack_capa(&as));
    FIO_LOG_DEBUG("set partial collision attack timing impact (attack vs. "
                  "normal) %zu vs. %zu",
                  end_bad - start_bad, end_ok - start_ok);
    fio_set_attack_free(&as);
  }
}
