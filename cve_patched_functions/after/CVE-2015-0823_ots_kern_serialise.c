bool ots_kern_serialise(OTSStream *out, OpenTypeFile *file) {
  const OpenTypeKERN *kern = file->kern;

  const uint16_t num_subtables = static_cast<uint16_t>(kern->subtables.size());
  if (num_subtables != kern->subtables.size() ||
      !out->WriteU16(kern->version) ||
      !out->WriteU16(num_subtables)) {
    return OTS_FAILURE_MSG("Can't write kern table header");
  }

  for (uint16_t i = 0; i < num_subtables; ++i) {
    const size_t length = 14 + (6 * kern->subtables[i].pairs.size());
    if (length > std::numeric_limits<uint16_t>::max() ||
        !out->WriteU16(kern->subtables[i].version) ||
        !out->WriteU16(static_cast<uint16_t>(length)) ||
        !out->WriteU16(kern->subtables[i].coverage) ||
        !out->WriteU16(
            static_cast<uint16_t>(kern->subtables[i].pairs.size())) ||
        !out->WriteU16(kern->subtables[i].search_range) ||
        !out->WriteU16(kern->subtables[i].entry_selector) ||
        !out->WriteU16(kern->subtables[i].range_shift)) {
      return OTS_FAILURE_MSG("Failed to write kern subtable %d", i);
    }
    for (unsigned j = 0; j < kern->subtables[i].pairs.size(); ++j) {
      if (!out->WriteU16(kern->subtables[i].pairs[j].left) ||
          !out->WriteU16(kern->subtables[i].pairs[j].right) ||
          !out->WriteS16(kern->subtables[i].pairs[j].value)) {
        return OTS_FAILURE_MSG("Failed to write kern pair %d for subtable %d", j, i);
      }
    }
  }

  return true;
}
