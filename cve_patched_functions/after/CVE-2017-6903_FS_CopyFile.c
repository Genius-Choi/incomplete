void FS_CopyFile( char *fromOSPath, char *toOSPath ) {
	FILE	*f;
	int		len;
	byte	*buf;

	FS_CheckFilenameIsMutable( fromOSPath, __func__ );

	Com_Printf( "copy %s to %s\n", fromOSPath, toOSPath );

	if (strstr(fromOSPath, "journal.dat") || strstr(fromOSPath, "journaldata.dat")) {
		Com_Printf( "Ignoring journal files\n");
		return;
	}

	f = fopen( fromOSPath, "rb" );
	if ( !f ) {
		return;
	}
	fseek (f, 0, SEEK_END);
	len = ftell (f);
	fseek (f, 0, SEEK_SET);

	if ( len == EOF )
	{
		fclose( f );
		Com_Error( ERR_FATAL, "Bad file length in FS_CopyFile()" );
	}

	// we are using direct malloc instead of Z_Malloc here, so it
	// probably won't work on a mac... Its only for developers anyway...
	buf = (unsigned char *)malloc( len );
	if (fread( buf, 1, len, f ) != (unsigned)len)
	{
		fclose( f );
		free ( buf );
		Com_Error( ERR_FATAL, "Short read in FS_Copyfiles()\n" );
	}
	fclose( f );

	if( FS_CreatePath( toOSPath ) ) {
		free ( buf );
		return;
	}

	f = fopen( toOSPath, "wb" );
	if ( !f ) {
		free ( buf );
		return;
	}
	if (fwrite( buf, 1, len, f ) != (unsigned)len)
	{
		fclose( f );
		free ( buf );
		Com_Error( ERR_FATAL, "Short write in FS_Copyfiles()\n" );
	}
	fclose( f );
	free( buf );
}
