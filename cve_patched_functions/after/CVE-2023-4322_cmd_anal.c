static int cmd_anal(void *data, const char *input) {
	const char *r;
	RCore *core = (RCore *)data;
	ut32 tbs = core->blocksize;
	switch (input[0]) {
	case 'p': // "ap"
		switch (input[1]) {
		case '?':
			r_core_cmd_help (core, help_msg_ap);
			break;
		case 'l': // "apl"
			// list function preludes
			{
				RSearchKeyword *k;
				RListIter *iter;
				RList *list = r_anal_preludes (core->anal);
				r_list_foreach (list, iter, k) {
					char *hex0 = r_hex_bin2strdup (k->bin_keyword, k->keyword_length);
					char *hex1 = r_hex_bin2strdup (k->bin_binmask, k->binmask_length);
					// XXX must add an align field
					r_cons_printf ("ap+ %s %s\n", hex0, hex1);
					free (hex0);
					free (hex1);
				}
			}
			break;
		case 't': // "apt"
			cmd_apt (core, input + 2);
			break;
		case ' ':
		case 0:
			match_prelude (core, r_str_trim_head_ro (input));
			break;
		default:
			r_core_cmd_help (core, help_msg_ap);
			break;
		}
		break;
	case '8':  // "a8"
		if (input[1] == '?') {
			r_core_cmd_help (core, help_msg_a8);
			break;
		}
		ut8 *buf = malloc (strlen (input) + 1);
		if (buf) {
			int len = r_hex_str2bin (input + 1, buf);
			if (len > 0) {
				core_anal_bytes (core, buf, len, 0, input[1]);
			}
			free (buf);
		}
		break;
	case 'b': // "ab"
		switch (input[1]) {
		case '.': // "ab."
			r_core_cmd_call (core, "ab $$");
			break;
		case 'a': // "aba"
			r_core_cmdf (core, "aeab%s", input + 1);
			break;
		case 'b': // "abb"
			core_anal_bbs (core, input + 2);
			break;
		case 'c': // "abc"
			cmd_afbc (core, r_str_trim_head_ro (input + 2));
			break;
		case 'o': // "abo"
			abo (core);
			break;
		case 'e': // "aeb"
			r_core_cmdf (core, "aeb%s", input + 2);
			break;
		case 'f': // "abf"
			core_anal_abf (core, input + 2);
			break;
		case 'r': // "abr"
			core_anal_bbs_range (core, input + 2);
			break;
		case 't':
			cmd_anal_abt (core, input + 2);
			break;
		case ',': // "ab,"
		case 'p': // "abp"
			cmd_anal_abp (core, input + 2);
			break;
		case 'l': // "abl"
			if (input[2] == '?') {
				r_core_cmd_help (core, help_msg_abl);
			} else {
				anal_bb_list (core, input + 2);
			}
			break;
		case 'j': { // "abj"
			ut64 addr = core->offset;
			if (input[2] && input[2] != '.') {
				addr = r_num_math (core->num, input + 2);
			}
			r_core_cmd_call_at (core, addr, "afbij");
			break;
		}
		case '-': // "ab-"
			  if (input[2] == '*') {
				  r_anal_block_reset (core->anal);
			  } else {
				  ut64 addr = core->offset;
				  if (input[2] == ' ') {
					  addr = r_num_math (core->num, input + 1);
				  }
				  r_anal_delete_block_at (core->anal, addr);
			  }
			  break;
		case 0:
		case ' ': // "ab "
			{
				// find block
				ut64 addr = core->offset;
				if (input[1] && input[1] != '.') {
					addr = r_num_math (core->num, input + 1);
				}
				r_core_cmd_call_at (core, addr, "afbi");
			}
			break;
		default:
			r_core_cmd_help (core, help_msg_ab);
			break;
		}
		break;
	case 'c': // "ac"
		cmd_anal_classes (core, input + 1);
		break;
	case 'C': // "aC"
		cmd_anal_aC (core, input + 1);
		break;
	case 'i': cmd_anal_info (core, input + 1); break; // "ai"
	case 'r': cmd_anal_reg (core, input + 1); break;  // "ar"
	case 'e': cmd_anal_esil (core, input + 1, true); break; // "ae"
	case 'L':
		switch (input[1]) {
		case 'j':
		case 'q':
		case 0:
			ranal2_list (core, NULL, input[1]);
			break;
		default:
			// help
			r_core_cmd_help (core, help_msg_La);
			break;
		}
		break;
	case 'o': // "ao"
		cmd_anal_opcode (core, input + 1);
		break;
	case 'O': // "aO"
		cmd_anal_bytes (core, input + 1);
		break;
	case 'F': // "aF"
		if (input[1] == '?') {
			r_core_cmd_help (core, help_msg_aF);
			break;
		}
		r_core_anal_fcn (core, core->offset, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);
		break;
	case 'l':
		{
			RList *l = r_asm_cpus (core->rasm);
			RListIter *iter;
			char *c;
			r_list_foreach (l, iter, c) {
				r_cons_printf ("- %s\n", c);
			}
			r_list_free (l);
		}
		break;
	case 'f': // "af"
		if (!cmd_af (core, input)) {
			return false;
		}
		break;
	case 'n': // "an"
		{
		const char *name = "";
		int mode = 0;
		switch (input[1]) {
		case '?':
			r_core_cmd_help (core, help_msg_an);
			mode = -1;
			break;
		case 'j':
		case '*':
			mode = input[1];
			input++;
			break;
		}
		if (mode >= 0) {
			if (input[1] == ' ') {
				name = input + 1;
				while (name[0] == ' ') {
					name++;
				}
				char *end = strchr (name, ' ');
				if (end) {
					*end = '\0';
				}
			}
			if (R_STR_ISEMPTY (name)) {
				name = NULL;
			}
			cmd_an (core, name, mode);
		}
		}
		break;
	case 'g': // "ag"
		cmd_anal_graph (core, input + 1);
		break;
	case 's': // "as"
		cmd_anal_syscall (core, input + 1);
		break;
	case 'v': // "av"
		cmd_anal_virtual_functions (core, input + 1);
		break;
	case 'x': // "ax"
		if (!cmd_anal_refs (core, input + 1)) {
			return false;
		}
		break;
	case '*': // "a*"
		r_core_cmd_call (core, "afl*");
		r_core_cmd_call (core, "ah*");
		r_core_cmd_call (core, "ax*");
		break;
	case 'a': // "aa"
		if (!cmd_anal_all (core, input + 1)) {
			return false;
		}
		break;
	case 'd': // "ad"
		switch (input[1]) {
		case 'f': // "adf"
			if (input[2] == 'g') {
				anal_fcn_data_gaps (core, r_str_trim_head_ro (input + 1));
			} else {
				anal_fcn_data (core, input + 1);
			}
			break;
		case 't': // "adt"
			cmd_anal_trampoline (core, input + 2);
			break;
		case '.': // "ad."
		case ' ': { // "ad" // asm describe maybe? see aod instead
			const int default_depth = 1;
			const char *p;
			int a, b;
			a = r_num_math (core->num, input + 2);
			p = strchr (input + 2, ' ');
			b = p? r_num_math (core->num, p + 1): default_depth;
			if (a < 1) {
				a = 1;
			}
			if (b < 1) {
				b = 1;
			}
			r_core_anal_data (core, core->offset, a, b, 0);
		} break;
		case 'k': // "adk"
			r = r_anal_data_kind (core->anal, core->offset, core->block, core->blocksize);
			r_cons_println (r);
			break;
		case '\0': // "ad"
			r_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 0);
			break;
		case '4': // "ad4"
			r_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 4);
			break;
		case '8': // "ad8"
			r_core_anal_data (core, core->offset, 2 + (core->blocksize / 4), 1, 8);
			break;
		default:
			r_core_cmd_help (core, help_msg_ad);
			break;
		}
		break;
	case 'h': // "ah"
		cmd_anal_hint (core, input + 1);
		break;
	case ':': // "a:"
		if (input[1] == '?') {
			r_core_cmd_help (core, help_msg_acolon);
		} else if (input[1] == 'l' || !input[1]) {
			RListIter *iter;
			RAnalPlugin *ap;
			r_list_foreach (core->anal->plugins, iter, ap) {
				r_cons_println (ap->meta.name);
			}
		} else {
			r_anal_cmd (core->anal, r_str_trim_head_ro (input + 1));
		}
		break;
	case 'j': // "aj"
		r_core_cmd_call (core, "aflj");
		break;
	case 0: // "a"
		r_core_cmd_call (core, "aai");
		break;
	case '?':
		if (input[1] == 'j') {
			r_cons_cmd_help_json (help_msg_a);
		} else {
			r_core_cmd_help (core, help_msg_a);
		}
		break;
	default:
		r_core_cmd_help (core, help_msg_a);
		break;
	}
	if (tbs != core->blocksize) {
		r_core_block_size (core, tbs);
	}
	if (r_cons_is_breaked ()) {
		r_cons_clear_line (1);
	}
	return 0;
}
