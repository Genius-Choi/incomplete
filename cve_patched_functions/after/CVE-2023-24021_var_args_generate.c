static int var_args_generate(modsec_rec *msr, msre_var *var, msre_rule *rule,
    apr_table_t *vartab, apr_pool_t *mptmp)
{
    const apr_array_header_t *arr = NULL;
    const apr_table_entry_t *te = NULL;
    int i, count = 0;

    /* Loop through the arguments. */
    arr = apr_table_elts(msr->arguments);
    te = (apr_table_entry_t *)arr->elts;
    for (i = 0; i < arr->nelts; i++) {
        msc_arg *arg = (msc_arg *)te[i].val;
        int match = 0;

        /* Figure out if we want to include this argument. */
        if (var->param == NULL) match = 1; /* Unconditional inclusion. */
        else {
            if (var->param_data != NULL) { /* Regex. */
                char *my_error_msg = NULL;
                /* Run the regex against the argument name. */
                if (!(msc_regexec((msc_regex_t *)var->param_data, arg->name,
                    arg->name_len, &my_error_msg) == PCRE_ERROR_NOMATCH)) match = 1;
            } else { /* Simple comparison. */
                if (strcasecmp(arg->name, var->param) == 0) match = 1;
            }
        }

        /* If we had a match add this argument to the collection. */
        if (match) {
            msre_var *rvar = apr_pmemdup(mptmp, var, sizeof(msre_var));

            rvar->value = arg->value;
            rvar->value_len = arg->value_len;
            rvar->name = apr_psprintf(mptmp, "ARGS:%s", log_escape_nq_ex(mptmp, arg->name, arg->name_len));
            apr_table_addn(vartab, rvar->name, (void *)rvar);

            count++;
        }
    }

    return count;
}
