static void decide_how_to_apply_bkgd(struct iw_context *ctx)
{
	if(!IW_IMGTYPE_HAS_ALPHA(ctx->img1_imgtype_logical)) {
		// If we know the image does not have any transparency,
		// we don't have to do anything.
		ctx->apply_bkgd=0;
		return;
	}

	// Figure out where to get the background color from, on the assumption
	// that we'll use one.
	if(ctx->img1_bkgd_label_set &&
		(ctx->req.use_bkgd_label_from_file || !ctx->req.bkgd_valid))
	{
		// The input file has a background color label, and either we are
		// requested to prefer it to the caller's background color, or
		// the caller did not give us a background color.
		// Use the color from the input file.
		ctx->bkgd_color_source = IW_BKGD_COLOR_SOURCE_FILE;
	}
	else if(ctx->req.bkgd_valid) {
		// Use the background color given by the caller.
		ctx->bkgd_color_source = IW_BKGD_COLOR_SOURCE_REQ;
		// Tentatively use the caller's checkerboard setting.
		// This may be overridden if we can't support checkerboard backgrounds
		// for some reason.
		ctx->bkgd_checkerboard = ctx->req.bkgd_checkerboard;
	}
	else {
		// No background color available. If we need one, we'll have to invent one.
		ctx->bkgd_color_source = IW_BKGD_COLOR_SOURCE_NONE;
	}

	if(ctx->bkgd_checkerboard) {
		if(ctx->bkgd_check_size<1) ctx->bkgd_check_size=1;
	}

	if(ctx->req.bkgd_valid) {
		// Caller told us to apply a background.
		ctx->apply_bkgd=1;
	}

	if(!(ctx->output_profile&IW_PROFILE_TRANSPARENCY)) {
		if(!ctx->req.bkgd_valid && !ctx->apply_bkgd) {
			iw_warning(ctx,"This image may have transparency, which is incompatible with the output format. A background color will be applied.");
		}
		ctx->apply_bkgd=1;
	}

	if(ctx->resize_settings[IW_DIMENSION_H].use_offset ||
		ctx->resize_settings[IW_DIMENSION_V].use_offset)
	{
		// If channel offset is enabled, and the image has transparency, we
		// must apply a solid color background (and we must apply it before
		// resizing), regardless of whether the user asked for it. It's the
		// only strategy we support.
		if(!ctx->req.bkgd_valid && !ctx->apply_bkgd) {
			iw_warning(ctx,"This image may have transparency, which is incompatible with a channel offset. A background color will be applied.");
		}
		ctx->apply_bkgd=1;

		if(ctx->bkgd_checkerboard && ctx->req.bkgd_checkerboard) {
			iw_warning(ctx,"Checkerboard backgrounds are not supported when using a channel offset.");
			ctx->bkgd_checkerboard=0;
		}
		ctx->apply_bkgd_strategy=IW_BKGD_STRATEGY_EARLY;
		return;
	}

	if(!ctx->apply_bkgd) {
		// No reason to apply a background color.
		return;
	}

	if(ctx->bkgd_checkerboard) {
		// Non-solid-color backgrounds must be applied after resizing.
		ctx->apply_bkgd_strategy=IW_BKGD_STRATEGY_LATE;
		return;
	}

	// At this point, either Early or Late background application is possible,
	// and (I think) would, in an idealized situation, yield the same result.
	// Things that can cause it to be different include
	// * using a different resampling algorithm for the alpha channel (this is
	//   no longer supported)
	// * 'intermediate clamping'
	//
	// Setting this to Late is the safe, though it is slower than Early.
	ctx->apply_bkgd_strategy=IW_BKGD_STRATEGY_LATE;
}
