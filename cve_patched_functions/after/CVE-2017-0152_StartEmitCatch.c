void ByteCodeGenerator::StartEmitCatch(ParseNode *pnodeCatch)
{
    Assert(pnodeCatch->nop == knopCatch);

    Scope *scope = pnodeCatch->sxCatch.scope;
    FuncInfo *funcInfo = scope->GetFunc();

    // Catch scope is a dynamic object if it can be passed to a scoped lookup helper (i.e., eval is present or we're in an event handler).
    if (funcInfo->GetCallsEval() || funcInfo->GetChildCallsEval() || (this->flags & (fscrEval | fscrImplicitThis | fscrImplicitParents)))
    {
        scope->SetIsObject();
    }

    if (pnodeCatch->sxCatch.pnodeParam->nop == knopParamPattern)
    {
        scope->SetCapturesAll(funcInfo->GetCallsEval() || funcInfo->GetChildCallsEval());
        scope->SetMustInstantiate(scope->Count() > 0 && (scope->GetMustInstantiate() || scope->GetCapturesAll() || funcInfo->IsGlobalFunction()));

        Parser::MapBindIdentifier(pnodeCatch->sxCatch.pnodeParam->sxParamPattern.pnode1, [&](ParseNodePtr item)
        {
            Symbol *sym = item->sxVar.sym;
            if (funcInfo->IsGlobalFunction())
            {
                sym->SetIsGlobalCatch(true);
            }

            Assert(sym->GetScopeSlot() == Js::Constants::NoProperty);
            if (sym->NeedsSlotAlloc(funcInfo))
            {
                sym->EnsureScopeSlot(funcInfo);
            }
        });

        // In the case of pattern we will always going to push the scope.
        PushScope(scope);
    }
    else
    {
        Symbol *sym = pnodeCatch->sxCatch.pnodeParam->sxPid.sym;

        // Catch object is stored in the catch scope if there may be an ambiguous lookup or a var declaration that hides it.
        scope->SetCapturesAll(funcInfo->GetCallsEval() || funcInfo->GetChildCallsEval() || sym->GetHasNonLocalReference());
        scope->SetMustInstantiate(scope->GetCapturesAll() || funcInfo->IsGlobalFunction());

        if (funcInfo->IsGlobalFunction())
        {
            sym->SetIsGlobalCatch(true);
        }

        if (scope->GetMustInstantiate())
        {
            if (sym->IsInSlot(funcInfo))
            {
                // Since there is only one symbol we are pushing to slot.
                // Also in order to make IsInSlot to return true - forcing the sym-has-non-local-reference.
                this->ProcessCapturedSym(sym);
                sym->EnsureScopeSlot(funcInfo);
            }
        }

        PushScope(scope);
    }
}
