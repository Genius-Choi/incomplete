static void gf_filter_pid_set_args_internal(GF_Filter *filter, GF_FilterPid *pid, char *args, Bool use_default_seps, u32 argfile_level)
{
	char sep_args, sep_frag, sep_name, sep_list;

	if (use_default_seps) {
		sep_args = ':';
		sep_frag = '#';
		sep_name = '=';
		sep_list = ',';
	} else {
		sep_args = filter->session->sep_args;
		sep_frag = filter->session->sep_frag;
		sep_name = filter->session->sep_name;
		sep_list = filter->session->sep_list;
	}

	//parse each arg
	while (args) {
		u32 p4cc=0;
		u32 prop_type=GF_PROP_FORBIDEN;
		Bool parse_prop = GF_TRUE;
		char *value_next_list = NULL;
		char *value_sep = NULL;
		char *value, *name, *sep;

		//escaped arg separator, skip everything until next escape sep or end
		if (args[0] == sep_args) {
			char szEscape[3];
			szEscape[0] = szEscape[1] = sep_args;
			szEscape[2] = 0;
			args++;
			sep = strstr(args, szEscape);
		} else {
			if (sep_args == ':') {
				sep = (char *)gf_fs_path_escape_colon(filter->session, args);
			} else {
				sep = strchr(args, sep_args);
			}
		}
		if (sep) {
			char *xml_start = strchr(args, '<');
			if (xml_start && (xml_start<sep)) {
				char szEnd[3];
				szEnd[0] = '>';
				szEnd[1] = filter->session->sep_args;
				szEnd[2] = 0;
				char *xml_end = strstr(xml_start, szEnd);
				if (!xml_end) {
					sep = NULL;
				} else {
					sep = xml_end+1;
				}
			}
		}

		if (sep) sep[0]=0;

		if (args[0] != sep_frag) {
			//if arg is not one of our reserved keywords and is a valid file, try to open it
			if (strcmp(args, "gpac") && strcmp(args, "gfopt") && strcmp(args, "gfloc") && gf_file_exists(args)) {
				if (argfile_level<5) {
					char szLine[2001];
					FILE *arg_file = gf_fopen(args, "rt");
					szLine[2000]=0;
					while (!gf_feof(arg_file)) {
						u32 llen;
						char *subarg, *res;
						szLine[0] = 0;
						res = gf_fgets(szLine, 2000, arg_file);
						if (!res) break;
						llen = (u32) strlen(szLine);
						while (llen && strchr(" \n\r\t", szLine[llen-1])) {
							szLine[llen-1]=0;
							llen--;
						}
						if (!llen)
							continue;

						subarg = szLine;
						while (subarg[0] && strchr(" \n\r\t", subarg[0]))
							subarg++;
						if ((subarg[0] == '/') && (subarg[1] == '/'))
							continue;

						gf_filter_pid_set_args_internal(filter, pid, subarg, use_default_seps, argfile_level+1);
					}
					gf_fclose(arg_file);
				} else {
					GF_LOG(GF_LOG_ERROR, GF_LOG_FILTER, ("Filter argument file has too many nested levels of sub-files, maximum allowed is 5\n"));
				}
			}
			goto skip_arg;
		}

		value = NULL;
		value_sep = strchr(args, sep_name);
		if (value_sep) {
			value_sep[0]=0;
			value = value_sep+1;
		}
		name = args+1;

		if (strlen(name)==4) {
			p4cc = GF_4CC(name[0], name[1], name[2], name[3]);
			if (p4cc) prop_type = gf_props_4cc_get_type(p4cc);
		}
		if (prop_type==GF_PROP_FORBIDEN) {
			p4cc = gf_props_get_id(name);
			if (p4cc) prop_type = gf_props_4cc_get_type(p4cc);
		}

		//look for conditional statements: "(PROP=VAL)VALUE"
		while (value && (value[0]=='(')) {
			Bool pid_excluded, needs_resolve, prop_not_found, prop_matched;
			char prop_dump_buffer[GF_PROP_DUMP_ARG_SIZE];

			char *next_val = NULL;
			char *closing = strchr(value, ')');
			if (!closing) break;

			if (!strncmp(value, "()", 2)) {
				value = closing+1;
				parse_prop = GF_TRUE;
				value_next_list = next_val;
				break;
			}

			parse_prop = GF_FALSE;

			next_val = strchr(closing, sep_list);
			if (next_val) next_val[0] = 0;

			while (closing) {
				char *next_closing;
				closing[0] = 0;
				prop_matched = filter_pid_check_fragment(pid, value+1, &pid_excluded, &needs_resolve, &prop_not_found, prop_dump_buffer);
				if (prop_not_found) prop_matched = GF_FALSE;
				closing[0] = ')';

				if (!prop_matched)
					break;
				if (strncmp(closing, ")(", 2)) break;
				next_closing = strchr(closing+2, ')');
				if (!next_closing) break;

				value = closing+1;
				closing = next_closing;
			}

			if (prop_matched) {
				value = closing+1;
				parse_prop = GF_TRUE;
				value_next_list = next_val;
				break;
			}
			if (!next_val) break;
			next_val[0] = sep_list;
			value = next_val+1;
		}

		if (!parse_prop)
			goto skip_arg;


		if (prop_type != GF_PROP_FORBIDEN) {
			GF_PropertyValue p;
			p.type = GF_PROP_FORBIDEN;

			//specific parsing for clli: it's a data prop but we allow textual specifiers
			if ((p4cc == GF_PROP_PID_CONTENT_LIGHT_LEVEL) && strchr(value, sep_list) ){
				GF_PropertyValue a_p = gf_props_parse_value(GF_PROP_UINT_LIST, name, value, NULL, sep_list);
				if ((a_p.type == GF_PROP_UINT_LIST) && (a_p.value.uint_list.nb_items==2))  {
					GF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
					gf_bs_write_u16(bs, a_p.value.uint_list.vals[0]);
					gf_bs_write_u16(bs, a_p.value.uint_list.vals[1]);
					gf_bs_get_content(bs, &p.value.data.ptr, &p.value.data.size);
					p.type = GF_PROP_DATA;
					gf_bs_del(bs);
				}
				gf_props_reset_single(&a_p);
			}
			//specific parsing for mdcv: it's a data prop but we allow textual specifiers
			else if ((p4cc == GF_PROP_PID_MASTER_DISPLAY_COLOUR) && strchr(value, sep_list) ) {
				GF_PropertyValue a_p = gf_props_parse_value(GF_PROP_UINT_LIST, name, value, NULL, sep_list);
				if ((a_p.type == GF_PROP_UINT_LIST) && (a_p.value.uint_list.nb_items==10))  {
					GF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
					gf_bs_write_u16(bs, a_p.value.uint_list.vals[0]);
					gf_bs_write_u16(bs, a_p.value.uint_list.vals[1]);
					gf_bs_write_u16(bs, a_p.value.uint_list.vals[2]);
					gf_bs_write_u16(bs, a_p.value.uint_list.vals[3]);
					gf_bs_write_u16(bs, a_p.value.uint_list.vals[4]);
					gf_bs_write_u16(bs, a_p.value.uint_list.vals[5]);
					gf_bs_write_u16(bs, a_p.value.uint_list.vals[6]);
					gf_bs_write_u16(bs, a_p.value.uint_list.vals[7]);
					gf_bs_write_u32(bs, a_p.value.uint_list.vals[8]);
					gf_bs_write_u32(bs, a_p.value.uint_list.vals[9]);
					gf_bs_get_content(bs, &p.value.data.ptr, &p.value.data.size);
					p.type = GF_PROP_DATA;
					gf_bs_del(bs);
				}
				gf_props_reset_single(&a_p);
			}
			//parse codecID
			else if (p4cc == GF_PROP_PID_CODECID) {
				//only for explicit filters
				if (filter->dynamic_filter) goto skip_arg;
				u32 cid = gf_codecid_parse(value);
				if (cid) {
					p.type = GF_PROP_UINT;
					p.value.uint = cid;
				}
			}
			//parse streamtype
			else if (p4cc == GF_PROP_PID_STREAM_TYPE) {
				//only for explicit filters
				if (filter->dynamic_filter) goto skip_arg;
				u32 st = gf_stream_type_by_name(value);
				if (st!=GF_STREAM_UNKNOWN) {
					p.type = GF_PROP_UINT;
					p.value.uint = st;
				}
			}
			//pix formats and others are parsed as specific prop types

			if (p.type == GF_PROP_FORBIDEN) {
				p = gf_props_parse_value(prop_type, name, value, NULL, sep_list);
			}

			if (p.type != GF_PROP_FORBIDEN) {
				if (prop_type==GF_PROP_NAME) {
					p.type = GF_PROP_STRING;
					gf_filter_pid_set_property(pid, p4cc, &p);
				} else {
					gf_filter_pid_set_property(pid, p4cc, &p);
				}
			}

			if ((p4cc==GF_PROP_PID_TEMPLATE) && p.value.string) {
				if (strstr(p.value.string, "$Bandwidth$")) {
					gf_opts_set_key("temp", "force_indexing", "true");
				}
			}

			if (prop_type==GF_PROP_STRING_LIST) {
				p.value.string_list.vals = NULL;
				p.value.string_list.nb_items = 0;
			}
			//use uint_list as base type for lists
			else if ((prop_type==GF_PROP_UINT_LIST) || (prop_type==GF_PROP_SINT_LIST) || (prop_type==GF_PROP_VEC2I_LIST) || (prop_type==GF_PROP_4CC_LIST)) {
				p.value.uint_list.vals = NULL;
			}
			gf_props_reset_single(&p);
		} else if (value) {
			Bool reset_prop=GF_FALSE;
			GF_PropertyValue p;
			if (!strncmp(value, "bxml@", 5)) {
				p = gf_props_parse_value(GF_PROP_DATA_NO_COPY, name, value, NULL, sep_list);
			} else if (!strncmp(value, "file@", 5)) {
				p = gf_props_parse_value(GF_PROP_STRING, name, value, NULL, sep_list);
				p.type = GF_PROP_STRING_NO_COPY;
			} else {
				u32 ptype = GF_PROP_FORBIDEN;
				char *type_sep = strchr(value, '@');
				if (type_sep) {
					type_sep[0] = 0;
					ptype = gf_props_parse_type(value);
					if (ptype==GF_PROP_FORBIDEN) {
						GF_LOG(GF_LOG_WARNING, GF_LOG_FILTER, ("Unrecognized property type %s, defaulting to string\n", value));
					} else {
						value = type_sep+1;
					}
					type_sep[0] = '@';
				}
				memset(&p, 0, sizeof(GF_PropertyValue));
				if (ptype == GF_PROP_FORBIDEN) {
					p.type = GF_PROP_STRING;
					p.value.string = value;
				} else {
					p = gf_props_parse_value(ptype, name, value, NULL, sep_list);
					reset_prop = GF_TRUE;
				}
			}
			gf_filter_pid_set_property_dyn(pid, name, &p);
			if (reset_prop) gf_props_reset_single(&p);
		}
		if (value_next_list)
			value_next_list[0] = sep_list;

skip_arg:
		if (value_sep)
			value_sep[0] = sep_name;

		if (sep) {
			sep[0] = sep_args;
			args=sep+1;
		} else {
			break;
		}
	}
}
