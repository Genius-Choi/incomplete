static Jsi_RC SysHashCmd(Jsi_Interp *interp, Jsi_Value *args, Jsi_Value *_this,
    Jsi_Value **ret, Jsi_Func *funcPtr)
{
    int n, hasopts = 0, olen;
    const char *cp = NULL;
    Jsi_RC rc = JSI_OK;
    Jsi_DString dStr = {};
    HashOpts edata = {};
    char zbuf[1024];
    
    Jsi_Value *arg = Jsi_ValueArrayIndex(interp, args, 0);
    if (!arg || !Jsi_ValueIsString(interp, arg))
        return Jsi_LogError("arg 1: expected string");
        
    cp=Jsi_ValueString(interp, arg, &n);
    Jsi_DSAppendLen(&dStr, cp, n);
    Jsi_Value *opt = Jsi_ValueArrayIndex(interp, args, 1);
    if (opt) {
        if (opt->vt != JSI_VT_OBJECT || opt->d.obj->ot != JSI_OT_OBJECT)
            return Jsi_LogError("arg1: expected object 'options'");
        if (Jsi_OptionsProcess(interp, HashOptions, &edata, opt, 0) < 0)
            return JSI_ERROR;
        hasopts = 1;
    }
    
    if (edata.file) {
        Jsi_Channel in = Jsi_Open(interp, edata.file, "rb");
        
        if( in==0 ) {
            rc = Jsi_LogError("unable to open file");
            goto done;
        }
        for(;;) {
            int n;
            n = Jsi_Read(interp, in, zbuf, sizeof(zbuf));
            if( n<=0 ) break;
            Jsi_DSAppendLen(&dStr, zbuf, n);;
        }
        Jsi_Close(interp, in);
    }
    cp = Jsi_DSValue(&dStr);
    n = Jsi_DSLength(&dStr);
    memset(zbuf, 0, sizeof(zbuf));
    Jsi_CryptoHash(zbuf, cp, n, edata.type, edata.hashcash, edata.noHex, &olen);
        
done:
    Jsi_DSFree(&dStr);
    if (hasopts)
        Jsi_OptionsFree(interp, HashOptions, &edata, 0);
    if (rc == JSI_OK) {
        jsi_ValueMakeBlobDup(interp, ret, (uchar*)zbuf, olen);
    }
    return rc;

}
