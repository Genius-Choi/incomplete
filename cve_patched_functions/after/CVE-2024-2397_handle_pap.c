handle_pap(netdissect_options *ndo,
           const u_char *p, u_int length)
{
	u_int code, len;
	u_int peerid_len, passwd_len, msg_len;
	const u_char *p0;
	u_int i;

	p0 = p;
	if (length < 1) {
		ND_PRINT("[|pap]");
		return;
	} else if (length < 4) {
		ND_PRINT("[|pap 0x%02x]", GET_U_1(p));
		return;
	}

	code = GET_U_1(p);
	ND_PRINT("PAP, %s (0x%02x)",
	          tok2str(papcode_values, "unknown", code),
	          code);
	p++;

	ND_PRINT(", id %u", GET_U_1(p));	/* ID */
	p++;

	len = GET_BE_U_2(p);
	p += 2;

	if (len > length) {
		ND_PRINT(", length %u > packet size", len);
		return;
	}
	length = len;
	if (length < (size_t)(p - p0)) {
		ND_PRINT(", length %u < PAP header length", length);
		return;
	}

	switch (code) {
	case PAP_AREQ:
		/* A valid Authenticate-Request is 6 or more octets long. */
		if (len < 6)
			goto trunc;
		if (length - (p - p0) < 1)
			return;
		peerid_len = GET_U_1(p);	/* Peer-ID Length */
		p++;
		if (length - (p - p0) < peerid_len)
			return;
		ND_PRINT(", Peer ");
		for (i = 0; i < peerid_len; i++) {
			fn_print_char(ndo, GET_U_1(p));
			p++;
		}

		if (length - (p - p0) < 1)
			return;
		passwd_len = GET_U_1(p);	/* Password Length */
		p++;
		if (length - (p - p0) < passwd_len)
			return;
		ND_PRINT(", Name ");
		for (i = 0; i < passwd_len; i++) {
			fn_print_char(ndo, GET_U_1(p));
			p++;
		}
		break;
	case PAP_AACK:
	case PAP_ANAK:
		/* Although some implementations ignore truncation at
		 * this point and at least one generates a truncated
		 * packet, RFC 1334 section 2.2.2 clearly states that
		 * both AACK and ANAK are at least 5 bytes long.
		 */
		if (len < 5)
			goto trunc;
		if (length - (p - p0) < 1)
			return;
		msg_len = GET_U_1(p);	/* Msg-Length */
		p++;
		if (length - (p - p0) < msg_len)
			return;
		ND_PRINT(", Msg ");
		for (i = 0; i< msg_len; i++) {
			fn_print_char(ndo, GET_U_1(p));
			p++;
		}
		break;
	}
	return;

trunc:
	ND_PRINT("[|pap]");
}
